// mini-macro for the bulk fixes, string updates
DEFINE_PATCH_MACRO cd_bulk_fix_item_strings BEGIN

  FOR (index = 0x54 ; index > 0x4f ; index -= 0x04) BEGIN // only if no identified descript to match and update, go after normal descript (blun04)
    READ_LONG index desc_strref
    PATCH_IF ((desc_strref >= 0) AND (desc_strref < 999999)) BEGIN
      READ_STRREF index desc
      INNER_PATCH_SAVE desc ~%desc%~ BEGIN
        REPLACE_TEXTUALLY ~%text_match%~ ~\1%fix%~
      END
      INNER_ACTION BEGIN
        STRING_SET_EVALUATE desc_strref ~%desc%~
      END
      SET index = 0 // kill loop (if identified updated, don't mess with unidentified)
    END
  END

END

/////                                                  \\\\\
///// alter_header                                     \\\\\
/////                                                  \\\\\

// got tired of crappy ALTER_ITEM_HEADER and ALTER_SPELL_HEADER
DEFINE_PATCH_FUNCTION ALTER_HEADER

  // defines what we're going to check
  INT_VAR multi_match         = 999
          verbose             = 0
          silent              = 0
          header              = "-1"

  // variables for finding the effect to match
          match_type        = "-1"
          match_location    = "-1"
          match_target      = "-1"
          match_target_num  = "-1"
          match_range       = "-1"
          match_speed       = "-1"
          match_projectile  = "-1"
          // spell headers only
          match_level       = "-1"
          // item headers only
          match_identify       = "-1"
          match_alt_dicesize   = "-1"
          match_launcher       = "-1"
          match_alt_dicenumber = "-1"
          match_alt_damage     = "-1"
          match_to_hit         = "-1"
          match_dicesize       = "-1"
          match_primary        = "-1"
          match_dicenumber     = "-1"
          match_secondary      = "-1"
          match_damage         = "-1"
          match_damage_type    = "-1"
          match_charges        = "-1"
          match_drained        = "-1"
          match_overhand       = "-1"
          match_backhand       = "-1"
          match_thrust         = "-1"
          match_arrow          = "-1"
          match_bolt           = "-1"
          match_bullet         = "-1"
          // flags at 0x26 (still item only)
          match_flag_strength      = "-1" // add strength bonus, bit0
          match_flag_break         = "-1" // breakable, bit1
          match_flag_str_damage    = "-1" // strength damage bonus, ee, bit2
          match_flag_str_to_hit    = "-1" // strength thac0 bonus, ee, bit3
          match_flag_hostile       = "-1" // hostile, bit10
          match_flag_recharge      = "-1" // recharge after resting, bit11
          match_flag_bypass        = "-1" // bypass armor, bit16
          match_flag_keenedge      = "-1" // keen edge, bit17
          match_flag_backstab      = "-1" // tobex only, toggle backstab, bit25
          match_flag_noinvisible   = "-1" // tobex only, cannot target invisible, bit26

  // variables for the new effect
          type        = "-1"
          location    = "-1"
          target      = "-1"
          target_num  = "-1"
          range       = "-1"
          speed       = "-1"
          projectile  = "-1"
          // spell headers only
          level       = "-1"
          // item headers only
          identify       = "-1"
          alt_dicesize   = "-1"
          launcher       = "-1"
          alt_dicenumber = "-1"
          alt_damage     = "-1"
          to_hit         = "-1"
          dicesize       = "-1"
          primary        = "-1"
          dicenumber     = "-1"
          secondary      = "-1"
          damage         = "-1"
          damage_type    = "-1"
          charges        = "-1"
          drained        = "-1"
          overhand       = "-1"
          backhand       = "-1"
          thrust         = "-1"
          arrow          = "-1"
          bolt           = "-1"
          bullet         = "-1"
          // flags at 0x26
          flag_strength      = "-1" // add strength bonus, bit0
          flag_break         = "-1" // breakable, bit1
          flag_str_damage    = "-1" // strength damage bonus, ee, bit2
          flag_str_to_hit    = "-1" // strength thac0 bonus, ee, bit3
          flag_hostile       = "-1" // hostile, bit10
          flag_recharge      = "-1" // recharge after resting, bit11
          flag_bypass        = "-1" // bypass armor, bit16
          flag_keenedge      = "-1" // keen edge, bit17
          flag_backstab      = "-1" // tobex only, toggle backstab, bit25
          flag_noinvisible   = "-1" // tobex only, cannot target invisible, bit26

  // same for match and new STR_VAR
  STR_VAR match_icon      = "SAME"
          icon            = "SAME"
BEGIN

  READ_ASCII 0x00 sig (3)
  SET abil_length = 0
  SET proceed = 0
  SET alter = 0
  PATCH_IF ("%sig%" STRING_COMPARE_CASE "ITM" = 0) BEGIN
    SET abil_length = 0x38
  END ELSE
  PATCH_IF ("%sig%" STRING_COMPARE_CASE "SPL" = 0) BEGIN
    SET abil_length = 0x28
  END
  PATCH_IF abil_length = 0 BEGIN
    PATCH_WARN ~WARNING: file type not recognized on %SOURCE_FILE% for ALTER_HEADER macro.~
  END ELSE BEGIN
    SET pro_off = abil_length = 0x38 ? 0x2a : 0x26
    READ_LONG   0x64 abil_off
    READ_SHORT  0x68 abil_num
    FOR (index = 0 ; index < abil_num ; ++index) BEGIN
      PATCH_IF ((header < 0) OR (header = index)) BEGIN
        SET base = abil_off + (index * abil_length)
        READ_BYTE  (base + 0x00) o_type
        READ_BYTE  (base + 0x02) o_location
        READ_ASCII (base + 0x04) o_icon (8) NULL
        READ_BYTE  (base + 0x0c) o_target
        READ_BYTE  (base + 0x0d) o_target_num
        READ_SHORT (base + 0x0e) o_range
        READ_SHORT (base + pro_off) o_projectile
        PATCH_IF abil_length = 0x38 BEGIN
          // item headers only
          READ_BYTE  (base + 0x01) o_identify
          READ_BYTE  (base + 0x03) o_alt_dicesize
          READ_BYTE  (base + 0x10) o_launcher
          READ_BYTE  (base + 0x11) o_alt_dicenumber
          READ_BYTE  (base + 0x12) o_speed
          READ_BYTE  (base + 0x13) o_alt_damage
          READ_SHORT (base + 0x14) o_to_hit
          READ_BYTE  (base + 0x16) o_dicesize
          READ_BYTE  (base + 0x17) o_primary
          READ_BYTE  (base + 0x18) o_dicenumber
          READ_BYTE  (base + 0x19) o_secondary
          READ_SHORT (base + 0x1a) o_damage
          READ_SHORT (base + 0x1c) o_damage_type
          READ_SHORT (base + 0x22) o_charges
          READ_SHORT (base + 0x24) o_drained
          READ_LONG  (base + 0x26) o_flags
          READ_SHORT (base + 0x2c) o_overhand
          READ_SHORT (base + 0x2e) o_backhand
          READ_SHORT (base + 0x30) o_thrust
          READ_SHORT (base + 0x32) o_arrow
          READ_SHORT (base + 0x34) o_bolt
          READ_SHORT (base + 0x36) o_bullet
        END ELSE BEGIN
          READ_SHORT (base + 0x10) o_level
          READ_SHORT (base + 0x12) o_speed
        END
        // now check our header vs. the match variables
        PATCH_IF ((multi_match != 0) AND
                  ((match_type       = o_type)       OR (match_type < 0))       AND
                  ((match_type       = o_type)       OR (match_type < 0))       AND
                  ((match_location   = o_location)   OR (match_location < 0))   AND
                  ((match_target     = o_target)     OR (match_target < 0))     AND
                  ((match_target_num = o_target_num) OR (match_target_num < 0)) AND
                  ((match_range      = o_range)      OR (match_range < 0))      AND
                  ((match_speed      = o_speed)      OR (match_speed < 0))      AND
                  ((match_projectile = o_projectile) OR (match_projectile < 0)) AND
                  (("%match_icon%" STRING_COMPARE_CASE "%o_icon%" = 0) OR ("%match_icon%" STRING_COMPARE_CASE "SAME" = 0))) BEGIN
          PATCH_IF (abil_length = 0x38) BEGIN  // item-specific checks
            PATCH_IF (((match_identify       = o_identify)       OR (match_identify < 0))       AND
                      ((match_alt_dicesize   = o_alt_dicesize)   OR (match_alt_dicesize < 0))   AND
                      ((match_launcher       = o_launcher)       OR (match_launcher < 0))       AND
                      ((match_alt_dicenumber = o_alt_dicenumber) OR (match_alt_dicenumber < 0)) AND
                      ((match_alt_damage     = o_alt_damage)     OR (match_alt_damage < 0))     AND
                      ((match_to_hit         = o_to_hit)         OR (match_to_hit < 0))         AND
                      ((match_dicesize       = o_dicesize)       OR (match_dicesize < 0))       AND
                      ((match_primary        = o_primary)        OR (match_primary < 0))        AND
                      ((match_dicenumber     = o_dicenumber)     OR (match_dicenumber < 0))     AND
                      ((match_secondary      = o_secondary)      OR (match_secondary < 0))      AND
                      ((match_damage         = o_damage)         OR (match_damage < 0))         AND
                      ((match_damage_type    = o_damage_type)    OR (match_damage_type < 0))    AND
                      ((match_charges        = o_charges)        OR (match_charges < 0))        AND
                      ((match_drained        = o_drained)        OR (match_drained < 0))        AND
                      ((match_overhand       = o_overhand)       OR (match_overhand < 0))       AND
                      ((match_backhand       = o_backhand)       OR (match_backhand < 0))       AND
                      ((match_thrust         = o_thrust)         OR (match_thrust < 0))         AND
                      ((match_arrow          = o_arrow)          OR (match_arrow < 0))          AND
                      ((match_bolt           = o_bolt)           OR (match_bolt < 0))           AND
                      ((match_bullet         = o_bullet)         OR (match_bullet < 0))         AND
                      ((match_flag_strength < 0) OR
                       (match_flag_strength = (flags & BIT0)) OR // not set
                       (match_flag_strength > 0 AND (flags & BIT0) = BIT0)) AND
                      ((match_flag_break < 0) OR
                       (match_flag_break = (flags & BIT1)) OR // not set
                       (match_flag_break > 0 AND (flags & BIT1) = BIT1)) AND
                      ((match_flag_str_damage < 0) OR
                       (match_flag_str_damage = (flags & BIT2)) OR // not set
                       (match_flag_str_damage > 0 AND (flags & BIT2) = BIT2)) AND
                      ((match_flag_str_to_hit < 0) OR
                       (match_flag_str_to_hit = (flags & BIT3)) OR // not set
                       (match_flag_str_to_hit > 0 AND (flags & BIT3) = BIT3)) AND
                      ((match_flag_hostile < 0) OR
                       (match_flag_hostile = (flags & BIT10)) OR // not set
                       (match_flag_hostile > 0 AND (flags & BIT10) = BIT10)) AND
                      ((match_flag_recharge < 0) OR
                       (match_flag_recharge = (flags & BIT11)) OR // not set
                       (match_flag_recharge > 0 AND (flags & BIT11) = BIT11)) AND
                      ((match_flag_bypass < 0) OR
                       (match_flag_bypass = (flags & BIT16)) OR // not set
                       (match_flag_bypass > 0 AND (flags & BIT16) = BIT16)) AND
                      ((match_flag_keenedge < 0) OR
                       (match_flag_keenedge = (flags & BIT17)) OR // not set
                       (match_flag_keenedge > 0 AND (flags & BIT17) = BIT17)) AND
                      ((match_flag_backstab < 0) OR
                       (match_flag_backstab = (flags & BIT25)) OR // not set
                       (match_flag_backstab > 0 AND (flags & BIT25) = BIT25)) AND
                      ((match_flag_noinvisible < 0) OR
                       (match_flag_noinvisible = (flags & BIT26)) OR // not set
                       (match_flag_noinvisible > 0 AND (flags & BIT26) = BIT26))) BEGIN
              SET proceed = 1
            END
          END ELSE BEGIN // spell-specific checks
            PATCH_IF ((match_level = o_level) OR (match_level < 0)) BEGIN
              SET proceed = 1
            END
          END
          PATCH_IF proceed BEGIN
            SET alter += 1
            SET multi_match -= 1
            PATCH_IF (type >= 0)       BEGIN WRITE_BYTE  (base + 0x00) type END
            PATCH_IF (location >= 0)   BEGIN WRITE_BYTE  (base + 0x02) location END
            PATCH_IF (target >= 0)     BEGIN WRITE_BYTE  (base + 0x0c) target END
            PATCH_IF (target_num >= 0) BEGIN WRITE_BYTE  (base + 0x0d) target_num END
            PATCH_IF (range >= 0)      BEGIN WRITE_SHORT (base + 0x0e) range END
            PATCH_IF (projectile >= 0) BEGIN WRITE_SHORT (base + pro_off) projectile END
            PATCH_IF ("%icon%" STRING_COMPARE_CASE "SAME") BEGIN WRITE_ASCIIE (base + 0x04) ~%icon%~ #8 END
            PATCH_IF abil_length = 0x38 BEGIN // item headers
              PATCH_IF (identify >= 0)       BEGIN WRITE_BYTE  (base + 0x01) identify       END
              PATCH_IF (alt_dicesize >= 0)   BEGIN WRITE_BYTE  (base + 0x03) alt_dicesize   END
              PATCH_IF (launcher >= 0)       BEGIN WRITE_BYTE  (base + 0x10) launcher       END
              PATCH_IF (alt_dicenumber >= 0) BEGIN WRITE_BYTE  (base + 0x11) alt_dicenumber END
              PATCH_IF (speed >= 0)          BEGIN WRITE_BYTE  (base + 0x12) speed          END
              PATCH_IF (alt_damage >= 0)     BEGIN WRITE_BYTE  (base + 0x13) alt_damage     END
              PATCH_IF (to_hit >= 0)         BEGIN WRITE_SHORT (base + 0x14) to_hit         END
              PATCH_IF (dicesize >= 0)       BEGIN WRITE_BYTE  (base + 0x16) dicesize       END
              PATCH_IF (primary >= 0)        BEGIN WRITE_BYTE  (base + 0x17) primary        END
              PATCH_IF (dicenumber >= 0)     BEGIN WRITE_BYTE  (base + 0x18) dicenumber     END
              PATCH_IF (secondary >= 0)      BEGIN WRITE_BYTE  (base + 0x19) secondary      END
              PATCH_IF (damage >= 0)         BEGIN WRITE_SHORT (base + 0x1a) damage         END
              PATCH_IF (damage_type >= 0)    BEGIN WRITE_SHORT (base + 0x1c) damage_type    END
              PATCH_IF (charges >= 0)        BEGIN WRITE_SHORT (base + 0x22) charges        END
              PATCH_IF (drained >= 0)        BEGIN WRITE_SHORT (base + 0x24) drained        END
              PATCH_IF (overhand >= 0)       BEGIN WRITE_SHORT (base + 0x2c) overhand       END
              PATCH_IF (backhand >= 0)       BEGIN WRITE_SHORT (base + 0x2e) backhand       END
              PATCH_IF (thrust >= 0)         BEGIN WRITE_SHORT (base + 0x30) thrust         END
              PATCH_IF (arrow >= 0)          BEGIN WRITE_SHORT (base + 0x32) arrow          END
              PATCH_IF (bolt >= 0)           BEGIN WRITE_SHORT (base + 0x34) bolt           END
              PATCH_IF (bullet >= 0)         BEGIN WRITE_SHORT (base + 0x36) bullet         END
  
              PATCH_IF (flag_strength = 0)    BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT0)  END
              PATCH_IF (flag_strength > 0)    BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT0)  END
              PATCH_IF (flag_break = 0)       BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT1)  END
              PATCH_IF (flag_break > 0)       BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT1)  END
              PATCH_IF (flag_str_damage = 0)  BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT2)  END
              PATCH_IF (flag_str_damage > 0)  BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT2)  END
              PATCH_IF (flag_str_to_hit = 0)  BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT3)  END
              PATCH_IF (flag_str_to_hit > 0)  BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT3)  END
              PATCH_IF (flag_hostile = 0)     BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT10) END
              PATCH_IF (flag_hostile > 0)     BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT10) END
              PATCH_IF (flag_recharge = 0)    BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT11) END
              PATCH_IF (flag_recharge > 0)    BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT11) END
              PATCH_IF (flag_bypass = 0)      BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT16) END
              PATCH_IF (flag_bypass > 0)      BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT16) END
              PATCH_IF (flag_keenedge = 0)    BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT17) END
              PATCH_IF (flag_keenedge > 0)    BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT17) END
              PATCH_IF (flag_backstab = 0)    BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT25) END
              PATCH_IF (flag_backstab > 0)    BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT25) END
              PATCH_IF (flag_noinvisible = 0) BEGIN WRITE_LONG (base + 0x26) (THIS &  `BIT26) END
              PATCH_IF (flag_noinvisible > 0) BEGIN WRITE_LONG (base + 0x26) (THIS BOR BIT26) END
            END ELSE BEGIN // spell headers
              PATCH_IF (level >= 0) BEGIN WRITE_SHORT (base + 0x10) level END
              PATCH_IF (speed >= 0) BEGIN WRITE_SHORT (base + 0x12) speed END
            END
          END // proceed check
        END // mutual fields check
      END // for loop
    END // header check
  END // abil_length check

  PATCH_IF (alter = 0 && !silent) BEGIN
    PATCH_WARN "WARNING: no effects altered on %SOURCE_FILE% via ALTER_HEADER"
  END

  PATCH_IF (verbose && !silent) BEGIN
    READ_LONG 0x0c strref
    PATCH_IF ((strref > 0) AND (strref < 200000)) BEGIN
      READ_STRREF 0x0c name
    END ELSE BEGIN
      READ_STRREF 0x08 name
    END
    PATCH_PRINT "              ~%SOURCE_FILE%~   ~override~ // %name%, %alter% effect(s) altered"
  END

END

/////                                                  \\\\\
///// ALTER_AREA_ANIMATION                             \\\\\
/////                                                  \\\\\


DEFINE_PATCH_FUNCTION ALTER_AREA_ANIMATION
  INT_VAR match_x_coord    = "-1"
          match_y_coord    = "-1"
          x_coord          = "-1" // new x coordinate at 0x20 and 0x24; negative values mean no change
          y_coord          = "-1" // new y coordinate at 0x22 and 0x26; negative values mean no change
          height           = "-1" // aka z-index, 0x38
          translucency     = "-1" // 0x3a
          start_frame      = "-1" // 0x3c
          loop_probability = "-1" // 0x3e
          start_delay      = "-1" // 0x3f
          bam_sequence     = "-1" // sequence at 0x30
          bam_frame        = "-1" // frame at 0x32
          flag_time_0         = "-1" // time flags at 0x24
          flag_time_1         = "-1"
          flag_time_2         = "-1"
          flag_time_3         = "-1"
          flag_time_4         = "-1"
          flag_time_5         = "-1"
          flag_time_6         = "-1"
          flag_time_7         = "-1"
          flag_time_8         = "-1"
          flag_time_9         = "-1"
          flag_time_10        = "-1"
          flag_time_11        = "-1"
          flag_time_12        = "-1"
          flag_time_13        = "-1"
          flag_time_14        = "-1"
          flag_time_15        = "-1"
          flag_time_16        = "-1"
          flag_time_17        = "-1"
          flag_time_18        = "-1"
          flag_time_19        = "-1"
          flag_time_20        = "-1"
          flag_time_21        = "-1"
          flag_time_22        = "-1"
          flag_time_23        = "-1"
          flag_enabled           = "-1" // animation flags at 0x34
          flag_no_shadow         = "-1"
          flag_not_light_source  = "-1"
          flag_partial_animation = "-1"
          flag_synchronized      = "-1"
          flag_random            = "-1"
          flag_not_covered_wall  = "-1"
          flag_static            = "-1"
          flag_background        = "-1"
          flag_all_frames        = "-1"
          flag_palette_recolor   = "-1"
          flag_mirror_y          = "-1"
          flag_remain_combat     = "-1"

  STR_VAR match_name     = "same"
          match_bam_file = "same"
          name           = "same" // required, at 0x00, used to match animation
          bam_file       = "same" // changes bam file at 0x28; "same" means no change
          palette        = "same" // changes bam file at 0x28; "same" means no change
BEGIN

  READ_LONG 0xac anim_num
  READ_LONG 0xb0 anim_off
  FOR (index = 0 ; index < anim_num ; ++index) BEGIN
    SET base = (anim_off + (index * 0x4c))
    READ_SHORT (base + 0x20) o_x_coord
    READ_SHORT (base + 0x22) o_y_coord
    READ_ASCII (base       ) o_name     (32) NULL
    READ_ASCII (base + 0x28) o_bam_file (8)  NULL
    PATCH_IF (((match_x_coord = o_x_coord) OR (match_x_coord < 0)) AND
              ((match_y_coord = o_y_coord) OR (match_y_coord < 0)) AND
              (("%match_name%"     STRING_COMPARE_CASE "%o_name%"     = 0) OR ("%match_name%"     STRING_COMPARE_CASE "same" = 0)) AND
              (("%match_bam_file%" STRING_COMPARE_CASE "%o_bam_file%" = 0) OR ("%match_bam_file%" STRING_COMPARE_CASE "same" = 0))) BEGIN
      PATCH_IF (x_coord >= 0)          BEGIN WRITE_SHORT (base + 0x20) x_coord END
      PATCH_IF (y_coord >= 0)          BEGIN WRITE_SHORT (base + 0x22) y_coord END
      PATCH_IF (bam_sequence >= 0)     BEGIN WRITE_SHORT (base + 0x30) bam_sequence END
      PATCH_IF (bam_frame >= 0)        BEGIN WRITE_SHORT (base + 0x32) bam_frame END
      PATCH_IF (height >= 0)           BEGIN WRITE_SHORT (base + 0x38) height END
      PATCH_IF (translucency >= 0)     BEGIN WRITE_SHORT (base + 0x3a) translucency END
      PATCH_IF (start_frame >= 0)      BEGIN WRITE_SHORT (base + 0x3c) start_frame END
      PATCH_IF (loop_probability >= 0) BEGIN WRITE_BYTE  (base + 0x3e) loop_probability END
      PATCH_IF (start_delay >= 0)      BEGIN WRITE_BYTE  (base + 0x3f) start_delay END
      PATCH_IF ("%name%"     STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_ASCIIE (base       ) "%name%" #32 END
      PATCH_IF ("%bam_file%" STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_ASCIIE (base + 0x28) "%bam_file%" #8 END
      PATCH_IF ("%palette%"  STRING_COMPARE_CASE "SAME" != 0) BEGIN WRITE_ASCIIE (base + 0x40) "%palette%"  #8 END
      // time flags
      PATCH_IF (flag_time_0 = 0)  BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT0) END
      PATCH_IF (flag_time_0 = 1)  BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT0) END
      PATCH_IF (flag_time_1 = 0)  BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT1) END
      PATCH_IF (flag_time_1 = 1)  BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT1) END
      PATCH_IF (flag_time_2 = 0)  BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT2) END
      PATCH_IF (flag_time_2 = 1)  BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT2) END
      PATCH_IF (flag_time_3 = 0)  BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT3) END
      PATCH_IF (flag_time_3 = 1)  BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT3) END
      PATCH_IF (flag_time_4 = 0)  BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT4) END
      PATCH_IF (flag_time_4 = 1)  BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT4) END
      PATCH_IF (flag_time_5 = 0)  BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT5) END
      PATCH_IF (flag_time_5 = 1)  BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT5) END
      PATCH_IF (flag_time_6 = 0)  BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT6) END
      PATCH_IF (flag_time_6 = 1)  BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT6) END
      PATCH_IF (flag_time_7 = 0)  BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT7) END
      PATCH_IF (flag_time_7 = 1)  BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT7) END
      PATCH_IF (flag_time_8 = 0)  BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT8) END
      PATCH_IF (flag_time_8 = 1)  BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT8) END
      PATCH_IF (flag_time_9 = 0)  BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT9) END
      PATCH_IF (flag_time_9 = 1)  BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT9) END
      PATCH_IF (flag_time_10 = 0) BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT10) END
      PATCH_IF (flag_time_10 = 1) BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT10) END
      PATCH_IF (flag_time_11 = 0) BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT11) END
      PATCH_IF (flag_time_11 = 1) BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT11) END
      PATCH_IF (flag_time_12 = 0) BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT12) END
      PATCH_IF (flag_time_12 = 1) BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT12) END
      PATCH_IF (flag_time_13 = 0) BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT13) END
      PATCH_IF (flag_time_13 = 1) BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT13) END
      PATCH_IF (flag_time_14 = 0) BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT14) END
      PATCH_IF (flag_time_14 = 1) BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT14) END
      PATCH_IF (flag_time_15 = 0) BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT15) END
      PATCH_IF (flag_time_15 = 1) BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT15) END
      PATCH_IF (flag_time_16 = 0) BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT16) END
      PATCH_IF (flag_time_16 = 1) BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT16) END
      PATCH_IF (flag_time_17 = 0) BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT17) END
      PATCH_IF (flag_time_17 = 1) BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT17) END
      PATCH_IF (flag_time_18 = 0) BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT18) END
      PATCH_IF (flag_time_18 = 1) BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT18) END
      PATCH_IF (flag_time_19 = 0) BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT19) END
      PATCH_IF (flag_time_19 = 1) BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT19) END
      PATCH_IF (flag_time_20 = 0) BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT20) END
      PATCH_IF (flag_time_20 = 1) BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT20) END
      PATCH_IF (flag_time_21 = 0) BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT21) END
      PATCH_IF (flag_time_21 = 1) BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT21) END
      PATCH_IF (flag_time_22 = 0) BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT22) END
      PATCH_IF (flag_time_22 = 1) BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT22) END
      PATCH_IF (flag_time_23 = 0) BEGIN WRITE_LONG  (base + 0x24) (THIS & `BIT23) END
      PATCH_IF (flag_time_23 = 1) BEGIN WRITE_LONG  (base + 0x24) (THIS BOR BIT23) END
      // other flags
      PATCH_IF (flag_enabled = 0)           BEGIN WRITE_LONG  (base + 0x34) (THIS & `BIT0) END
      PATCH_IF (flag_enabled = 1)           BEGIN WRITE_LONG  (base + 0x34) (THIS BOR BIT0) END
      PATCH_IF (flag_no_shadow = 0)         BEGIN WRITE_LONG  (base + 0x34) (THIS & `BIT1) END
      PATCH_IF (flag_no_shadow = 1)         BEGIN WRITE_LONG  (base + 0x34) (THIS BOR BIT1) END
      PATCH_IF (flag_not_light_source = 0)  BEGIN WRITE_LONG  (base + 0x34) (THIS & `BIT2) END
      PATCH_IF (flag_not_light_source = 1)  BEGIN WRITE_LONG  (base + 0x34) (THIS BOR BIT2) END
      PATCH_IF (flag_partial_animation = 0) BEGIN WRITE_LONG  (base + 0x34) (THIS & `BIT3) END
      PATCH_IF (flag_partial_animation = 1) BEGIN WRITE_LONG  (base + 0x34) (THIS BOR BIT3) END
      PATCH_IF (flag_synchronized = 0)      BEGIN WRITE_LONG  (base + 0x34) (THIS & `BIT4) END
      PATCH_IF (flag_synchronized = 1)      BEGIN WRITE_LONG  (base + 0x34) (THIS BOR BIT4) END
      PATCH_IF (flag_random = 0)            BEGIN WRITE_LONG  (base + 0x34) (THIS & `BIT5) END
      PATCH_IF (flag_random = 1)            BEGIN WRITE_LONG  (base + 0x34) (THIS BOR BIT5) END
      PATCH_IF (flag_not_covered_wall = 0)  BEGIN WRITE_LONG  (base + 0x34) (THIS & `BIT6) END
      PATCH_IF (flag_not_covered_wall = 1)  BEGIN WRITE_LONG  (base + 0x34) (THIS BOR BIT6) END
      PATCH_IF (flag_static = 0)            BEGIN WRITE_LONG  (base + 0x34) (THIS & `BIT7) END
      PATCH_IF (flag_static = 1)            BEGIN WRITE_LONG  (base + 0x34) (THIS BOR BIT7) END
      PATCH_IF (flag_background = 0)        BEGIN WRITE_LONG  (base + 0x34) (THIS & `BIT8) END
      PATCH_IF (flag_background = 1)        BEGIN WRITE_LONG  (base + 0x34) (THIS BOR BIT8) END
      PATCH_IF (flag_all_frames = 0)        BEGIN WRITE_LONG  (base + 0x34) (THIS & `BIT9) END
      PATCH_IF (flag_all_frames = 1)        BEGIN WRITE_LONG  (base + 0x34) (THIS BOR BIT9) END
      PATCH_IF (flag_palette_recolor = 0)   BEGIN WRITE_LONG  (base + 0x34) (THIS & `BIT10) END
      PATCH_IF (flag_palette_recolor = 1)   BEGIN WRITE_LONG  (base + 0x34) (THIS BOR BIT10) END
      PATCH_IF (flag_mirror_y = 0)          BEGIN WRITE_LONG  (base + 0x34) (THIS & `BIT11) END
      PATCH_IF (flag_mirror_y = 1)          BEGIN WRITE_LONG  (base + 0x34) (THIS BOR BIT11) END
      PATCH_IF (flag_remain_combat = 0)     BEGIN WRITE_LONG  (base + 0x34) (THIS & `BIT12) END
      PATCH_IF (flag_remain_combat = 1)     BEGIN WRITE_LONG  (base + 0x34) (THIS BOR BIT12) END
    END
  END

END

/////                                                  \\\\\
///// ALTER_AREA/CREATURE_ITEM                         \\\\\
/////                                                  \\\\\

// alter_creature and alter_area just feed into a common macro that does the work

DEFINE_PATCH_FUNCTION ALTER_AREA_ITEM

  // defines what we're going to check
  INT_VAR expiry           = "-1"
          charge1          = "-1"
          charge2          = "-1"
          charge3          = "-1"
          flags            = "-1"
          flag_identified  = "-1"
          flag_unstealable = "-1"
          flag_stolen      = "-1"
          flag_undroppable = "-1"
  STR_VAR item       = "same"
          match_item = "same"

BEGIN

  READ_SHORT 0x76 item_num ELSE 0
  READ_LONG  0x78 item_off ELSE 0
  LPF ALTER_AREA-CREATURE_ITEM INT_VAR expiry charge1 charge2 charge3 flags flag_identified flag_unstealable flag_stolen flag_undroppable item_num item_off
                               STR_VAR item match_item END

END

DEFINE_PATCH_FUNCTION ALTER_CREATURE_ITEM

  // defines what we're going to check
  INT_VAR expiry           = "-1"
          charge1          = "-1"
          charge2          = "-1"
          charge3          = "-1"
          flags            = "-1"
          flag_identified  = "-1"
          flag_unstealable = "-1"
          flag_stolen      = "-1"
          flag_undroppable = "-1"
  STR_VAR item       = "same"
          match_item = "same"

BEGIN

  READ_LONG  0x2bc item_off ELSE 0
  READ_LONG  0x2c0 item_num ELSE 0
  LPF ALTER_AREA-CREATURE_ITEM INT_VAR expiry charge1 charge2 charge3 flags flag_identified flag_unstealable flag_stolen flag_undroppable item_num item_off
                               STR_VAR item match_item END

END

DEFINE_PATCH_FUNCTION ALTER_AREA-CREATURE_ITEM

  // defines what we're going to check
  INT_VAR expiry           = "-1"
          charge1          = "-1"
          charge2          = "-1"
          charge3          = "-1"
          flags            = "-1"
          flag_identified  = "-1"
          flag_unstealable = "-1"
          flag_stolen      = "-1"
          flag_undroppable = "-1"
          item_num         = 0
          item_off         = 0
  STR_VAR item       = "same"
          match_item = "same"

BEGIN

  FOR (index = 0 ; index < item_num ; ++index) BEGIN
    SET base = (item_off + (index * 0x14))
    READ_ASCII base o_item
    PATCH_IF (("%o_item%" STRING_COMPARE_CASE "%match_item%" = 0) OR
              ("all"      STRING_COMPARE_CASE "%match_item%" = 0)) BEGIN
      PATCH_IF (expiry >= 0)  BEGIN WRITE_SHORT (base + 0x08) expiry END
      PATCH_IF (charge1 >= 0) BEGIN WRITE_SHORT (base + 0x0a) charge1 END
      PATCH_IF (charge2 >= 0) BEGIN WRITE_SHORT (base + 0x0c) charge2 END
      PATCH_IF (charge3 >= 0) BEGIN WRITE_SHORT (base + 0x0e) charge3 END
      PATCH_IF (flags >= 0)   BEGIN
        WRITE_LONG (base + 0x10) flags
      END ELSE BEGIN // only check individual flags if overall value not given
        PATCH_IF (flag_identified = 0)  BEGIN WRITE_LONG  (base + 0x10) (THIS & `BIT0) END
        PATCH_IF (flag_identified = 1)  BEGIN WRITE_LONG  (base + 0x10) (THIS BOR BIT0) END
        PATCH_IF (flag_unstealable = 0) BEGIN WRITE_LONG  (base + 0x10) (THIS & `BIT1) END
        PATCH_IF (flag_unstealable = 1) BEGIN WRITE_LONG  (base + 0x10) (THIS BOR BIT1) END
        PATCH_IF (flag_stolen = 0)      BEGIN WRITE_LONG  (base + 0x10) (THIS & `BIT2) END
        PATCH_IF (flag_stolen = 1)      BEGIN WRITE_LONG  (base + 0x10) (THIS BOR BIT2) END
        PATCH_IF (flag_undroppable = 0) BEGIN WRITE_LONG  (base + 0x10) (THIS & `BIT3) END
        PATCH_IF (flag_undroppable = 1) BEGIN WRITE_LONG  (base + 0x10) (THIS BOR BIT3) END
      END
      PATCH_IF ("%item%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE base ~%item%~ #8
      END
    END
  END

END

/////                                                  \\\\\
///// miscellaneous creature inventory macros          \\\\\
/////                                                  \\\\\

// this function takes an item listed in a creture file and moves it to an open slot
// it'll try the appropriate slot first and then move to inventory
DEFINE_PATCH_FUNCTION cd_equip_item

  // defines what we're going to check
  INT_VAR move = 0
          gpuse = 0
  STR_VAR item = "same"
          slot = "helmet"

BEGIN

  SET fruitbats = "-1"
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "helmet" = 0) BEGIN
    SET start = 0
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "armor" = 0) BEGIN
    SET start = 1
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "shield" = 0) BEGIN
    SET start = 2
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "gloves" = 0) BEGIN
    SET start = 3
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "rings" = 0) BEGIN
    SET start = 4
    SET fruitbats = 5
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "amulet" = 0) BEGIN
    SET start = 6
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "jewelry" = 0) BEGIN
    SET start = 4
    SET fruitbats = 6
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "belt" = 0) BEGIN
    SET start = 7
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "boots" = 0) BEGIN
    SET start = 8
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "weapon" = 0) BEGIN
    SET start = 9
    SET fruitbats = 12
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "quiver" = 0) BEGIN
    SET start = 13
    SET fruitbats = 15
  END ELSE
  PATCH_IF ("%slot%" STRING_COMPARE_CASE "quickslot" = 0) BEGIN
    SET start = 18
    SET fruitbats = 20
  END ELSE BEGIN // inventory
    PATCH_IF gpuse = 0 BEGIN // creatures with gpuse scripts will try to use items in the first inventory slots
      SET start = 21
    END ELSE BEGIN
      SET start = 23
    END
    SET fruitbats = 0
  END
  PATCH_IF fruitbats < 0 BEGIN SET fruitbats = start END

  READ_LONG  0x2b8 slot_off ELSE 0
  READ_LONG  0x2bc itm_off ELSE 0
  READ_LONG  0x2c0 itm_num ELSE 0
  FOR (index = 0 ; index < itm_num ; ++index) BEGIN
    READ_ASCII (itm_off + (0x14 * index)) test_item
    PATCH_IF ("%item%" STRING_COMPARE_CASE "%test_item%" = 0) BEGIN
      SET proceed = 1
      FOR (index2 = 0 ; index2 < 36 ; ++index2) BEGIN // first make a loop to make sure it's not assigned somwhere already
        READ_SHORT (slot_off + (index2 * 0x02)) ref
        PATCH_IF ref = index BEGIN
          PATCH_IF move = 1 BEGIN
            WRITE_SHORT (slot_off + (index2 * 0x02)) 0xffff
          END ELSE BEGIN
            SET proceed = 0
          END
        END
      END
      PATCH_IF proceed BEGIN
        FOR (index2 = start ; index2 < 36 ; ++index2) BEGIN // first make a loop to make sure it's not assigned somwhere already
          READ_SHORT (slot_off + (index2 * 0x02)) ref
          PATCH_IF (ref = 0xffff) BEGIN // if null reference in targeted slot
            WRITE_SHORT (slot_off + (index2 * 0x02)) index // adds reference to item
            SET index2 = 36 // kills loop
          END
          PATCH_IF (index2 = fruitbats) BEGIN // if end of possible equipment slots, skip ahead to inventory
            PATCH_IF gpuse = 0 BEGIN // creatures with gpuse scripts will try to use items in the first inventory slots
              SET index2 = 20 // otherwise go to inventory slots
            END ELSE BEGIN
              SET index2 = 22 // otherwise go to inventory slots
            END
          END
        END
      END
    END
  END

END

// run this on creatures with invalid selected weapons; it'll check the weapon slots and update the equipped weapon as needed
DEFINE_PATCH_FUNCTION cd_equip_weapon BEGIN

  READ_LONG  0x2b8 slot_off ELSE 0
  READ_LONG  0x2c0 itm_num  ELSE 0
  WRITE_SHORT (slot_off + 0x4c) 0xffff // null equipped weapon - either patch below will enter a valid value, or no valid value exists
  FOR (index = 0 ; index < 4 ; ++index) BEGIN // search through weapon slots
    READ_SHORT (slot_off + 0x12 + (index * 0x02)) ref
    PATCH_IF ((ref != 0xffff) AND (ref < itm_num)) BEGIN // if valid reference in weapon slots
//    PATCH_IF (ref != 0xffff) BEGIN // if valid reference in weapon slots
      WRITE_SHORT (slot_off + 0x4c) index // equipped weapon
      SET "index" = 4 // kills loop and prevents next patch_if
    END
  END

END

// run this on creatures with invalid selected weapons; it'll check the weapon slots and update the equipped weapon as needed
DEFINE_PATCH_FUNCTION cd_equip_weapon_specific

  // defines what we're going to check
  STR_VAR item = ""

BEGIN


  READ_LONG  0x2b8 slot_off
  READ_LONG  0x2bc itm_off
  FOR (index = 0; index < 4; ++index) BEGIN // cycles through weapon slots
    READ_SHORT (slot_off + 0x12 + (index * 0x02)) slot_num
    PATCH_IF (slot_num < 37) BEGIN
      READ_ASCII (itm_off + (slot_num * 0x14)) weapon
      PATCH_IF ("%item%" STRING_COMPARE_CASE "%weapon%" = 0) BEGIN // if long sword
        WRITE_SHORT (slot_off + 0x4c) index // sets weapon slot to selected weapon
        SET index = 4
      END
    END
  END

END

// this function moves an item in a creture file into a slot where it can't be pickocketed
// also used to move items out of helmet slot for non-legit crit protection
DEFINE_PATCH_FUNCTION cd_no_pickpocket

  // defines what we're going to check
  STR_VAR item = ""

BEGIN

  READ_LONG 0x2b8 slot_off ELSE 0
  READ_LONG 0x2bc itm_off  ELSE 0
  READ_LONG 0x2c0 itm_num  ELSE 0
  SET added = 0
  FOR (index = 0 ; index < itm_num ; ++index) BEGIN
    READ_ASCII (itm_off + (0x14 * index)) file_item
    PATCH_IF ("%item%" STRING_COMPARE_CASE "%file_item%" = 0) BEGIN
      FOR (index2 = 0 ; index2 < 36 ; ++index2) BEGIN // search through item slots; first pass finds and/or removes
        READ_SHORT (slot_off + (0x02 * index2)) ref
        PATCH_IF (ref = index) BEGIN // if item in question
          PATCH_IF ((index2 = 1) OR (index2 = 3) OR ((index2 > 6) AND (index2 < 18))) BEGIN // if legit slot (1, 3, 7-17)
            SET added = 1
          END ELSE BEGIN
            WRITE_SHORT (slot_off + (0x02 * index2)) 0xffff // nulls reference
          END
        END
      END
      PATCH_IF added = 0 BEGIN // if not in a legit slot to begin with
        FOR (index2 = 1 ; index2 < 36 ; ++index2) BEGIN // search through item slots (skipping helmet at 0); first pass finds and/or removes
          PATCH_IF (index2 =  2) BEGIN SET index2 =  3 END // skip shield slot
          PATCH_IF (index2 =  4) BEGIN SET index2 =  7 END // skip rings & amulet
          PATCH_IF (index2 = 18) BEGIN SET index2 = 21 END // skip quick slots
          READ_SHORT (slot_off + (0x02 * index2)) ref
          PATCH_IF (ref = 0xffff) BEGIN // if empty, legit slot
            WRITE_SHORT (slot_off + (0x02 * index2)) index // adds reference
            SET index  = itm_num  // kill loops
            SET index2 = 36       // kill loops
          END
        END
      END
    END
  END

END

/////                                                  \\\\\
///// creature spellbook stuff                         \\\\\
/////                                                  \\\\\

// used repeatedly in spellbook changes; set array and offsets before calling this function
DEFINE_PATCH_FUNCTION cd_spellbook_sub BEGIN

  READ_LONG (offset       ) spell_off
  READ_LONG (offset + 0x04) spell_num
  FOR (index = 0 ; index < spell_num ; ++index) BEGIN
    READ_ASCII (spell_off +        (0x0c * index)) spell
    PATCH_PHP_EACH cd_spell_sub AS old => new BEGIN
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "%old%" = 0) BEGIN
        WRITE_ASCIIE (spell_off +        (0x0c * index)) ~%new%~ #8
      END
    END
  END

END

/////                                                  \\\\\
///// ALTER_STORE_ITEM                                 \\\\\
/////                                                  \\\\\

DEFINE_PATCH_FUNCTION ALTER_STORE_ITEM

  // defines what we're going to check
  INT_VAR expiry           = "-1"
          charge1          = "-1"
          charge2          = "-1"
          charge3          = "-1"
          flags            = "-1"
          flag_identified  = "-1"
          flag_unstealable = "-1"
          flag_stolen      = "-1"
          flag_undroppable = "-1"
          stock            = "-1"
          infinite         = "-1"
          match_expiry     = "-1"
          match_charge1    = "-1"
          match_charge2    = "-1"
          match_charge3    = "-1"
          match_flags      = "-1"
          match_stock      = "-1"
          match_infinite   = "-1"
  STR_VAR item       = "same"
          match_item = "same"

BEGIN

  READ_LONG 0x34 item_off
  READ_LONG 0x38 item_num
  FOR (index = 0 ; index < item_num ; ++index) BEGIN
    SET base = (item_off + (index * 0x1c))
    READ_ASCII (base       ) o_item
    READ_SHORT (base + 0x08) o_expiry
    READ_SHORT (base + 0x0a) o_charge1
    READ_SHORT (base + 0x0c) o_charge2
    READ_SHORT (base + 0x0e) o_charge3
    READ_LONG  (base + 0x10) o_flags
    READ_LONG  (base + 0x14) o_stock
    READ_LONG  (base + 0x18) o_infinite

    PATCH_IF ((("%o_item%" STRING_COMPARE_CASE "%match_item%" = 0) OR
              ("all"      STRING_COMPARE_CASE "%match_item%" = 0)) AND
              ((match_expiry < 0)   OR (match_expiry = o_expiry))    AND
              ((match_charge1 < 0)  OR (match_charge1 = o_charge1))  AND
              ((match_charge2 < 0)  OR (match_charge2 = o_charge2))  AND
              ((match_charge3 < 0)  OR (match_charge3 = o_charge3))  AND
              ((match_flags < 0)    OR (match_flags = o_flags))      AND
              ((match_stock < 0)    OR (match_stock = o_stock))      AND
              ((match_infinite < 0) OR (match_infinite = o_infinite))) BEGIN
      PATCH_IF (expiry >= 0)   BEGIN WRITE_SHORT (base + 0x08) expiry   END
      PATCH_IF (charge1 >= 0)  BEGIN WRITE_SHORT (base + 0x0a) charge1  END
      PATCH_IF (charge2 >= 0)  BEGIN WRITE_SHORT (base + 0x0c) charge2  END
      PATCH_IF (charge3 >= 0)  BEGIN WRITE_SHORT (base + 0x0e) charge3  END
      PATCH_IF (stock >= 0)    BEGIN WRITE_LONG  (base + 0x14) stock    END
      PATCH_IF (infinite >= 0) BEGIN WRITE_LONG  (base + 0x18) infinite END
      PATCH_IF (flags >= 0)   BEGIN
        WRITE_LONG (base + 0x10) flags
      END ELSE BEGIN // only check individual flags if overall value not given
        PATCH_IF (flag_identified = 0)  BEGIN WRITE_LONG  (base + 0x10) (THIS & `BIT0) END
        PATCH_IF (flag_identified = 1)  BEGIN WRITE_LONG  (base + 0x10) (THIS BOR BIT0) END
        PATCH_IF (flag_unstealable = 0) BEGIN WRITE_LONG  (base + 0x10) (THIS & `BIT1) END
        PATCH_IF (flag_unstealable = 1) BEGIN WRITE_LONG  (base + 0x10) (THIS BOR BIT1) END
        PATCH_IF (flag_stolen = 0)      BEGIN WRITE_LONG  (base + 0x10) (THIS & `BIT2) END
        PATCH_IF (flag_stolen = 1)      BEGIN WRITE_LONG  (base + 0x10) (THIS BOR BIT2) END
        PATCH_IF (flag_undroppable = 0) BEGIN WRITE_LONG  (base + 0x10) (THIS & `BIT3) END
        PATCH_IF (flag_undroppable = 1) BEGIN WRITE_LONG  (base + 0x10) (THIS BOR BIT3) END
      END
      PATCH_IF ("%item%" STRING_COMPARE_CASE "same") BEGIN
        WRITE_ASCIIE base ~%item%~ #8
      END
    END
  END

END

/////                                                  \\\\\
///// CD_EXTEND-O-MATIC, patent pending                \\\\\
/////                                                  \\\\\

// this function creates headers and does basic duration extensions to level 30; written for inwd-in-bg2 ages ago
DEFINE_PATCH_FUNCTION CD_EXTEND-O-MATIC
  INT_VAR base_dur    =  0 // constant to add to all durations
          step_dur    =  6 // how much duration to add to each consecutive header
          step_size   =  1 // how many levels between headers
          level_cap   = 20 // stop extending at level
          min_dur     =  4 // ignore effects with durations less than this (e.g. cosmetics)
          dur_special =  0 // just add step_dur to existing effects (ignore base_dur)
          min_lev_alt =  0 // if extending from level 1, use this value as its minimum level instead (e.g. fifth slevel spell with only one header, use 9 here)
BEGIN

  READ_LONG  0x64 abil_off
  READ_SHORT 0x68 abil_num
  READ_LONG  0x6a fx_off
  READ_SHORT (abil_off + 0x10 + (0x28 * (abil_num - 1))) min_lev // read level of last ability
  PATCH_IF ((min_lev = 1) AND (min_lev_alt != 0)) BEGIN SET min_lev = min_lev_alt END
  FOR (index = min_lev + step_size ; index < (level_cap + 1) ; index = index + step_size) BEGIN
    READ_ASCII (abil_off +        (0x28 * (abil_num - 1))) abil (0x28) // read entire ability
    READ_SHORT (abil_off + 0x1e + (0x28 * (abil_num - 1))) abil_fx_num
    READ_SHORT (abil_off + 0x20 + (0x28 * (abil_num - 1))) abil_fx_idx
    READ_ASCII (fx_off +        (0x30 * abil_fx_idx)) effects (abil_fx_num * 0x30) // read entire fx block
    INSERT_BYTES (fx_off +        (0x30 * (abil_fx_idx + abil_fx_num))) (abil_fx_num * 0x30) // insert bytes for new ability
    WRITE_ASCIIE (fx_off +        (0x30 * (abil_fx_idx + abil_fx_num))) "%effects%"          // write in effects block
    FOR (index2 = 0 ; index2 < abil_fx_num ; ++index2) BEGIN
      READ_LONG (fx_off + 0x0e + (0x30 * (abil_fx_idx + abil_fx_num + index2))) duration
      PATCH_IF (duration > min_dur) BEGIN // exclude instant/cosmetic efects
        PATCH_IF dur_special = 1 BEGIN
          SET new_dur = duration + step_dur
        END ELSE BEGIN
          SET new_dur = (base_dur + (index * step_dur))
        END
        WRITE_LONG (fx_off + 0x0e + (0x30 * (abil_fx_idx + abil_fx_num + index2))) new_dur // adjust durations
      END
    END
    INSERT_BYTES (abil_off +        (0x28 * abil_num)) 0x28 // insert new ability
    WRITE_ASCIIE (abil_off +        (0x28 * abil_num)) "%abil%"
    WRITE_SHORT  (abil_off + 0x10 + (0x28 * abil_num)) index
    WRITE_SHORT  (abil_off + 0x20 + (0x28 * abil_num)) (abil_fx_idx + abil_fx_num)
    SET abil_num += 1
    SET fx_off   += 0x28
  END
  WRITE_SHORT 0x68 abil_num
  WRITE_LONG  0x6a fx_off

END

/////                                                  \\\\\
///// CD_MISSING_SPELL_HEADERS                         \\\\\
/////                                                  \\\\\

// this function is useful for filling in missing spell headers between existing headers
// you'll pretty much have to run a series of ALTER_EFFECTs to fix the inserted effects, though
DEFINE_PATCH_FUNCTION CD_MISSING_SPELL_HEADERS
  INT_VAR first_missing =  0 // first missing level
          last_missing  =  0 // last missing level
BEGIN

  // sanity check
  PATCH_IF ((first_missing != 0) AND (last_missing != 0) AND (first_missing <= last_missing)) BEGIN
    // create headers first, then fix effects
    READ_LONG  0x64 abil_off
    READ_SHORT 0x68 abil_num
    READ_LONG  0x6a fx_off
    CLEAR_ARRAY cd_levels
    FOR (index = first_missing ; index < (last_missing + 1) ; ++index) BEGIN
      DEFINE_ASSOCIATIVE_ARRAY cd_levels BEGIN ~%index%~ => 0 END
    END
    SET new_abil = 0
    FOR (index = 0 ; index < abil_num ; ++index) BEGIN
      READ_SHORT  (abil_off + 0x10 + (0x28 * index)) min_lev
      PATCH_IF (min_lev < first_missing) BEGIN // last header before gap, keep overwriting as needed
        READ_SHORT (abil_off + 0x1e + (0x28 * index)) abil_fx_num
        READ_SHORT (abil_off + 0x20 + (0x28 * index)) abil_fx_idx
        READ_ASCII (abil_off + (0x28 * index))       abil_clone (0x28)
        READ_ASCII (fx_off + (0x30 * (abil_fx_idx))) fx_clone (0x30 * abil_fx_num)
        SET new_fx = abil_fx_num
        SET start_fx = (abil_fx_idx + abil_fx_num)
        SET insert = (abil_off + (0x28 * (index + 1)))
      END ELSE
      PATCH_IF (min_lev >= first_missing) AND (min_lev <= last_missing) BEGIN
        DEFINE_ASSOCIATIVE_ARRAY cd_levels BEGIN "%min_lev%" => 1 END
      END
    END
    PATCH_PHP_EACH cd_levels AS level => exist BEGIN
      PATCH_IF (exist = 0) BEGIN
        INSERT_BYTES   ((fx_off + (0x28 * new_abil)) + (0x30 * (start_fx * (new_abil + 1)))) (0x30 * new_fx)
          WRITE_ASCIIE ((fx_off + (0x28 * new_abil)) + (0x30 * (start_fx * (new_abil + 1)))) "%fx_clone%"
        INSERT_BYTES (insert + (0x28 * new_abil)) 0x28
          WRITE_ASCIIE (insert +        (0x28 * new_abil)) "%abil_clone%"
          WRITE_SHORT  (insert + 0x10 + (0x28 * new_abil)) level
          WRITE_SHORT  (insert + 0x1e + (0x28 * new_abil)) new_fx
          WRITE_SHORT  (insert + 0x20 + (0x28 * new_abil)) (start_fx * (new_abil + 1))
        SET new_abil += 1
      END
    END
    PATCH_IF (new_abil > 0) BEGIN
      SET abil_num += new_abil
      WRITE_SHORT 0x68 abil_num
      WRITE_LONG  0x6a (fx_off + (0x28 * new_abil))
      FOR (index = 0 ; index < abil_num ; ++index) BEGIN
        READ_SHORT  (abil_off + 0x10 + (0x28 * index)) min_lev
        PATCH_IF (min_lev > last_missing) BEGIN // if after new inserted effects
          WRITE_SHORT (abil_off + 0x20 + (0x28 * index)) (THIS + (new_abil * new_fx))
        END
      END
    END
  END
  
END