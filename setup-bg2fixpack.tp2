BACKUP ~bg2fixpack/backup~ // location to store files for uninstall purposes
AUTHOR ~pcamagna@yahoo.com~ // email address displayed if install fails

VERSION ~v9.21~

README ~bg2fixpack/readme-bg2fixpack.html~

ALLOW_MISSING

  //fixpack created files
  ~spin104a.spl~
  ~spwi314a.spl~
  
  // ToB area files
  ~ar3001.are~
  ~ar3003.are~
  ~ar3004.are~
  ~ar3005.are~
  ~ar3006.are~
  ~ar3007.are~
  ~ar3008.are~
  ~ar3009.are~
  ~ar3010.are~
  ~ar3011.are~
  ~ar3012.are~
  ~ar3013.are~
  ~ar3014.are~
  ~ar3016.are~
  ~ar3018.are~
  ~ar3021.are~
  ~ar3022.are~
  ~ar3023.are~
  ~ar4000.are~
  ~ar5000.are~
  ~ar5001.are~
  ~ar5002.are~
  ~ar5003.are~
  ~ar5004.are~
  ~ar5005.are~
  ~ar5006.are~
  ~ar5007.are~
  ~ar5008.are~
  ~ar5009.are~
  ~ar5010.are~
  ~ar5011.are~
  ~ar5012.are~
  ~ar5013.are~
  ~ar5014.are~
  ~ar5015.are~
  ~ar5200.are~
  ~ar5201.are~
  ~ar5202.are~
  ~ar5203.are~
  ~ar5204.are~
  ~ar5501.are~
  ~ar5502.are~
  ~ar5503.are~
  ~ar5504.are~
  ~ar5505.are~
  ~ar5506.are~
  ~ar5507.are~
  ~ar5508.are~
  ~ar5509.are~
  ~ar6000.are~
  ~ar6001.are~
  ~ar6008.are~
  ~ar6011.are~
  ~ar6012.are~
  ~ar6012.are~
  ~ar6100.are~
  ~ar6101.are~
  ~ar6102.are~
  ~ar6103.are~
  ~ar6105.are~
  ~ar6106.are~
  ~ar6107.are~
  ~ar6108.are~
  ~ar6109.are~
  ~ar6110.are~
  ~ar6111.are~
  ~ar6200.are~
  ~ar6300.are~
  ~ar6400.are~
  
  //ToB scripts
  ~ABAZDRAG.BCS~
  ~AESGAR.BCS~
  ~ALARM25.BCS~
  ~amduel1.bcs~
  ~amduel2.bcs~
  ~AMLICH01.BCS~
  ~AMLICH02.BCS~
  ~AR3020.BCS~
  ~AR3021.BCS~
  ~AR3351.BCS~
  ~AR4000.BCS~
  ~BALMONK.BCS~
  ~botsmith.bcs~
  ~CARCH20B.BCS~
  ~CARCH30B.BCS~
  ~CASSA20B.BCS~
  ~CASSA20C.BCS~
  ~CBARB20B.BCS~
  ~CBARD12A.BCS~
  ~CBERS20B.BCS~
  ~CESPEN.BCS~
  ~CFIGH20A.BCS~
  ~CFIGH20B.BCS~
  ~CFIGH30B.BCS~
  ~CFMAG20B.BCS~
  ~chalcy02.bcs~
  ~CHALDIE.BCS~
  ~chaltrol.bcs~
  ~CHALPC01.BCS~
  ~CKENS20B.BCS~
  ~CKENS30B.BCS~
  ~CKMAG20A.BCS~
  ~CKMAG20B.BCS~
  ~CKTHI20B.BCS~
  ~CMACL20A.BCS~
  ~CMAGE20A.BCS~
  ~CMAGE20B.BCS~
  ~CMONK20B.BCS~
  ~ctaltar.bcs~
  ~CTHIE20A.BCS~
  ~CTHIE20B.BCS~
  ~cut207c.bcs~
  ~CUT215A.BCS~
  ~CUT216A.BCS~
  ~DECK622.BCS~
  ~dlich01.bcs~
  ~DRACONIS.BCS~
  ~dragblue.bcs~
  ~DRAGBROW.BCS~
  ~DRAGGRE2.BCS~
  ~DRAGGREE.BCS~
  ~ELTAN.BCS~
  ~FINSOL04.BCS~
  ~FIRLCH01.BCS~
  ~FORCEF.BCS~
  ~FSWHEEL.BCS~
  ~gorbat.bcs~
  ~gorbat1.bcs~
  ~GORCAMB2.BCS~
  ~GORCAMB3.BCS~
  ~GORCAMB4.BCS~
  ~GORCAMB5.BCS~
  ~GORCAMB6.BCS~
  ~GORDECKF.BCS~
  ~GORGOLI.BCS~
  ~gorgua02.bcs~
  ~GORLIC01.BCS~
  ~GORSAL.BCS~
  ~GORSTAM.BCS~
  ~gortan.bcs~
  ~gortan1.bcs~
  ~GPHEALER.BCS~
  ~GPKENSAI.BCS~
  ~GPMAGE1.BCS~
  ~GPMAGE2.BCS~
  ~GPMERC.BCS~
  ~GPTHIEF.BCS~
  ~GRPSHT01.BCS~
  ~hgtrl01.bcs~
  ~ILLASERA.BCS~
  ~ITGLOBES.BCS~
  ~KUOARC20.BCS~
  ~KUOWAR20.BCS~
  ~MAGEHIGH.BCS~
  ~meliss01.bcs~
  ~meliss02.bcs~
  ~meliss03.bcs~
  ~MINDAL01.BCS~
  ~planet.bcs~
  ~salgrfir.bcs~
  ~SARBUL01.BCS~
  ~SARBUL02.BCS~
  ~SARBUL03.BCS~
  ~SARDW01.BCS~
  ~SARDW02.BCS~
  ~SARDW03.BCS~
  ~sarev25.bcs~
  ~sarrein.bcs~
  ~senbattl.bcs~
  ~SENDARK.BCS~
  ~SENGUA04.BCS~
  ~SENGUA05.BCS~
  ~tahazz.bcs~ 
  ~TELTIEF3.BCS~
  ~TELWRAI.BCS~
  ~TIEF3.BCS~
  ~trolic03.bcs~
  ~tomegol4.bcs~
  ~UND5509.BCS~
  ~XEIWIN.BCS~
  ~YAGALT.BCS~
  ~YAGART.BCS~
  ~YSCARA.BCS~
  ~YSGP01.BCS~
  ~YSGP02.BCS~
  ~YSGP03.BCS~
  ~YSGP04.BCS~
  ~YSGRUNT.BCS~
  ~ZILMAG01.BCS~

  // ToB creatures
  ~25spell.cre~
  ~abazigal.cre~
  ~abisred1.cre~
  ~aerie12.cre~
  ~ALUFIE01.CRE~
  ~alufie02.cre~
  ~amarch01.cre~
  ~amarch02.cre~
  ~amasana.cre~
  ~amcapt01.cre~
  ~amcarras.cre~
  ~amcler01.cre~
  ~amcler02.cre~
  ~amcst02.cre~
  ~amcst03.cre~
  ~amcst04.cre~
  ~amduel01.cre~
  ~amduel02.cre~
  ~amduel03.cre~
  ~amelm01.cre~
  ~amfaheed.cre~
  ~amfem01.cre~
  ~amfem02.cre~
  ~amfsleep.cre~
  ~AMGIRL01.CRE~
  ~amlich01.cre~
  ~ammag01.cre~
  ~AMMAJIRA.CRE~
  ~ammayor.cre~
  ~ammerc01.cre~
  ~ammerc02.cre~
  ~ammerc03.cre~
  ~ammerc04.cre~
  ~ammerc07.cre~
  ~ammerc08.cre~
  ~ammerc09.cre~
  ~ammgrd01.cre~
  ~ammgrd02.cre~
  ~ammgrd03.cre~
  ~ammgrd04.cre~
  ~ammgrd05.cre~
  ~ammlegs.cre~
  ~ammonk01.cre~
  ~ammonk02.cre~
  ~ammonk03.cre~
  ~ammonk04.cre~
  ~ammonk05.cre~
  ~ammonk06.cre~
  ~ammonk07.cre~
  ~AMMONK08.CRE~
  ~amsaemon.cre~
  ~amsmith.cre~
  ~amsmug01.cre~
  ~amsmug02.cre~
  ~amtarc01.cre~
  ~amtcap01.cre~
  ~amtcle01.cre~
  ~amtcler0.cre~
  ~amtgen01.cre~
  ~amtmag01.cre~
  ~anomen12.cre~
  ~army01.cre~
  ~argrim.cre~
  ~balelite.cre~
  ~balor01.cre~
  ~balth.cre~
  ~bazdra01.cre~
  ~bazdra02.cre~
  ~bazdra03.cre~
  ~bazeye01.cre~
  ~bazeye02.cre~
  ~bazliz01.cre~
  ~bazliz02.cre~
  ~bazliz03.cre~
  ~bazliz04.cre~
  ~bazmonk.cre~
  ~bazpat01.cre~
  ~bazpat02.cre~
  ~bazpat03.cre~
  ~BEHHIV01.CRE~
  ~bhaal01.cre~
  ~bonebld.cre~
  ~cernd14.cre~
  ~chalcy01.cre~
  ~chalcy02.cre~
  ~chaldt01.cre~
  ~chalin01.cre~
  ~chalpc01.cre~
  ~chalpc02.cre~
  ~chalpc03.cre~
  ~chalpc04.cre~
  ~chalpc05.cre~
  ~chalpc06.cre~
  ~chalpc07.cre~
  ~chalpc08.cre~
  ~chalpc09.cre~
  ~chalpc10.cre~
  ~chalpc11.cre~
  ~chalpc12.cre~
  ~chalpc13.cre~
  ~chalpc14.cre~
  ~chalpc15.cre~
  ~chalpc16.cre~
  ~chalrv01.cre~
  ~chalslay.cre~
  ~chang01.cre~
  ~chang02.cre~
  ~chevil01.cre~
  ~chevil02.cre~
  ~chevil03.cre~
  ~chevil04.cre~
  ~chevil05.cre~
  ~chevil06.cre~
  ~chevil07.cre~
  ~chevil08.cre~
  ~chevil09.cre~
  ~chevil10.cre~
  ~chgood01.cre~
  ~chgood04.cre~
  ~chgood05.cre~
  ~chgood06.cre~
  ~chgood07.cre~
  ~chgood08.cre~
  ~chgood09.cre~
  ~chsam01.cre~
  ~chsam02.cre~
  ~chtaz01.cre~
  ~chtaz02.cre~
  ~cutamfig.cre~
  ~cutamgrd.cre~
  ~cutammag.cre~
  ~cutbalth.cre~
  ~cutgrd01.cre~
  ~cutgrd02.cre~
  ~cutgrd03.cre~
  ~cutgrd04.cre~
  ~cutmelis.cre~
  ~D1GHOST.CRE~
  ~D1GORI.CRE~  
  ~D1MOTHDW.CRE~
  ~D1MOTHEL.CRE~
  ~D1MOTHHA.CRE~
  ~D1MOTHHU.CRE~
  ~d1sarev.cre~
  ~d1skel.cre~
  ~dbonef01.cre~
  ~DEADCOW1.CRE~
  ~DEADCOW2.CRE~
  ~DEADDEM1.CRE~
  ~deaddem2.cre~
  ~DEATHKNI.CRE~
  ~DECK615.CRE~
  ~deck622.cre~
  ~deckass1.cre~
  ~deckwar1.cre~
  ~dedsmug.cre~
  ~DEMABI01.CRE~
  ~DEMCOR01.CRE~
  ~demgla01.cre~
  ~demglab.cre~
  ~demglab2.cre~
  ~demglasu.cre~
  ~demilich.CRE~
  ~demoarch.cre~
  ~democler.cre~
  ~demogor1.cre~
  ~demogor2.cre~
  ~DEMOSUM1.CRE~
  ~DEMOSUM2.CRE~
  ~DEMOSUM3.CRE~
  ~DEMOSUM4.CRE~
  ~demsuc01.cre~
  ~deriny01.cre~
  ~devaevil.cre~
  ~devagood.cre~
  ~devast01.cre~
  ~devmon01.cre~
  ~dimp01.cre~
  ~dglab01.cre~
  ~DPFEMALE.CRE~
  ~dpmale.cre~
  ~DPSTAT05.CRE~
  ~dquas01.cre~
  ~dragblue.cre~
  ~dragbrow.cre~
  ~dragpurp.cre~
  ~dragyell.cre~
  ~dreampc.cre~
  ~drofod01.cre~
  ~drofod02.cre~
  ~drofod03.cre~
  ~drofod04.cre~
  ~DRUEAR01.CRE~
  ~drufir01.cre~
  ~ecolt.cre~
  ~edwin15.cre~
  ~ELEMchan.cre~
  ~elemcryo.cre~
  ~elemhydr.cre~
  ~elemimix.cre~
  ~elemogre.cre~
  ~elemsunn.cre~
  ~elemyanc.cre~
  ~elemzaam.cre~
  ~enddem01.cre~
  ~enddem02.cre~
  ~EYEEGL01.CRE~
  ~EYEGOR01.CRE~
  ~EYEDED01.CRE~
  ~EYESEK01.CRE~
  ~EYESNT01.CRE~
  ~EYEVIG01.CRE~
  ~famcat25.cre~
  ~famdus25.cre~
  ~famfai25.CRE~
  ~famfer25.CRE~
  ~famimp25.cre~ 
  ~fampsd25.CRE~
  ~famqua25.cre~
  ~famrab25.cre~
  ~fangel01.cre~
  ~finmel01.cre~
  ~finsol01.cre~
  ~finsol02.cre~
  ~finsol03.cre~
  ~finsol04.cre~
  ~firlch01.cre~
  ~fsdragon.cre~
  ~fsghos.cre~
  ~fsghos2.cre~
  ~FSGIBB.CRE~
  ~fsglob.cre~
  ~FSGOBL.CRE~
  ~fshorde2.cre~
  ~fshorde4.cre~
  ~fshorde5.cre~
  ~fshorde6.cre~
  ~FSMAGE01.CRE~
  ~FSMAGE02.CRE~
  ~FSMAGE03.CRE~
  ~fsmage04.cre~
  ~fsridd.cre~
  ~FSSKEL.CRE~
  ~fsspir1.cre~
  ~fsspir2.cre~
  ~fsspir3.cre~
  ~fsspira.cre~
  ~fsspirb.cre~
  ~fsspirc.cre~
  ~garock.cre~
  ~GIAFIR01.CRE~
  ~GORAIR01.CRE~
  ~gorair02.cre~
  ~golbon01.cre~
  ~golice01.cre~
  ~golmag01.cre~
  ~GORAPR.CRE~
  ~gorarc.cre~
  ~gorbat1.cre~
  ~gorbat2.cre~
  ~gorbat3.cre~
  ~gorbat4.cre~
  ~gorbat5.cre~
  ~gorbel.cre~
  ~gorcamb.cre~
  ~gorcamb2.cre~
  ~gorcamb3.cre~
  ~gorcamb4.cre~
  ~gorcamb5.cre~
  ~gorcamb6.cre~
  ~gorcamb7.cre~
  ~gorcar.cre~
  ~GORCHR.CRE~
  ~gordeck1.cre~
  ~gordeck2.cre~
  ~gordeck3.cre~
  ~gordeck4.cre~
  ~gordeck5.cre~
  ~gordeck6.cre~
  ~gordeck7.cre~
  ~gordeck8.cre~
  ~gordeck9.cre~
  ~gordecka.cre~
  ~gordeckf.cre~
  ~gordem.cre~
  ~gordem2.cre~
  ~gordemc1.cre~
  ~gorfirg.cre~
  ~gorgit.cre~
  ~gorgitc1.cre~
  ~gorgitc2.cre~
  ~gorgitc3.cre~
  ~gorgitc4.cre~
  ~gorgith2.cre~
  ~gorgua01.cre~
  ~gorgua02.cre~
  ~gorgua03.cre~
  ~gorgua04.cre~
  ~gorgua05.cre~
  ~gorimp01.cre~
  ~gorjelf2.cre~
  ~gorjelfu.cre~
  ~gorjelgr.cre~
  ~gorkuo01.cre~
  ~gorkuo02.cre~
  ~gorkuo03.cre~
  ~gorkuo04.cre~
  ~gorkuo05.cre~
  ~gorlic01.cre~
  ~gorlum.cre~
  ~gormad1.cre~
  ~GORMIM01.CRE~
  ~GORMIM02.CRE~
  ~GORMIM03.CRE~
  ~GORMIM04.CRE~
  ~GORMIND.CRE~
  ~gormisti.cre~
  ~gormistp.cre~
  ~gororc01.cre~
  ~gororc02.cre~
  ~gororc03.cre~
  ~gorpri1.cre~
  ~gorsal.cre~
  ~gorsku01.cre~
  ~gorsnake.cre~
  ~gorsta01.cre~
  ~gorsta02.cre~
  ~gorsta03.cre~
  ~gorsta04.cre~
  ~gorsta05.cre~
  ~gorsta06.cre~
  ~gorsta07.cre~
  ~gorsta08.cre~
  ~gorsta09.cre~
  ~gorsta10.cre~
  ~gorsta11.cre~
  ~gorsta12.cre~
  ~gorstalk.cre~
  ~gorsuc01.cre~
  ~gortan1.cre~
  ~gortan2.cre~
  ~gortan3.cre~
  ~gortan4.cre~
  ~gortan5.cre~
  ~gortan6.cre~
  ~gortor1.cre~
  ~gortor2.cre~
  ~gortor3.cre~
  ~gortor4.cre~
  ~gortor5.cre~
  ~gortor6.cre~
  ~gorwom01.cre~
  ~gorwom02.cre~
  ~gorwom03.cre~
  ~gorwom04.cre~
  ~gorwom05.cre~
  ~gorwom06.cre~
  ~gromg01.cre~
  ~gromg02.cre~
  ~gromg03.cre~
  ~gromg04.cre~
  ~gromg05.cre~
  ~gromg06.cre~
  ~gromg07.cre~
  ~gromg08.cre~
  ~gromg09.cre~
  ~gromg10.cre~
  ~gromg11.cre~
  ~gromg12.cre~
  ~gromg13.cre~
  ~gromg14.cre~
  ~gromnir.cre~
  ~haer19.cre~
  ~HGBER01.CRE~
  ~hgfel01.cre~
  ~hgkar01.cre~
  ~hgmag01.cre~
  ~hgmag02.cre~
  ~hgmis01.cre~
  ~hgmis02.cre~
  ~hgmnd2.cre~
  ~hgmound.cre~
  ~hgnya01.cre~
  ~hgnymph.cre~
  ~hgsal01.cre~
  ~hgskl01.cre~
  ~hgskl02.cre~
  ~hgskl03.cre~
  ~hgskl04.cre~
  ~hgsku01.cre~
  ~hgslv01.cre~
  ~hgtrl01.cre~
  ~hgwar02.cre~
  ~hgwra01.cre~
  ~hgwra02.cre~
  ~hgwra03.cre~
  ~icyuan04.cre~
  ~icyuan05.cre~
  ~illasera.cre~
  ~imoen15.cre~
  ~inp1ivsg.bcs~
  ~jahei14.cre~
  ~jan15.cre~
  ~jondem01.cre~
  ~jondem03.cre~
  ~jondem05.cre~
  ~keldor14.cre~
  ~killmonk.cre~
  ~kobswi01.cre~
  ~korgan15.cre~
  ~kuoarc20.cre~
  ~kuocle20.cre~
  ~kuowar20.cre~
  ~lichel01.cre~
  ~lout.cre~
  ~loveone1.cre~
  ~loveone2.cre~
  ~loveone3.cre~
  ~loveone4.cre~
  ~loveone5.cre~
  ~magcle20.cre~
  ~magetest.cre~
  ~malla01.cre~
  ~malla02.cre~
  ~mazzy15.cre~
  ~mddust.cre~
  ~MDEARTH.CRE~
  ~MDEARTH2.CRE~
  ~mdrak.cre~
  ~mel01.cre~
  ~meliss01.cre~
  ~melsum01.cre~
  ~melsum02.cre~
  ~melsum04.cre~
  ~melsum05.cre~
  ~melsum06.cre~
  ~mindva01.cre~
  ~mugger4.cre~
  ~nalia18.cre~
  ~pheas01.cre~
  ~PLANET01.CRE~
  ~planevil.cre~
  ~plangood.cre~
  ~planwish.cre~
  ~plshhg02.cre~
  ~PPGUY01.CRE~
  ~pudden01.cre~
  ~pudden02.cre~
  ~rabbit.cre~
  ~rock.cre~
  ~salgrfir.cre~
  ~salgrice.cre~
  ~saralegs.cre~
  ~sarbar01.cre~
  ~sarbar02.cre~
  ~sarbha01.cre~
  ~sarbha02.cre~
  ~sarbul01.cre~
  ~sarbul02.cre~
  ~sarbul03.cre~
  ~sarbul04.cre~
  ~sarbul05.cre~
  ~sarbul06.cre~
  ~sarbul07.cre~
  ~sarcpt01.cre~
  ~sarcult.cre~
  ~sarcult2.cre~
  ~sarculto.cre~
  ~SARDW01.CRE~
  ~sardw02.cre~
  ~sardw03.cre~
  ~sardw04.cre~
  ~sardw05.cre~
  ~sarelf01.cre~
  ~sarelf02.cre~
  ~sarelf03.cre~
  ~sarelf04.cre~
  ~sarelf05.cre~
  ~sarelf06.cre~
  ~sarevok.cre~
  ~sarevokg.cre~
  ~SARFAKI2.CRE~
  ~SARFAKIE.CRE~
  ~sargrd01.cre~
  ~sargrd02.cre~
  ~sargrd03.cre~
  ~sargrd04.cre~
  ~sargrd05.cre~
  ~sargrd06.cre~
  ~sargrd07.cre~
  ~sargrd08.cre~
  ~sargrd09.cre~
  ~sargrd10.cre~
  ~sargrd11.cre~
  ~sargrd12.cre~
  ~sargrd13.cre~
  ~sargrd14.cre~
  ~sargrd15.cre~
  ~sargrd16.cre~
  ~sarhal.cre~
  ~saripg01.cre~
  ~saripg02.cre~
  ~saripg03.cre~
  ~saripg04.cre~
  ~sarjai01.cre~
  ~sarkis01.cre~
  ~sarkis02.cre~
  ~sarkis03.cre~
  ~sarkis04.cre~
  ~sarmag01.cre~
  ~sarmat01.cre~
  ~sarmil01.cre~
  ~sarmil02.cre~
  ~sarmist.cre~
  ~sarorc01.cre~
  ~saroro01.cre~
  ~sarpro01.cre~
  ~sarprovf.cre~
  ~sarprovm.cre~
  ~sarrein1.cre~
  ~sarrein2.cre~
  ~sarson01.cre~
  ~sarspir.cre~
  ~SARTEM01.CRE~
  ~sarthf01.cre~
  ~sarthf02.cre~
  ~sartro01.cre~
  ~sartro02.cre~
  ~sartro03.cre~
  ~sarvam01.cre~
  ~sarvam02.cre~
  ~sarvam03.cre~
  ~sarvie01.cre~
  ~sarvolo.cre~
  ~SENANI01.CRE~
  ~SENANI02.CRE~
  ~SENANI03.CRE~
  ~senani04.cre~
  ~senani05.cre~
  ~sendai.cre~
  ~sendai2.cre~
  ~sendai3.cre~
  ~sendai4.cre~
  ~sendai5.cre~
  ~sendai6.cre~
  ~sendai7.cre~
  ~sendai8.cre~
  ~sendark.CRE~
  ~sendro01.cre~
  ~sendro02.cre~
  ~sendro03.cre~
  ~sendro04.cre~
  ~sendro05.cre~
  ~senfod01.cre~
  ~senfod02.cre~
  ~sengua01.cre~
  ~sengua02.cre~
  ~sengua03.cre~
  ~sengua04.cre~
  ~sengua05.cre~
  ~senken01.cre~
  ~senlich.cre~
  ~senmonk.cre~
  ~senorc01.cre~
  ~senorc02.cre~
  ~senorc03.cre~
  ~senorc04.cre~
  ~senpri01.cre~
  ~sensmsp2.cre~
  ~senstalk.cre~
  ~sewarc01.cre~
  ~sewarc02.cre~
  ~sewdue01.cre~
  ~sewdue02.cre~
  ~seworo01.cre~
  ~sewsha01.cre~
  ~sewsha02.cre~
  ~sewsha03.cre~
  ~sewyag01.cre~
  ~sewyag02.cre~
  ~sewyag03.cre~
  ~sewyag04.cre~
  ~shadfi02.cre~
  ~shugar01.cre~
  ~shugfg01.cre~
  ~shugho01.cre~
  ~shugmg01.cre~
  ~shugod01.cre~
  ~shugod02.cre~
  ~shugpr01.cre~
  ~shupol01.cre~
  ~skelar01.cre~
  ~skelar02.cre~
  ~slaysh01.cre~
  ~slifis02.cre~
  ~smspid02.cre~
  ~solar.cre~
  ~solar01.cre~
  ~spellh01.cre~
  ~spidvo01.cre~
  ~squirl.cre~
  ~squirr.cre~
  ~SWAAIR01.CRE~
  ~SWAAIR02.CRE~
  ~SWAEAR01.CRE~
  ~SWAEAR02.CRE~
  ~SWAFIR01.CRE~
  ~SWAAIR01.CRE~
  ~TELBAL1.CRE~
  ~telbal2.cre~
  ~telcam1.cre~
  ~telcor1.cre~
  ~telelfir.cre~
  ~telicesa.cre~
  ~telimp1.cre~
  ~TELPIT1.CRE~
  ~TELPIT2.CRE~
  ~TELSLAV.CRE~
  ~telsuc1.cre~
  ~telqua1.cre~
  ~telqua2.cre~
  ~TELTAN1.CRE~
  ~TELTAN2.CRE~
  ~teltief1.cre~
  ~teltief2.cre~
  ~teltief3.cre~
  ~telwrai.cre~
  ~tobban01.cre~
  ~tobban02.cre~
  ~tobban03.cre~
  ~tobban04.cre~
  ~tobpar01.cre~
  ~tobpar02.cre~
  ~tobpar03.cre~
  ~tobpar04.cre~
  ~tobpar05.cre~
  ~tobpar06.cre~
  ~tomegol1.cre~
  ~tomegol2.cre~
  ~tomegol3.cre~
  ~tomegol4.cre~
  ~trolic03.cre~
  ~trolic04.cre~
  ~turn.CRE~
  ~valyg14.cre~
  ~viconi16.cre~
  ~victown1.cre~
  ~victown2.cre~
  ~victown3.cre~
  ~wauksqu.cre~
  ~weregrdr.cre~
  ~werewyv1.cre~
  ~werewyv2.cre~
  ~wish01.cre~
  ~wish02.cre~
  ~wpwench1.cre~
  ~yaga01.cre~
  ~yaga02.cre~
  ~yaga03.cre~
  ~yaga04.cre~
  ~yaga05.cre~
  ~yagaspir.cre~
  ~yarmy01.cre~
  ~yarmy02.cre~
  ~yarmy03.cre~
  ~yscara01.cre~
  ~yscara02.cre~
  ~yscara03.cre~
  ~yscara05.cre~
  ~ysfire01.cre~
  ~ysfire02.cre~
  ~ysg2.cre~
  ~ysgp01.cre~
  ~ysgp02.cre~
  ~ysgp03.cre~
  ~ysgp04.cre~
  ~ysgp05.cre~
  ~ysgrunt.cre~
  ~ysguar01.cre~
  ~ysguar02.cre~
  ~ysguar03.cre~
  ~ysguar04.cre~
  ~ysguar05.cre~
  ~ysguar06.cre~
  ~ysmage01.cre~
  ~ysmage02.cre~
  ~yssold01.cre~
  ~yssold02.cre~
  ~yssold03.cre~
  ~yssold04.cre~
  ~yssold10.cre~
  ~yssold12.cre~
  ~yssold13.cre~
  ~yssold14.cre~
  ~yssold15.cre~
  ~yssold16.cre~
  ~zilarc01.cre~
  ~zilfgt01.cre~
  ~zilfgt02.cre~
  ~zilmag01.cre~
  
  // ToB items
  ~aeriebab.itm~
  ~ABAZRING.ITM~
  ~amul27.itm~
  ~amul28.itm~
  ~aurstaf.itm~
  ~ax1h16.itm~
  ~BAZPATRG.ITM~
  ~BHAALHP1.ITM~
  ~BHAALIMM.ITM~
  ~blun26.itm~
  ~blun27.itm~
  ~blun30.itm~
  ~blun31.itm~
  ~bolt09.itm~
  ~bonedag.itm~
  ~boot12.itm~
  ~bow20.itm~
  ~bow21.itm~
  ~bow22.itm~
  ~bow23.itm~
  ~bow24.itm~
  ~bow25.itm~
  ~bow26.itm~
  ~brac21.itm~
  ~brdflute.itm~
  ~bull05.itm~
  ~bull06.itm~
  ~chains.itm~
  ~chalcy2.itm~
  ~chalcy3.itm~
  ~CHALSLAY.ITM~
  ~chan20.itm~
  ~chan21.itm~
  ~dart08.itm~
  ~dartmel.itm~
  ~DEMOGORG.ITM~
  ~DEMSUC01.ITM~
  ~DEVA.ITM~
  ~devaevil.itm~
  ~druear.itm~
  ~drufir.itm~
  ~elemchan.itm~
  ~elemcryo.itm~
  ~elemhydr.itm~
  ~elemimix.itm~
  ~elemogre.itm~
  ~elemprin.itm~
  ~elemsunn.itm~
  ~elemyanc.itm~
  ~elemzaam.itm~
  ~eneblade.itm~
  ~famcat25.ITM~
  ~FAMDUS25.ITM~
  ~FAMFAI25.ITM~
  ~FAMFER25.ITM~
  ~FAMIMP25.ITM~
  ~FAMPSD25.ITM~
  ~FAMQUA25.ITM~
  ~FAMRAB25.ITM~
  ~FINMEL01.ITM~
  ~FSSPIR.ITM~
  ~GIAFIR.ITM~
  ~GIAFIR2.ITM~
  ~GIAFIR3.ITM~
  ~globblu1.itm~
  ~globblu3.itm~
  ~globgre1.itm~
  ~globpur3.itm~
  ~globred1.itm~
  ~globred2.itm~
  ~globred4.itm~
  ~golmag01.itm~
  ~gorcamb.itm~
  ~GORCHR.ITM~
  ~GORFIRG.ITM~
  ~GORJELFU.ITM~
  ~GORJELGR.ITM~
  ~GORMISTI.ITM~
  ~gormistp.itm~
  ~gorwom1.itm~
  ~gorwom2.itm~
  ~gorwom4.itm~
  ~HAMM10.ITM~
  ~HAMM11.ITM~
  ~helm30.itm~
  ~helm34.itm~
  ~hgber01.itm~
  ~hgnya01.itm~
  ~HGNYMPH.ITM~
  ~hgwra01.itm~
  ~hgwra02.itm~
  ~HOLDRING.ITM~
  ~icetrl.itm~
  ~impclaw.itm~
  ~INNOC.ITM~
  ~INNOC2.ITM~
  ~INVULNER.ITM~
  ~JWSUPER.ITM~
  ~kuobolt2.itm~
  ~kuobolt3.itm~
  ~leat24.itm~
  ~MEL01.ITM~
  ~mistice.itm~
  ~mistva2.itm~
  ~mound.itm~
  ~planetar.itm~
  ~plat20.itm~
  ~plat22.itm~
  ~plat23.itm~
  ~plot02a.itm~
  ~plot02b.itm~
  ~plot02c.itm~
  ~plot02d.itm~
  ~plot02e.itm~
  ~plot03a.itm~
  ~plot03b.itm~
  ~plot03c.itm~
  ~plot03d.itm~
  ~plot04i.itm~
  ~plot05a.itm~
  ~plot05b.itm~
  ~plot05c.itm~
  ~plot05d.itm~
  ~potn55.itm~
  ~potn56.itm~
  ~psdclaw.itm~
  ~quasclaw.itm~
  ~quiv01.itm~
  ~quiver01.itm~
  ~quiver02.itm~
  ~quiver03.itm~
  ~quiver04.itm~
  ~quiver05.itm~
  ~quiver06.itm~
  ~ravag01.itm~
  ~ravag02.itm~
  ~RAVAG03.ITM~
  ~ring46.itm~
  ~rods06.itm~
  ~sarbone.itm~
  ~sarskel.itm~
  ~sarskul.itm~
  ~scrlb4.itm~
  ~secret01.itm~
  ~secret02.itm~
  ~secret03.itm~
  ~secret04.itm~
  ~sendai.itm~
  ~SENGUA04.ITM~
  ~shakti1.itm~
  ~shararm.itm~
  ~slaysh01.ITM~
  ~spellh01.itm~
  ~sper11.itm~
  ~sper12.itm~
  ~spermel.itm~
  ~staf22.itm~
  ~stonring.ITM~
  ~SUREHP1.ITM~
  ~sw1h58.itm~
  ~sw1h59.itm~
  ~SW1H61.ITM~
  ~sw1h62.itm~
  ~sw1h63.itm~
  ~sw1h64.itm~
  ~sw1h65.itm~
  ~sw1h66.itm~
  ~SW1H69.ITM~
  ~sw1h71.itm~
  ~sw2h19.itm~
  ~sw2h21.itm~
  ~TELSLAV.ITM~
  ~TELSLAV2.ITM~
  ~umber02.itm~
  ~wand18.itm~
  ~wand19.itm~
  ~xbow15.itm~
  ~xbow16.itm~
  ~xbow17.itm~

  // ToB spells
  ~abzaway.spl~
  ~BALSHLD.SPL~
  ~balth01.spl~
  ~balth01a.spl~
  ~balth02.spl~
  ~BALTH03.SPL~
  ~BALTH05.SPL~
  ~balth10.spl~
  ~beguile.spl~
  ~BHAAL1b.SPL~
  ~bhaal2a.spl~
  ~BHAAL3A.SPL~
  ~BHAAL4A.SPL~
  ~BHAAL4B.SPL~
  ~CH3DRAIN.SPL~
  ~demochm.spl~
  ~dgarchon.spl~
  ~dgfaith.spl~
  ~dgright.spl~
  ~DRGRBRHT.SPL~
  ~JWFALL.SPL~
  ~jwglobe.SPL~
  ~JWONEHIT.SPL~
  ~JWSP02.SPL~
  ~LICHTEL.SPL~
  ~melis02.spl~
  ~SAREVEFF.SPL~
  ~senbehkd.spl~
  ~SENSPISU.SPL~
  ~spcl233b.spl~
  ~spcl900.spl~
  ~spcl901.spl~
  ~spcl902.spl~
  ~spcl903.spl~
  ~spcl904.spl~
  ~spcl905.spl~
  ~spcl906.spl~
  ~spcl907.spl~
  ~spcl909.spl~
  ~spcl910.spl~
  ~spcl910b.spl~
  ~spcl911.spl~
  ~spcl911b.spl~
  ~spcl912.spl~
  ~spcl912b.spl~
  ~spcl913.spl~
  ~spcl914.spl~
  ~spcl915.spl~
  ~spcl916.spl~
  ~spcl917.spl~
  ~spcl918.spl~
  ~spcl919.spl~
  ~spcl920.spl~
  ~spcl920a.spl~
  ~spcl921.spl~
  ~spcl921a.spl~
  ~spcl922.spl~
  ~spcl923.spl~
  ~spcl924.spl~
  ~spcl928.spl~
  ~spcl929.spl~
  ~spcl930.spl~
  ~spin529.spl~
  ~spin530.spl~
  ~spin531.spl~
  ~spin532.spl~
  ~spin534.spl~
  ~spin540.spl~
  ~spin544.spl~
  ~spin550.spl~
  ~spin553.spl~
  ~spin554.spl~
  ~spin555.spl~
  ~spin556.spl~
  ~spin557.spl~
  ~spin558.spl~
  ~spin571.spl~
  ~spin575.spl~
  ~spin576.spl~
  ~spin579.spl~
  ~spin580.spl~
  ~spin581.spl~
  ~spin582.spl~
  ~spin583.spl~
  ~spin584.spl~
  ~spin585.spl~
  ~spin586.spl~
  ~spin587.spl~
  ~spin588.spl~
  ~spin589.spl~
  ~spin590.spl~
  ~spin591.spl~
  ~spin594.spl~
  ~spin595.spl~
  ~spin596.spl~
  ~spin607.spl~
  ~spin611.spl~
  ~spin612.spl~
  ~spin613.spl~
  ~spin615.spl~
  ~spin616.spl~
  ~spin618.spl~
  ~spin626.spl~
  ~spin632.spl~
  ~spin640.spl~
  ~spin641.spl~
  ~spin644.spl~
  ~spin646.spl~
  ~spin647.spl~
  ~spin648.spl~
  ~spin649.spl~
  ~spinhum.spl~
  ~spmdslay.spl~
  ~sppr722.spl~
  ~sppr723.spl~
  ~sppr724.spl~
  ~sppr725.spl~
  ~sppr729.spl~
  ~sppr730.spl~
  ~sppr731.spl~
  ~sppr732.spl~
  ~spwi222.spl~
  ~spwi723.spl~
  ~spwi818.spl~
  ~spwi918.spl~
  ~spwi921.spl~
  ~spwi922.spl~
  ~spwi925.spl~
  ~spwish07.spl~
  ~spwish10.spl~
  ~spwish11.spl~
  ~spwish12.spl~
  ~spwish13.spl~
  ~spwish14.spl~
  ~spwish16.spl~
  ~spwish17.spl~
  ~spwish25.spl~
  ~spwish30.spl~
  ~spwish46.spl~
  ~spwm109.spl~
  ~spwm183.spl~
  ~urgekill.spl~

  // ToB stores
  ~25spell2.sto~
  ~amsmug01.sto~
  ~amsmug02.sto~
  ~bag20.sto~
  ~bag21.sto~
  ~bag22.sto~
  ~bag23.sto~
  ~bag24.sto~
  ~bag25.sto~
  ~bag26.sto~
  ~bag27.sto~
  ~bag28.sto~
  ~bag29.sto~
  ~bag30.sto~
  ~garlena.sto~
  ~hgkar01.sto~
  ~sartem01.sto~

  // ToB miscellany
  ~SPCL906B.EFF~

LANGUAGE ~English~                                ~english~ ~bg2fixpack/languages/english/setup.tra~
LANGUAGE ~Polski (by yarpen)~                     ~polski~  ~bg2fixpack/languages/english/setup.tra~
                                                            ~bg2fixpack/languages/polski/setup.tra~
LANGUAGE ~Espanol (by Immortality and Clan DLAN)~ ~spanish~ ~bg2fixpack/languages/english/setup.tra~
                                                            ~bg2fixpack/languages/spanish/setup.tra~
LANGUAGE ~Deutsch (by Leonardo Watson)~           ~german~  ~bg2fixpack/languages/english/setup.tra~
                                                            ~bg2fixpack/languages/german/setup.tra~
LANGUAGE ~Francais (by Anomaly)~                  ~french~  ~bg2fixpack/languages/english/setup.tra~
                                                            ~bg2fixpack/languages/french/setup.tra~
LANGUAGE ~Korean (by Web2Air)~                    ~korean~  ~bg2fixpack/languages/english/setup.tra~
                                                            ~bg2fixpack/languages/korean/setup.tra~
LANGUAGE ~Italian (by Andrea C.)~                 ~italian~ ~bg2fixpack/languages/english/setup.tra~
                                                            ~bg2fixpack/languages/italian/setup.tra~
LANGUAGE ~Russian (by Fess)~                      ~russian~ ~bg2fixpack/languages/english/setup.tra~
                                                            ~bg2fixpack/languages/russian/setup.tra~
LANGUAGE ~Japanese (by Taro)~                    ~japanese~ ~bg2fixpack/languages/english/setup.tra~
                                                            ~bg2fixpack/languages/japanese/setup.tra~
LANGUAGE ~Traditional Chinese (by good0593)~     ~tchinese~ ~bg2fixpack/languages/english/setup.tra~
                                                            ~bg2fixpack/languages/tchinese/setup.tra~
LANGUAGE ~Simplified Chinese (by good0593)~      ~schinese~ ~bg2fixpack/languages/english/setup.tra~
                                                            ~bg2fixpack/languages/schinese/setup.tra~

/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////                                                  \\\\\
///// Begin core component                             \\\\\
/////                                                  \\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\

BEGIN @0 DESIGNATED 0 // Core Fixes
REQUIRE_PREDICATE NOT FILE_EXISTS_IN_GAME ~druidab.bcs~ @26 // in case BD or Fixpack already installed
REQUIRE_PREDICATE NOT FILE_EXISTS_IN_GAME ~oh3500.are~  @27 // not needed for BGEE

// patch functions
INCLUDE ~bg2fixpack/lib/functions.tpa~

// os x "can't save" bug
ACTION_IF ~%WEIDU_OS%~ STRING_EQUAL_CASE ~osx~ THEN BEGIN
<<<<<<<< fix-temp
#!/bin/sh
test -f temp && (rm -f temp && mkdir temp)
>>>>>>>>
  COPY ~fix-temp~ ~fix-temp~
  AT_NOW ~sh fix-temp~
END

/////                                                  \\\\\
///// string fixes                                     \\\\\
/////                                                  \\\\\

STRING_SET  6709 @140 // weight of regular mace
STRING_SET  8857 @100 // Viconia's non-sequitir line
STRING_SET  8863 @101 // Viconia's non-sequitir line
STRING_SET 14320 @141 // symbol fear descript (1 round per 3 levels, not 2 rounds)
STRING_SET 17890 @127 // [VALYGA01] sound restoration
STRING_SET 25201 @137 // Berserker enrage missing protection list
STRING_SET 26315 @136 // spellstrike descript
STRING_SET 35168 @132 // [HAERDA95] sound restoration
STRING_SET 36460 @139 // flail +2 damage
STRING_SET 37155 @133 // [JANJAN67] sound restoration
// STRING_SET 39798 @107 // captain arat
STRING_SET 45869 @138 // Barbarian rage missing protection list
STRING_SET 58250 @134 // [ELLESI02] sound restoration
STRING_SET 60724 @112 // adalon soundset restoration
STRING_SET 60741 @113 // adalon soundset restoration

ACTION_IF ("%LANGUAGE%" STRING_COMPARE_CASE "korean") THEN BEGIN // no korean translation for these strings

  STRING_SET   176 @146 // speed factor of +2 long bow
  STRING_SET   199 @147 // speed factor of +2 short bow
  STRING_SET  1768 @148 // weight of plate mail
  STRING_SET  2494 @149 // speed factor of spear of withering
  STRING_SET  4330 @150 // [IMOEN20] sound fix
  STRING_SET  4421 @151 // sword of flame +1 speed factor fix
  STRING_SET  4432 @168 // soa dust mephit familiar item description
  STRING_SET  4433 @170 // soa fairy dragon familiar item description
  STRING_SET  4434 @162 // soa ferret familiar item description
  STRING_SET  4435 @164 // soa imp familiar item description
  STRING_SET  4436 @174 // soa quasit familiar item description
  STRING_SET  4437 @160 // soa pseudo-dragon familiar item description
  STRING_SET  4438 @166 // soa rabbit familiar item description
  STRING_SET  5962 @152 // sound resref fix
  STRING_SET  8064 @155 // globe of invulnerability descript
  STRING_SET 11848 @153 // wrong save v. death penalty for claw of kazgaroth
  STRING_SET 12146 @154 // minor globe of invulnerability descript
  STRING_SET 25894 @156 // teleport field has no saving throw
  STRING_SET 41385 @172 // soa cat familiar item description
  STRING_SET 45889 @159 // find familiar spell descript
  STRING_SET 46589 @157 // prevent dupe CoC items; see also sahkng01.bcs, ar2300.bcs, sahpr4.cre, sahpr2.dlg
  STRING_SET 46590 @158 // prevent dupe CoC items; see also sahkng01.bcs, ar2300.bcs, sahpr4.cre, sahpr2.dlg
  
  //Description fixes for item weight, speed factor and other things (Wisp)
  //NB. This will need to be moved based on what translations we get (as will the corresponding ToB part)
  STRING_SET  1764 @209   
              8505 @191
             19359 @177
             21957 @210
             32186 @211
             32187 @212
             34732 @190
             39461 @213
             39511 @179
             39531 @189
             39579 @183
             39626 @196
             39627 @197
             39629 @198
             39631 @199
             39632 @200
             39633 @201
             39634 @202
             41389 @185
             41620 @186
             41621 @187
             47131 @182
             48658 @206
             51884 @204
             51947 @192
             51949 @193
             54340 @180
             57897 @181
             61580 @184
             61593 @208

END

ACTION_IF (FILE_EXISTS_IN_GAME ~mel01.cre~) AND ("%LANGUAGE%" STRING_COMPARE_CASE "korean") THEN BEGIN // tob strings, no korean trans

  STRING_SET 72757 @173 // tob cat familiar item description
  STRING_SET 72760 @169 // tob dust mephit familiar item description
  STRING_SET 72762 @171 // tob fairy dragon familiar item description
  STRING_SET 72763 @163 // tob ferret familiar item description
  STRING_SET 72764 @165 // tob imp familiar item description
  STRING_SET 72765 @161 // tob pseudo-dragon familiar item description
  STRING_SET 72766 @175 // tob quasit familiar item description
  STRING_SET 72767 @167 // tob rabbit familiar item description
  
  //Description fixes for item weight and speed factor (Wisp)
  STRING_SET 66203 @205
             66369 @203
             66372 @194
             66474 @195
             70785 @207
             71058 @188
             71131 @176
             73912 @178
  
END

/////                                                  \\\\\
///// ids fixes                                        \\\\\
/////                                                  \\\\\

// add ToB scripting actions/triggers to SoA; done as a library in case other mods want to nab it
INCLUDE ~bg2fixpack/lib/tob2soa.tph~

// imprisoned summon fix: see cdwi917a.spl, cdwi910.eff, cdwi917a.eff, spin580.spl, spin626.spl, spin788.spl, spwi910.spl, spwi917.spl
APPEND ~gender.ids~ ~66 IMPRISONED_SUMMONED~ UNLESS ~^66 ~

// fixing kit.ids; creature corrections are down in the creature section
COPY_EXISTING ~kit.ids~ ~override~
  REPLACE_TEXTUALLY ~.*\bTRUECLASS\b~              ~0x4000 TRUECLASS~
  REPLACE_TEXTUALLY ~.*\bBERSERKER\b~              ~0x4001 BERSERKER~
  REPLACE_TEXTUALLY ~.*\bWIZARDSLAYER\b~           ~0x4002 WIZARDSLAYER~
  REPLACE_TEXTUALLY ~.*\bKENSAI\b~                 ~0x4003 KENSAI~
  REPLACE_TEXTUALLY ~.*\bCAVALIER\b~               ~0x4004 CAVALIER~
  REPLACE_TEXTUALLY ~.*\bINQUISITOR\b~             ~0x4005 INQUISITOR~
  REPLACE_TEXTUALLY ~.*\bUNDEADHUNTER\b~           ~0x4006 UNDEADHUNTER~
  REPLACE_TEXTUALLY ~.*\bMAGESCHOOL_ABJURER\b~     ~0x0040 MAGESCHOOL_ABJURER~
  REPLACE_TEXTUALLY ~.*\bMAGESCHOOL_CONJURER\b~    ~0x0080 MAGESCHOOL_CONJURER~
  REPLACE_TEXTUALLY ~.*\bMAGESCHOOL_DIVINER\b~     ~0x0100 MAGESCHOOL_DIVINER~
  REPLACE_TEXTUALLY ~.*\bMAGESCHOOL_ENCHANTER\b~   ~0x0200 MAGESCHOOL_ENCHANTER~
  REPLACE_TEXTUALLY ~.*\bMAGESCHOOL_ILLUSIONIST\b~ ~0x0400 MAGESCHOOL_ILLUSIONIST~
  REPLACE_TEXTUALLY ~.*\bMAGESCHOOL_INVOKER\b~     ~0x0800 MAGESCHOOL_INVOKER~
  REPLACE_TEXTUALLY ~.*\bMAGESCHOOL_NECROMANCER\b~ ~0x1000 MAGESCHOOL_NECROMANCER~
  REPLACE_TEXTUALLY ~.*\bMAGESCHOOL_TRANSMUTER\b~  ~0x2000 MAGESCHOOL_TRANSMUTER~
  REPLACE_TEXTUALLY ~.*\bMAGESCHOOL_GENERALIST\b~  ~0x4000 MAGESCHOOL_GENERALIST~
  REPLACE_TEXTUALLY ~.*\bFERALAN\b~                ~0x4007 FERALAN~
  REPLACE_TEXTUALLY ~.*\bSTALKER\b~                ~0x4008 STALKER~
  REPLACE_TEXTUALLY ~.*\bBEASTMASTER\b~            ~0x4009 BEASTMASTER~
  REPLACE_TEXTUALLY ~.*\bASSASIN\b~                ~0x400A ASSASIN~
  REPLACE_TEXTUALLY ~.*\bBOUNTYHUNTER\b~           ~0x400B BOUNTYHUNTER~
  REPLACE_TEXTUALLY ~.*\bSWASHBUCKLER\b~           ~0x400C SWASHBUCKLER~
  REPLACE_TEXTUALLY ~.*\bBLADE\b~                  ~0x400D BLADE~
  REPLACE_TEXTUALLY ~.*\bJESTER\b~                 ~0x400E JESTER~
  REPLACE_TEXTUALLY ~.*\bSKALD\b~                  ~0x400F SKALD~
  REPLACE_TEXTUALLY ~.*\bGODTALOS\b~               ~0x4013 GODTALOS~
  REPLACE_TEXTUALLY ~.*\bGODHELM\b~                ~0x4014 GODHELM~
  REPLACE_TEXTUALLY ~.*\bGODLATHANDER\b~           ~0x4015 GODLATHANDER~
  REPLACE_TEXTUALLY ~.*\bTOTEMIC\b~                ~0x4010 TOTEMIC~
  REPLACE_TEXTUALLY ~.*\bSHAPESHIFTER\b~           ~0x4011 SHAPESHIFTER~
  REPLACE_TEXTUALLY ~.*\bBEASTFRIEND\b~            ~0x4012 BEASTFRIEND~
  //REPLACE_TEXTUALLY ~.*\bBARBARIAN\b~              ~0x0000 BARBARIAN~ //Avoid changing the values, what with ToBEx and all (Wisp)
  //REPLACE_TEXTUALLY ~.*\bWILDMAGE\b~               ~0x0000 WILDMAGE~
  BUT_ONLY_IF_IT_CHANGES

APPEND ~kit.ids~ ~0x4000 TRUECLASS~
  UNLESS ~\bTRUECLASS\b~
APPEND ~kit.ids~ ~0x0000 BARBARIAN~
  UNLESS ~\bBARBARIAN\b~
APPEND ~kit.ids~ ~0x0000 WILDMAGE~
  UNLESS ~\bWILDMAGE\b~

// projectl.ids changes; projectiles need to be added early to make variable available for spell/item patching
// new projectile to correct detect evil range; see cddetevl.spl for additional changes
ADD_PROJECTILE ~bg2fixpack/pro/CDDETEVL.pro~

// clone beholder ray and assign it to beholder lightning bolt spells
// this allows it to be reflected by cloak of reflection without also reflecting all beholder projectiles
COPY_EXISTING ~spbehbla.pro~ ~override/cdbehbla.pro~
ADD_PROJECTILE ~override/cdbehbla.pro~

// eliminates duplicate SHADOW entries
COPY_EXISTING ~race.ids~ ~override~
  REPLACE_TEXTUALLY ~^149 +SHADOW\b~ ~149 STATUE~
  BUT_ONLY_IF_IT_CHANGES

// add ettin racial entry; needed to give Crom ability to insta-kill ettins
APPEND ~race.ids~ ~199 ETTIN~ UNLESS ~199 ETTIN~

// added snares for scripting purposes, fix broken entry
COPY_EXISTING ~spell.ids~ ~override~
  REPLACE_TEXTUALLY ~3544 PSIONIC _SUPERIOR_INVISIBILITY~ ~3544 PSIONIC_SUPERIOR_INVISIBILITY~
APPEND ~spell.ids~ ~1718 CLERIC_SYMBOL_STUN~      UNLESS ~^1718 CLERIC_SYMBOL_STUN~
APPEND ~spell.ids~ ~1719 CLERIC_SYMBOL_DEATH~     UNLESS ~^1719 CLERIC_SYMBOL_DEATH~
APPEND ~spell.ids~ ~4321 BERSERKER_ENRAGE~        UNLESS ~^4321 BERSERKER_ENRAGE~
APPEND ~spell.ids~ ~4412 THIEF_SET_SNARE~         UNLESS ~^4412 THIEF_SET_SNARE~
APPEND ~spell.ids~ ~4414 THIEF_SET_SPECIAL_SNARE~ UNLESS ~^4414 THIEF_SET_SPECIAL_SNARE~

// new state needed to fix Dead() triggers that don't use DVs
APPEND ~state.ids~ ~0x00000FC0 STATE_REALLY_DEAD~ UNLESS ~0x00000FC0 STATE_REALLY_DEAD~

// force WeiDU to reload altered IDS files
CLEAR_IDS_MAP

/////                                                  \\\\\
///// misc 2da fixes                                   \\\\\
/////                                                  \\\\\

// chicken sound fixes
COPY_EXISTING achk.2da override
  SET_2DA_ENTRY 12 1 1 0
  SET_2DA_ENTRY 14 1 1 0
BUT_ONLY

// sound fix
COPY_EXISTING achk.2da ~override/mshr.2da~ // It's easier to just build these from the ground up
  SET_2DA_ENTRY_LATER ~mshr~  0 0 ~MSHR /shrieker/~
  SET_2DA_ENTRY_LATER ~mshr~  3 1 ~SHRIE04B NOSOUND NOSOUND~
  SET_2DA_ENTRY_LATER ~mshr~  4 1 ~2 0 0~
  SET_2DA_ENTRY_LATER ~mshr~ 11 1 ~SHRIE07A SHRIE07B~
  SET_2DA_ENTRY_LATER ~mshr~ 12 1 ~0 0~
  SET_2DA_ENTRY_LATER ~mshr~ 13 1 ~SHRIE09A SHRIE09B~
  SET_2DA_ENTRY_LATER ~mshr~ 14 1 ~0 0~
  SET_2DA_ENTRY_LATER ~mshr~ 25 1 ~SHRIE03A NOSOUND NOSOUND~
  SET_2DA_ENTRY_LATER ~mshr~ 26 1 ~2 0 0~
  SET_2DA_ENTRY_LATER ~mshr~ 27 1 ~SHRIE03B NOSOUND NOSOUND~
  SET_2DA_ENTRY_LATER ~mshr~ 28 1 ~2 0 0~
  SET_2DA_ENTRY_LATER ~mshr~ 29 1 ~SHRIE04A NOSOUND NOSOUND~
  SET_2DA_ENTRY_LATER ~mshr~ 30 1 ~2 0 0~
  SET_2DA_ENTRY_LATER ~mshr~ 39 1 ~***~ // Doesn't really need a battle cry, since it doesn't ever attack
  SET_2DA_ENTRIES_NOW ~mshr~ 1

// allows multi-class thieves to be LN and LE
COPY_EXISTING ~ALIGNMNT.2da~ ~override~
  SET_2DA_ENTRY_LATER ~ALIGNMNT~ 13 2 ~1~
  SET_2DA_ENTRY_LATER ~ALIGNMNT~ 13 3 ~1~
  SET_2DA_ENTRY_LATER ~ALIGNMNT~ 14 2 ~1~
  SET_2DA_ENTRY_LATER ~ALIGNMNT~ 14 3 ~1~
  SET_2DA_ENTRY_LATER ~ALIGNMNT~ 15 2 ~1~
  SET_2DA_ENTRY_LATER ~ALIGNMNT~ 15 3 ~1~
  SET_2DA_ENTRY_LATER ~ALIGNMNT~ 17 2 ~1~
  SET_2DA_ENTRY_LATER ~ALIGNMNT~ 17 3 ~1~
  SET_2DA_ENTRIES_NOW ~ALIGNMNT~ 1
  BUT_ONLY_IF_IT_CHANGES
  
// blade pp fix
COPY_EXISTING ~clabba02.2da~ ~override~
  SET_2DA_ENTRY_LATER ~blade~ 8 1 ~AP_CDBLPP1~
  FOR (col = 2 ; col < 18 ; col = col + 2) BEGIN
    SET_2DA_ENTRY_LATER ~blade~ 8 col ~AP_CDBLPP3~
  END
  FOR (col = 3 ; col < 18 ; col = col + 2) BEGIN
    SET_2DA_ENTRY_LATER ~blade~ 8 col ~AP_CDBLPP2~
  END
  FOR (col = 17 ; col < 37 ; col = col + 2) BEGIN
    SET_2DA_ENTRY_LATER ~blade~ 8 col ~AP_CDBLPP4~
  END
  FOR (col = 18 ; col < 37 ; col = col + 2) BEGIN
    SET_2DA_ENTRY_LATER ~blade~ 8 col ~AP_CDBLPP5~
  END
  SET_2DA_ENTRIES_NOW ~blade~ 1
  BUT_ONLY_IF_IT_CHANGES

//Fix Skald's lack of thac0 bonus
COPY_EXISTING ~CLABBA04.2DA~ ~override~
  REPLACE_TEXTUALLY ~AP_SPCL541~ ~AP_SPCL141~ // Replaces Skald's +1 damage with Swashbuckler's +1 thac0/damage.
  UNLESS ~AP_SPCL141~
  BUT_ONLY_IF_IT_CHANGES

// in SoA, two swashbuckler ability columns run together
COPY_EXISTING ~clabth04.2da~ ~override~
 REPLACE_TEXTUALLY ~\(AP_SPCL[14]41\)\(\*+\|GA_SPCL412\)~ ~\1 \2~
 BUT_ONLY_IF_IT_CHANGES

//The progression of the Kensai abilities SPCL141 and SPCL143 are both irregular; the table is also one cell short in the first row
//The levels for SPCL143 for level < 9 are the same as vanilla
COPY_EXISTING clabfi04.2da override
  REPLACE_TEXTUALLY ~AP_SPCL141[ %TAB%]+\*\*\*\*[ %TAB%]+AP_SPCL141~
                    ~AP_SPCL141  **** ****  AP_SPCL141~            //Fix the broken progression for SPCL141 by adding the missing cell
  REPLACE_TEXTUALLY AP_SPCL143 "****"                              //Remove all instances of SPCL143 and start from scratch
  COUNT_2DA_COLS cols
  READ_2DA_ENTRIES_NOW "#rclabfi04" cols
  PATCH_FOR_EACH j IN 1 4 BEGIN                                    //Write the entries for levels < 8
    FOR (i = 0; i < "#rclabfi04"; ++i) BEGIN
      READ_2DA_ENTRY_FORMER "#rclabfi04" i j entry
      PATCH_IF "%entry%" STRING_EQUAL "****" BEGIN
        SET_2DA_ENTRY_LATER "#sclabfi04" i j AP_SPCL143
        i = "#rclabfi04"
      END
    END
  END
  FOR (i = 8; i < cols; i += 4) BEGIN                              //Add abilities every 4 levels starting at level 8
    FOR (j = 0; j < "#rclabfi04"; ++j) BEGIN
      READ_2DA_ENTRY_FORMER "#rclabfi04" j i entry
      PATCH_IF "%entry%" STRING_EQUAL "****" BEGIN
        SET_2DA_ENTRY_LATER "#sclabfi04" j i AP_SPCL143
        j = "#rclabfi04"
      END
    END
  END
  SET_2DA_ENTRIES_NOW "#sclabfi04" cols
  PRETTY_PRINT_2DA
BUT_ONLY

// fallen paladin/ranger missing a column in their ABILITY1 line
COPY_EXISTING ~clabfi05.2da~ ~override~
 REPLACE_TEXTUALLY ~^\(ABILITY1 +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+ +[^ %TAB%]+\).*$~ ~\1~
 BUT_ONLY_IF_IT_CHANGES

// in ToB archers and stalkers not allowed to dual-class; adding restriction to SoA games as well
COPY_EXISTING ~dualclas.2da~ ~override~
  SET_2DA_ENTRY 32 2 7 ~0~ // archer (feralan)
  SET_2DA_ENTRY 33 2 7 ~0~ // stalker
  BUT_ONLY_IF_IT_CHANGES

// Imoen gets her groove back. And her banter file.
ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN

  COPY_EXISTING ~interdia.2da~ ~override~
    SET_2DA_ENTRY 17 1 2 ~BIMOEN2~ // fixes ToB version
    BUT_ONLY_IF_IT_CHANGES

END ELSE BEGIN

  APPEND ~interdia.2da~ ~IMOEN       BIMOEN2~ // fixes SoA version
    UNLESS ~BIMOEN2~

END
  
// maze not lasting as long as specified in descript; patching intmod.2da for int < 9
COPY_EXISTING ~intmod.2da~ ~override~
  SET "dice" = 20
  FOR (index = 3 ; index < 12 ; index = index + 1) BEGIN
    SET_2DA_ENTRY_LATER ~intmod~ "%index%" 4 "%dice%"
    PATCH_IF ("%index%" = 5) BEGIN
      SET "dice" = 10
    END ELSE
    PATCH_IF ("%index%" = 8) BEGIN
      SET "dice" = 5
    END
  END
  SET_2DA_ENTRIES_NOW ~intmod~ 1
  BUT_ONLY_IF_IT_CHANGES

// Mithral Field Plate Armor +2 and Missile Attraction +2 armors can no longer be worn together with rings and amulets of protection (Wisp)
APPEND itemexcl.2da "bruenpla 1" UNLESS bruenpla
APPEND itemexcl.2da "leat06 1" UNLESS leat06

// removes incorrect NWN reference in load hints
COPY_EXISTING ~loadhint.2da~ ~override~
  REPLACE_TEXTUALLY ~40954~ ~34572~
  BUT_ONLY_IF_IT_CHANGES

// sound fixes for monsters
COPY_EXISTING mair.2da ~override/mwwe.2da~
  REPLACE_TEXTUALLY ~Mair/air elemental~ ~%DEST_RES% /water weird~

COPY_EXISTING mcar.2da ~override/mcwl.2da~
  REPLACE_TEXTUALLY ~Mcar/carrion crawler~ ~%DEST_RES% /Carrion Crawler/~

COPY_EXISTING mdji.2da ~override/mdjl.2da~
  REPLACE_TEXTUALLY ~Mdji/Djinni~ ~%DEST_RES% /djinni w legs/~

COPY_EXISTING mgo1.2da ~override/mgo3.2da~
  REPLACE_TEXTUALLY ~MGO1 /goblin w axe/~ ~%DEST_RES% /goblin elite w axe/~

COPY_EXISTING mgo2.2da ~override/mgo4.2da~
  REPLACE_TEXTUALLY ~MGO2 /goblin w bow/~ ~%DEST_RES% /goblin elite w bow/~

COPY_EXISTING mli2.2da ~override/mli3.2da~
  REPLACE_TEXTUALLY ~MLI2 /lizard man 1 hand/~ ~%DEST_RES% /lizard man caster 3/~

COPY_EXISTING mmyc.2da ~override/mmy2.2da~
  REPLACE_TEXTUALLY ~MMYC /myconid,red/~ ~%DEST_RES% /myconid,blue/~

COPY_EXISTING mor2.2da override
  REPLACE_TEXTUALLY "orcbw07" "orcbw07a"
  REPLACE_TEXTUALLY "orcbw08" "orcbw07b"
BUT_ONLY

COPY_EXISTING mor2.2da ~override/mor4.2da~
  REPLACE_TEXTUALLY ~MOR2 /orc w bow/~  ~%DEST_RES% /orc ranged 4/~

COPY_EXISTING msal.2da ~override/msa2.2da~
  REPLACE_TEXTUALLY ~MSAL /salamander/~ ~%DEST_RES% /salamander,frost/~

COPY_EXISTING mska.2da ~override/mskt.2da~
  REPLACE_TEXTUALLY ~MSKA /skeleton,armored/~ ~%DEST_RES% /skeleton armored no helmet/~

// small spider soundset fixes
COPY_EXISTING msps.2da override
  REPLACE_TEXTUALLY ~^Selection +smspid03~ ~Selection                       smspid01~
  REPLACE_TEXTUALLY ~\bsmspid03 +smspid04~ ~smspid01 smspid02~
  REPLACE_TEXTUALLY ~\bsmspid08~ ~smspid06~
  REPLACE_TEXTUALLY ~\bsmspid09~ ~smspid07~
BUT_ONLY

/* does nothing :(
COPY_EXISTING mtro.2da override
  REPLACE_TEXTUALLY ~TROLL08a~ ~troll07a troll07b~
  REPLACE_TEXTUALLY ~TROLL08b~ ~troll08a troll08b~
  SET_2DA_ENTRY 4 2 3 ~0 0 0~
BUT_ONLY
*/

// small troll sounds
COPY_EXISTING mtrs.2da override
  REPLACE_TEXTUALLY ~ICETR~ ~troll~
BUT_ONLY

COPY_EXISTING mwfm.2da override
  REPLACE_TEXTUALLY ~pseudo0~ ~pseud0~
BUT_ONLY

COPY_EXISTING myu2.2da override
  REPLACE_TEXTUALLY ~yanel\(7\|8\)~ ~yanel0\1~
BUT_ONLY

// gives bards a fourth level 6 spell at high levels, SoA-only
ACTION_IF NOT FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN

  COPY_EXISTING ~MXSPLBRD.2da~ ~override~
    COUNT_2DA_ROWS ~1~ "rowcount"
    FOR (row = rowcount ; row > (rowcount - 19) ; row = row - 1) BEGIN
      SET_2DA_ENTRY_LATER ~MXSPLBRD~ "%row%" 6 ~4~
    END
    SET_2DA_ENTRIES_NOW ~MXSPLBRD~ 1
    BUT_ONLY_IF_IT_CHANGES

END

// NPCs joining level 25+ PCs in SoA would be at their minimum level, not max
COPY_EXISTING ~npclevel.2da~ ~override~
  REPLACE_TEXTUALLY ~^\([A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+[%TAB% ]+[A-Za-z0-9*]+\)\([%TAB% ]+[A-Za-z0-9*]+\)~
    ~\1\2\2\2\2\2\2\2\2\2\2\2\2\2\2\2\2\2~ // extends individual lines
  REPLACE_TEXTUALLY ~\(2[%TAB% ]+3[%TAB% ]+4[%TAB% ]+5[%TAB% ]+6[%TAB% ]+7[%TAB% ]+8[%TAB% ]+9[%TAB% ]+10[%TAB% ]+11[%TAB% ]+12[%TAB% ]+13[%TAB% ]+14[%TAB% ]+15[%TAB% ]+16[%TAB% ]+17[%TAB% ]+18[%TAB% ]+19[%TAB% ]+20[%TAB% ]+21[%TAB% ]+22[%TAB% ]+23\)\([%TAB% ]+\)24~
    ~\1\224\225\226\227\228\229\230\231\232\233\234\235\236\237\238\239\240~ // extends header row
  UNLESS ~25[%TAB% ]+26[%TAB% ]+27[%TAB% ]+28[%TAB% ]+29[%TAB% ]+30[%TAB% ]+31[%TAB% ]+32[%TAB% ]+33[%TAB% ]+34[%TAB% ]+35[%TAB% ]+36[%TAB% ]+37[%TAB% ]+38[%TAB% ]+39[%TAB% ]+40~
  BUT_ONLY_IF_IT_CHANGES

// consistent raise dead prices
COPY_EXISTING ~RAISDEAD.2DA~ ~override~
  SET_2DA_ENTRY_LATER ~RAISDEAD~ 31 1 ~12500~
  SET_2DA_ENTRY_LATER ~RAISDEAD~ 32 1 ~13000~
  SET_2DA_ENTRY_LATER ~RAISDEAD~ 34 1 ~14000~
  SET_2DA_ENTRY_LATER ~RAISDEAD~ 36 1 ~15000~
  SET_2DA_ENTRY_LATER ~RAISDEAD~ 38 1 ~16000~
  SET_2DA_ENTRY_LATER ~RAISDEAD~ 40 1 ~17000~
  SET_2DA_ENTRY_LATER ~RAISDEAD~ 42 1 ~18000~
  SET_2DA_ENTRIES_NOW ~RAISDEAD~ 1
  BUT_ONLY_IF_IT_CHANGES

// fixes to high level rogue saves
COPY_EXISTING ~SAVEROG.2da~ ~override~
  FOR (col = 21 ; col < 41 ; col = col + 1) BEGIN
    SET_2DA_ENTRY_LATER ~SAVEROG~ 3 "%col%" ~8~
    SET_2DA_ENTRY_LATER ~SAVEROG~ 4 "%col%" ~4~
    SET_2DA_ENTRY_LATER ~SAVEROG~ 5 "%col%" ~7~
    SET_2DA_ENTRY_LATER ~SAVEROG~ 6 "%col%" ~11~
    SET_2DA_ENTRY_LATER ~SAVEROG~ 7 "%col%" ~5~
  END
  SET_2DA_ENTRIES_NOW ~SAVEROG~ 1
  BUT_ONLY_IF_IT_CHANGES

// fixes to high level mage saves
COPY_EXISTING ~SAVEWIZ.2da~ ~override~
  FOR (col = 21 ; col < 41 ; col = col + 1) BEGIN
    SET_2DA_ENTRY_LATER ~SAVEWIZ~ 3 "%col%" ~8~
    SET_2DA_ENTRY_LATER ~SAVEWIZ~ 4 "%col%" ~3~
    SET_2DA_ENTRY_LATER ~SAVEWIZ~ 5 "%col%" ~5~
    SET_2DA_ENTRY_LATER ~SAVEWIZ~ 6 "%col%" ~7~
    SET_2DA_ENTRY_LATER ~SAVEWIZ~ 7 "%col%" ~4~
  END
  SET_2DA_ENTRIES_NOW ~SAVEWIZ~ 1
  BUT_ONLY_IF_IT_CHANGES

//build skilldex down to 1
COPY_EXISTING ~skilldex.2da~ ~override~
  REPLACE_TEXTUALLY ~^9\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
~8\1
9\1~
  UNLESS ~^8\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
  BUT_ONLY_IF_IT_CHANGES
COPY_EXISTING ~skilldex.2da~ ~override~
  REPLACE_TEXTUALLY ~^8\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
~7\1
8\1~
  UNLESS ~^7\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
  BUT_ONLY_IF_IT_CHANGES
COPY_EXISTING ~skilldex.2da~ ~override~
  REPLACE_TEXTUALLY ~^7\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
~6\1
7\1~
  UNLESS ~^6\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
  BUT_ONLY_IF_IT_CHANGES
COPY_EXISTING ~skilldex.2da~ ~override~
  REPLACE_TEXTUALLY ~^6\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
~5\1
6\1~
  UNLESS ~^5\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
  BUT_ONLY_IF_IT_CHANGES
COPY_EXISTING ~skilldex.2da~ ~override~
  REPLACE_TEXTUALLY ~^5\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
~4\1
5\1~
  UNLESS ~^4\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
  BUT_ONLY_IF_IT_CHANGES
COPY_EXISTING ~skilldex.2da~ ~override~
  REPLACE_TEXTUALLY ~^4\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
~3\1
4\1~
  UNLESS ~^3\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
  BUT_ONLY_IF_IT_CHANGES
COPY_EXISTING ~skilldex.2da~ ~override~
  REPLACE_TEXTUALLY ~^3\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
~2\1
3\1~
  UNLESS ~^2\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
  BUT_ONLY_IF_IT_CHANGES
COPY_EXISTING ~skilldex.2da~ ~override~
  REPLACE_TEXTUALLY ~^2\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
~1\1
2\1~
  UNLESS ~^1\( .+ + .+ + .+ + .+ + .+ + .+ + .+\)~
  BUT_ONLY_IF_IT_CHANGES

// echo-y Promenade fix
COPY_EXISTING ~sndresrf.2da~ ~override~
  REPLACE_TEXTUALLY ~AR0700 +STONE0~ ~*       *~
  BUT_ONLY_IF_IT_CHANGES

// spell shield is hardcoded to display icon #73 which is currently protection from magical energy; need to swap
// see also states.bam, states2.bam, spwi606.spl
COPY_EXISTING ~statdesc.2da~ ~override~
  REPLACE_TEXTUALLY ~^\(73[%TAB% ]+\)[0-9]+~ ~\126228~
  REPLACE_TEXTUALLY ~^\(123[%TAB% ]+\)[0-9]+~ ~\18286~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~THAC0.2DA~ ~override~
  SET_2DA_ENTRY  6 21 1 ~10~
  SET_2DA_ENTRY  7 21 1 ~10~
  SET_2DA_ENTRY 15 21 1 ~10~
  BUT_ONLY_IF_IT_CHANGES

// adds dupe rod of lordly might, book of infinite spells
APPEND ~tooltip.2da~ ~RODS02A           6337         6352        6350~
APPEND ~tooltip.2da~ ~MISC3AA           6618         4731        -1~

COPY_EXISTING ~WEAPPROF.2da~ ~override~
  SET_2DA_ENTRY_LATER ~weapprof~ 16 41 ~2~ // 1 > 2 stars for swashbucklers in katanas
  SET_2DA_ENTRY_LATER ~weapprof~ 16 51 ~1~ // 0 > 1 star for monk in katanas
  SET_2DA_ENTRY_LATER ~weapprof~ 20 20 ~2~ // 3 > 2 stars for f/m/c in clubs
  SET_2DA_ENTRY_LATER ~weapprof~ 20 21 ~2~ // 3 > 2 stars for c/r in clubs
  SET_2DA_ENTRY_LATER ~weapprof~ 26 41 ~1~ // 2 > 1 star for swashbucklers in xbows
  SET_2DA_ENTRY_LATER ~weapprof~ 28 41 ~1~ // 2 > 1 star for swashbucklers in shortbows
  SET_2DA_ENTRY_LATER ~weapprof~ 29 32 ~0~ // 5 > 0 stars for kensai in darts
  SET_2DA_ENTRY_LATER ~weapprof~ 29 33 ~0~ // 2 > 0 stars for cavalier in darts
  SET_2DA_ENTRY_LATER ~weapprof~ 30 41 ~1~ // 2 > 1 star for swashbucklers in slings
  SET_2DA_ENTRY_LATER ~weapprof~ 31 19 ~2~ // 1 > 2 stars for f/d in 2 handed
  SET_2DA_ENTRY_LATER ~weapprof~ 31 20 ~2~ // 1 > 2 stars for f/m/c in 2 handed
  SET_2DA_ENTRY_LATER ~weapprof~ 31 21 ~2~ // 1 > 2 stars for c/r in 2 handed
//  SET_2DA_ENTRY_LATER ~weapprof~ 34  9 ~2~ // 3 > 2 stars for paladin in 2 wpn style
  SET_2DA_ENTRY_LATER ~weapprof~ 34 19 ~3~ // 1 > 3 stars for f/d in 2 wpn style
  SET_2DA_ENTRY_LATER ~weapprof~ 34 20 ~3~ // 2 > 3 stars for f/m/c in 2 wpn style
  SET_2DA_ENTRY_LATER ~weapprof~ 34 21 ~3~ // 2 > 3 stars for c/r in 2 wpn style
  COUNT_2DA_ROWS ~1~ "rowcount"
  FOR (row = rowcount ; row > (rowcount - 20) ; row = row - 1) BEGIN // covers last 19 rows (n/a as actual profs)
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%"  5 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%"  8 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%"  9 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 11 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 12 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 14 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 15 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 20 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 21 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 30 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 31 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 32 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 33 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 34 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 35 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 36 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 37 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 38 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 42 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 43 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 44 ~0~
    SET_2DA_ENTRY_LATER ~weapprof~ "%row%" 52 ~0~
  END
  SET_2DA_ENTRIES_NOW ~weapprof~ 1
  BUT_ONLY_IF_IT_CHANGES

ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB-only stuff check

  // invalid resource ref used for bard kits
  COPY_EXISTING ~25STWEAP.2da~ ~override~
    REPLACE_TEXTUALLY ~LEATH14~ ~LEAT14 ~
    
  // part of the multi-holy symbol exploit fix. Also needed: CDHLYSYM.spl, CDHLYSY2.spl, CDHLYSYM.itm, and holysym.baf.
  COPY_EXISTING ~clabpr01.2da~ ~override~
                ~clabpr02.2da~ ~override~
                ~clabpr03.2da~ ~override~
                ~clabpr04.2da~ ~override~
    REPLACE_TEXTUALLY ~AP_SPCl93[1234] ~ ~AP_CDHLYSYM~
    BUT_ONLY_IF_IT_CHANGES

  // adds load hints for ToB
  APPEND ~LOADH25.2DA~ ~79          34572~
               UNLESS ~^79 ~
  APPEND ~LOADHINT.2DA~ ~75          34572~
                UNLESS ~^75 ~
  APPEND ~LOADHINT.2DA~ ~76          72818~
                UNLESS ~^76 ~

  // removes incorrect NWN reference in load hints
  COPY_EXISTING ~loadh25.2da~ ~override~
    REPLACE_TEXTUALLY ~ 40954~ ~34572~
    BUT_ONLY_IF_IT_CHANGES

  // gives f/m/c and f/m/t unique HLAs; tables created below
  COPY_EXISTING ~LUABBR.2DA~ ~override~
    SET_2DA_ENTRY 14 1 1 ~FMT~
    SET_2DA_ENTRY 19 1 1 ~FMC~
    BUT_ONLY_IF_IT_CHANGES

  // Multiclass Thieves' Multiple Assassination Abilities Fix part 1
  COPY_EXISTING ~luba1.2da~ ~override~
                ~luba2.2da~ ~override~
                ~luba3.2da~ ~override~
                ~luth2.2da~ ~override~
                ~luth3.2da~ ~override~
    SET_2DA_ENTRY 9 7 1 ~*~
    SET_2DA_ENTRY 9 8 1 ~GA_SPCL916~
    BUT_ONLY_IF_IT_CHANGES

  // Multiclass Thieves' Multiple Assassination Abilities Fix part 2
  COPY_EXISTING ~LUCT0.2DA~ ~override~
                ~LUMT0.2DA~ ~override~
    SET_2DA_ENTRY 9 7 1 ~*~
    SET_2DA_ENTRY 9 8 1 ~GA_SPCL916~
    BUT_ONLY_IF_IT_CHANGES

  // Multiclass Thieves' Multiple Assassination Abilities Fix part 3
  COPY_EXISTING ~LUFT0.2DA~ ~override~
    SET_2DA_ENTRY 19 7 1 ~*~
    SET_2DA_ENTRY 19 8 1 ~GA_SPCL916~
    BUT_ONLY_IF_IT_CHANGES

  // creates f/m/c HLA table
  COPY_EXISTING ~LUFC0.2DA~ ~override/LUFMC.2DA~
    FOR (ROW = 22; ROW < 25; ROW = ROW + 1) BEGIN
      SET_2DA_ENTRY_LATER ~LUFMC~ ROW 4 ~1~
      SET_2DA_ENTRY_LATER ~LUFMC~ ROW 5 ~99~
      SET_2DA_ENTRY_LATER ~LUFMC~ ROW 6 ~1~
    END
    SET_2DA_ENTRY_LATER ~LUFMC~ 22 1 ~AP_SPCL928~
    SET_2DA_ENTRY_LATER ~LUFMC~ 23 1 ~AP_SPCL929~
    SET_2DA_ENTRY_LATER ~LUFMC~ 23 7 ~AP_SPCL928~
    SET_2DA_ENTRY_LATER ~LUFMC~ 24 1 ~AP_SPCL930~
    SET_2DA_ENTRY_LATER ~LUFMC~ 24 7 ~AP_SPCL929~
    SET_2DA_ENTRIES_NOW ~LUFMC~ 1
    BUT_ONLY_IF_IT_CHANGES
 
  // creates f/m/t HLA table
  COPY_EXISTING ~LUFT0.2DA~ ~override/LUFMT.2DA~
    FOR (ROW = 23; ROW < 26; ROW = ROW + 1) BEGIN
      SET_2DA_ENTRY_LATER ~LUFMT~ ROW 4 ~1~
      SET_2DA_ENTRY_LATER ~LUFMT~ ROW 5 ~99~
      SET_2DA_ENTRY_LATER ~LUFMT~ ROW 6 ~1~
    END
    SET_2DA_ENTRY_LATER ~LUFMT~ 23 1 ~AP_SPCL928~
    SET_2DA_ENTRY_LATER ~LUFMT~ 24 1 ~AP_SPCL929~
    SET_2DA_ENTRY_LATER ~LUFMT~ 24 7 ~AP_SPCL928~
    SET_2DA_ENTRY_LATER ~LUFMT~ 25 1 ~AP_SPCL930~
    SET_2DA_ENTRY_LATER ~LUFMT~ 25 7 ~AP_SPCL929~
    SET_2DA_ENTRIES_NOW ~LUFMT~ 1
    BUT_ONLY_IF_IT_CHANGES

  //fixes Gromnir XP bug
  COPY_EXISTING ~XPLIST.2DA~ ~override~
    SET_2DA_ENTRY 67 38 39 ~-1 -1 -1 -1~
    BUT_ONLY_IF_IT_CHANGES
END

/////                                                  \\\\\
///// mass compile/copy actions actions                \\\\\
/////                                                  \\\\\

COMPILE ~bg2fixpack/compile/soa-dlg.d~    // all dialogue fixes
        ~bg2fixpack/compile/ar0512.baf~   // blanks area script for helm temple in bridge ditrict; had been using old durlag tower script
        ~bg2fixpack/compile/bhcrypt.baf~  // crypt king horror
        ~bg2fixpack/compile/cdkpdog.baf~  // keep dogs non-hostile
        ~bg2fixpack/compile/cut41i.baf~   // spellhold cutscene loop
        ~bg2fixpack/compile/cut41j.baf~   // spellhold cutscene loop
        ~bg2fixpack/compile/druidad.baf~  // druid messenger
        ~bg2fixpack/compile/rdog.baf~     // corrupted scrpt; compile new one with uncorrupted bits
        ~bg2fixpack/compile/rdwarf.baf~   // corrupted scrpt; compile new one with uncorrupted bits
        ~bg2fixpack/compile/retter.baf~   // corrupted scrpt; compile new one with uncorrupted bits
        ~bg2fixpack/compile/rgibbler.baf~ // corrupted scrpt; compile new one with uncorrupted bits
        ~bg2fixpack/compile/rhalflin.baf~ // corrupted scrpt; compile new one with uncorrupted bits
        ~bg2fixpack/compile/rhobgoba.baf~ // corrupted scrpt; compile new one with uncorrupted bits
        ~bg2fixpack/compile/rhobgobf.baf~ // corrupted scrpt; compile new one with uncorrupted bits
        ~bg2fixpack/compile/rkobold.baf~  // corrupted scrpt; compile new one with uncorrupted bits
        ~bg2fixpack/compile/rogre.baf~    // corrupted scrpt; compile new one with uncorrupted bits
        ~bg2fixpack/compile/rsiren.baf~   // corrupted scrpt; compile new one with uncorrupted bits
        ~bg2fixpack/compile/rsirine.baf~  // corrupted scrpt; compile new one with uncorrupted bits
COPY_EXISTING ~ar0512.bcs~ ~override/ar1800.bcs~ // north forest also using old BG script

COPY ~bg2fixpack/copy/amb_e09b.wav~ ~override~ // missing ambient sound files from BG
     ~bg2fixpack/copy/amb_m09a.wav~ ~override~ // missing ambient sound files from BG
     ~bg2fixpack/copy/amb_m09b.wav~ ~override~ // missing ambient sound files from BG
     ~bg2fixpack/copy/ar0512.mos~   ~override~ // bridge district temple of helm green water fix
     ~bg2fixpack/copy/ar0512.tis~   ~override~ // bridge district temple of helm green water fix
     ~bg2fixpack/copy/ar0512.wed~   ~override~ // bridge district temple of helm green water fix
     ~bg2fixpack/copy/ar0512ht.bmp~ ~override~ // bridge district temple of helm green water fix
     ~bg2fixpack/copy/ar0512lm.bmp~ ~override~ // bridge district temple of helm green water fix
     ~bg2fixpack/copy/ar0512sr.bmp~ ~override~ // bridge district temple of helm green water fix
     ~bg2fixpack/copy/ar1404.mos~   ~override~ // temple ruins daytime map
     ~bg2fixpack/copy/ax1h10a.eff~  ~override~ // 1d6+4 extra damage vs. undead for Azuredge (slashing)
     ~bg2fixpack/copy/ax1h10b.eff~  ~override~ // 1d6+4 extra damage vs. undead for Azuredge (missile)
     ~bg2fixpack/copy/cdblpp1.spl~  ~override~ // pickpocket score adjustment spell for blade fix
     ~bg2fixpack/copy/cdblpp2.spl~  ~override~ // pickpocket score adjustment spell for blade fix
     ~bg2fixpack/copy/cdblpp3.spl~  ~override~ // pickpocket score adjustment spell for blade fix
     ~bg2fixpack/copy/cdblpp4.spl~  ~override~ // pickpocket score adjustment spell for blade fix
     ~bg2fixpack/copy/cdblpp5.spl~  ~override~ // pickpocket score adjustment spell for blade fix
     ~bg2fixpack/copy/cdcmelem.eff~ ~override~ // ring of foo control charm fix (see ring27, ring28, ring29)
     ~bg2fixpack/copy/cdelfcm0.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfcm1.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfcm2.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfcm3.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfcm4.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfcm5.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfcm6.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfsl0.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfsl1.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfsl2.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfsl3.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdelfsl4.eff~ ~override~ // elf/halfelf sleep/charm resistance
     ~bg2fixpack/copy/cdfampsd.itm~ ~override~ // SoA pseudo-gragon attack item
     ~bg2fixpack/copy/cdlv3na.spl~  ~override~ // removes 3rd level holy/unholy cleric spells per alignment
     ~bg2fixpack/copy/cdlv7na.spl~  ~override~ // removes 7th level holy/unholy cleric spells per alignment
     ~bg2fixpack/copy/cdrmv313.eff~ ~override~ // removes holy smite
     ~bg2fixpack/copy/cdrmv314.eff~ ~override~ // removes unholy blight
     ~bg2fixpack/copy/cdrmv710.eff~ ~override~ // removes holy word
     ~bg2fixpack/copy/cdrmv715.eff~ ~override~ // removes unholy word
     ~bg2fixpack/copy/cdspja00.eff~ ~override~ // str attribute penalies for harper's call
     ~bg2fixpack/copy/cdspja01.eff~ ~override~ // dex attribute penalies for harper's call
     ~bg2fixpack/copy/cdspja02.eff~ ~override~ // con attribute penalies for harper's call
     ~bg2fixpack/copy/cdspja03.eff~ ~override~ // int attribute penalies for harper's call
     ~bg2fixpack/copy/cdspja04.eff~ ~override~ // wis attribute penalies for harper's call
     ~bg2fixpack/copy/cdspja05.eff~ ~override~ // chr attribute penalies for harper's call
     ~bg2fixpack/copy/cdwi910.eff~  ~override~ // imprisoned summon fix: see gender.ids, cdwi917a.spl, cdwi917a.eff, spin580.spl, spin626.spl, spin788.spl, spwi910.spl, spwi917.spl
     ~bg2fixpack/copy/cdwi917a.spl~ ~override~ // imprisoned summon fix: see gender.ids, cdwi910.eff, cdwi917a.eff, spin580.spl, spin626.spl, spin788.spl, spwi910.spl, spwi917.spl
     ~bg2fixpack/copy/daystar2.eff~ ~override~ // for daystar fixes (see sw1h31.itm, daystar1.eff)
     ~bg2fixpack/copy/famcat01.wav~ ~override~ // cat familiar sounds from ToB to SoA
     ~bg2fixpack/copy/iscrl5a.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5b.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5c.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5d.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5e.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5f.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5g.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5h.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5i.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5j.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5k.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5l.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5m.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5n.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5o.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5p.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/iscrl5q.bam~  ~override~ // fixed spell scroll bam
     ~bg2fixpack/copy/mdog_mo.bmp~  ~override~ // fixed moon dog avatar
     ~bg2fixpack/copy/misc_01b.wav~ ~override~ // missing sound files
     ~bg2fixpack/copy/misc_01c.wav~ ~override~ // missing sound files
     ~bg2fixpack/copy/misc_03a.wav~ ~override~ // missing sound files
     ~bg2fixpack/copy/misc_04a.wav~ ~override~ // missing sound files
     ~bg2fixpack/copy/misc_06b.wav~ ~override~ // missing sound files
     ~bg2fixpack/copy/pre_p06.wav~  ~override~ // missing sound files
     ~bg2fixpack/copy/sppr203d.spl~ ~override~ // shell spell for chant
     ~bg2fixpack/copy/sppr203e.spl~ ~override~ // shell spell for chant   
     ~bg2fixpack/copy/spwi413a.spl~ ~override~ // otiluke spell shell; see also spcl415.spl, spcl415a.spl, spwi413.spl
     ~bg2fixpack/copy/states.bam~   ~override~ // spell shield is hardcoded to display icon #73 which is currently protection from magical energy; need to swap - see also statdesc.2da, spwi606.spl
     ~bg2fixpack/copy/states2.bam~  ~override~ // spell shield is hardcoded to display icon #73 which is currently protection from magical energy; need to swap - see also statdesc.2da, spwi606.spl
     ~bg2fixpack/copy/worldmap.wmp~ ~override~ // fixed soa worldmap
COPY_EXISTING ~cdwi910.eff~ ~override/cdwi917a.eff~ // imprisoned summon fix: see gender.ids, cdwi917a.spl, cdwi910.eff, spin580.spl, spin626.spl, spin788.spl, spwi910.spl, spwi917.spl
  WRITE_LONG 0x1c 6 //summoned

ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // additional copy & compile for ToB

  COMPILE ~bg2fixpack/compile-tob/tob-dlg.d~            // all ToB dialogue fixes
  COMPILE ~bg2fixpack/compile-tob/wk-ntrjex.d~          // add WK interjections to SoA
  COPY    ~bg2fixpack/copy-tob/cdhlysy2.spl~ ~override~ // dupe holy symbol fixes
          ~bg2fixpack/copy-tob/cdhlysym.spl~ ~override~ // dupe holy symbol fixes
          ~bg2fixpack/copy-tob/cdhlysym.itm~ ~override~ // dupe holy symbol fixes
          ~bg2fixpack/copy-tob/worldmap.wmp~ ~override~ // fixed soa worldmap; tob version is better due to cleaner drizzt fixes

  // celestial weapons turn opaque when attacking
  COPY_EXISTING ~masgg2bw.bam~ ~override/maslg2bw.bam~
                ~masgg2s1.bam~ ~override/maslg2s1.bam~
                ~msogg2bw.bam~ ~override/msolg2bw.bam~
                ~msogg2s1.bam~ ~override/msolg2s1.bam~

  // travel time fix for abazigal <--> WK
  COPY_EXISTING ~worldm25.wmp~ ~override~
    READ_LONG 0x0c "mos_off"
    READ_LONG ("%mos_off%" + 0x20) "area_num"
    READ_LONG ("%mos_off%" + 0x24) "area_off"
    READ_LONG ("%mos_off%" + 0x28) "link_off"
    FOR (index = 0 ; index < area_num ; index = index + 1) BEGIN
      READ_ASCII ("%area_off%" + 0x08 + ("%index%" * 0xf0)) "area"
      PATCH_IF ("%area%" STRING_COMPARE_CASE "ar3000" = 0) BEGIN // wk
        SET "wk" = "%index%"
      END ELSE
      PATCH_IF ("%area%" STRING_COMPARE_CASE "ar6000" = 0) BEGIN // abazigal
        SET "abazigal" = "%index%"
      END
    END
    // read links
    FOR (index2 = 0 ; index2 < 4 ; index2 = index2 + 1) BEGIN
      READ_LONG ("%area_off%" + 0x50 + ("%index2%" * 0x08) + ("%wk%" * 0xf0)) "link_idx"
      READ_LONG ("%area_off%" + 0x54 + ("%index2%" * 0x08) + ("%wk%" * 0xf0)) "link_num"
      FOR (index3 = 0 ; index3 < link_num ; index3 = index3 + 1) BEGIN
        READ_LONG ("%link_off%" +        (("%link_idx%" + "%index3%") * 0xd8)) "target"
        PATCH_IF ("%target%" = "%abazigal%") BEGIN
          WRITE_LONG ("%link_off%" + 0x24 + (("%link_idx%" + "%index3%") * 0xd8)) 9 // travel time
        END
      END
    END
    BUT_ONLY_IF_IT_CHANGES

END

ACTION_IF ("%LANGUAGE%" STRING_EQUAL_CASE "english") THEN BEGIN // these are English-only sounds (spoken lines)

  COPY ~bg2fixpack/copy/shael_07.wav~ ~override~ // missing sound files
       ~bg2fixpack/copy/shael_08.wav~ ~override~ // missing sound files
       ~bg2fixpack/copy/shael_09.wav~ ~override~ // missing sound files
       ~bg2fixpack/copy/shael_10.wav~ ~override~ // missing sound files

END

/////                                                  \\\\\
///// dialogue fixes                                   \\\\\
/////                                                  \\\\\

// these three show as corrupted by NI if done via d patch... believe it's empty DO ~~ actions. recompile fixes all issues.
COPY_EXISTING ~glanma.dlg~ ~override~
              ~ramazi.dlg~ ~override~
              ~thalan.dlg~ ~override~
  DECOMPILE_DLG_TO_D
  COMPILE_D_TO_DLG

// makes Delcia's guard's dialogue pause the game to prevent Delcia's interruption
COPY_EXISTING ~kpsold01.dlg~ ~override~
  WRITE_LONG 0x30 0
  BUT_ONLY_IF_IT_CHANGES

// Nalia dialog fix (Taimon)
COPY_EXISTING ~naliap.dlg~ ~override~
  DECOMPILE_DLG_TO_D
    REPLACE_TEXTUALLY CASE_INSENSITIVE ~Global("EnteredAR1300","LOCALS",1)~ ~OR(2)Global("EnteredAR1300","GLOBAL",1)Global("EnteredAR1300","GLOBAL",2)~
  COMPILE_D_TO_DLG
  BUT_ONLY_IF_IT_CHANGES

// Maheer the blacksmith in Waukeen's Promenade should only take a single diamond/beljuril for upgrading the Horn of Valhalla (aVENGER)
COPY_EXISTING ~shop03.dlg~ ~override~
  DECOMPILE_DLG_TO_D
    REPLACE_TEXTUALLY CASE_INSENSITIVE ~TakePartyItem("misc42")~ ~TakePartyItemNum("misc42",1)~ // Diamond
    REPLACE_TEXTUALLY CASE_INSENSITIVE ~TakePartyItem("misc6z")~ ~TakePartyItemNum("misc6z",1)~ // Beljuril
  COMPILE_D_TO_DLG
  BUT_ONLY_IF_IT_CHANGES

/// Dirbert won't take swords from party if they don't have exactly 3 (concept by Icendoan, but recoded by DavidW)
COPY_EXISTING ~uhkid01.dlg~ ~override~
  DECOMPILE_DLG_TO_D
    REPLACE_TEXTUALLY CASE_INSENSITIVE ~NumItemsParty("SW1H01",3)~ ~NumItemsPartyGT("SW1H01",2)~
  COMPILE_D_TO_DLG
  BUT_ONLY_IF_IT_CHANGES
  
/////                                                  \\\\\
///// scripting fixes                                  \\\\\
/////                                                  \\\\\

// player AI script fixes
// please don't cast chaotic commands on enemies
COPY ~scripts/cleric1.bs~ ~scripts/cleric1.bs~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~HaveSpell(CLERIC_CHAOTIC_COMMANDS)~ ~False()~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// targets for the misc heals are poorly defined, can be mistargeted
COPY ~scripts/cleric2.bs~ ~scripts/cleric2.bs~
     ~scripts/cleric3.bs~ ~scripts/cleric3.bs~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~\(HPPercentLT(LastSeenBy(Myself),10)\)~ ~See([PC]) \1~
    REPLACE_TEXTUALLY ~\(HPPercentLT(Myself,90)[%TAB% %LNL%%MNL%%WNL%]+HaveSpell(CLERIC_CURE_LIGHT_WOUNDS)[%TAB% %LNL%%MNL%%WNL%]+THEN[%TAB% %LNL%%MNL%%WNL%]+RESPONSE #100[%TAB% %LNL%%MNL%%WNL%]+\)Spell(MostDamagedOf(Myself),CLERIC_CURE_LIGHT_WOUNDS)~
    ~\1 Spell(Myself,CLERIC_CURE_LIGHT_WOUNDS)~
    REPLACE_TEXTUALLY ~MostDamagedOf(Myself)~ ~MostDamagedOf()~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// check to see if outside is broken
COPY ~scripts/cleric3.bs~ ~scripts/cleric3.bs~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~AreaCheck("UTDOOR)")~ ~AreaType(OUTDOOR)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// check to see if outside is broken
COPY ~scripts/fighter4.bs~ ~scripts/fighter4.bs~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~!Dead("astAttackerOf(LastSeenBy(Myself)))")~ ~!StateCheck(LastAttackerOf(LastSeenBy(Myself)),STATE_REALLY_DEAD)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// please don't cast ray of enfeeblement on yourself
COPY ~scripts/mage3.bs~ ~scripts/mage3.bs~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Spell(Myself,WIZARD_RAY_OF_ENFEEBLEMENT)~ ~Spell(LastSeenBy(Myself),WIZARD_RAY_OF_ENFEEBLEMENT)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// actual compile errors first
// override corrupt biffed scripts with blanks
EXTEND_BOTTOM ~ar2812.bcs~   ~bg2fixpack/compile/ar0512.baf~

// fix compile error
COPY_EXISTING ~IDIOT01.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~OR(31)~ ~OR(30)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// fix compile errors with bad numbers in OR blocks
COPY_EXISTING ~VICG.BCS~  ~override~
              ~VICG1.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~OR(4)~ ~OR(2)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// big, major script patch
COPY_EXISTING ~ABAZDRAG.BCS~ ~override~
              ~AERIEX.BCS~   ~override~
              ~AESGAR.BCS~   ~override~
              ~ALARM25.BCS~  ~override~
              ~AMLICH01.BCS~ ~override~
              ~AMLICH02.BCS~ ~override~
//              ~ANOMEN.BCS~   ~override~
              ~ANOMX.BCS~    ~override~
              ~APPRENTI.BCS~ ~override~
              ~AR0329.BCS~   ~override~
              ~AR1202.BCS~   ~override~
              ~AR2500.BCS~   ~override~
//              ~AR3021.BCS~   ~override~
//              ~AR3351.BCS~   ~override~
              ~AR4000.BCS~   ~override~
//              ~AREATEST.BCS~ ~override~
              ~ASYLUM.BCS~   ~override~
              ~BALMONK.BCS~  ~override~
              ~BEHELD01.BCS~ ~override~ 
              ~CARCH20B.BCS~ ~override~
              ~CARCH30B.BCS~ ~override~
              ~CASSA20B.BCS~ ~override~
              ~CASSA20C.BCS~ ~override~
              ~CAULDRON.BCS~ ~override~
              ~CBARB20B.BCS~ ~override~
              ~CBARD12A.BCS~ ~override~
              ~CBERS20B.BCS~ ~override~
              ~CESPEN.BCS~   ~override~
              ~CFIGH20A.BCS~ ~override~
              ~CFIGH20B.BCS~ ~override~
              ~CFIGH30B.BCS~ ~override~
              ~CFMAG20B.BCS~ ~override~
              ~CHALDIE.BCS~  ~override~
              ~CHALPC01.BCS~ ~override~
              ~CKENS20B.BCS~ ~override~
              ~CKENS30B.BCS~ ~override~
              ~CKMAG20A.BCS~ ~override~
              ~CKMAG20B.BCS~ ~override~
              ~CKTHI20B.BCS~ ~override~
              ~CMACL20A.BCS~ ~override~
              ~CMAGE20A.BCS~ ~override~
              ~CMAGE20B.BCS~ ~override~
              ~CMONK20B.BCS~ ~override~
              ~CTHIE20A.BCS~ ~override~
              ~CTHIE20B.BCS~ ~override~
//              ~CUT.BCS~      ~override~
              ~CUT01.BCS~    ~override~
              ~CUT215A.BCS~  ~override~
              ~CUT216A.BCS~  ~override~
              ~CUT35B.BCS~   ~override~
              ~CUT49E.BCS~   ~override~
              ~CUT57C.BCS~   ~override~
              ~CUTD1.BCS~    ~override~
              ~DADROW5.BCS~  ~override~
              ~DAQDROW.BCS~  ~override~
//              ~DCRITTER.BCS~ ~override~
              ~DDGUARD7.BCS~ ~override~ 
              ~DECK622.BCS~  ~override~
              ~DEGARD.BCS~   ~override~
              ~DEGARD2.BCS~  ~override~
//              ~DMONSTER.BCS~ ~override~
//              ~DNPC.BCS~     ~override~
              ~DRACONIS.BCS~ ~override~
              ~DRAGBROW.BCS~ ~override~
              ~DRAGGRE2.BCS~ ~override~
              ~DRAGGREE.BCS~ ~override~
              ~DRAGSILV.BCS~ ~override~
              ~DRUIDX.BCS~   ~override~
//              ~DUMMY.BCS~    ~override~
              ~DWVITH.BCS~   ~override~
              ~EDWIN.BCS~    ~override~
              ~ELTAN.BCS~    ~override~
              ~ENFORAM.BCS~  ~override~
//              ~EWMOVE.BCS~   ~override~
              ~FINSOL04.BCS~ ~override~
              ~FIRLCH01.BCS~ ~override~
              ~FORCEF.BCS~   ~override~
              ~FSWHEEL.BCS~  ~override~
//              ~FTOWNA3.BCS~  ~override~
//              ~GANIMAL.BCS~  ~override~
//              ~GHUMANIO.BCS~ ~override~
//              ~GMONSTER.BCS~ ~override~
              ~GORCAMB2.BCS~ ~override~
              ~GORCAMB3.BCS~ ~override~
              ~GORCAMB4.BCS~ ~override~
              ~GORCAMB5.BCS~ ~override~
              ~GORCAMB6.BCS~ ~override~
              ~GORDECKF.BCS~ ~override~
              ~GORGOLI.BCS~  ~override~
              ~GORLIC01.BCS~ ~override~
              ~GORSAL.BCS~   ~override~
              ~GORSTAM.BCS~  ~override~
              ~GP115.BCS~    ~override~
              ~GP116.BCS~    ~override~
              ~GPARCHER.BCS~ ~override~
              ~GPHEALER.BCS~ ~override~
              ~GPKENSAI.BCS~ ~override~
              ~GPMAGE1.BCS~  ~override~
              ~GPMAGE2.BCS~  ~override~
              ~GPMERC.BCS~   ~override~
              ~GPSHOUT.BCS~  ~override~
              ~GPTHIEF.BCS~  ~override~
              ~GRPSHT01.BCS~ ~override~
//              ~GUNDEAD.BCS~  ~override~
              ~HELLGEN.BCS~  ~override~
              ~HELLSLAY.BCS~ ~override~
              ~ILLASERA.BCS~ ~override~
              ~ILYICH.BCS~   ~override~
              ~ITGLOBES.BCS~ ~override~
              ~JATERMIN.BCS~ ~override~
              ~KAYSMG03.BCS~ ~override~
              ~KAYSMG04.BCS~ ~override~
              ~KELDORNX.BCS~ ~override~
              ~KEYSCRIP.BCS~ ~override~
//              ~KOBOLD.BCS~   ~override~
              ~KPFIGHT.BCS~  ~override~
              ~KPROEN02.BCS~ ~override~
              ~KUOARC20.BCS~ ~override~
              ~KUOWAR20.BCS~ ~override~
              ~LEHTINAN.BCS~ ~override~
//              ~LGAREA.BCS~   ~override~
              ~MAGE10A.BCS~  ~override~
              ~MAGE10D.BCS~  ~override~
              ~MAGE12B.BCS~  ~override~
              ~MAGE12D.BCS~  ~override~
              ~MAGE12E.BCS~  ~override~
              ~MAGE14A.BCS~  ~override~
              ~MAGE14B.BCS~  ~override~
              ~MAGE14C.BCS~  ~override~
              ~MAGE14D.BCS~  ~override~
              ~MAGE14M.BCS~  ~override~
              ~MAGE14T.BCS~  ~override~
              ~MAGE16A.BCS~  ~override~
              ~MAGE16B.BCS~  ~override~
              ~MAGE16C.BCS~  ~override~
              ~MAGE16M.BCS~  ~override~
              ~MAGE18A.BCS~  ~override~
              ~MAGE18B.BCS~  ~override~
              ~MAGE18C.BCS~  ~override~
              ~MAGE18D.BCS~  ~override~
              ~MAGE18E.BCS~  ~override~
              ~MAGE18Y.BCS~  ~override~
              ~MAGE20A.BCS~  ~override~
              ~MAGE20B.BCS~  ~override~
              ~MAGE20C.BCS~  ~override~
              ~MAGEHIGH.BCS~ ~override~
              ~MAZZY.BCS~    ~override~
//              ~MDAREA.BCS~   ~override~
              ~MINDAL01.BCS~ ~override~
//              ~MINSC.BCS~    ~override~
              ~MINSCX.BCS~   ~override~
              ~MINVSED.BCS~  ~override~
//              ~MONSTER.BCS~  ~override~
              ~MOVIE03A.BCS~ ~override~
              ~MOVIE03B.BCS~ ~override~
//              ~NALIA.BCS~    ~override~
//              ~NEMOVE.BCS~   ~override~
              ~NEVA.BCS~     ~override~
              ~NPC.BCS~      ~override~
              ~NPCDRU1.BCS~  ~override~
//              ~NSMOVE.BCS~   ~override~
//              ~NWMOVE.BCS~   ~override~
//              ~PIPE04.BCS~   ~override~
              ~PPCRUS1.BCS~  ~override~
              ~PPSHAD01.BCS~ ~override~
              ~PPSHAD02.BCS~ ~override~
              ~PPSHAD03.BCS~ ~override~
              ~PPSHAD04.BCS~ ~override~
              ~PPSHAD05.BCS~ ~override~
              ~PPSHAD06.BCS~ ~override~ 
              ~PWARDEN.BCS~  ~override~
//              ~RANDFLY.BCS~  ~override~
//              ~RANDWALK.BCS~ ~override~
//              ~RBEAR.BCS~    ~override~
//              ~RCHICKEN.BCS~ ~override~
//              ~RCOW.BCS~     ~override~
//              ~RELF.BCS~     ~override~
//              ~RGNOLL.BCS~   ~override~
//              ~RHORSE.BCS~   ~override~
//              ~RHUMAN.BCS~   ~override~
//              ~RSPIDER.BCS~  ~override~
//              ~RWOLF.BCS~    ~override~
              ~SARBUL01.BCS~ ~override~
              ~SARBUL02.BCS~ ~override~
              ~SARBUL03.BCS~ ~override~
              ~SARDW01.BCS~  ~override~
              ~SARDW02.BCS~  ~override~
              ~SARDW03.BCS~  ~override~
              ~SENDARK.BCS~  ~override~
              ~SENGUA04.BCS~ ~override~
              ~SENGUA05.BCS~ ~override~
              ~SHADEL.BCS~   ~override~
//              ~SMAREA.BCS~   ~override~
//              ~SPSHADOM.BCS~ ~override~
//              ~SPSHADOW.BCS~ ~override~
              ~spwnrak.BCS~  ~override~
              ~SUMTAN01.BCS~ ~override~
              ~TELTIEF3.BCS~ ~override~
              ~TELWRAI.BCS~  ~override~
              ~TEMPV01.BCS~  ~override~
              ~TEMSUP.BCS~   ~override~
              ~TIEF3.BCS~    ~override~
              ~UDMASTER.BCS~ ~override~
              ~UDTRAIN.BCS~  ~override~
              ~UND5509.BCS~  ~override~
              ~USEITEM.BCS~  ~override~
              ~VALVSED.BCS~  ~override~
              ~VALYGX.BCS~   ~override~
              ~VICX.BCS~     ~override~
//              ~VWENCH.BCS~   ~override~
//              ~WAIT.BCS~     ~override~
              ~XEIWIN.BCS~   ~override~
//              ~XR2600.BCS~   ~override~
              ~YAGALT.BCS~   ~override~
              ~YAGART.BCS~   ~override~
              ~YOCHLOL.BCS~  ~override~
//              ~YOSHIMO.BCS~  ~override~
              ~YSCARA.BCS~   ~override~
              ~YSGP01.BCS~   ~override~
              ~YSGP02.BCS~   ~override~
              ~YSGP03.BCS~   ~override~
              ~YSGP04.BCS~   ~override~
              ~YSGRUNT.BCS~  ~override~
              ~ZILMAG01.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY %Dead("yself)")% %StateCheck(Myself,STATE_REALLY_DEAD)%
    REPLACE_TEXTUALLY %Dead("astSeenBy(\(Myself\)?))")% %StateCheck(LastSeenBy(Myself),STATE_REALLY_DEAD)%
    REPLACE_TEXTUALLY %Dead("astHeardBy(\(Myself\)?))")% %StateCheck(LastHeardBy(Myself),STATE_REALLY_DEAD)%
    REPLACE_TEXTUALLY %Dead("astTrigger)")% %StateCheck(LastTrigger,STATE_REALLY_DEAD)%
    REPLACE_TEXTUALLY %Dead("astAttackerOf(")% %StateCheck(LastAttackerOf(Myself),STATE_REALLY_DEAD)%
    REPLACE_TEXTUALLY %Dead("PC\])")% %StateCheck([PC],STATE_REALLY_DEAD)%
    REPLACE_TEXTUALLY %Dead("layer\([1-6]\))")% %StateCheck(Player\1,STATE_REALLY_DEAD)%
    REPLACE_TEXTUALLY %ApplySpell("runrun",0)% %ApplySpellRES("runrun",Myself)%
    REPLACE_TEXTUALLY %AreaCheck("UTDOOR)")% %AreaType(OUTDOOR)%
    REPLACE_TEXTUALLY %CreateVisualEffectObject("yself","SPFLESHS")% %CreateVisualEffectObject("SPFLESHS",Myself)%
    REPLACE_TEXTUALLY %AddXP2DA("PLOT05C")% %AddXP2DA("PLOT5C")%
    REPLACE_TEXTUALLY %AddXP2DA("PLOT05B")% %AddXP2DA("PLOT5B")%
    REPLACE_TEXTUALLY %AddXP2DA("PLOT06E")% %AddXP2DA("PLOT6E")%
    REPLACE_TEXTUALLY %TakeItemReplace("DWDUST","DWCSW1H01"% %TakeItemReplace("DWDUST","DWSW1H01"%
    REPLACE_TEXTUALLY %"EFF_38"% %"EFF_M38"%
    REPLACE_TEXTUALLY %"ISC_03A"% %"MISC_03A"%
    REPLACE_TEXTUALLY %"ISC_15A"% %"MISC_15A"%
    REPLACE_TEXTUALLY %"ISC_15B"% %"MISC_15B"%
    REPLACE_TEXTUALLY %"MISC_02A"% %"MISC_02A"%
    REPLACE_TEXTUALLY %PlaySound("MONTR10")% %%
    REPLACE_TEXTUALLY %CreateCreatureObjectEffect("DEMOSUM1","SPPLOYMP",Myself)% %CreateCreatureObjectEffect("DEMOSUM1","SPPOLYMP",Myself)%
    REPLACE_TEXTUALLY %CreateCreatureObjectEffect("DEMSUC01","SPPLOYMP",Myself)% %CreateCreatureObjectEffect("DEMSUC01","SPPOLYMP",Myself)%
    REPLACE_TEXTUALLY %CreateCreatureObjectEffect("TELALU1","SPPLOYMP",Myself)% %CreateCreatureObjectEffect("TELALU1","SPPOLYMP",Myself)%
    REPLACE_TEXTUALLY %CreateVisualEffectObject("ANCALL",Myself)% %CreateVisualEffectObject("AMCALL",Myself)%
    REPLACE_TEXTUALLY %MoveBetweenAreasEffect("AR3015","SPDOOR"% %MoveBetweenAreasEffect("AR3015","SPDIMNDR"%
    REPLACE_TEXTUALLY %CreateVisualEffectObject("SPOWWRD",Player1)% %CreateVisualEffectObject("SPPOWWRD",Player1)%
    REPLACE_TEXTUALLY %CreateVisualEffect("SPMAGICH"% %CreateVisualEffect("ICMAGICH"%
    REPLACE_TEXTUALLY %CreateVisualEffectObject("ppireni1","SPDIMNDR")% %CreateVisualEffectObject("SPDIMNDR","ppireni1")%
    REPLACE_TEXTUALLY %ActionOverride("Imoen",SetDialog\(ue\)?("None"))% %ActionOverride("Imoen",SetDialog(""))%
    REPLACE_TEXTUALLY %Dead("firkraag")% %Dead("firkra02")%
    REPLACE_TEXTUALLY %Dead("aran02")% %Dead("aran")%
    REPLACE_TEXTUALLY %MoveToObject("ammonk")% %MoveToObject("ammonk01")%
    REPLACE_TEXTUALLY %"Jaheria"% %"Jaheira"%
//    REPLACE_TEXTUALLY %CreateVisualEffectObject("SPSTRENH","OilDoor")% %CreateVisualEffectObject("SPSTRENH","Door07")%
    REPLACE_TEXTUALLY %See("Player1")% %See(Player1)%
    REPLACE_TEXTUALLY %ActionOverride("Player\([2-6]\)",Rest())% %ActionOverride(Player\1,Rest())%
    REPLACE_TEXTUALLY %StateCheck("Player1",STATE_SLEEPING)% %StateCheck(Player1,STATE_SLEEPING)%
    REPLACE_TEXTUALLY %CreateCreature("dogre01",\[-1\.-1\],0)% %CreateCreature("ogre01",[-1.-1],0)%
    REPLACE_TEXTUALLY %CreateVisualEffect("SPGFLSH"% %CreateVisualEffect("SPGFLSH1"%
    REPLACE_TEXTUALLY %Spell(Myself,WIZARD_LIGHTNING_BOLT)% %Spell(NearestEnemyOf(Myself),WIZARD_LIGHTNING_BOLT)%
    REPLACE_TEXTUALLY %Global("R0406PitFight","",3)% %Global("PitFight","AR0406",3)%
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// eou romance fixes                                \\\\\
/////                                                  \\\\\

//COMPILE     ~ease/romhap/rom/JAGALVAR.D~      now in soa-dlg.d
COPY_EXISTING ~aerie.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~AreaType(0)~ ~AreaType(OUTDOOR)~
  COMPILE_BAF_TO_BCS

COPY_EXISTING ~anomen.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~SetGlobal("AnomenIsNotKnight","GLOBAL",1)~
      ~SetGlobal("AnomenIsNotKnight","GLOBAL",1)
      ChangeAlignment("Anomen",CHAOTIC_NEUTRAL)~
    REPLACE_TEXTUALLY ~"TALKEDTOCOR","GLOBAL"~ ~"TALKEDCOR","GLOBAL"~
  COMPILE_BAF_TO_BCS
EXTEND_TOP ~anomen.bcs~ ~bg2fixpack/baf/anomen.baf~

COPY_EXISTING ~jaheira.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~GlobalLT("DerminSpawn","GLOBAL",5)~
      ~  GlobalLT("DerminSpawn","GLOBAL",5)
        !InParty(Myself)
      THEN
        RESPONSE #100
          RealSetGlobalTimer("JaheiraRomance","GLOBAL",3600)
          SetGlobal("DerminSpawn","GLOBAL",5)
          SetGlobalTimer("DerminAppear","GLOBAL",17280)
          StartDialogueNoSet([PC])
      END

      IF
        False()~
    REPLACE_TEXTUALLY ~\bSetGlobalTimer("TerminselAppear","GLOBAL",FIVE_DAYS)~
                      ~RealSetGlobalTimer("TerminselAppear","GLOBAL",3600)~ // originally 36000 seems to be more than random.
  COMPILE_BAF_TO_BCS

COPY_EXISTING ~viconia.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("LoveTalk","LOCALS",71)~ ~False()~
  COMPILE_BAF_TO_BCS

// If ToB installed, patch ToB BCS files:
ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN

  COPY_EXISTING ~anom25.BCS~ ~override~
    DECOMPILE_BCS_TO_BAF
      REPLACE_TEXTUALLY ~Global("AnomenSummoned","GLOBAL",1)~
      ~Global("AnomenSummoned","GLOBAL",1)
      !Global("AnomenIsKnight","GLOBAL",1)~
    COMPILE_BAF_TO_BCS
  EXTEND_TOP ~anom25.bcs~ ~bg2fixpack/baf/anom25.baf~

  COPY_EXISTING ~jahe25.BCS~ ~override~
    DECOMPILE_BCS_TO_BAF
      REPLACE_TEXTUALLY ~OR(2)~ ~!Global("JaheiraRomanceActive","GLOBAL",0) !Global("JaheiraRomanceActive","GLOBAL",3) OR(2)~
    COMPILE_BAF_TO_BCS

END

/////                                                  \\\\\
///// missing IDS entries                              \\\\\
/////                                                  \\\\\

// notes
// unused in BG2: andris, ch1cut01, ch1cut02, daitel, deathkni, hgwiz01, pheoarch, semaj
// SpellCast(0) is needed for CW summoning in ar0020, ar0300, ar0400, ar0500, ar0700, ar0900, ar1000
// SpellCastOnMe([ANYONE],0) is needed for nishru01; nishruus heal themselves when magic is used against them
// cdtamoko error is from cloning gpkensai
// specifics errors safe to ignore (?)
// SpellCast([PC],0) for ttxan is appropriate for tutorial


// many dispel magic actions have two missing CheckStatGT triggers in an OR() block
COPY_EXISTING ~abazdrag.bcs~ ~override~
              ~amlich02.bcs~ ~override~
              ~dragbrow.bcs~ ~override~
              ~finsol04.bcs~ ~override~
              ~gorgua02.bcs~ ~override~
              ~meliss01.bcs~ ~override~
              ~meliss02.bcs~ ~override~
              ~meliss03.bcs~ ~override~
              ~planet.bcs~   ~override~
              ~senbattl.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~CheckStatGT(LastSeenBy(Myself),0,0)[%TAB% %LNL%%MNL%%WNL%]+CheckStatGT(LastSeenBy(Myself),0,0)~
                     ~CheckStatGT(LastSeenBy(Myself),0,IMPROVEDHASTE) CheckStatGT(LastSeenBy(Myself),0,STONESKINS)~
                     // triggers for a dispel magic
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// alter missing areatype check to match banter trigger
COPY_EXISTING ~aerie.bcs~   ~override~
              ~anomen.bcs~  ~override~
              ~minsc.bcs~   ~override~
              ~nalia.bcs~   ~override~
              ~yoshimo.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~AreaType(0)~ ~AreaType(OUTDOOR)~ // for Minsc Umar Hills reminder, Nalia-Edwina banter
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// many priest scripts have a failed CLERIC_HEAL call
COPY_EXISTING ~aeriex.bcs~   ~override~
              ~anomx.bcs~    ~override~
              ~anvskel.bcs~  ~override~
              ~pries18a.bcs~ ~override~
              ~pries18b.bcs~ ~override~
              ~pries18c.bcs~ ~override~
              ~pries18d.bcs~ ~override~
              ~saerkx.bcs~   ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~Spell(Myself,0)~ ~Spell(Myself,CLERIC_HEAL)~ // trigger checks for this spell
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// aerie's very straightforward--both missing Spell calls check for a spell in memory in the trigger
COPY_EXISTING ~aeriex.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~Spell(LastSeenBy(Myself),0)~ ~Spell(LastSeenBy(Myself),CLERIC_ANIMAL_SUMMONING_3)~ // trigger checks for this spell
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// recurring issue--going to enemy, but checks that allegiance is either neutral, goodbutblue, or ?
COPY_EXISTING ~amduel1.bcs~  ~override~
              ~amduel2.bcs~  ~override~
              ~balmonk.bcs~  ~override~
              ~chalpc01.bcs~ ~override~
              ~gorbat.bcs~   ~override~
              ~gorbat1.bcs~  ~override~
              ~gortan.bcs~   ~override~
              ~gortan1.bcs~  ~override~
              ~gparcher.bcs~ ~override~
              ~gphealer.bcs~ ~override~
              ~gpkensai.bcs~ ~override~
              ~gpmage1.bcs~  ~override~
              ~gpmage2.bcs~  ~override~
              ~gpshout.bcs~  ~override~
              ~grpsht01.bcs~ ~override~
              ~sarbul01.bcs~ ~override~
              ~sarbul02.bcs~ ~override~
              ~sarbul03.bcs~ ~override~
              ~sardw01.bcs~  ~override~
              ~sardw02.bcs~  ~override~
              ~sardw03.bcs~  ~override~
              ~sarrein.bcs~  ~override~
              ~teltief3.bcs~ ~override~
              ~trgrd02.bcs~  ~override~
              ~trgrd03.bcs~  ~override~
              ~trgrdr01.bcs~ ~override~
              ~trgrdr02.bcs~ ~override~
              ~trgrdr03.bcs~ ~override~
              ~trgrdr04.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~Allegiance(Myself,0)~ ~Allegiance(Myself,EVILBUTBLUE)~ // third allegiance check?
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~amlich02.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~ForceSpell(Myself,0)~ ~ForceSpell(Myself,WIZARD_STONE_SKIN)~ // trigger, locals checks for stoneskins
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// anomen's very straightforward--missing Spell calls check for a spell in memory in the trigger
COPY_EXISTING ~anomx.bcs~   ~override~
              ~anvskel.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~Spell(LastSeenBy(Myself),0)[%TAB% %LNL%%MNL%%WNL%]+AttackOneRound(LastSeenBy(Myself))~
                     ~Spell(LastSeenBy(Myself),CLERIC_SLAY_LIVING) AttackOneRound(LastSeenBy(Myself))~ // trigger checks for this spell
   REPLACE_TEXTUALLY ~Spell(LastSeenBy(Myself),0)[%TAB% %LNL%%MNL%%WNL%]+Continue()~ 
                     ~Spell(LastSeenBy(Myself),CLERIC_ANIMAL_SUMMONING_3) Continue()~ // trigger checks for this spell
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// pairing MI with trigger
COPY_EXISTING ~clone1.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY 
      ~HaveSpell(0)\([%TAB% %LNL%%MNL%%WNL%]+THEN[%TAB% %LNL%%MNL%%WNL%]+RESPONSE #100[%TAB% %LNL%%MNL%%WNL%]+Spell(Myself,WIZARD_MIRROR_IMAGE)\)~
      ~HaveSpell(WIZARD_MIRROR_IMAGE)\1~ // Spell action associated with this block casts WIZARD_MIRROR_IMAGE
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// end of CI Escape cutscene, everyone leaving
COPY_EXISTING ~cut01g.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY
      ~ForceSpell(Myself,0)~
      ~ForceSpell(Myself,DRYAD_TELEPORT)~   // cast by CSCowl6 and 8
    REPLACE_TEXTUALLY 
      ~ForceSpell("CSImoen",DRYAD_TELEPORT)~ 
      ~ForceSpell("CSImoen",DRYAD_TELEPORT) ForceSpell(Myself,DRYAD_TELEPORT)~   // cast by CSCowl4 on Imoen, added to causes effects for self as well
    REPLACE_TEXTUALLY
      ~ForceSpell("CSIren",0)~ 
      ~ForceSpell("CSIren",DRYAD_TELEPORT) ForceSpell(Myself,DRYAD_TELEPORT)~ // cast by CSCowl7 on Irenicus, also makes CSCowl7 go away
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// all other cres are hasted with identical blocks to this one
COPY_EXISTING ~cut207c.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~ApplySpell(Myself,0)~ ~ApplySpell(Myself,CUTSCENE_HASTE)~ // all other creatures hasted in similar blocks
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// displays 'protection from energy' string without, uh, casting it
COPY_EXISTING ~dlich01.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~ApplySpell(Myself,0)~ ~ApplySpell(Myself,WIZARD_PROTECTION_FROM_ENERGY)~ // action immediately above is displaystring 'protection from energy'
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// saladrex's dispel block is missing a stat check and valid stat.ids refs
COPY_EXISTING ~gorsal.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~OR(8)\([%TAB% %LNL%%MNL%%WNL%]+StateCheck(LastSeenBy(Myself),STATE_INVISIBLE)[%TAB% %LNL%%MNL%%WNL%]+StateCheck(LastSeenBy(Myself),STATE_IMPROVEDINVISIBILITY)[%TAB% %LNL%%MNL%%WNL%]+StateCheck(LastSeenBy(Myself),STATE_HASTED)[%TAB% %LNL%%MNL%%WNL%]+StateCheck(LastSeenBy(Myself),STATE_BLESS)[%TAB% %LNL%%MNL%%WNL%]+StateCheck(LastSeenBy(Myself),STATE_DRAWUPONHOLYMIGHT)[%TAB% %LNL%%MNL%%WNL%]+StateCheck(LastSeenBy(Myself),STATE_BLUR)[%TAB% %LNL%%MNL%%WNL%]+StateCheck(LastSeenBy(Myself),STATE_MIRRORIMAGE)[%TAB% %LNL%%MNL%%WNL%]+\)CheckStatGT(LastSeenBy(Myself),0,0)\([%TAB% %LNL%%MNL%%WNL%]+THEN\)~
                     ~OR(9) \1 CheckStatGT(LastSeenBy(Myself),0,IMPROVEDHASTE) CheckStatGT(LastSeenBy(Myself),0,STONESKINS) \2~
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// gphealer should run away and heal themselves, but missing actual casting; two more unknown issues
COPY_EXISTING ~gphealer.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY 
     ~HaveSpell(\([A-Z_]+\))\([%TAB% %LNL%%MNL%%WNL%]+THEN[%TAB% %LNL%%MNL%%WNL%]+RESPONSE #100[%TAB% %LNL%%MNL%%WNL%]+RunAwayFrom(NearestEnemyOf(Myself),30)[%TAB% %LNL%%MNL%%WNL%]+\)Spell(Myself,0)~ 
     ~HaveSpell(\1) \2 Spell(Myself,\1)~ //
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// missing a priest spell in their resist fear trigger
COPY_EXISTING ~gpmage1.bcs~  ~override~
              ~magehigh.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~SpellCastPriest(\[GOODCUTOFF\],0)~ ~SpellCastPriest([GOODCUTOFF],CLERIC_CLOAK_OF_FEAR)~ // only missing divine 'fear' spell
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// should attack Jon's minions until minions dead, then turn on party
COPY_EXISTING ~ishthf01.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~Allegiance(Myself,0)~ ~Allegiance(Myself,GOODBUTBLUE)~ // triggers for a dispel magic
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// missing spell is preceded by stringhead
COPY_EXISTING ~jatermin.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~ApplySpell(Myself,0)~ ~ApplySpell(Myself,WIZARD_PROTECTION_FROM_NORMAL_MISSILES)~ // preceded by string
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// action dictates trigger
COPY_EXISTING ~jatermin.bcs~ ~override~
              ~mage20a.bcs~  ~override~
              ~mage20c.bcs~  ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~HaveSpell(0)~ ~HaveSpell(WIZARD_MAZE)~ // associated action casts this spell
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// should attack Jon's minions until minions dead, then turn on party
COPY_EXISTING ~jonthief.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~Allegiance(Myself,0)~ ~Allegiance(Myself,GOODBUTBLUE)~ // triggers for a dispel magic
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// mage10d checks for buffing spells; remove fear appears to fit the gap between bless and sanctuary
COPY_EXISTING ~mage10d.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~SpellCastPriest(\[PC\],0)~ ~SpellCastPriest([PC],CLERIC_REMOVE_FEAR)~ // triggers are for party buffs
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// missing spell trigger is followed by casting spell
COPY_EXISTING ~mage16m.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~HaveSpell(0)~ ~HaveSpell(WIZARD_STONE_SKIN)~ // associated action casts this spell
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// missing spell is preceded by stringhead
COPY_EXISTING ~mage8d.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~HaveSpell(0)~ ~HaveSpell(WIZARD_CHROMATIC_ORB)~ // associated action casts this spell
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// trigger defines spell
COPY_EXISTING ~senbattl.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~Spell(Myself,0)~ ~Spell(Myself,WIZARD_STONE_SKIN)~ // associated trigger checks this spell
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// surakw1-4 identical except for surakw1's spell trigger
COPY_EXISTING ~surakw2.bcs~  ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~\(IncrementGlobal("Fight","LOCALS",1)[%TAB% %LNL%%MNL%%WNL%]+\)ForceSpell(Myself,0)~
        ~\1 ForceSpell(Myself,WIZARD_PROTECTION_FROM_MAGIC_WEAPONS)~ // from surakw4
    REPLACE_TEXTUALLY ~\(StateCheck(Myself,STATE_SILENCED)[%TAB% %LNL%%MNL%%WNL%]+THEN[%TAB% %LNL%%MNL%%WNL%]+RESPONSE #100[%TAB% %LNL%%MNL%%WNL%]+\)ForceSpell(Myself,0)~
        ~\1 ForceSpell(Myself,WIZARD_VOCALIZE)~ // if silenced - vocalize?
    REPLACE_TEXTUALLY ~\(!See(LastSeenBy(Myself))[%TAB% %LNL%%MNL%%WNL%]+THEN[%TAB% %LNL%%MNL%%WNL%]+RESPONSE #100[%TAB% %LNL%%MNL%%WNL%]+\)ForceSpell(Myself,0)~
        ~\1 ForceSpell(Myself,WIZARD_TRUE_SIGHT)~ // if can detect but not see - true sight?
    REPLACE_TEXTUALLY
      ~ApplySpell(Myself,0)\([%TAB% %LNL%%MNL%%WNL%]+DisplayString(Myself,39968)[%TAB% %LNL%%MNL%%WNL%]+\)ApplySpell(Myself,0)~
      ~ApplySpell(Myself,WIZARD_GLOBE_OF_INVULNERABILITY) \1 ApplySpell(Myself,WIZARD_PROTECTION_FROM_MAGIC_WEAPONS)~ // two spell spell trigger
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// surakw1-4 identical except for surakw1's spell trigger
COPY_EXISTING ~surakw3.bcs~  ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~ApplySpell(Myself,0)\([%TAB% %LNL%%MNL%%WNL%]+DisplayString(Myself,39968)[%TAB% %LNL%%MNL%%WNL%]+\)ApplySpell(Myself,0)\([%TAB% %LNL%%MNL%%WNL%]+\)ApplySpell(Myself,0)~
       ~ApplySpell(Myself,WIZARD_STONE_SKIN) \1 ApplySpell(Myself,WIZARD_GLOBE_OF_INVULNERABILITY) \2 ApplySpell(Myself,WIZARD_MISLEAD)~ // from surakw4
   REPLACE_TEXTUALLY ~\(IncrementGlobal("Fight","LOCALS",1)[%TAB% %LNL%%MNL%%WNL%]+\)ForceSpell(Myself,0)~
       ~\1 ForceSpell(Myself,WIZARD_PROTECTION_FROM_MAGIC_WEAPONS)~ // from surakw4
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// surakw1-4 identical except for surakw1's spell trigger
COPY_EXISTING ~surakw4.bcs~  ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~ApplySpell(Myself,0)\([%TAB% %LNL%%MNL%%WNL%]+DisplayString(Myself,39968)[%TAB% %LNL%%MNL%%WNL%]+\)ApplySpell(Myself,0)\([%TAB% %LNL%%MNL%%WNL%]+\)ApplySpell(Myself,0)~
       ~ApplySpell(Myself,WIZARD_STONE_SKIN) \1 ApplySpell(Myself,WIZARD_GLOBE_OF_INVULNERABILITY) \2 ApplySpell(Myself,WIZARD_MISLEAD)~ // three spell spell trigger
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// viccy's combat script for keldorn fight
COPY_EXISTING ~vicvskel.bcs~  ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~Spell(Myself,0)~ ~Spell(Myself,CLERIC_HEAL)~
   REPLACE_TEXTUALLY ~\(HPGT("Keldorn",20)[%TAB% %LNL%%MNL%%WNL%]+THEN[%TAB% %LNL%%MNL%%WNL%]+RESPONSE #100[%TAB% %LNL%%MNL%%WNL%]+\)Spell(LastSeenBy(Myself),0)~
     ~\1 Spell(LastSeenBy(Myself),CLERIC_SLAY_LIVING)~
   REPLACE_TEXTUALLY ~\(HaveSpell(CLERIC_ANIMAL_SUMMONING_3)[%TAB% %LNL%%MNL%%WNL%]+THEN[%TAB% %LNL%%MNL%%WNL%]+RESPONSE #100[%TAB% %LNL%%MNL%%WNL%]+\)Spell(LastSeenBy(Myself),0)~
     ~\1 Spell(LastSeenBy(Myself),CLERIC_ANIMAL_SUMMONING_3)~
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// viccy's generic combat script
COPY_EXISTING ~vicx.bcs~  ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~Spell(Myself,0)~ ~Spell(Myself,CLERIC_HEAL)~
   REPLACE_TEXTUALLY ~\(HPGT(NearestEnemyOf(Myself),20)[%TAB% %LNL%%MNL%%WNL%]+THEN[%TAB% %LNL%%MNL%%WNL%]+RESPONSE #100[%TAB% %LNL%%MNL%%WNL%]+\)Spell(LastSeenBy(Myself),0)~
     ~\1 Spell(LastSeenBy(Myself),CLERIC_SLAY_LIVING)~
   REPLACE_TEXTUALLY ~\(HaveSpell(CLERIC_ANIMAL_SUMMONING_3)[%TAB% %LNL%%MNL%%WNL%]+THEN[%TAB% %LNL%%MNL%%WNL%]+RESPONSE #100[%TAB% %LNL%%MNL%%WNL%]+\)Spell(LastSeenBy(Myself),0)~
     ~\1 Spell(LastSeenBy(Myself),CLERIC_ANIMAL_SUMMONING_3)~
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// other scripting fixes                            \\\\\
/////                                                  \\\\\

// stop (kuo-toan) archers and air elementals from charging across areas to engage party
EXTEND_TOP ~airele01.bcs~ ~bg2fixpack/baf/gparcher.baf~
EXTEND_TOP ~gparcher.bcs~ ~bg2fixpack/baf/gparcher.baf~

// norh rep trap uses same name for timer and variable; see fixes to knight.dlg
COPY_EXISTING ~amntrp01.bcs~ ~override~
              ~amntrp02.bcs~ ~override~
              ~amntrp03.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~!GlobalTimerNotExpired("MostNobleOrder","GLOBAL")~ ~!GlobalTimerNotExpired("CDMostNobleOrder","GLOBAL")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Puts the variable setting in front of the dialogue triggering so that Anomen's complaint about delaying Garren kid's quest gets triggered
// also add triggers to stop infinite whining if anomen is !good
COPY_EXISTING ~anomen.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~\(StartDialogu?e?NoSet(Player1)[%TAB% %LNL%%MNL%%WNL%]+\)\(SetGlobal("ddAnomenWhine","LOCALS",1)\)~
      ~\2 \1~
    REPLACE_TEXTUALLY ~Global("ddAnomenWhine","LOCALS",0)~ ~Global("ddAnomenWhine","LOCALS",0) !Dead("garkid01") !Dead("garkid02")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// flydian shouldn't hang around asking folks to save trademeet after it's already been saved
EXTEND_BOTTOM ~ar0020.bcs~ ~bg2fixpack/baf/ar0020.baf~

// UE not appearing bug
COPY_EXISTING ~ar0202.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("UnseeingEye","GLOBAL",1)~ ~Global("UnseeingEye","GLOBAL",1) Global("CDSpawnTheEyeOnlyOnce","GLOBAL",0)~
    REPLACE_TEXTUALLY ~CreateCreature("BHEYE",\[2429\.1914\],0)~ ~CreateCreature("BHEYE",[2429.1914],0) SetGlobal("CDSpawnTheEyeOnlyOnce","GLOBAL",1)~
  COMPILE_BAF_TO_BCS

// instead of a wait, change to timer for new block
COPY_EXISTING ~ar0205.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~CreateCreature("BHEYE",\[2528\.1897\],12)~ ~~
    REPLACE_TEXTUALLY ~Wait(~ ~SetGlobalTimer("CDUnseeingEyeAppears","AR0205",~
    APPEND_FILE ~bg2fixpack/baf/ar0205.baf~
  COMPILE_BAF_TO_BCS

// fixing transition calls
COPY_EXISTING ~ar0300.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~\(TriggerActivation("Tran0329\)\(",[A-Z]+)\)~ ~\1a\2 \1b\2~
    REPLACE_TEXTUALLY ~Tran0303a~ ~Tran0303~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Arledrian goes hostile but stands there due to area script bug
COPY_EXISTING ~ar0312.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~SetGlobal("ArledHostile","GLOBAL",1)~ ~SetGlobal("ArledHostile","AR0312",1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// allows resting in thieves guild stronghold
EXTEND_BOTTOM ~ar0321.bcs~ ~bg2fixpack/baf/ar032x.baf~
EXTEND_BOTTOM ~ar0322.bcs~ ~bg2fixpack/baf/ar032x.baf~
EXTEND_BOTTOM ~ar0323.bcs~ ~bg2fixpack/baf/ar032x.baf~
EXTEND_BOTTOM ~ar0324.bcs~ ~bg2fixpack/baf/ar032x.baf~

// multiple stringheads for thieves return fix; not paying thieves guild quota fix; see also baldur.bcs, joster.bcs, shthlt01.dlg
COPY_EXISTING ~ar0322.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~SetGlobal("NotifyThiefHead","GLOBAL",0)~ ~~
    REPLACE_TEXTUALLY ~CreateCreature("SHTH05",\[691\.292\],2)~
      ~SetGlobal("CDJoster","AR0322",1) CreateCreature("SHTH05",[691.292],2)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// welther can spawn infinitely, Shagbag's always-true block disables half the area script
COPY_EXISTING ~ar0400.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("ElgeaGone","GLOBAL",0)~
                      ~Global("ElgeaGone","GLOBAL",0)
                       Global("ElgeaFree","GLOBAL",0)~
    REPLACE_TEXTUALLY ~[^!]GlobalTimerExpired("FindShagbag","GLOBAL")~
                      ~False()~
    APPEND_FILE ~bg2fixpack/baf/ar0400.baf~
  COMPILE_BAF_TO_BCS

// stops Yoshimo's block from interrupting everything else in the area
COPY_EXISTING ~ar0406.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("WorkingForBodhi","GLOBAL",1)~ ~Global("WorkingForBodhi","GLOBAL",1) Exists("Yoshimo")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Teos/Planar Sphere fix
EXTEND_TOP ~ar0411.bcs~ ~bg2fixpack/baf/ar0411.baf~

// Tyrianna fix, part 1 (second is plgirl01.cre patch)
EXTEND_TOP ~ar0415.bcs~ ~bg2fixpack/baf/ar0415.baf~

// saerk's doors should lock and unlock together
COPY_EXISTING ~ar0500.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Unlock("DOOR0504")~ ~Unlock("DOOR0504") Unlock("DOOR0505b")~
    REPLACE_TEXTUALLY ~\bLock("DOOR0504")~ ~CloseDoor("DOOR0504") CloseDoor("DOOR0505b") Lock("DOOR0504") Lock("DOOR0505b")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// area objects can't have LOCALS variables
// bard playhouse issues--transition can be left open
COPY_EXISTING ~ar0522.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~"SamuelAttacks","LOCALS"~ ~"SamuelAttacks","AR0522"~
    REPLACE_TEXTUALLY ~GlobalTimerExpired("MeetHiggin6a","GLOBAL")~
                      ~GlobalTimerExpired("MeetHiggin6a","GLOBAL") Global("BardPlot1","GLOBAL",40)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// bard playhouse issues--jenna not going to proper spot, meck sometimes not appearing upon completion
COPY_EXISTING ~ar0523.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ActionOverride("bdact03",MoveToPoint(\[1301\.453\]))~
                      ~ActionOverride("bdact03",MoveToPoint([1301.181]))~
    APPEND_FILE ~bg2fixpack/baf/ar0523.baf~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Waukeen's Promenade script loop fix (Nythrun)
COPY_EXISTING ar0700.bcs override
  DECOMPILE_BCS_TO_BAF 
    REPLACE_TEXTUALLY
    ~^\(  GlobalTimerExpired("Bystander","GLOBAL")\)~
    ~\1 OR(2) InMyArea("bystand1") InMyArea("bystand2")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY

// ar0701 shouldn't be able to trigger in ar0205, but it does
COPY_EXISTING ~ar0701.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~PartyHasItem("MISC5Z")~ 
      ~PartyHasItem("MISC5Z") InMyArea(Player1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// death of mekrath not clearing journal entries; see mekrat.dlg
EXTEND_BOTTOM ~ar0705.bcs~ ~bg2fixpack/baf/ar0705.baf~

// random Garrick stuff can prevent Bodhi's appearance
COPY_EXISTING ~ar0800.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("GarrickSpeak","GLOBAL",1)~
                      ~False()~
  COMPILE_BAF_TO_BCS
  EXTEND_BOTTOM ~ar0800.bcs~ ~bg2fixpack/baf/ar0800.baf~

// bodhi broken if saved during her wait()-laden spawn; unstakable vampire fix
// Unlock the main door to Bodhi's lair if the player sides with her in Chapter 2 (aVENGER)
COPY_EXISTING ~ar0801.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~SetGlobal("LassalVampires","GLOBAL",3)~ ~~
    REPLACE_TEXTUALLY ~CreateCreatureDoor("bodhi2",\[480\.1338\],14)~
      ~SetGlobal("LassalVampires","GLOBAL",3) CreateCreatureDoor("bodhi2",[480.1338],14)~
    REPLACE_TEXTUALLY EXACT_MATCH ~SetGlobal("SpawnBodhiFriends","AR0801",1)~ ~SetGlobal("SpawnBodhiFriends","AR0801",1) Unlock("DOOR03")~
    APPEND_FILE ~bg2fixpack/baf/ar0801.baf~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// allow cleric-rangers to acquire temple stronghold; see bharval.dlg, borinall.dlg, scsain.dlg, travin.dlg
COPY_EXISTING ~ar0900.bcs~ ~override~
              ~ar0902.bcs~ ~override~
              ~arval.bcs~  ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~OR(5)\([%TAB% %LNL%%MNL%%WNL%]+Class(Player1,CLERIC)[%TAB% %LNL%%MNL%%WNL%]+Class(Player1,FIGHTER_CLERIC)[%TAB% %LNL%%MNL%%WNL%]+Class(Player1,CLERIC_MAGE)[%TAB% %LNL%%MNL%%WNL%]+Class(Player1,CLERIC_THIEF)[%TAB% %LNL%%MNL%%WNL%]+Class(Player1,FIGHTER_MAGE_CLERIC)[%TAB% %LNL%%MNL%%WNL%]+\)\(Alignment(Player1,MASK_GOOD)\)~
                      ~OR(6) \1 Class(Player1,CLERIC_RANGER) \2~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// can still rest in lathander temple after stripped due to var scope issue
// telwyn HoG exploit fix, pt 2/2 (see sctelwyn.d)
COPY_EXISTING ~ar0901.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~"AR0902"~ ~"AR0901"~
    APPEND_FILE ~bg2fixpack/baf/ar0901.baf~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// allows resting in paladin stronghold
EXTEND_BOTTOM ~ar0903.bcs~ ~bg2fixpack/baf/ar0903.baf~

// terrece should only spawn if you speak to corneil, not just enter his area
COPY_EXISTING ~ar1000.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("TerreceSpawn","GLOBAL",1)~
                      ~Global("TerreceSpawn","GLOBAL",1) Global("TalkedToCorneil","GLOBAL",1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// ar1002 should check tolgerias' alternate DV
/// Tolgerias only vanishes once (proposed by Jastey, coded by DavidW)
// Ketlaar Argrim and his bodyguards go away from the Council building if he's imprisoned
COPY_EXISTING ~ar1002.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Dead("TOLGER")~
                      ~OR(2) Dead("TOLGER") Dead("TOLGER2")~
    REPLACE_TEXTUALLY CASE_INSENSITIVE ~Dead("TOLGER2")~ ~Dead("TOLGER2")Exists("tolger")~
    APPEND_FILE ~bg2fixpack/baf/ar1002.baf~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// no escape from TR
EXTEND_BOTTOM ~ar1008.bcs~ ~bg2fixpack/baf/ar1008.baf~

// paladin-firkraag journal entry not being set due to bad variable scope
COPY_EXISTING ~ar1202.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~"AR1200"~ ~"AR1202"~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// monster invincible items updated, need to update script to same
COPY_EXISTING ~ar1300.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ActionOverride("trolgi0\([12]\)",DestroyItem("MINHP1"))~
                      ~ActionOverride("trolgi0\1",DestroyItem("MINHP1")) ActionOverride("trolgi0\1",DestroyItem("MONHP1"))~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// can't lure dead umber hulks; assigned kpumb01 DVs to make this work
COPY_EXISTING ~ar1301.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("UmberHungry","AR1301",0)~ ~Global("UmberHungry","AR1301",0) NumDeadLT("KPUMB01",5)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// fixes Glacias charm issue
COPY_EXISTING ~ar1303.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~[^,]ApplySpell("kpglai01",WIZARD_TRUE_DISPEL_MAGIC)~
                      ~ActionOverride("kpglai01",ApplySpell("kpglai01",FORCE_DISPEL_MAGIC))~
    REPLACE_TEXTUALLY ~[^,]ChangeEnemyAlly("kpglai01",NEUTRAL)~
                      ~ActionOverride("kpglai01",ChangeEnemyAlly(Myself,NEUTRAL))~
  COMPILE_BAF_TO_BCS

// spirit doesn't escape area due to bad DV call
COPY_EXISTING ~ar1400.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ActionOverride("rspirit1"~ ~ActionOverride("rspirit01"~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// enables container in shade lord dungeon; see shaava01.dlg
COPY_EXISTING ~ar1401.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY ~SetGlobal("Deactivate","AR1401",1)~
    ~SetGlobal("Deactivate","AR1401",1)
     ContainerEnable("CONTAINER2",FALSE)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// more shadow fiends don't spawn due to DV typo
COPY_EXISTING ~ar1404.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~"shdafi01"~ ~"shadfi01"~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// asylum script bugs
COPY_EXISTING ~ar1515.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("ppattackedJon","GLOBAL",1)~
                      ~Global("ppattackedJon","GLOBAL",1)
                       Global("WackoArmy","GLOBAL",0)~
    REPLACE_TEXTUALLY ~Global("PPdeshSend","GLOBAL",0)~
                      ~OR(2)
                         Global("PPdeshSend","GLOBAL",0)
                         Global("PirateRefused","GLOBAL",1)~
  COMPILE_BAF_TO_BCS
UNLESS ~PirateRefused~

// Brynnlaw initial vamp fight should check for non-existence not dead (revised by Ardanis)
COPY_EXISTING ~ar1600.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY ~Dead("ppvalen")
  Dead("ppparis")
  Dead("ppdel")~
 ~Global("ThiefGroup","global",1) // only trigger if the party has sided with the Shadow Thieves
  !Exists("ppvalen")
  !Exists("ppparis")
  !Exists("ppdel")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// multiple rerdes due to bad var scope
COPY_EXISTING ~ar1613.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~"SpawnCaptain","AR1613"~ ~"SpawnCaptain","GLOBAL"~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Jenia will wait until PC officially hero of trademmet
COPY_EXISTING ~ar2000.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY ~Global("JeniaSpawn","AR2000",0)~
    ~Global("JeniaSpawn","AR2000",0)
     Global("loganjob2","GLOBAL",2)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// deirex killed during cutscene fix 1/2; see jarlich.cre
EXTEND_BOTTOM ~ar2207.bcs~ ~bg2fixpack/baf/ar2207.baf~

// prevent dupe CoC items; see also sahkng01.bcs, sahpr4.cre, sahpr2.dlg, string sets
EXTEND_BOTTOM ~ar2300.bcs~   ~bg2fixpack/baf/ar2300.baf~

// no-repeat Drizzt
ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB, much easier thanks to new action

  COPY_EXISTING ~ar2601.bcs~ ~override~
    DECOMPILE_BCS_TO_BAF
      REPLACE_TEXTUALLY ~"DrizztEncounter","AR2601"~ ~"DrizztEncounter","GLOBAL"~
      REPLACE_TEXTUALLY ~Explore()~ ~Explore()
        SetEncounterProbability("AR2500","AR0020",0)
        SetEncounterProbability("AR2500","AR1300",0)
        SetEncounterProbability("AR2500","AR1304",0)
        SetEncounterProbability("AR2500","AR1700",0)~
    COMPILE_BAF_TO_BCS
    BUT_ONLY_IF_IT_CHANGES
  
END ELSE BEGIN // SoA

  COPY_EXISTING ~ar2601.bcs~ ~override~
    DECOMPILE_BCS_TO_BAF
    COMPILE_BAF_TO_BCS
    BUT_ONLY_IF_IT_CHANGES
  COPY_EXISTING ~ar0043.bcs~ ~override~
  EXTEND_BOTTOM ~ar2601.bcs~ ~override/ar0043.bcs~

END

// alignment change if evil path in hell trials; other fixes in teardoor.bcs
EXTEND_BOTTOM ~ar2900.bcs~ ~bg2fixpack/baf/ar2900.baf~

// script changes to ensure paladins/rangers fall in Hell tests; also closing selfish exploits
EXTEND_BOTTOM ~ar2901.bcs~ ~bg2fixpack/baf/ar2901.baf~
EXTEND_BOTTOM ~ar2902.bcs~ ~bg2fixpack/baf/ar2902.baf~
EXTEND_BOTTOM ~ar2903.bcs~ ~bg2fixpack/baf/ar2903.baf~
COPY_EXISTING ~ar2904.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("PaladinGone","AR2904"~ ~Global("AbyssPaladinGone","GLOBAL"~
    REPLACE_TEXTUALLY ~Global("RangerGone","AR2904"~  ~Global("AbyssRangerGone","GLOBAL"~
    REPLACE_TEXTUALLY ~Class(Player1,RANGER_ALL)~  ~Class(Player1,RANGER_ALL) !Class(Player1,CLERIC_RANGER)~
    REPLACE_TEXTUALLY ~\(OpenState("DOOR03",TRUE)\)~ ~\1 Global("OpenedDoor1","AR2904",1)~
    REPLACE_TEXTUALLY ~\(OpenState("DOOR04",TRUE)\)~ ~\1 Global("OpenedDoor2","AR2904",1)~
    REPLACE_TEXTUALLY ~\(OpenState("DOOR05",TRUE)\)~ ~\1 Global("OpenedDoor3","AR2904",1)~
    REPLACE_TEXTUALLY ~\(OpenState("DOOR06",TRUE)\)~ ~\1 Global("OpenedDoor4","AR2904",1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
EXTEND_BOTTOM ~ar2905.bcs~ ~bg2fixpack/baf/ar2905.baf~

// tries to remove override scripts for knights before killing them
COPY_EXISTING ~ar3020.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ChangeAIScript("one",OVERRIDE))~ ~ChangeAIScript("",OVERRIDE))~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// removing call to nonexistent trigger
COPY_EXISTING ~ar3021.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~TriggerActivation("OilDoor",FALSE)~ ~~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Viccy can romance half-orcs; multi-brus fixes
// drow item exploits closed
// not paying thieves guild quota fix; see also ar0322.bcs, joster.bcs, shthlt01.dlg
COPY_EXISTING ~baldur.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Race(Player1,0)~ ~Race(Player1,HALFORC)~
    REPLACE_TEXTUALLY ~Global("SpawnBrus","GLOBAL",1)~ 
      ~Global("SpawnBrus","GLOBAL",1) Global("CHAPTER","GLOBAL",2) !AreaCheck("AR0800") !AreaCheck("AR2000") CombatCounter(0)~
    REPLACE_TEXTUALLY ~CreateCreatureObjectOffScreen("BRUS3",Player1,0,0,0)~
      ~CreateCreatureObjectOffScreen("BRUS3",Player1,0,0,0) SetGlobal("SPAWNBRUS","GLOBAL",2)~
    REPLACE_TEXTUALLY ~\bGlobal("JosterLeave","GLOBAL",2)~ ~!Global("JosterLeave","GLOBAL",1)~
    APPEND_FILE ~bg2fixpack/baf/baldur.baf~
  COMPILE_BAF_TO_BCS

// cespy's handing out undercharged items
COPY_EXISTING ~botsmith.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~GiveItemCreate("clck31",Player1,0,0,0)~ ~GiveItemCreate("clck31",Player1,1,1,0)~
    REPLACE_TEXTUALLY ~GiveItemCreate("sw1h69",Player1,0,0,0)~ ~GiveItemCreate("sw1h69",Player1,0,1,1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~BRANNEL.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("LathanPlot1","GLOBAL",1)~ ~Global("LathanPlot","GLOBAL",1)~
    REPLACE_TEXTUALLY ~Global("LathanPlot2","GLOBAL",1)~ ~Global("LathanPlot","GLOBAL",2)~
    REPLACE_TEXTUALLY ~StartDialog\(ue\)?NoSet(Myself)~  ~StartDialogueNoSet(Player1)~
  COMPILE_BAF_TO_BCS

// ch 6 allies check wrong drizzt DV
COPY_EXISTING ~c6arkan.bcs~ ~override~
              ~c6eric.bcs~  ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~("c6drizz")~ ~("c6drizz2")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Killing war elves while escaping Underdark lets you kill the surface elves
COPY_EXISTING ~c6elf.bcs~   ~override~
              ~c6elhan.bcs~ ~override~
              ~c6extra.bcs~ ~override~
              ~c6gener.bcs~ ~override~
              ~warsage.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("GoodElfKill","GLOBAL",0)~ ~GlobalLT("GoodElfKill","GLOBAL",2)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// valen's premature death prevents Del changing from bat form and attacking
COPY_EXISTING ~c6valen.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ReallyForceSpellDead(Myself,VALEN_MIST_FORM_CHANGE)~
      ~SetGlobal("ValenFight","AR0808",1) ReallyForceSpellDead(Myself,VALEN_MIST_FORM_CHANGE)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// remove minhp1 for a moment to allow bodhi's str decrease to take effect
COPY_EXISTING ~c6bweak.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ApplySpell(Myself,C6BODHI_WEAKNESS)~
                      ~TakeItemReplace("monhp1","minhp1",Myself) ApplySpell(Myself,C6BODHI_WEAKNESS) TakeItemReplace("minhp1","monhp1",Myself)~
    REPLACE_TEXTUALLY ~DestroyItem("VAMPREG3")~ ~DestroyItem("VAMPREG2")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// cadril's script using wrong DVs for Cyrando and Irlana
COPY_EXISTING ~cadril.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~"tcyrando"~ ~"cyrando"~
    REPLACE_TEXTUALLY ~"tirlana"~ ~"irlana"~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Cernd goes hostile if Grove poisoned
EXTEND_BOTTOM ~cernd.bcs~ ~bg2fixpack/baf/cernd.baf~

// new troll scripts to transform to dead versions at low HP
COPY_EXISTING ~troll01.bcs~  ~override/cdtroll1.bcs~
              ~trolsn01.bcs~ ~override/obsice11.bcs~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ChangeAnimationNoEffect("TROLSN02")~ ~ChangeAnimationNoEffect("obsice11")~
    REPLACE_TEXTUALLY ~ChangeAnimationNoEffect("TROLL02")~  ~ChangeAnimationNoEffect("cdtroll2")~
  COMPILE_BAF_TO_BCS

// new troll scripts to transform from dead to alive after time expires
COPY_EXISTING ~troll02.bcs~  ~override/cdtroll2.bcs~
              ~trolsn02.bcs~ ~override/obsice01.bcs~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ReallyForceSpell(Myself,TROLL_CHANGE)~      ~ReallyForceSpellRES("cdtroll1",Myself)~
    REPLACE_TEXTUALLY ~ReallyForceSpell(Myself,TROLL_SNOW_CHANGE)~ ~ReallyForceSpellRES("obsice01",Myself)~
  COMPILE_BAF_TO_BCS

// trolls giving double XP if slain by instant-death spell
COPY_EXISTING ~chaltrol.bcs~ ~override~ // giant troll, challenge
              ~dgtrol01.bcs~ ~override~ // troll, druid grove
              ~firamb03.bcs~ ~override~ // fire troll
              ~hgtrl01.bcs~  ~override~ // fire troll
              ~rogtro01.bcs~ ~override~ // roger's sea troll
              ~trolde01.bcs~ ~override~ // desert troll
              ~trolfr01.bcs~ ~override~ // freshwater troll
              ~trolgi01.bcs~ ~override~ // giant troll
              ~trolic01.bcs~ ~override~ // ice troll
              ~trolic03.bcs~ ~override~ // blizzard troll
              ~troll01.bcs~  ~override~ // generic troll
              ~trolsi01.bcs~ ~override~ // spirit troll
              ~trollsm2.bcs~ ~override~ // small troll - lacking timers and such
              ~trolsn01.bcs~ ~override~ // snow troll
              ~trolsp01.bcs~ ~override~ // spectral troll
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~HPLT(Myself,\([0-9]+\))~ ~!StateCheck(Myself,STATE_REALLY_DEAD) HPLT(Myself,\1)~
    PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "trolfr01" = 0) BEGIN // extra fix for freshwater troll
      REPLACE_TEXTUALLY ~"TROLGI02"~ ~"trolfr02"~ // freshwater trolls becoming giant trolls when knocked down
    END
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// cromwell cutscene; removes multi-forged item bug
COPY_EXISTING ~cromwell.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~CutSceneId("wsmith01")~ ~CutSceneId("wsmith01") ClearAllActions()~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~ctaltar.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~"PortalOpen","GLOBAL"~ ~"PortalOpen","AR3001"~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

/// Ployer breaks the game if he meets Jaheira when she has fewer than 20 hit points. (see also dw#fpplo.spl) 
// (proposed and originally coded by Icendoan, this code by DavidW)
COPY_EXISTING ~cut12b.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY CASE_INSENSITIVE ~ForceSpell("Jaheira",JAHEIRA_WEAKNESS)~ ~ApplySpellRES("dw#fpplo","Jaheira")SmallWait(5)ForceSpell("Jaheira",JAHEIRA_WEAKNESS)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// removes call to nonexistent cre file
COPY_EXISTING ~cut31q.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~CreateCreature("bdcoun04",\[592\.825\],10)~ ~~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// rest commands not executed due to DayNight flakiness
COPY_EXISTING ~cut41c.bcs~ ~override~
              ~cut41d.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~[^,]Rest()~
                      ~Wait(1)
                      Rest()~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// fix cutscene for departing Amn
COPY_EXISTING ~cut41d.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ActionOverride("pparan2",DestroySelf())~
                      ~ActionOverride("aran",DestroySelf())~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// part of desharik's xp exploit fix, see ppdesh in the d file
COPY_EXISTING ~cut41f.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY ~SetGlobal("EnteredArea1500","GLOBAL",1)~
    ~SetGlobal("EnteredArea1500","GLOBAL",1)
     AddXPObject(Player1,38500)
     AddXPObject(Player2,38500)
     AddXPObject(Player3,38500)
     AddXPObject(Player4,38500)
     AddXPObject(Player5,38500)
     AddXPObject(Player6,38500)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// familiars and summons should be pushed back when hell door opens
COPY_EXISTING ~cut85a.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ActionOverride("HELLSPY4",ApplySpell(Player[1-6],HELL_BUFFET))~ ~~
    REPLACE_TEXTUALLY ~ActionOverride("hellspy4",ApplySpell(\[FAMILIAR\],HELL_BUFFET))~ ~ActionOverride("HELLSPY4",ForceSpell(Player1,HELL_BUFFET))~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// ust natha scenery cutscene can occur offscreen, meaning player stands in dark for no apparent reason
COPY_EXISTING ~dadrow20.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~StartCutSceneMode()~
      ~StartCutSceneMode() CreateCreature("cutspy",[3864.273],0) MoveViewPoint([3864.273],INSTANT)~
    REPLACE_TEXTUALLY ~EscapeArea()~
      ~EscapeArea() ActionOverride("cutspy",DestroySelf()) MoveViewObject(Player1,INSTANT)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// delon's script using wrong variable for talking to Lloyd; had EscapeArea() issues
COPY_EXISTING ~delon.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~TalkedToMayor~ ~TalkedToLloyd~
    REPLACE_TEXTUALLY ~OR(4)[%TAB% %LNL%%MNL%%WNL%]+Global("Acceptance","GLOBAL",1)~ ~OR(3)~
    REPLACE_TEXTUALLY ~AreaCheck("AR1000")~ ~~
    REPLACE_TEXTUALLY ~GlobalTimerExpired("MinscDelon","GLOBAL")~ ~False()~
    APPEND_FILE ~bg2fixpack/baf/delon.baf~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~demglasu.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~See(\[ANYONE\])[%TAB% %LNL%%MNL%%WNL%]+Global("Prep","LOCALS",1)~  ~See([ANYONE])~
  COMPILE_BAF_TO_BCS
  BUT_ONLY

// restore Nith's attack script, pt 1: false() out stuff that'll break
COPY_EXISTING ~drshnl01.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~HPLT(Myself,10)~ ~False()~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// new troll scripts to transform to dead versions at low HP
COPY_EXISTING ~troll01.bcs~ ~override/drshnl11.bcs~
              ~troll01.bcs~ ~override/eletro03.bcs~
              ~troll01.bcs~ ~override/kptrol23.bcs~
              ~troll01.bcs~ ~override/pptroll2.bcs~
              ~troll01.bcs~ ~override/sutroll2.bcs~
              ~troll01.bcs~ ~override/torgal2.bcs~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ChangeAnimationNoEffect("TROLL02")~ ~ChangeAnimationNoEffect("%DEST_RES%")~
  COMPILE_BAF_TO_BCS

// duplicates functionality, but needed for ub compatibility
EXTEND_TOP ~drshnl01.bcs~ ~override/drshnl11.bcs~

// new troll scripts to transform from dead to alive after time expires
COPY_EXISTING ~troll02.bcs~ ~override/drshnl21.bcs~
              ~troll02.bcs~ ~override/eletro01.bcs~
              ~troll02.bcs~ ~override/kptrol13.bcs~
              ~troll02.bcs~ ~override/pptroll1.bcs~
              ~troll02.bcs~ ~override/sutroll.bcs~
              ~troll02.bcs~ ~override/torgal3.bcs~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ReallyForceSpell(Myself,TROLL_CHANGE)~ ~ReallyForceSpellRES("%DEST_RES%",Myself)~
  COMPILE_BAF_TO_BCS

// edwin soundset issues for transformation
COPY_EXISTING ~edwin.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~SetPlayerSound(Myself,30716,SELECT_ACTION4)~ ~SetPlayerSound(Myself,30715,SELECT_ACTION4)~
    REPLACE_TEXTUALLY ~SetPlayerSound(Myself,30717,SELECT_ACTION5)~ ~SetPlayerSound(Myself,3984,SELECT_ACTION5)~
    REPLACE_TEXTUALLY ~SetPlayerSound(Myself,30718,SELECT_ACTION6)~ ~SetPlayerSound(Myself,3985,SELECT_ACTION6)~
    REPLACE_TEXTUALLY ~SetPlayerSound(Myself,30719,SELECT_ACTION7)~ ~SetPlayerSound(Myself,3986,SELECT_ACTION7)~
  COMPILE_BAF_TO_BCS

// containers can summon guards days after they're open
COPY_EXISTING ~enforam.bcs~ ~override~
              ~tempv01.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~OR(2)[%TAB% %LNL%%MNL%%WNL%]+!See(\[NOTGOOD\])[%TAB% %LNL%%MNL%%WNL%]+Global("warn","LOCALS",1)~
      ~GlobalTimerExpired("CDGoAway","LOCALS")~
    REPLACE_TEXTUALLY ~Global("warn","LOCALS",0)~ ~Global("warn","LOCALS",0) GlobalTimerNotExpired("CDGoAway","LOCALS")~
    REPLACE_TEXTUALLY ~Wait(5)~ ~~
    REPLACE_TEXTUALLY ~See(\[NEUTRAL\])~ ~See([NEUTRAL.HUMANOID])~
    APPEND_FILE ~bg2fixpack/baf/enforam.baf~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// script should check live and dead troll DV
COPY_EXISTING ~firamb01.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~\([^!]\)Dead("firamb05")~ ~\1OR(2) Dead("firamb03") Dead("firamb05")~
  COMPILE_BAF_TO_BCS

// add slight delay so Anomen can comment on dead Windspear knights before Garren
// double Garren Windspears
COPY_EXISTING ~garren.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~\(GlobalLT("DomainPaladinBattle","GLOBAL",4)[%TAB% %LNL%%MNL%%WNL%]+THEN[%TAB% %LNL%%MNL%%WNL%]+RESPONSE #100\)[%TAB% %LNL%%MNL%%WNL%]+\(StartDialogu?e?NoSet(Player1)\)~
      ~\1 Wait(1) \2~
    APPEND_FILE ~bg2fixpack/baf/garren.baf~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// animals shold not run away from druids, elves, and rangers
COPY_EXISTING ~genshy.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~OR(3)~ ~~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// other gladiators should do something when Hendak does
COPY_EXISTING ~glad2782.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY ~Dead("Hendak")~
    ~OR(2)
     Dead("Hendak")
     Allegiance("Hendak",255)~
    APPEND_FILE ~bg2fixpack/baf/glad2782.baf~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// gorf the squisher fixes
COPY_EXISTING ~gorf.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~SetGlobal("GoKillEm","LOCALS",2)~
                      ~SetGlobal("GoKillEm","LOCALS",2)
                      SetGlobal("GorfBystander","GLOBAL",1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// prevents Tamoko from running away and making PP challenge unfinishable, see chtaz02.cre for other half
COPY_EXISTING ~gpkensai.bcs~ ~override/cdtamoko.bcs~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~!HasItem("POTN55",Myself)~ ~False()~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// move grae's minhp1 destruction to dialogue options where she dies; see soa-dlg.d for rest of changes
COPY_EXISTING ~grae.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~DestroyItem("minhp1")~ ~~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// don't interrupt lucette when she's kiling xzar
COPY_EXISTING ~harpass1.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~FaceObject("Lyros")~ ~SetInterrupt(FALSE) DialogInterrupt(FALSE) FaceObject("Lyros")~
    REPLACE_TEXTUALLY ~StartDialog\(ue\)?NoSet(Player1)~ ~DialogInterrupt(TRUE) SetInterrupt(TRUE) StartDialogueNoSet(Player1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// lesser clay golems in CI can be killed twice
COPY_EXISTING ~igolfle1.bcs~ ~override~
              ~igolfle2.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("Ellsime","AR0602",1)~ ~Global("Ellsime","AR0602",1) !StateCheck(Myself,STATE_REALLY_DEAD)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// ilyich actually wears his imported armor
EXTEND_BOTTOM ~ilyich.bcs~ ~bg2fixpack/baf/ilyich.baf~

// sahugin spectre should only kill one party member and then escape
COPY_EXISTING ~impches3.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~!Global("ImpRiddle","GLOBAL",3)~ ~!Global("ImpRiddle","GLOBAL",3) Global("CDImpChest","AR2300",0)~
    REPLACE_TEXTUALLY ~Kill(LastTrigger)~ ~Kill(LastTrigger) SetGlobal("CDImpChest","AR2300",1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// not paying thieves guild quota fix; see also ar0322.bcs, baldur.bcs, shthlt01.dlg
EXTEND_BOTTOM ~joster.bcs~ ~bg2fixpack/baf/joster.baf~

// script fixes for anarg-smuggler battle; see also kaypal03.bcs, kaysmg04.bcs
COPY_EXISTING ~kaypal02.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~(\[NEUTRAL\.0\.HUMAN\.THIEF\])~ ~([NOTGOOD.0.0.CLERIC])~
   REPLACE_TEXTUALLY ~(\[ENEMY\.0\.HUMAN\.THIEF\])~   ~([NOTGOOD.0.0.THIEF]) Name("kaysmg",LastSeenBy(Myself))~
   REPLACE_TEXTUALLY ~AttackReevaluate(NearestEnemyOf(Myself),15)~
                     ~AttackReevaluate(LastSeenBy(Myself),15)~
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// script fixes for anarg-smuggler battle; see also kaypal02.bcs, kaysmg04.bcs
COPY_EXISTING ~kaypal03.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~AttackReevaluate(NearestEnemyOf(Myself),30)~ 
                     ~AttackReevaluate(LastSeenBy(Myself),30)~
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// script fixes for anarg-smuggler battle; see also kaypal02.bcs, kaypal03.bcs
COPY_EXISTING ~kaysmg04.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~\(HPPercentLT("kaysmgl",50)[%TAB% %LNL%%MNL%%WNL%]+See("kaysmgl")\)~ ~\1 !Dead("kaysmgl")~
   REPLACE_TEXTUALLY ~HPPercentLT("kaysmg",30)[%TAB% %LNL%%MNL%%WNL%]+See("kaysmg")~ 
                     ~See([NOTGOOD.0.0.THIEF]) HPPercentLT(LastSeenBy(Myself),30) Name("kaysmg",LastSeenBy(Myself))~
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// Arkanis Gath should not spawn and kill the PC post-Bynnlaw
EXTEND_TOP ~killpc.bcs~ ~bg2fixpack/baf/killpc.baf~

// flail of ages forge should still work after acquiring stronghold; wasn't due to bad variable scope
// Assembling the Flail of Ages piece by piece should grant an XP reward (Wisp)
COPY_EXISTING ~kpforge.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~,"AR1302",~ ~,"GLOBAL",~
    REPLACE_TEXTUALLY CASE_INSENSITIVE EVALUATE_REGEXP ~TakePartyItem("\(blun14[abc]\)")[ %LNL%]+TakePartyItem("\(blun14[ghi]\)")[ %LNL%]+TakePartyItem("\(blun14[def]\)")[ %LNL%]+GiveItemCreate("BLUN14",LastTrigger,0,0,0)[%LNL%]END~ ~TakePartyItem("\1") TakePartyItem("\2") TakePartyItem("\3") GiveItemCreate("BLUN14",LastTrigger,0,0,0) AddexperienceParty(22350) SetGlobal("ForgeUsed","GLOBAL",1) END~
  COMPILE_BAF_TO_BCS
  BUT_ONLY

// should be able to steal at Lathander temple if invisible
COPY_EXISTING ~LATHALRM.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~OR(2)~ ~~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// lavok dying too early because of this cheese script
// False()d rather than unassigned in case someone wants to use this for lavok02-specific scripting
COPY_EXISTING ~lavok02.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~!HasItem("MINHP1",Myself)~ ~False()~
    APPEND_FILE ~bg2fixpack/baf/lavok02.baf~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
  
// madeen should go away if Tolgerias dead--check for other DV
EXTEND_TOP ~madeen.bcs~ ~bg2fixpack/baf/madeen.baf~

// mazzy only goes hostile if Valygar is hostile and not charmed
COPY_EXISTING ~mazzy.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Allegiance("Valygar",ENEMY)~
                      ~Allegiance("Valygar",ENEMY)
                      !StateCheck("Valygar",STATE_CHARMED)~
    REPLACE_TEXTUALLY ~OR(2)[ %LNL%%MNL%%WNL%]+Dead("gorf")[ %LNL%%MNL%%WNL%]+Dead("gorf03")~ ~Dead("gorf")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Hostile and out of party Minsc and Valygar shouldn't heal party members (Nythrun)
COPY_EXISTING minscx.bcs   override
              valvsed.bcs  override
              valygx.bcs   override
  REPLACE_TEXTUALLY ~^0 0 0 0 0 0 0 1 6 0 0 0 ""OB~ ~0 0 0 0 0 0 0 1 0 0 0 0 ""OB~
BUT_ONLY
IF ~^0 0 0 0 0 0 0 1 6 0 0 0 ""OB~

// disables Gath spawn from mvally
COPY_EXISTING ~mvally.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~OR(2)~
                      ~False()~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
EXTEND_TOP ~mvally.bcs~ ~bg2fixpack/baf/mvally.baf~

// disables Gath spawn from mvally2
COPY_EXISTING ~mvally2.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~AttackedBy(\[GOODCUTOFF\],DEFAULT)~
                      ~False()~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
EXTEND_TOP ~mvally2.bcs~ ~bg2fixpack/baf/mvally2.baf~

// tyrianna should disappear after conclusion of her quest
EXTEND_BOTTOM ~plgirl01.bcs~ ~bg2fixpack/baf/plgirl01.baf~

// asylum crushing trap hitting wrong folks
COPY_EXISTING ~ppcrus1.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~!StateCheck(LastTrigger,STATE_REALLY_DEAD)~ ~False()~
    REPLACE_TEXTUALLY ~StateCheck(LastTrigger,STATE_REALLY_DEAD)~ ~~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// emphatic manifestation can be killed by resting outside
EXTEND_TOP ~riftcr04.bcs~ ~bg2fixpack/baf/riftcr04.baf~

// fixes breaking bridge in UE quest
COPY_EXISTING ~riftg01.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY ~!Dead("Riftcr0[23]")~ ~False()~
  REPLACE_TEXTUALLY ~!Dead("Riftcr01")~ ~Dead("Riftcr01")~
  REPLACE_TEXTUALLY ~!Exists("Riftcr01")~
  ~CombatCounter(0)
  OR(2)
     !Exists("Riftcr03")
     Dead("Riftcr03")
  OR(2)
     !Exists("Riftcr02")
     Dead("Riftcr02")
   OR(2)
     !Exists("Riftcr01")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// amalas' buddies should leave together if you kill him
COPY_EXISTING ~rufpal.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global(\("itFight","R0406P"\|"R0406PitFight",""\),3)~ ~Global("PitFight","AR0406",3)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// trigger misordering causing folks to flee from party, not enemies
COPY_EXISTING ~runenemy.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~\(See(\[ENEMY\])\)[%TAB% %LNL%%MNL%%WNL%]+\(!?Detect(\[PC\])\)~ ~\2 \1~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// prevent dupe CoC items; see also ar2300.bcs, sahpr4.cre, sahpr2.dlg, string sets
EXTEND_BOTTOM ~sahkng01.bcs~ ~bg2fixpack/baf/sahkng01.baf~

COPY_EXISTING ~sardw01.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~"SaradushAmbientInsults","GLOBAL"~ ~"SaradushAmbientInsults","AR5000"~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// habib shouldn't spawn if dead
COPY_EXISTING ~slilmat.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("SpawnHabib","GLOBAL",5)~
                      ~Global("SpawnHabib","GLOBAL",5) !Dead("Habib")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// ring of djinni summoning should destroy ring if djinni dies
EXTEND_TOP ~sumdj01.bcs~ ~bg2fixpack/baf/sumdj01.baf~

// avatar of rilifane xp exploit fix
COPY_EXISTING ~sustatue.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Contains("MISCB3",Myself)~
      ~Contains("MISCB3",Myself) Global("CDNoRepeat","AR2803",0)~
    REPLACE_TEXTUALLY ~TriggerActivation("Tran2800",FALSE)~
      ~SetGlobal("CDNoRepeat","AR2803",1) TriggerActivation("Tran2800",FALSE)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// alignment change if evil path in hell trials; other fixes in ar2900.bcs
EXTEND_TOP ~teardoor.bcs~ ~bg2fixpack/baf/teardoor.baf~

// stops Terrece from initiating dialogue from outside
COPY_EXISTING ~terrece.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("TerreceSpawn","GLOBAL",2)~ ~Global("TerreceSpawn","GLOBAL",2) See([PC])~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// multiple ring of the ram exploit fixes
EXTEND_TOP ~tolger.bcs~ ~bg2fixpack/baf/tolger.baf~

// summoned juggernaut golem shouldn't die instantly if summoned by clone
COPY_EXISTING ~tomegol4.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~!CheckStatGT(Player1,0,STONESKINSGOLEM)~ ~!CheckStatGT(LastSummonerOf(Myself),0,STONESKINSGOLEM) !CheckStatGT(Player1,0,STONESKINSGOLEM)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// removes bug of losing rogue stone if reloaded
// The Twisted Rune entrance trigger in the Bridge District should only consume a single Rogue Stone (aVENGER)
COPY_EXISTING ~tran1008.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~TakePartyItem("MISC45")~ ~~
    REPLACE_TEXTUALLY ~ActionOverride(Player1,LeaveAreaLUAPanic("AR1008","",\[495\.755\],10))~
                      ~ActionOverride(Player1,LeaveAreaLUAPanic("AR1008","",[495.755],10))
                      TakePartyItemNum("MISC45",1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
 
// trrakxx should have dialogue when attacked
COPY_EXISTING ~TrRak01.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~AttackedBy(\[ANYONE\],DEFAULT)~ ~Global("attacked","LOCALS",1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
EXTEND_TOP ~TrRak01.bcs~ ~bg2fixpack/baf/TrRak01.baf~

// endless Ust Natha tavern combat music
COPY_EXISTING ~ucounter.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF 
    REPLACE_TEXTUALLY ~SetGlobal("HaltMusicWithLesaonar","GLOBAL",0)~ ~SetGlobal("HaltMusicWithLesaonar","GLOBAL",2)~
    REPLACE_TEXTUALLY ~\(CombatCounterLT(50)[%TAB% %LNL%%MNL%%WNL%]+Global("HaltMusicWithLesaonar","GLOBAL",\)0)~ ~\12)~
    APPEND_FILE ~bg2fixpack/baf/ucounter.baf~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// prevent journal entry for already-openeed UD illithid doors
COPY_EXISTING ~uddoor2.bcs~ ~override~
              ~uddoor3.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("thrallDoorMes","AR2400",0)~  ~Global("thrallDoorMes","AR2400",0)  Global("thrallDoorOpen","AR2400",0)~
    REPLACE_TEXTUALLY ~Global("thrallDoorMes2","AR2400",0)~ ~Global("thrallDoorMes2","AR2400",0) Global("thrallDoorOpen2","AR2400",0)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Ust Natha egg guards no longer see invisible folks
COPY_EXISTING ~udeggs.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~GlobalTimerExpired("eggGuardDoesWarn","GLOBAL")~
                      ~GlobalTimerExpired("eggGuardDoesWarn","GLOBAL")
                      See([PC])~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
  
// dialogue breaks in phaere's recue if Sola is invald for dialogue
EXTEND_TOP ~udphae01.bcs~ ~bg2fixpack/baf/udphae01.baf~

// uhleave5 and 6 should be moving between areas, opening doors, etc.
COPY_EXISTING ~uhleave5.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~MoveToPointNoInterrupt(\[805\.407\])~ ~MoveToPointNoInterrupt([805.407]) Unlock("DOOR02") OpenDoor("DOOR02")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
EXTEND_TOP ~uhleave5.bcs~ ~BG2Fixpack/baf/uhleave5.baf~

COPY_EXISTING ~uhleave6.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~MoveToPointNoInterrupt(\[709\.301\])~ ~MoveToPointNoInterrupt([709.301]) Unlock("DOOR02") OpenDoor("DOOR02")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
EXTEND_TOP ~uhleave6.bcs~ ~BG2Fixpack/baf/uhleave6.baf~

// trap triggers can't check LOCALS variables; display different string if umber hulks already dead
EXTEND_TOP    ~umbpoly.bcs~ ~bg2fixpack/baf/umbpoly.baf~
COPY_EXISTING ~umbpoly.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("UmbPoly","LOCALS",0)~ ~Global("UmbPoly","AR1301",0) NumDeadLT("KPUMB01",5)~
    REPLACE_TEXTUALLY ~"LOCALS"~ ~"AR1301"~
  COMPILE_BAF_TO_BCS
  REPLACE ~98765~ @142
  BUT_ONLY_IF_IT_CHANGES

// Valygar only goes hostile if mazzy is hostile and not charmed
// valygar goes hostile if something happens to hervo, but should leave the party first
COPY_EXISTING ~valygar.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Allegiance("Mazzy",ENEMY)~
                      ~Allegiance("Mazzy",ENEMY)
                      !StateCheck("Mazzy",STATE_CHARMED)~
    REPLACE_TEXTUALLY ~SetGlobal("vgAttackTheParty","LOCALS",1)~ ~SetGlobal("vgAttackTheParty","LOCALS",1) LeaveParty()~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
  
// Valygar leaving party in Slums can cause cutscene hang
COPY_EXISTING ~valyorb.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~IsOverMe("Valygar")~
      ~IsOverMe("Valygar") InParty("Valygar") IsValidForPartyDialogue("Valygar") !StateCheck("Valygar",STATE_SLEEPING)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// prevents viekang's double dialogue
COPY_EXISTING ~viekang.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("Attacked","LOCALS",0)~ ~Global("Attacked","LOCALS",0) !Global("ViekangSeesPC","LOCALS",1)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// closes Yoshimo exploit of resurrecting him after Spellhold
// prevent Yoshimo telling you to see Renal when you already have
COPY_EXISTING ~yoshimo.BCS~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Kill(Myself)~
                      ~Kill(Myself)
                      LeaveParty()~
    REPLACE_TEXTUALLY ~Global("YoshimoMentionsRenal","LOCALS",0)~ ~Global("YoshimoMentionsRenal","LOCALS",0) Global("TalkedToRenal","GLOBAL",0)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Yoshimo should not drop two hearts when slain by a petrification effect (Nythrun)
COPY_EXISTING yoshimox.bcs override
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~^\(  Die()\)~ ~\1 !StateCheck(Myself,128)~
  COMPILE_BAF_TO_BCS
BUT_ONLY

ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB check

  // part of the multi-holy symbol exploit fix. Also needed: CDHLYSYM.spl, CDHLYSY2.spl, CDHLYSYM.itm, and clabpr02-04 changes.
  EXTEND_TOP ~baldur.bcs~   ~bg2fixpack/baf/holysym.baf~
  EXTEND_TOP ~baldur25.bcs~ ~bg2fixpack/baf/holysym.baf~

  COPY_EXISTING ~demnabsu.bcs~ ~override~
                ~dempitsu.bcs~ ~override~
    DECOMPILE_BCS_TO_BAF
      REPLACE_TEXTUALLY ~See(\[ANYONE\])~ ~See([ANYONE]) CheckStatLT(LastSeenBy(Myself),1,169)~
    COMPILE_BAF_TO_BCS
    BUT_ONLY

  // Hostile Planetars and Devas should not attempt to heal party members (Nythrun and aVENGER)
  ACTION_FOR_EACH script IN devaevil devagood plangood BEGIN

    ACTION_IF FILE_EXISTS_IN_GAME ~%script%.bcs~ THEN BEGIN

      COPY_EXISTING ~%script%.bcs~ override
        DECOMPILE_BCS_TO_BAF
          REPLACE_TEXTUALLY ~HaveSpell(CLERIC_LESSER_RESTORATION)~ ~HaveSpell(CLERIC_LESSER_RESTORATION) Allegiance(Myself,GOODCUTOFF)~
          REPLACE_TEXTUALLY ~HaveSpell(CLERIC_NEUTRALIZE_POISON)~ ~HaveSpell(CLERIC_NEUTRALIZE_POISON) Allegiance(Myself,GOODCUTOFF)~
          REPLACE_TEXTUALLY ~HaveSpell(CLERIC_REMOVE_FEAR)~ ~HaveSpell(CLERIC_REMOVE_FEAR) Allegiance(Myself,GOODCUTOFF)~
          REPLACE_TEXTUALLY ~HPPercentLT(MostDamagedOf(Myself),25)~ ~HPPercentLT(MostDamagedOf(Myself),25) Allegiance(Myself,GOODCUTOFF)~
          REPLACE_TEXTUALLY ~HaveSpell(CLERIC_DISPEL_MAGIC)~ ~HaveSpell(CLERIC_DISPEL_MAGIC) Allegiance(Myself,GOODCUTOFF)~
        COMPILE_BAF_TO_BCS
      BUT_ONLY

    END

  END

  // if killed directly via spell, fire trolls should do groovy death animations
  EXTEND_TOP ~hgtrl01.bcs~ ~bg2fixpack/baf/hgtrl01.baf~

  // moves LOCALS var set to local script instead of ar4500
  EXTEND_TOP ~keld25.bcs~ ~bg2fixpack/baf/keld25.baf~

  // sarevok soundset fixes
  EXTEND_BOTTOM ~sarev25.bcs~ ~bg2fixpack/baf/sarev25.baf~

  // Killing unrelated baatezu outside Ka'rashur's room should not turn him and his cohort in Watcher's Keep hostile (see also ar3005.are, ar3006.are, ar3009.are and ar6012.are) (Wisp)
  COPY_EXISTING yssumm2.bcs override
    DECOMPILE_BCS_TO_BAF
      REPLACE_TEXTUALLY CASE_INSENSITIVE EXACT_MATCH ~"gorbat2"~ ~"deriny01"~
    COMPILE_BAF_TO_BCS

END

/////                                                  \\\\\
///// area fixes                                       \\\\\
/////                                                  \\\\\

// adds new entrance points to wmp areas that don't have one already (second half of wmp fixes)
COPY_EXISTING ~ar1700.are~ ~override~
              ~ar1800.are~ ~override~
              ~ar2500.are~ ~override~
              ~ar2600.are~ ~override~
  READ_LONG 0x54 "actor_off"
  READ_LONG 0x5c "info_off"
  READ_LONG 0x60 "spawn_off"
  READ_LONG 0x68 "ent_off"
  READ_LONG 0x6c "ent_num"
  READ_LONG 0x70 "cont_off"
  READ_LONG 0x78 "item_off"
  READ_LONG 0x7c "vert_off"
  READ_LONG 0x84 "amb_off"
  READ_LONG 0x88 "var_off"
  READ_LONG 0xa0 "bmp_off"
  READ_LONG 0xa8 "door_off"
  READ_LONG 0xb0 "anim_off"
  READ_LONG 0xb8 "tiled_off"
  READ_LONG 0xbc "song_off"
  READ_LONG 0xc0 "rest_off"
  READ_LONG 0xc4 "note_off"
  PATCH_IF ("ar1700" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) BEGIN
    SET "x_coord" = 3375
    SET "y_coord" = 142
  END ELSE
  PATCH_IF ("ar1800" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) BEGIN
    SET "x_coord" = 1325
    SET "y_coord" = 56
  END ELSE
  PATCH_IF ("ar2500" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) BEGIN
    SET "x_coord" = 404
    SET "y_coord" = 125
  END ELSE
  PATCH_IF ("ar2600" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) BEGIN
    SET "x_coord" = 3856
    SET "y_coord" = 115
  END
  WRITE_LONG 0x6c ("%ent_num%" + 1)
  INSERT_BYTES "%ent_off%" 0x68
    WRITE_ASCII "%ent_off%" ~CDExit~ // entrance name
    WRITE_SHORT ("%ent_off%" + 0x20) "%x_coord%"
    WRITE_SHORT ("%ent_off%" + 0x22) "%y_coord%"
  PATCH_IF NOT ("%actor_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0x54 ("%actor_off%" + 0x68)
  END
  PATCH_IF NOT ("%info_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0x5c ("info_off" + 0x68)
  END
  PATCH_IF NOT ("%spawn_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0x60 ("spawn_off" + 0x68)
  END
  PATCH_IF NOT ("%cont_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0x70 ("cont_off" + 0x68)
  END
  PATCH_IF NOT ("%item_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0x78 ("item_off" + 0x68)
  END
  PATCH_IF NOT ("%vert_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0x7c ("vert_off" + 0x68)
  END
  PATCH_IF NOT ("%amb_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0x84 ("amb_off" + 0x68)
  END
  PATCH_IF NOT ("%var_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0x88 ("var_off" + 0x68)
  END
  PATCH_IF NOT ("%bmp_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0xa0 ("bmp_off" + 0x68)
  END
  PATCH_IF NOT ("%door_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0xa8 ("door_off" + 0x68)
  END
  PATCH_IF NOT ("%anim_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0xb0 ("anim_off" + 0x68)
  END
  PATCH_IF NOT ("%tiled_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0xb8 ("tiled_off" + 0x68)
  END
  PATCH_IF NOT ("%song_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0xbc ("song_off" + 0x68)
  END
  PATCH_IF NOT ("%rest_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0xc0 ("rest_off" + 0x68)
  END
  PATCH_IF NOT ("%note_off%" < "%ent_off%") BEGIN
    WRITE_LONG 0xc4 ("note_off" + 0x68)
  END
  BUT_ONLY_IF_IT_CHANGES

// some areas have scripts that are not assigned to them
COPY_EXISTING ~ar0321.are~ ~override~
              ~ar0323.are~ ~override~
              ~ar0324.are~ ~override~
              ~ar0327.are~ ~override~
              ~ar0401.are~ ~override~
              ~ar1005.are~ ~override~
              ~ar1009.are~ ~override~ // has wrong script assigned; could cause cutscene hangs
              ~ar1904.are~ ~override~
              ~ar5004.are~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x11b) THEN BEGIN // protects against invalid files
    READ_ASCII 0x94 "script"
    PATCH_IF ("" STRING_COMPARE_CASE "%script%" = 0) BEGIN
      WRITE_EVALUATED_ASCII 0x94 ~%SOURCE_RES%~
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// adds outdoor flag
COPY_EXISTING ~ar0041.are~ ~override~
              ~ar0042.are~ ~override~
              ~ar0044.are~ ~override~
              ~ar0045.are~ ~override~
              ~ar1607.are~ ~override~
  READ_BYTE  0x48 "flags"
  WRITE_BYTE 0x48 ("%flags%" BOR 0b00000001)
  BUT_ONLY_IF_IT_CHANGES

// removes outdoor flag
COPY_EXISTING ~ar0321.are~ ~override~
              ~ar0322.are~ ~override~
              ~ar0323.are~ ~override~
  READ_BYTE  0x48 "flags"
  WRITE_BYTE 0x48 ("%flags%" BAND 0b11111110)
  BUT_ONLY_IF_IT_CHANGES

// removes city flag
COPY_EXISTING ~ar0303.are~ ~override~
              ~ar0305.are~ ~override~
              ~ar0307.are~ ~override~
              ~ar0308.are~ ~override~
              ~ar0309.are~ ~override~
              ~ar0311.are~ ~override~
              ~ar0312.are~ ~override~
              ~ar0315.are~ ~override~
              ~ar0316.are~ ~override~
              ~ar0317.are~ ~override~
              ~ar0406.are~ ~override~ //Copper Coronet
              ~ar0501.are~ ~override~
              ~ar0504.are~ ~override~
              ~ar0505.are~ ~override~
              ~ar0506.are~ ~override~
              ~ar0507.are~ ~override~
              ~ar0508.are~ ~override~
//              ~ar0509.are~ ~override~ //Five Flagons, ground floor
//              ~ar0510.are~ ~override~ //Five Flagons, theater
//              ~ar0511.are~ ~override~ //Five Flagons, second floor
//              ~ar0512.are~ ~override~
              ~ar0513.are~ ~override~ //Calbor's Inn, first floor
              ~ar0514.are~ ~override~ //Calbor's Inn, second floor
              ~ar0515.are~ ~override~ //Calbor's Inn, third floor
//              ~ar0522.are~ ~override~ //Five Flagons, ground floor (stronghold)
//              ~ar0523.are~ ~override~ //Five Flagons, theater (stronghold)
              ~ar0706.are~ ~override~
              ~ar0901.are~ ~override~ //Temple District, Helm temple
              ~ar0902.are~ ~override~ //Temple District, Lathander temple
              ~ar0904.are~ ~override~ //Temple District, Talos temple
              ~ar0905.are~ ~override~ //Temple District, Pimlico's Estate
              ~ar0906.are~ ~override~ //Temple District, guarded compound ground floor
              ~ar0907.are~ ~override~ //Temple District, guarded compound second floor
              ~ar5507.are~ ~override~ //Saradush, basement entrance to Gromnir's castle
  PATCH_IF (SOURCE_SIZE > 0x11b) THEN BEGIN // protects against invalid files
    READ_BYTE  0x48 "flags"
    WRITE_BYTE 0x48 ("%flags%" BAND 0b11110111)
  END
  BUT_ONLY_IF_IT_CHANGES

// adds dungeon flag
COPY_EXISTING ~ar0310.are~ ~override~
              ~ar0331.are~ ~override~
              ~ar0418.are~ ~override~
              ~ar0521.are~ ~override~
              ~ar0526.are~ ~override~
              ~ar0601.are~ ~override~
              ~ar0606.are~ ~override~
              ~ar0804.are~ ~override~
              ~ar1106.are~ ~override~
              ~ar1203.are~ ~override~
              ~ar1402.are~ ~override~
              ~ar1501.are~ ~override~
              ~ar1608.are~ ~override~
              ~ar1610.are~ ~override~
              ~ar2901.are~ ~override~
              ~ar2902.are~ ~override~
              ~ar2903.are~ ~override~
              ~ar2905.are~ ~override~
  READ_BYTE  0x48 "flags"
  WRITE_BYTE 0x48 ("%flags%" BOR 0b00100000)
  BUT_ONLY_IF_IT_CHANGES

// removes dungeon flag
COPY_EXISTING ~ar1101.are~ ~override~
              ~ar2603.are~ ~override~
  READ_BYTE  0x48 "flags"
  WRITE_BYTE 0x48 ("%flags%" BAND 0b11011111)
  BUT_ONLY_IF_IT_CHANGES

// adds 'can rest' flag
COPY_EXISTING ~ar0522.are~ ~override~ // five flagons theater, stronghold version
              ~ar0905.are~ ~override~ // pimlico's estate
              ~ar0906.are~ ~override~ // guarded compound ground floor
              ~ar0907.are~ ~override~ // guarded compound second floor
  READ_BYTE  0x48 "flags"
  WRITE_BYTE 0x48 ("%flags%" BOR 0b10000000)
  BUT_ONLY_IF_IT_CHANGES

// transitions which need 'party required' flags
COPY_EXISTING ~ar0300.are~ ~override~
              ~ar0400.are~ ~override~
              ~ar0415.are~ ~override~
              ~ar0500.are~ ~override~
              ~ar0504.are~ ~override~
              ~ar0505.are~ ~override~
              ~ar2000.are~ ~override~
              ~ar2207.are~ ~override~
              ~ar2600.are~ ~override~
              ~ar2902.are~ ~override~
  READ_SHORT 0x5A "info_num"
  READ_LONG  0x5C "info_off"
  FOR (index = 0 ; index < info_num ; index = index + 1) BEGIN
    READ_ASCII ("%info_off%" + 0x38 + (0xC4 * "%index%")) "area"
    PATCH_IF ((("ar0300" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0328" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0400" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0402" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0415" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0300" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0500" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0505" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0504" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0500" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0505" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0500" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2000" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2002" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2207" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2200" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2600" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2603" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2902" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2900" STRING_COMPARE_CASE "%area%" = 0))) BEGIN
      READ_BYTE  ("%info_off%" + 0x60 + (0xC4 * "%index%")) "flags"
      WRITE_BYTE ("%info_off%" + 0x60 + (0xC4 * "%index%")) ("%flags%" BOR 0b00000100)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// transitions which need 'can not be passed by NPC' flags
COPY_EXISTING ~ar0015.are~ ~override~
              ~ar0021.are~ ~override~
              ~ar0022.are~ ~override~
              ~ar0082.are~ ~override~
              ~ar0300.are~ ~override~
              ~ar0305.are~ ~override~
              ~ar0306.are~ ~override~
              ~ar0307.are~ ~override~
              ~ar0308.are~ ~override~
              ~ar0400.are~ ~override~
              ~ar0407.are~ ~override~
              ~ar0410.are~ ~override~
              ~ar0413.are~ ~override~
              ~ar0414.are~ ~override~
              ~ar0415.are~ ~override~
              ~ar0601.are~ ~override~
              ~ar0605.are~ ~override~
              ~ar0800.are~ ~override~
              ~ar0801.are~ ~override~
              ~ar1100.are~ ~override~
              ~ar1106.are~ ~override~
              ~ar1200.are~ ~override~
              ~ar1202.are~ ~override~
              ~ar1300.are~ ~override~
              ~ar1302.are~ ~override~
              ~ar1400.are~ ~override~
              ~ar1512.are~ ~override~
              ~ar1514.are~ ~override~
              ~ar1515.are~ ~override~
              ~ar1900.are~ ~override~
              ~ar2000.are~ ~override~
              ~ar2008.are~ ~override~
              ~ar2200.are~ ~override~
              ~ar2206.are~ ~override~
              ~ar2207.are~ ~override~
              ~ar2210.are~ ~override~
              ~ar2600.are~ ~override~
              ~ar2800.are~ ~override~
              ~ar5000.are~ ~override~
              ~ar5001.are~ ~override~
              ~ar5007.are~ ~override~
              ~ar5013.are~ ~override~
              ~ar5015.are~ ~override~
              ~ar5200.are~ ~override~
              ~ar5503.are~ ~override~
              ~ar5504.are~ ~override~
              ~ar5507.are~ ~override~
              ~ar6101.are~ ~override~
              ~ar6107.are~ ~override~
  READ_SHORT 0x5A "info_num" ELSE 0
  READ_LONG  0x5C "info_off" ELSE 0
  FOR (index = 0 ; index < info_num ; index = index + 1) BEGIN
    READ_ASCII ("%info_off%" + 0x38 + (0xC4 * "%index%")) "area"
    PATCH_IF ((("ar0015" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0018" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0021" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0020" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0021" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0082" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0022" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0021" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0082" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0021" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0300" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0301" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0300" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0302" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0300" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0303" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0300" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0304" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0300" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0308" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0300" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0309" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0305" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0300" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0306" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0300" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0307" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0300" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0308" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0300" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0308" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0309" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0400" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0311" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0407" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0300" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0410" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0411" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0413" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0412" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0414" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0411" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0415" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0300" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0601" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0602" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0605" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0606" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0800" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0801" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0801" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0800" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar0801" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar0802" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1100" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1104" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1106" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1100" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1200" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1201" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1202" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1201" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1300" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1302" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1302" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1300" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1400" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1401" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1400" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1402" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1400" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1403" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1512" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1513" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1512" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1514" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1514" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1507" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1515" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1500" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar1900" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar1902" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2000" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2008" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2000" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2013" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2008" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2000" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2200" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2206" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2200" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2207" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2200" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2210" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2206" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2200" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2207" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2200" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2210" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2200" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2600" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2603" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar2800" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar2807" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar5000" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar5002" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar5001" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar5000" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar5001" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar5002" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar5007" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar5006" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar5013" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar5000" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar5015" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar5016" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar5200" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar5201" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar5503" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar5500" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar5504" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar5500" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar5507" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar5500" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar6101" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar6100" STRING_COMPARE_CASE "%area%" = 0)) OR
              (("ar6107" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) AND ("ar6108" STRING_COMPARE_CASE "%area%" = 0))) BEGIN
      READ_BYTE  ("%info_off%" + 0x61 + (0xC4 * "%index%")) "flags"
      WRITE_BYTE ("%info_off%" + 0x61 + (0xC4 * "%index%")) ("%flags%" BOR 0b00000010)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect orientation when entering areas
COPY_EXISTING ~ar0201.are~ ~override~ // ghoul village, UE quest
              ~ar0202.are~ ~override~ // UE quest, cult hideout
              ~ar0204.are~ ~override~ // UE quest, temple city
              ~ar0300.are~ ~override~ // docks
              ~ar0302.are~ ~override~ // mae'var's guild entrance
              ~ar0304.are~ ~override~ // mae'var's guild third floor
              ~ar0312.are~ ~override~ // sleeping room
              ~ar0322.are~ ~override~ // mae'var's guild entrance (pc controlled)
              ~ar0324.are~ ~override~ // mae'var's guild third floor (pc controlled)
              ~ar0400.are~ ~override~ // slums
              ~ar0402.are~ ~override~ // jansen ground floor
              ~ar0404.are~ ~override~ // sewers under CC
              ~ar0405.are~ ~override~ // slaver's ship
              ~ar0406.are~ ~override~ // copper coronet
              ~ar0409.are~ ~override~ // ployer's home
              ~ar0500.are~ ~override~ // bridge district
              ~ar0509.are~ ~override~ // first floor five flagons
              ~ar0513.are~ ~override~ // calbor's inn
              ~ar0531.are~ ~override~ // commoner house
              ~ar0700.are~ ~override~ // promenade
              ~ar0703.are~ ~override~ // temple of ilmater (promenade)
              ~ar0707.are~ ~override~ // enge's shop
              ~ar0801.are~ ~override~ // bodhi's area
              ~ar0903.are~ ~override~ // norh
              ~ar0905.are~ ~override~ // pimlico's home
              ~ar1001.are~ ~override~ // delryn's home
              ~ar1003.are~ ~override~ // keldorn's home
              ~ar1004.are~ ~override~ // deril's home
              ~ar1005.are~ ~override~ // prison
              ~ar1009.are~ ~override~ // roenall's home
              ~ar1200.are~ ~override~ // windspear hills
              ~ar1300.are~ ~override~ // de'arnise keep exterior
              ~ar1304.are~ ~override~ // de'arnise keep exterior (pc)
              ~ar2101.are~ ~override~ // underdark beholder lair
  READ_LONG 0x68 "enter_off"
  READ_LONG 0x6c "enter_num"
  FOR (index = 0 ; index < enter_num ; index = index + 1) BEGIN
    READ_ASCII ("%enter_off%" +        ("%index%" * 0x68)) "name"
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0709" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0700" = 0))    // den of seven vales to promenade
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 1 // south-southwest
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0506a" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0500" = 0))    // noble home to bridge
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 2 // southwest
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0402" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0400" = 0))    // jansen home to slums
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 5 // west-northwest
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0303" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0304" = 0))  OR // 2nd to 3rd floor, mae'var
               (("%name%" STRING_COMPARE_CASE "exit0323" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0324" = 0))  OR // 2nd to 3rd floor, mae'var (pc)
               (("%name%" STRING_COMPARE_CASE "exit0405" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0404" = 0))  OR // slaver ship to sewers
               (("%name%" STRING_COMPARE_CASE "exit0400" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0409" = 0))  OR // slums to ployer's home
               (("%name%" STRING_COMPARE_CASE "exit0705" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0500" = 0))  OR // mekrath's lair to bridge
               (("%name%" STRING_COMPARE_CASE "exit0500" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0509" = 0))  OR // bridge to five flagons
               (("%name%" STRING_COMPARE_CASE "exit0500" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0531" = 0))  OR // bridge to commoner home
               (("%name%" STRING_COMPARE_CASE "exit0700" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0707" = 0))  OR // promenade to enge's shop
               (("%name%" STRING_COMPARE_CASE "exit0900" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0903" = 0))  OR // temple district to norh
               (("%name%" STRING_COMPARE_CASE "exit0900b" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0903" = 0)) OR // temple district to norh
               (("%name%" STRING_COMPARE_CASE "exit0900" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0905" = 0))  OR // temple district to pimlico's
               (("%name%" STRING_COMPARE_CASE "exit1000" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar1001" = 0))  OR // gov't to delryn's home
               (("%name%" STRING_COMPARE_CASE "exit1000b" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar1001" = 0)) OR // gov't to delryn's home
               (("%name%" STRING_COMPARE_CASE "exit1000" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar1003" = 0))  OR // gov't to keldorn's home
               (("%name%" STRING_COMPARE_CASE "exit1000" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar1004" = 0))  OR // gov't to deril's home
               (("%name%" STRING_COMPARE_CASE "exit1000" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar1005" = 0))  OR // gov't to prison
               (("%name%" STRING_COMPARE_CASE "exit1000" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar1009" = 0))  OR // gov't to roenall's home
               (("%name%" STRING_COMPARE_CASE "exitse" = 0)   AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar1300" = 0))  OR // de'arnise keep from wmp
               (("%name%" STRING_COMPARE_CASE "exitse" = 0)   AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar1304" = 0))     // de'arnise keep (pc) from wmp
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 6 // northwest
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0514a" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0500" = 0)) OR // inn at bridge district to bridge
               (("%name%" STRING_COMPARE_CASE "exit0514b" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0500" = 0)) OR // inn at bridge district to bridge
               (("%name%" STRING_COMPARE_CASE "exit800d" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0801" = 0))     // graveyard to bohdi's lair
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 7 // north-northwest
      SET "index" = "%enter_num%" // kills loop
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "Exit2100" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar2101" = 0))    // underdark to beholder lair
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 8 // north
      SET "index" = "%enter_num%" // kills loop
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0202" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0204" = 0))    // graveyard to bohdi's lair
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 9 // north-northeast
      SET "index" = "%enter_num%" // kills loop
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0311" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0312" = 0)) OR // gaelan downstairs to upstairs
               (("%name%" STRING_COMPARE_CASE "exit0400" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0405" = 0)) OR // slums to slaver ship
               (("%name%" STRING_COMPARE_CASE "exit0400" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0406" = 0)) OR // slums to CC
               (("%name%" STRING_COMPARE_CASE "exi0400b" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0406" = 0)) OR // slums to CC
               (("%name%" STRING_COMPARE_CASE "exit0700" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0703" = 0)) OR // ilmater temple from promenade
               (("%name%" STRING_COMPARE_CASE "exit0900" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0903" = 0)) OR // norh from temple district
               (("%name%" STRING_COMPARE_CASE "exit1000b" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar1005" = 0))   // prison from gov't district
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 10 // northeast
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0301" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0302" = 0)) OR // basement to entrance, mae'var
               (("%name%" STRING_COMPARE_CASE "exi00321" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0322" = 0)) OR // basement to entrance, mae'var (pc)
               (("%name%" STRING_COMPARE_CASE "exitw" = 0)    AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar1200" = 0))    // windspear hills from wmp
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 12 // east
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0308" = 0)  AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0300" = 0))   // harper hq to docks
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 13 // east-southeast
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0405" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0400" = 0))  OR // slaver ship to slums
               (("%name%" STRING_COMPARE_CASE "exit0406" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0400" = 0))  OR // CC to slums
               (("%name%" STRING_COMPARE_CASE "exi0406b" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0400" = 0))  OR // CC to slums
               (("%name%" STRING_COMPARE_CASE "exit0406" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0404" = 0))  OR // CC to sewers
               (("%name%" STRING_COMPARE_CASE "exit0506b" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0500" = 0)) OR // noble house to bridge dist
               (("%name%" STRING_COMPARE_CASE "exit0513" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0500" = 0))  OR // calbor's inn to bridge dist
               (("%name%" STRING_COMPARE_CASE "exit0515" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0500" = 0))  OR // inn to bridge dist
               (("%name%" STRING_COMPARE_CASE "exit0706" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0700" = 0))  OR // fletcher to promenade
               (("%name%" STRING_COMPARE_CASE "exit0707" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0700" = 0))  OR // enge's shop to promenade
               (("%name%" STRING_COMPARE_CASE "exit0708" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0700" = 0))  OR // cernd's home to promenade
               (("%name%" STRING_COMPARE_CASE "exit0710" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0700" = 0))    // fennecia's home to promenade
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 14 // southeast
    END ELSE
    PATCH_IF (
               (("%name%" STRING_COMPARE_CASE "exit0206a" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0201" = 0)) OR   // ghouls under temple from halfling village
               (("%name%" STRING_COMPARE_CASE "exit0206b" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0201" = 0)) OR   // ghouls under temple from halfling village
               (("%name%" STRING_COMPARE_CASE "exit0202" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0205" = 0))  OR   // beholder hideout from cult hideout (UE)
               (("%name%" STRING_COMPARE_CASE "exit0514" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0513" = 0))  OR   // calbor's inn, second floor to first
               (("%name%" STRING_COMPARE_CASE "exit0704" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "ar0700" = 0))       // mithrest to promenade
             ) BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 15 // southeast
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes several areas with detected traps
COPY_EXISTING ~AR0062.ARE~ ~override~
              ~AR0063.ARE~ ~override~
              ~AR0064.ARE~ ~override~
              ~AR0065.ARE~ ~override~
              ~AR0328.ARE~ ~override~
              ~AR0406.ARE~ ~override~
              ~AR0413.ARE~ ~override~
              ~AR0801.ARE~ ~override~
              ~AR0803.ARE~ ~override~
              ~AR0808.ARE~ ~override~
              ~AR1006.ARE~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  WHILE ("%cont_num%" > 0) BEGIN
    SET "cont_num" = ("%cont_num%" - 1)
    READ_SHORT ("%cont_off%" + 0x30 + ("%cont_num%" * 0xc0)) "trapped"
    READ_SHORT ("%cont_off%" + 0x32 + ("%cont_num%" * 0xc0)) "detected"
    PATCH_IF (("%trapped%" = 1) AND ("%detected%" = 1)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x32 + ("%cont_num%" * 0xc0)) 0
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// makes two chests openable
COPY_EXISTING ~ar0327.are~ ~override~
              ~ar1006.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  WHILE ("%cont_num%" > 0) BEGIN
    SET "cont_num" = ("%cont_num%" - 1)
    READ_SHORT ("%cont_off%" + 0x26 + ("%cont_num%" * 0xc0)) "diff"
    READ_SHORT ("%cont_off%" + 0x28 + ("%cont_num%" * 0xc0)) "locked"
    READ_ASCII ("%cont_off%" + 0x78 + ("%cont_num%" * 0xc0)) "key"
    PATCH_IF (("%diff%" > 90) AND ("%locked%" BOR 0b11111110 = 0b11111111) AND ("%key%" STRING_COMPARE_CASE "" = 0)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x26 + ("%cont_num%" * 0xc0)) 90
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes traps in tut area
COPY_EXISTING ~AR0016.ARE~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  WHILE ("%cont_num%" > 0) BEGIN
    SET "cont_num" = ("%cont_num%" - 1)
    READ_SHORT ("%cont_off%" + 0x2C + ("%cont_num%" * 0xc0)) "diff"
    READ_SHORT ("%cont_off%" + 0x30 + ("%cont_num%" * 0xc0)) "trapped"
    PATCH_IF (("%diff%" > 99) AND ("%trapped%" = 1)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x2C + ("%cont_num%" * 0xc0)) 0
      WRITE_SHORT ("%cont_off%" + 0x30 + ("%cont_num%" * 0xc0)) 0
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon
COPY_EXISTING ~ar0201.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 1310) AND ("%y_coord%" = 1611)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 10 // body
      SET "index" = "%cont_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// changes sewer key to be used up in sewer door, moves container slightly to avoid collisions with nearby actors
COPY_EXISTING ~AR0202.ARE~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  READ_LONG  0xa4 "door_num"
  READ_LONG  0xa8 "door_off"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 1993) AND ("%y_coord%" = 2236)) BEGIN // move to avoid actor collision
      WRITE_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) 2037
      WRITE_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) 2242
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 6     // correct icon to shelf
      SET "index" = "%cont_num%" // kills loop
    END
  END
  WHILE ("%door_num%" > 0) BEGIN
    SET "door_num" = ("%door_num%" - 1)
    READ_ASCII ("%door_off%" +        ("%door_num%" * 0xc8)) "doorname"
    READ_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) "usekey"
    PATCH_IF (("%doorname%" STRING_COMPARE_CASE "SWERDOOR" = 0) AND ("%usekey%" BOR 0b11111011 = 0b11111011)) BEGIN
      WRITE_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) ("%usekey%" BOR 0b00000100) // sets uses key bit
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// moves container slightly to avoid collisions with nearby actors, container icon fixes
COPY_EXISTING ~ar0204.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 1260) AND ("%y_coord%" = 2623)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 8 // nonvisible
    END ELSE
    PATCH_IF (("%x_coord%" = 3755) AND ("%y_coord%" = 2522)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) 3738
      WRITE_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) 2515
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 8 // nonvisible
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon
COPY_EXISTING ~ar0206.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 577) AND ("%y_coord%" = 522)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 8 // nonvisible
      SET "index" = "%cont_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// animation glitches due to bad layering/flags
COPY_EXISTING ~ar0307.are~ ~override~
  READ_LONG 0xac "anim_num"
  READ_LONG 0xb0 "anim_off"
  FOR (index = 0 ; index < anim_num ; index = index + 1) BEGIN
    READ_ASCII ("%anim_off%" + ("%index%" * 0x4c)) "anim_name"
    PATCH_IF ("%anim_name%" STRING_COMPARE_CASE "am307tt1" = 0) BEGIN // spiky wheel in torturer's room
      READ_BYTE   ("%anim_off%" + 0x35 + ("%index%" * 0x4c)) "flags"
      WRITE_BYTE  ("%anim_off%" + 0x35 + ("%index%" * 0x4c)) ("%flags%" BOR 0b00000001) // adds draw as background flag
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0xff7e // height
    END ELSE
    PATCH_IF ("%anim_name%" STRING_COMPARE_CASE "am307ur1" = 0) BEGIN // spiky wheel you run across
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0 // height
    END ELSE
    PATCH_IF ("%anim_name%" STRING_COMPARE_CASE "am307ur3" = 0) BEGIN // another spiky wheel you run across
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0xffcc // height
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// animation glitches due to bad layering
COPY_EXISTING ~ar0312.are~ ~override~
              ~ar0335.are~ ~override~
  READ_LONG 0xac "anim_num"
  READ_LONG 0xb0 "anim_off"
  FOR (index = 0 ; index < anim_num ; index = index + 1) BEGIN
    READ_SHORT ("%anim_off%" + 0x20 + ("%index%" * 0x4c)) "x_coord"
    READ_SHORT ("%anim_off%" + 0x22 + ("%index%" * 0x4c)) "y_coord"
    PATCH_IF ((("%x_coord%" = 180) AND ("%y_coord%" = 304)) OR
              (("%x_coord%" = 170) AND ("%y_coord%" = 310)) OR
              (("%x_coord%" = 552) AND ("%y_coord%" = 107)) OR
              (("%x_coord%" = 573) AND ("%y_coord%" = 114)))  BEGIN // sconce
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0x31 // height
    END ELSE
    PATCH_IF (("%x_coord%" = 438) AND ("%y_coord%" = 121)) BEGIN // sconce
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0x34 // height
    END ELSE
    PATCH_IF (("%x_coord%" = 670) AND ("%y_coord%" = 188)) BEGIN // sconce
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0x2e // height
    END ELSE
    PATCH_IF (("%x_coord%" = 426) AND ("%y_coord%" = 129)) BEGIN // sconce
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0x3a // height
    END ELSE
    PATCH_IF (("%x_coord%" = 680) AND ("%y_coord%" = 194)) BEGIN // sconce
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0x38 // height
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon
COPY_EXISTING ~ar0312.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 492) AND ("%y_coord%" = 275)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 2 // chest
      SET "index" = "%cont_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// animation glitches due to bad flags
COPY_EXISTING ~ar0313.are~ ~override~
              ~ar0529.are~ ~override~
              ~ar0713.are~ ~override~
  READ_LONG 0xac "anim_num"
  READ_LONG 0xb0 "anim_off"
  FOR (index = 0 ; index < anim_num ; index = index + 1) BEGIN
    READ_ASCII ("%anim_off%" + ("%index%" * 0x4c)) "anim_name"
    PATCH_IF ("%anim_name%" STRING_COMPARE_CASE "am003xa" = 0) BEGIN // oven
      WRITE_SHORT ("%anim_off%" + 0x20 + ("%index%" * 0x4c)) 334 // x coord, only wrong in ar0713
      WRITE_SHORT ("%anim_off%" + 0x22 + ("%index%" * 0x4c)) 377 // y coord, only wrong in ar0713
      READ_BYTE   ("%anim_off%" + 0x34 + ("%index%" * 0x4c)) "flags"
      WRITE_BYTE  ("%anim_off%" + 0x34 + ("%index%" * 0x4c)) ("%flags%" BOR  0b01000000) // adds not covered by wall flag
      READ_BYTE   ("%anim_off%" + 0x35 + ("%index%" * 0x4c)) "flags"
      WRITE_BYTE  ("%anim_off%" + 0x35 + ("%index%" * 0x4c)) ("%flags%" BOR 0b00000001) // adds draw as background flag
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon
COPY_EXISTING ~ar0319.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 477) AND ("%y_coord%" = 357)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 5 // table
      SET "index" = "%cont_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// makes doors actually require keys that they are listed as requiring
COPY_EXISTING ~AR0329.ARE~ ~override~
  READ_LONG 0xa4 "door_num"
  READ_LONG 0xa8 "door_off"
  WHILE ("%door_num%" > 0) BEGIN
    SET "door_num" = ("%door_num%" - 1)
    READ_ASCII ("%door_off%" +        ("%door_num%" * 0xc8)) "doorname"
    READ_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) "usekey"
    PATCH_IF ((("%doorname%" STRING_COMPARE_CASE "DOOR07" = 0) OR ("%doorname%" STRING_COMPARE_CASE "DOOR08" = 0))
                AND ("%usekey%" BOR 0b11111011 = 0b11111011)) BEGIN
      WRITE_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) ("%usekey%" BOR 0b00000100) // sets uses key bit
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// ar0333.are entry/exit points are reversed; undoing the Escher architecture
COPY_EXISTING ~ar0333.are~ ~override~
  READ_SHORT 0x5a "info_num"
  READ_LONG  0x5c "info_off"
  READ_LONG 0x68 "enter_off"
  READ_LONG 0x6c "enter_num"
  FOR (index = 0 ; index < info_num ; index = index + 1) BEGIN // swap transition (exit) points
    READ_ASCII ("%info_off%" + 0x38 + (0xc4 * "%index%")) "area"
    PATCH_IF ("ar0300" STRING_COMPARE_CASE "%area%" = 0) BEGIN
      WRITE_ASCII ("%info_off%" +        (0xc4 * "%index%")) "Tran0332" #32 // transition point name
      WRITE_ASCII ("%info_off%" + 0x38 + (0xc4 * "%index%")) "ar0332" #8    // destination area
      WRITE_ASCII ("%info_off%" + 0x40 + (0xc4 * "%index%")) "Exit0333" #8  //  exit point
    END ELSE
    PATCH_IF ("ar0332" STRING_COMPARE_CASE "%area%" = 0) BEGIN
      WRITE_ASCII ("%info_off%" +        (0xc4 * "%index%")) "Tran0300" #32 // transition point name
      WRITE_ASCII ("%info_off%" + 0x38 + (0xc4 * "%index%")) "ar0300" #8    // destination area
      WRITE_ASCII ("%info_off%" + 0x40 + (0xc4 * "%index%")) "Exit0333" #8  //  exit point
    END
  END
  FOR (index = 0 ; index < enter_num ; index = index + 1) BEGIN // swap entry points
    READ_ASCII ("%enter_off%" +        ("%index%" * 0x68)) "name"
    PATCH_IF ("%name%" STRING_COMPARE_CASE "Exit0300" = 0) BEGIN
      WRITE_ASCII ("%enter_off%" +        ("%index%" * 0x68)) "Exit0332"
    END ELSE
    PATCH_IF ("%name%" STRING_COMPARE_CASE "Exit0332" = 0) BEGIN
      WRITE_ASCII ("%enter_off%" +        ("%index%" * 0x68)) "Exit0300"
    END 
  END
  BUT_ONLY_IF_IT_CHANGES

// animation glitches due to bad layering
COPY_EXISTING ~ar0334.are~ ~override~
              ~ar0406.are~ ~override~
              ~ar0706.are~ ~override~
              ~ar1603.are~ ~override~
              ~ar2001.are~ ~override~
  READ_LONG 0xac "anim_num"
  READ_LONG 0xb0 "anim_off"
  FOR (index = 0 ; index < anim_num ; index = index + 1) BEGIN
    READ_ASCII ("%anim_off%" + ("%index%" * 0x4c)) "anim_name"
    PATCH_IF ("%anim_name%" STRING_COMPARE_CASE "fpit1s" = 0) BEGIN // forges
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0 // height
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// moves container slightly to avoid collisions with nearby actors, container icon fixes
COPY_EXISTING ~ar0400.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    SET "cont_num" = ("%cont_num%" - 1)
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 1000) AND ("%y_coord%" = 835)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) 1000
      WRITE_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) 840
    END ELSE
    PATCH_IF (("%x_coord%" = 2953) AND ("%y_coord%" = 2102)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 5 // table
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// areas with identified items in containers
COPY_EXISTING ~ar0405.are~ ~override~
              ~ar0602.are~ ~override~
              ~ar1101.are~ ~override~
  READ_SHORT 0x76 "item_num"
  READ_LONG  0x78 "item_off"
  FOR (index = 0 ; index < item_num ; index = index + 1) BEGIN
    READ_ASCII ("%item_off%" +        (0x14 * "%index%")) "item"
    READ_BYTE  ("%item_off%" + 0x10 + (0x14 * "%index%")) "flag"
    PATCH_IF (("%item%" STRING_COMPARE_CASE "arow02" = 0) OR
              ("%item%" STRING_COMPARE_CASE "arow08" = 0) OR
              ("%item%" STRING_COMPARE_CASE "sper02" = 0) OR
              ("%item%" STRING_COMPARE_CASE "sw1h05" = 0)) BEGIN
      WRITE_BYTE  ("%item_off%" + 0x10 + (0x14 * "%index%")) ("%flag%" BAND 0b11111110)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon
COPY_EXISTING ~ar0406.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 1412) AND ("%y_coord%" = 1558)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 2 // chest
      SET "index" = "%cont_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// trapped container doesn't actually do anything
COPY_EXISTING ~ar0407.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_ASCII ("%cont_off%" +        ("%index%" * 0xc0)) "name"
    PATCH_IF ("%name%" STRING_COMPARE_CASE "Container 2" = 0) BEGIN
      WRITE_ASCII ("%cont_off%" + 0x48 + ("%index%" * 0xc0)) ~ctmm~ #8
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon
COPY_EXISTING ~ar0411.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 2443) AND ("%y_coord%" = 642)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0))  10 // body
      SET "index" = "%cont_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes demon eye animation
COPY_EXISTING ~AR0414.ARE~ ~override~
  READ_LONG 0xac "anim_num"
  READ_LONG 0xb0 "anim_off"
  WHILE ("%anim_num%" > 0) BEGIN
    SET "anim_num" = ("%anim_num%" - 1)
    READ_ASCII ("%anim_off%" +        ("%anim_num%" * 0x4c)) "animname"
    PATCH_IF ("%animname%" STRING_COMPARE_CASE "AM414EY2" = 0) BEGIN
      WRITE_SHORT ("%anim_off%" + 0x22 + ("%anim_num%" * 0x4c)) 2794
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes trap script
COPY_EXISTING ~AR0415.ARE~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  WHILE ("%cont_num%" > 0) BEGIN
    SET "cont_num" = ("%cont_num%" - 1)
    READ_ASCII ("%cont_off%" + 0x48 + ("%cont_num%" * 0xc0)) "script"
    PATCH_IF ("%script%" STRING_COMPARE_CASE "ACT02" = 0) BEGIN
      WRITE_ASCII ("%cont_off%" + 0x48 + ("%cont_num%" * 0xc0)) ~CTALARM~ #8 // correct trap script reference
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes multiple Stanets
COPY_EXISTING ~AR0500.ARE~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  SET "stanets" = 0
  WHILE ("%actor_num%" > 0) BEGIN
    SET "actor_num" = ("%actor_num%" - 1)
    READ_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "BMTOWN4" = 0) BEGIN
      PATCH_IF ("%stanets%" = 0) BEGIN
        SET "stanets" = 1
      END ELSE BEGIN
        WRITE_ASCII ("%actor_off%" +        ("%actor_num%" * 0x110)) ~Commoner~ #32
        WRITE_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) ~BMTOWN2~ #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon
COPY_EXISTING ~ar0501.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 667) AND ("%y_coord%" = 176)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 11 // barrel
      SET "index" = "%cont_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon
COPY_EXISTING ~ar0506.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 550) AND ("%y_coord%" = 172)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 7 // altar
      SET "index" = "%cont_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes portal animation
COPY_EXISTING ~AR0510.ARE~ ~override~
  READ_LONG 0xac "anim_num"
  READ_LONG 0xb0 "anim_off"
  WHILE ("%anim_num%" > 0) BEGIN
    SET "anim_num" = ("%anim_num%" - 1)
    READ_ASCII ("%anim_off%" +        ("%anim_num%" * 0x4c)) "animname"
    PATCH_IF ("%animname%" STRING_COMPARE_CASE "AM0510A" = 0) BEGIN
      WRITE_SHORT ("%anim_off%" + 0x20 + ("%anim_num%" * 0x4c)) 839 // adjusts x coordinate
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// moves container slightly to avoid collisions with nearby actors
COPY_EXISTING ~ar0513.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 908) AND ("%y_coord%" = 385)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) 886
      WRITE_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) 471
      SET "index" = "%cont_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon, makes Neb's trap disarmable
COPY_EXISTING ~ar0529.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    READ_SHORT ("%cont_off%" + 0x2e + ("%index%" * 0xc0)) "removal"
    READ_SHORT ("%cont_off%" + 0x30 + ("%index%" * 0xc0)) "trapped"
    PATCH_IF (("%x_coord%" = 326) AND ("%y_coord%" = 363)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 8 // nonvisible
    END
    PATCH_IF (("%removal%" > 90) AND ("%trapped%" = 1)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x2e + ("%index%" * 0xc0)) 90
      READ_SHORT  ("%cont_off%" + 0x2C + ("%index%" * 0xc0)) "detection"
      PATCH_IF ("%detection%" < 50) BEGIN
        WRITE_SHORT ("%cont_off%" + 0x2C + ("%index%" * 0xc0)) 50
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// ice mephit has wrong script
COPY_EXISTING ~ar0603.are~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  FOR (index = 0 ; index < actor_num ; index = index + 1) BEGIN
    READ_ASCII ("%actor_off%" + 0x80 + ("%index%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "mepice01" = 0) BEGIN // ice mephit
      WRITE_ASCII ("%actor_off%" + 0x50 + ("%index%" * 0x110)) ~waitpc2~ #8 // override script
      SET "index" = "%actor_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// changes guard reference in ar0700 to not be the rubble-guarder type, moves container slightly to avoid collisions with nearby actors
COPY_EXISTING ~AR0700.ARE~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  WHILE ("%actor_num%" > 0) BEGIN
    SET "actor_num" = ("%actor_num%" - 1)
    READ_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "AMNG1" = 0) BEGIN
      WRITE_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) ~AMNG2~ #8
    END
  END
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 3323) AND ("%y_coord%" = 308)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) 3249
      WRITE_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) 300
    END ELSE
    PATCH_IF (("%x_coord%" = 606) AND ("%y_coord%" = 1136)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) 572
      WRITE_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) 1163
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// mind flayer door uses up key
COPY_EXISTING ~AR0701.ARE~ ~override~
  READ_LONG 0xa4 "door_num"
  READ_LONG 0xa8 "door_off"
  WHILE ("%door_num%" > 0) BEGIN
    SET "door_num" = ("%door_num%" - 1)
    READ_ASCII ("%door_off%" +        ("%door_num%" * 0xc8)) "doorname"
    READ_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) "usekey"
    PATCH_IF (("%doorname%" STRING_COMPARE_CASE "Door02" = 0) AND ("%usekey%" BOR 0b11111011 = 0b11111011)) BEGIN
      WRITE_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) ("%usekey%" BOR 0b00000100) // sets uses key bit
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// wrong creature reference in Waukeen Ilmater temple; see soa-dlg.d for changes to wilmat.dlg
COPY_EXISTING ~ar0703.are~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  FOR (index = 0 ; index < actor_num ; index = index + 1) BEGIN
    READ_ASCII ("%actor_off%" + 0x80 + ("%index%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "slilmat" = 0) BEGIN
      WRITE_ASCII ("%actor_off%" + 0x80 + ("%index%" * 0x110)) ~wilmat~ #8
      SET "index" = "%actor_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon
COPY_EXISTING ~ar0705.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 582) AND ("%y_coord%" = 848)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 6 // shelf
      SET "index" = "%cont_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// indoor actor has outdoor script
COPY_EXISTING ~ar0713.are~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  FOR (index = 0 ; index < actor_num ; index = index + 1) BEGIN
    READ_ASCII ("%actor_off%" + 0x80 + ("%index%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "mtown3" = 0) BEGIN
      WRITE_ASCII ("%actor_off%" + 0x50 + ("%index%" * 0x110)) ~runenemy~ #8
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// makes VVMADMAN only exist at night so he won't EscapeArea()
COPY_EXISTING ~AR0900.ARE~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  WHILE ("%actor_num%" > 0) BEGIN
    SET "actor_num" = ("%actor_num%" - 1)
    READ_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "VVMADMAN" = 0) BEGIN
      WRITE_LONG ("%actor_off%" + 0x40 + ("%actor_num%" * 0x110)) 0xfff8001f
    END
  END
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 3066) AND ("%y_coord%" = 1647)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 8 // nonvisible
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// changes Festule's potion to minor healing
COPY_EXISTING ~AR0901.ARE~ ~override~
  READ_SHORT 0x76 "item_num"
  READ_LONG  0x78 "item_off"
  WHILE ("%item_num%" > 0) BEGIN
    SET "item_num" = ("%item_num%" - 1)
    READ_ASCII ("%item_off%" + ("%item_num%" * 0x14)) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "POTN53" = 0) BEGIN
      WRITE_ASCII ("%item_off%" + ("%item_num%" * 0x14)) ~POTN08~ #8
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect container icon
COPY_EXISTING ~ar0902.are~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  FOR (index = 0 ; index < cont_num ; index = index + 1) BEGIN
    READ_SHORT ("%cont_off%" + 0x20 + ("%index%" * 0xc0)) "x_coord"
    READ_SHORT ("%cont_off%" + 0x22 + ("%index%" * 0xc0)) "y_coord"
    PATCH_IF (("%x_coord%" = 1325) AND ("%y_coord%" = 1510)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x24 + ("%index%" * 0xc0)) 8 // nonvisible
      SET "index" = "%cont_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// changes guard references in ar1000 to not be the rubble-guarder type, enables one ambient, fixes multiple gftown02
COPY_EXISTING ~AR1000.ARE~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  READ_SHORT 0x82 "amb_num"
  READ_LONG  0x84 "amb_off"
  WHILE ("%actor_num%" > 0) BEGIN
    SET "actor_num" = ("%actor_num%" - 1)
    READ_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "AMNG1" = 0) BEGIN
      WRITE_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) ~AMNG2~ #8
    END ELSE
    PATCH_IF (("%cre_file%" STRING_COMPARE_CASE "victown1" = 0) OR
              ("%cre_file%" STRING_COMPARE_CASE "victown4" = 0)) BEGIN
      WRITE_LONG ("%actor_off%" + 0x28 + ("%actor_num%" * 0x110)) 9
    END ELSE
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "gftown02" = 0) BEGIN
      READ_SHORT ("%actor_off%" + 0x20 + ("%actor_num%" * 0x110)) "x_coord"
      READ_SHORT ("%actor_off%" + 0x22 + ("%actor_num%" * 0x110)) "y_coord"
      PATCH_IF (("%x_coord%" != 2265) AND ("%y_coord%" != 692)) BEGIN
        WRITE_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) ~gftown01~ #8
      END
    END
  END
  WHILE ("%amb_num%" > 0) BEGIN
    SET "amb_num" = ("%amb_num%" - 1)
    READ_SHORT ("%amb_off%" + 0x20 + ("%amb_num%" * 0xd4)) "x_coord"
    PATCH_IF ("%x_coord%" = 907) BEGIN
      WRITE_LONG ("%amb_off%" + 0x8C + ("%amb_num%" * 0xd4)) 0x001fffc0
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// part of making Ketlaar's guards disappear if Ketlaar is killed
COPY_EXISTING ~AR1002.ARE~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  SET "toggle" = 0
  WHILE ("%actor_num%" > 0) BEGIN
    SET "actor_num" = ("%actor_num%" - 1)
    READ_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "BODYG2" = 0) BEGIN
      WRITE_BYTE ("%actor_off%" + 0x28 + ("%actor_num%" * 0x110)) 9
      PATCH_IF ("%toggle%" = 0) BEGIN
        WRITE_ASCII ("%actor_off%" + ("%actor_num%" * 0x110)) ~MGKETBG1~ #32
        SET "toggle" = 1
      END ELSE BEGIN
        WRITE_ASCII ("%actor_off%" + ("%actor_num%" * 0x110)) ~MGKETBG2~ #32
        SET "toggle" = 0
      END
    END ELSE
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "argrim" = 0) BEGIN
      WRITE_BYTE  ("%actor_off%" + 0x28 + ("%actor_num%" * 0x110)) 9
      WRITE_ASCII ("%actor_off%" +        ("%actor_num%" * 0x110)) ~argrim~ #32
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// forces two doors to use keys and by setting lock difficulties of 100 and setting a bit
COPY_EXISTING ~AR1202.ARE~ ~override~
  READ_LONG 0xa4 "door_num"
  READ_LONG 0xa8 "door_off"
  WHILE ("%door_num%" > 0) BEGIN
    SET "door_num" = ("%door_num%" - 1)
    READ_ASCII ("%door_off%" +        ("%door_num%" * 0xc8)) "doorname"
    PATCH_IF (("%doorname%" STRING_COMPARE_CASE "Door24" = 0) OR
              ("%doorname%" STRING_COMPARE_CASE "Door29" = 0)) BEGIN
      READ_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) "usekey"
      WRITE_BYTE ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) ("%usekey%" BOR 0b00000100) // sets uses key bit
      WRITE_LONG ("%door_off%" + 0x8c + ("%door_num%" * 0xc8)) 100 // lock difficulty
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes bad item reference in Nalia's keep
COPY_EXISTING ~AR1303.ARE~ ~override~
  READ_SHORT 0x76 "item_num"
  READ_LONG  0x78 "item_off"
  WHILE ("%item_num%" > 0) BEGIN
    SET "item_num" = ("%item_num%" - 1)
    READ_ASCII ("%item_off%" + ("%item_num%" * 0x14)) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "" = 0) BEGIN
      WRITE_ASCII ("%item_off%" + ("%item_num%" * 0x14)) ~arow08~ 
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// door from ground floor of stronghold de'Arnise Keep is off, not attached to door
COPY_EXISTING ~ar1306.are~ ~override~
  READ_SHORT 0x5a "info_num"
  READ_LONG  0x5c "info_off"
  READ_LONG  0x7c "vert_off"
  READ_LONG  0xa4 "door_num"
  READ_LONG  0xa8 "door_off"
  FOR (index = 0 ; index < info_num ; index = index + 1) BEGIN
    READ_ASCII ("%info_off%" +        ("%index%" * 0xc4)) "info_name" (9)
    PATCH_IF ("%info_name%" STRING_COMPARE_CASE "Tran1304a" = 0) BEGIN
      // bounding box
      WRITE_SHORT ("%info_off%" + 0x22 + ("%index%" * 0xc4)) 442  // bounding: left
      WRITE_SHORT ("%info_off%" + 0x24 + ("%index%" * 0xc4)) 1799 // bounding: top
      WRITE_SHORT ("%info_off%" + 0x26 + ("%index%" * 0xc4)) 520  // bounding: right
      WRITE_SHORT ("%info_off%" + 0x28 + ("%index%" * 0xc4)) 1935 // bounding: bottom
      // vertices
      READ_SHORT  ("%info_off%" + 0x2c + ("%index%" * 0xc4)) "vert_idx"
      WRITE_SHORT ("%vert_off%" +        (0x04 * "%vert_idx%")) 442
      WRITE_SHORT ("%vert_off%" + 0x02 + (0x04 * "%vert_idx%")) 1799
      WRITE_SHORT ("%vert_off%" + 0x04 + (0x04 * "%vert_idx%")) 442
      WRITE_SHORT ("%vert_off%" + 0x06 + (0x04 * "%vert_idx%")) 1891
      WRITE_SHORT ("%vert_off%" + 0x08 + (0x04 * "%vert_idx%")) 520
      WRITE_SHORT ("%vert_off%" + 0x0a + (0x04 * "%vert_idx%")) 1935
      WRITE_SHORT ("%vert_off%" + 0x0c + (0x04 * "%vert_idx%")) 520
      WRITE_SHORT ("%vert_off%" + 0x0e + (0x04 * "%vert_idx%")) 1845
      // add attached to door flag (also next loop)
      READ_BYTE  ("%info_off%" + 0x61 + (0xc4 * "%index%")) "flags"
      WRITE_BYTE ("%info_off%" + 0x61 + (0xc4 * "%index%")) ("%flags%" BOR 0b00001000)
      SET "index" = "%info_num%" // kills loop
    END
  END
  FOR (index = 0 ; index < door_num ; index = index + 1) BEGIN
    READ_ASCII ("%door_off%" +        ("%index%" * 0xc8)) "door_name"
    PATCH_IF ("%door_name%" STRING_COMPARE_CASE "secret07" = 0) BEGIN
      WRITE_ASCII ("%door_off%" + 0x9c + ("%index%" * 0xc8)) "Tran1304a" #16
    END
  END
  BUT_ONLY_IF_IT_CHANGES

//moves imp to passable ground
COPY_EXISTING ~ar1513.are~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  FOR (index = 0 ; index < actor_num ; index = index + 1) BEGIN
    READ_ASCII ("%actor_off%" + 0x80 + ("%index%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "imp01" = 0) BEGIN
      READ_SHORT("%actor_off%" + 0x20 + ("%index%" * 0x110)) "x_coord"
      READ_SHORT("%actor_off%" + 0x22 + ("%index%" * 0x110)) "y_coord"
      PATCH_IF (("%x_coord%" = 1639) AND ("%y_coord%" = 1140)) BEGIN
        WRITE_SHORT("%actor_off%" + 0x20 + ("%index%" * 0x110)) 1724
        WRITE_SHORT("%actor_off%" + 0x22 + ("%index%" * 0x110)) 1164
        WRITE_SHORT("%actor_off%" + 0x24 + ("%index%" * 0x110)) 1724
        WRITE_SHORT("%actor_off%" + 0x26 + ("%index%" * 0x110)) 1164
        SET "index" = "%actor_num%" // kill loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// animation glitches due to bad flag
COPY_EXISTING ~ar1601.are~ ~override~
  READ_LONG 0xac "anim_num"
  READ_LONG 0xb0 "anim_off"
  FOR (index = 0 ; index < anim_num ; index = index + 1) BEGIN
    READ_ASCII ("%anim_off%" + ("%index%" * 0x4c)) "anim_name"
    PATCH_IF ("%anim_name%" STRING_COMPARE_CASE "smoke" = 0) BEGIN // oven smoke plume
      READ_BYTE   ("%anim_off%" + 0x34 + ("%index%" * 0x4c)) "flags"
      WRITE_BYTE  ("%anim_off%" + 0x34 + ("%index%" * 0x4c)) ("%flags%" BAND  0b01111111) // remove show in fog of war flag
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// overlay fix
COPY_EXISTING ~AR1603.ARE~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  READ_LONG  0x7c "vert_off"
  WHILE ("%cont_num%" > 0) BEGIN
    SET "cont_num" = ("%cont_num%" - 1)
    READ_SHORT ("%cont_off%" + 0x20 + ("%cont_num%" * 0xc0)) "x_coord"
    PATCH_IF ("%x_coord%" = 270) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x38 + ("%cont_num%" * 0xc0)) 243
      WRITE_SHORT ("%cont_off%" + 0x3a + ("%cont_num%" * 0xc0)) 414
      WRITE_SHORT ("%cont_off%" + 0x3c + ("%cont_num%" * 0xc0)) 292
      READ_SHORT  ("%cont_off%" + 0x50 + ("%cont_num%" * 0xc0)) "vert_idx"
      WRITE_SHORT ("%vert_off%" +        (("%vert_idx%" + 0) * 0x04)) 292
      WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%" + 0) * 0x04)) 442
      WRITE_SHORT ("%vert_off%" +        (("%vert_idx%" + 1) * 0x04)) 286
      WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%" + 1) * 0x04)) 414
      WRITE_SHORT ("%vert_off%" +        (("%vert_idx%" + 2) * 0x04)) 243
      WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%" + 2) * 0x04)) 458
      WRITE_SHORT ("%vert_off%" +        (("%vert_idx%" + 3) * 0x04)) 252
      WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%" + 3) * 0x04)) 489
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// changes another door to use its key
COPY_EXISTING ~AR1608.ARE~ ~override~
  READ_LONG 0xa4 "door_num"
  READ_LONG 0xa8 "door_off"
  WHILE ("%door_num%" > 0) BEGIN
    SET "door_num" = ("%door_num%" - 1)
    READ_ASCII ("%door_off%" +        ("%door_num%" * 0xc8)) "doorname"
    READ_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) "usekey"
    PATCH_IF (("%doorname%" STRING_COMPARE_CASE "DOOR05" = 0) AND ("%usekey%" BOR 0b11111011 = 0b11111011)) BEGIN
      WRITE_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) ("%usekey%" BOR 0b00000100) // sets uses key bit
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// changes another door to use its key
COPY_EXISTING ~AR1611.ARE~ ~override~
  READ_LONG 0xa4 "door_num"
  READ_LONG 0xa8 "door_off"
  WHILE ("%door_num%" > 0) BEGIN
    SET "door_num" = ("%door_num%" - 1)
    READ_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) "usekey"
    READ_ASCII ("%door_off%" + 0x78 + ("%door_num%" * 0xc8)) "keyname"
    PATCH_IF (("%keyname%" STRING_COMPARE_CASE "KEY27" = 0) AND ("%usekey%" BOR 0b11111011 = 0b11111011)) BEGIN
      WRITE_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) ("%usekey%" BOR 0b00000100) // sets uses key bit
    END
  END
  BUT_ONLY_IF_IT_CHANGES

//moves troll to passable ground
COPY_EXISTING ~AR1904.ARE~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  WHILE ("%actor_num%" > 0) BEGIN
    SET "actor_num" = ("%actor_num%" - 1)
    READ_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "TROLL01" = 0) BEGIN
      READ_SHORT("%actor_off%" + 0x20 + ("%actor_num%" * 0x110)) "x_coord"
      READ_SHORT("%actor_off%" + 0x22 + ("%actor_num%" * 0x110)) "y_coord"
      PATCH_IF (("%x_coord%" = 1492) AND ("%y_coord%" = 1172)) BEGIN
        WRITE_SHORT("%actor_off%" + 0x20 + ("%actor_num%" * 0x110)) 1273
        WRITE_SHORT("%actor_off%" + 0x22 + ("%actor_num%" * 0x110)) 1180
        WRITE_SHORT("%actor_off%" + 0x24 + ("%actor_num%" * 0x110)) 1273
        WRITE_SHORT("%actor_off%" + 0x26 + ("%actor_num%" * 0x110)) 1180
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes ambient sound, trademeet tomb uses key
COPY_EXISTING ~AR2000.ARE~ ~override~
  READ_SHORT 0x82 "amb_num"
  READ_LONG  0x84 "amb_off"
  READ_LONG  0xa4 "door_num"
  READ_LONG  0xa8 "door_off"
  WHILE ("%amb_num%" > 0) BEGIN
    SET "amb_num" = ("%amb_num%" - 1)
    READ_SHORT ("%amb_off%" + 0x20 + ("%amb_num%" * 0xd4)) "x_coord"
    READ_SHORT ("%amb_off%" + 0x22 + ("%amb_num%" * 0xd4)) "y_coord"
    PATCH_IF (("%x_coord%" = 35) AND ("%y_coord%" = 59)) BEGIN
      WRITE_LONG ("%amb_off%" + 0x8C + ("%amb_num%" * 0xd4)) 0x001fffc0
    END
  END
  WHILE ("%door_num%" > 0) BEGIN
    SET "door_num" = ("%door_num%" - 1)
    READ_ASCII ("%door_off%" +        ("%door_num%" * 0xc8)) "doorname"
    READ_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) "usekey"
    PATCH_IF (("%doorname%" STRING_COMPARE_CASE "DOOR01" = 0) AND ("%usekey%" BOR 0b11111011 = 0b11111011)) BEGIN
      WRITE_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) ("%usekey%" BOR 0b00000100) // sets uses key bit
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// removes spurious trap flag
COPY_EXISTING ~AR2002.ARE~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  WHILE ("%cont_num%" > 0) BEGIN
    SET "cont_num" = ("%cont_num%" - 1)
    READ_ASCII ("%cont_off%" + 0x48 + ("%cont_num%" * 0xc0)) "script"
    READ_SHORT ("%cont_off%" + 0x30 + ("%cont_num%" * 0xc0)) "trapped"
    PATCH_IF (("%script%" STRING_COMPARE_CASE "" = 0) AND ("%trapped%" = 1)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x2C + ("%cont_num%" * 0xc0)) 0
      WRITE_SHORT ("%cont_off%" + 0x2E + ("%cont_num%" * 0xc0)) 0
      WRITE_SHORT ("%cont_off%" + 0x30 + ("%cont_num%" * 0xc0)) 0
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// corrects music in underdark
COPY_EXISTING ~AR2100.ARE~ ~override~
  READ_LONG 0xbc "song_off"
  WRITE_LONG ("%song_off%" + 0x04) 31
  BUT_ONLY_IF_IT_CHANGES

// trap fixes
COPY_EXISTING ~AR2207.ARE~ ~override~
  READ_LONG  0x70 "cont_off"
  READ_SHORT 0x74 "cont_num"
  WHILE ("%cont_num%" > 0) BEGIN
    SET "cont_num" = ("%cont_num%" - 1)
    READ_ASCII ("%cont_off%" + 0x48 + ("%cont_num%" * 0xc0)) "script"
    READ_SHORT ("%cont_off%" + 0x30 + ("%cont_num%" * 0xc0)) "trapped"
    PATCH_IF (("%trapped%" = 0) AND ("%script%" STRING_COMPARE_CASE "GSPEAR" = 0)) BEGIN
      WRITE_SHORT ("%cont_off%" + 0x30 + ("%cont_num%" * 0xc0)) 1
    END
    PATCH_IF ("%script%" STRING_COMPARE_CASE "GT007" = 0) BEGIN
      READ_SHORT ("%cont_off%" + 0x2C + ("%cont_num%" * 0xc0)) "detect"
      READ_SHORT ("%cont_off%" + 0x2e + ("%cont_num%" * 0xc0)) "remove"
      PATCH_IF ("%detect%" = 0) BEGIN
        WRITE_SHORT ("%cont_off%" + 0x2C + ("%cont_num%" * 0xc0)) 50
      END
      PATCH_IF ("%remove%" > 90) BEGIN
        WRITE_SHORT ("%cont_off%" + 0x2e + ("%cont_num%" * 0xc0)) 90
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// animation glitches due to bad layering
COPY_EXISTING ~ar2300.are~ ~override~
  READ_LONG 0xac "anim_num"
  READ_LONG 0xb0 "anim_off"
  FOR (index = 0 ; index < anim_num ; index = index + 1) BEGIN
    READ_SHORT ("%anim_off%" + 0x20 + ("%index%" * 0x4c)) "x_coord"
    READ_SHORT ("%anim_off%" + 0x22 + ("%index%" * 0x4c)) "y_coord"
    PATCH_IF (("%x_coord%" = 3590) AND ("%y_coord%" = 2171)) BEGIN // water spout
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0xffef // height
    END ELSE
    PATCH_IF (("%x_coord%" = 4116) AND ("%y_coord%" = 1641)) BEGIN // water spout
      WRITE_SHORT ("%anim_off%" + 0x38 + ("%index%" * 0x4c)) 0xffd3 // height
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// cleans up junk in the rest spawn block
COPY_EXISTING ~AR2400.ARE~ ~override~
  READ_LONG 0xc0 "rest_off"
  SAY         ("%rest_off%" + 0x40) #10134
  WRITE_LONG  ("%rest_off%" + 0x70) 0
  WRITE_LONG  ("%rest_off%" + 0x78) 0
  WRITE_LONG  ("%rest_off%" + 0x80) 0
  WRITE_LONG  ("%rest_off%" + 0x88) 0
  WRITE_LONG  ("%rest_off%" + 0x90) 0
  BUT_ONLY_IF_IT_CHANGES
  
// war elves in ar2401 go hostile with drow shouts
COPY_EXISTING ~ar2401.are~ ~override~
  READ_LONG  0x54 "actor_off"
  READ_SHORT 0x58 "actor_num"
  WHILE ("%actor_num%" > 0) BEGIN
    SET "actor_num" = ("%actor_num%" - 1)
    READ_ASCII ("%actor_off%" + 0x80 + ("%actor_num%" * 0x110)) "cre_file"
    PATCH_IF ("%cre_file%" STRING_COMPARE_REGEXP "udelf0[1-5]" = 0) BEGIN
      WRITE_ASCII ("%actor_off%" + 0x60 + ("%actor_num%" * 0x110)) ~waitpc~ #8
      PATCH_IF ("%cre_file%" STRING_COMPARE_CASE "udelf02" = 0) BEGIN
        WRITE_ASCII ("%actor_off%" + 0x58 + ("%actor_num%" * 0x110)) ~wtarsgt~ #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// removes party-required flag from AR2600 transition
COPY_EXISTING ~ar2603.are~ ~override~
  READ_SHORT 0x5A "info_num"
  READ_LONG  0x5C "info_off"
  WHILE ("%info_num%" > 0) BEGIN
    SET "info_num" = ("%info_num%" - 1)
    READ_ASCII ("%info_off%" + 0x38 + (0xC4 * "%info_num%")) "area"
    PATCH_IF ("AR2600" STRING_COMPARE_CASE "%area%" = 0) BEGIN
      READ_BYTE  ("%info_off%" + 0x60 + (0xC4 * "%info_num%")) "flags"
      WRITE_BYTE ("%info_off%" + 0x60 + (0xC4 * "%info_num%")) ("%flags%" BAND 0b11111011)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB-only stuff check

  // fixes coordinates
  COPY_EXISTING ~AR3000.ARE~ ~override~
    READ_SHORT 0x5A "info_num"
    READ_LONG  0x5C "info_off"
    READ_LONG  0x7c "vert_off"
    READ_LONG  0xa4 "door_num"
    READ_LONG  0xa8 "door_off"
    WHILE ("%info_num%" > 0) BEGIN
      SET "info_num" = ("%info_num%" - 1)
      READ_ASCII ("%info_off%" + 0x7c + (0xC4 * "%info_num%")) "script"
      PATCH_IF ("TP3001A" STRING_COMPARE_CASE "%script%" = 0) BEGIN
        WRITE_SHORT ("%info_off%" + 0x24 + (0xC4 * "%info_num%")) 406  // bounding box
        READ_LONG   ("%info_off%" + 0x2c + (0xC4 * "%info_num%")) "vert_idx"
        WRITE_SHORT ("%vert_off%" +        (("%vert_idx%" + 3) * 0x04)) 1040 // vertex
        WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%" + 3) * 0x04)) 406  // vertex
      END ELSE
      PATCH_IF ("TP3017B" STRING_COMPARE_CASE "%script%" = 0) BEGIN
        READ_LONG   ("%info_off%" + 0x2c + (0xC4 * "%info_num%")) "vert_idx"
        WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%" + 2) * 0x04)) 1774 // vertex
      END ELSE
      PATCH_IF ("TP3019B" STRING_COMPARE_CASE "%script%" = 0) BEGIN
        WRITE_SHORT ("%info_off%" + 0x24 + (0xC4 * "%info_num%")) 1596 // bounding box
        READ_LONG   ("%info_off%" + 0x2c + (0xC4 * "%info_num%")) "vert_idx"
        WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%" + 1) * 0x04)) 1569 // vertex
      END ELSE
      PATCH_IF ("TP3020" STRING_COMPARE_CASE "%script%" = 0) BEGIN
        WRITE_SHORT ("%info_off%" + 0x22 + (0xC4 * "%info_num%")) 429  // bounding box
        WRITE_SHORT ("%info_off%" + 0x24 + (0xC4 * "%info_num%")) 1899 // bounding box
        WRITE_SHORT ("%info_off%" + 0x26 + (0xC4 * "%info_num%")) 489  // bounding box
        WRITE_SHORT ("%info_off%" + 0x28 + (0xC4 * "%info_num%")) 2039 // bounding box
        READ_LONG   ("%info_off%" + 0x2c + (0xC4 * "%info_num%")) "vert_idx"
        WRITE_SHORT ("%vert_off%" +        (("%vert_idx%"    ) * 0x04)) 429  // vertex
        WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%"    ) * 0x04)) 2003 // vertex
        WRITE_SHORT ("%vert_off%" +        (("%vert_idx%" + 1) * 0x04)) 448  // vertex
        WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%" + 1) * 0x04)) 1899 // vertex
        WRITE_SHORT ("%vert_off%" +        (("%vert_idx%" + 2) * 0x04)) 489  // vertex
        WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%" + 2) * 0x04)) 1931 // vertex
        WRITE_SHORT ("%vert_off%" +        (("%vert_idx%" + 3) * 0x04)) 483  // vertex
        WRITE_SHORT ("%vert_off%" + 0x02 + (("%vert_idx%" + 3) * 0x04)) 2039 // vertex
      END
    END
    WHILE ("%door_num%" > 0) BEGIN
      SET "door_num" = ("%door_num%" - 1)
      READ_ASCII ("%door_off%" +        ("%door_num%" * 0xc8)) "doorname"
      READ_BYTE  ("%door_off%" + 0x29 + ("%door_num%" * 0xc8)) "usekey"
      PATCH_IF ("%doorname%" STRING_COMPARE_CASE "DOOR02" = 0) BEGIN
        WRITE_SHORT ("%door_off%" + 0x44 + ("%door_num%" * 0xc8)) 508 // bounding box
        READ_LONG   ("%door_off%" + 0x34 + ("%door_num%" * 0xc8)) "cl_vert_idx" // closed vertex index
        WRITE_SHORT ("%vert_off%" +        (("%cl_vert_idx%" + 1) * 0x04)) 445  // vertex
        WRITE_SHORT ("%vert_off%" + 0x02 + (("%cl_vert_idx%" + 1) * 0x04)) 1896 // vertex
        WRITE_SHORT ("%vert_off%" +        (("%cl_vert_idx%" + 2) * 0x04)) 508  // vertex
        WRITE_SHORT ("%vert_off%" +        (("%cl_vert_idx%" + 3) * 0x04)) 495  // vertex
        WRITE_SHORT ("%vert_off%" + 0x02 + (("%cl_vert_idx%" + 3) * 0x04)) 2048 // vertex
      END
    END
    BUT_ONLY_IF_IT_CHANGES

  // corrects ambients, animation glitches due to bad flag
  COPY_EXISTING ~ar3001.are~ ~override~
    READ_SHORT 0x82 "amb_num"  ELSE 0
    READ_LONG  0x84 "amb_off"  ELSE 0
    READ_LONG  0xac "anim_num" ELSE 0
    READ_LONG  0xb0 "anim_off" ELSE 0
    WHILE ("%amb_num%" > 0) BEGIN
      SET "amb_num" = ("%amb_num%" - 1)
      READ_SHORT ("%amb_off%" + 0x20 + ("%amb_num%" * 0xd4)) "x_coord"
      PATCH_IF ("%x_coord%" = 1406) BEGIN
        WRITE_SHORT ("%amb_off%" + 0x80 + ("%amb_num%" * 0xd4)) 10
      END
    END
    FOR (index = 0 ; index < anim_num ; index = index + 1) BEGIN
      READ_ASCII ("%anim_off%" + ("%index%" * 0x4c)) "anim_name"
      PATCH_IF ("%anim_name%" STRING_COMPARE_CASE "am3001f" = 0) BEGIN // glowing globes
        READ_BYTE   ("%anim_off%" + 0x34 + ("%index%" * 0x4c)) "flags"
        WRITE_BYTE  ("%anim_off%" + 0x34 + ("%index%" * 0x4c)) ("%flags%" BOR  0b10000000) // add show in fog of war flag
      END
    END
    BUT_ONLY_IF_IT_CHANGES

  // changes rest spawn demon from summoned to regular one
  COPY_EXISTING ~AR3004.ARE~ ~override~
    READ_LONG 0xc0 "rest_off"
    WRITE_ASCII ("%rest_off%" + 0x60) ~DGLAB01~ #8
    BUT_ONLY_IF_IT_CHANGES

  // fixes rest spawn demon cre reference
  COPY_EXISTING ~AR3010.ARE~ ~override~
    READ_LONG 0xc0 "rest_off"
    WRITE_ASCII ("%rest_off%" + 0x58) ~DERINY01~
    BUT_ONLY_IF_IT_CHANGES

  // makes trigger names unique
  COPY_EXISTING ~AR5006.ARE~ ~override~
    READ_SHORT 0x5A "info_num"
    READ_LONG  0x5C "info_off"
    FOR (index = 0; index < info_num ; index = index + 1) BEGIN
      READ_SHORT ("%info_off%" + 0x24 + (0xC4 * "%index%" )) "bound_top"
      PATCH_IF ("%bound_top%" = 603) BEGIN
        WRITE_ASCII ("%info_off%" + (0xC4 * "%index%" )) "SpiritAppear2" #32
      END
    END
    BUT_ONLY_IF_IT_CHANGES

  // non-secret door shouldn't be flagged as secret
  COPY_EXISTING ~ar5015.are~ ~override~
    READ_LONG 0xa4 "door_num" ELSE 0
    READ_LONG 0xa8 "door_off" ELSE 0
    FOR (index = 0 ; index < door_num ; index = index + 1) BEGIN
      READ_ASCII ("%door_off%" + 0x9c + ("%index%" * 0xc8)) "trans_name"
      PATCH_IF ("%trans_name%" STRING_COMPARE_CASE "tran5016" = 0) BEGIN
        READ_BYTE  ("%door_off%" + 0x28 + ("%index%" * 0xc8)) "secret"
        WRITE_BYTE ("%door_off%" + 0x28 + ("%index%" * 0xc8)) ("%secret%" BAND 0b01111111) // removes secret flag
      END
    END
    BUT_ONLY_IF_IT_CHANGES

END

// checking areas for overcharged items
COPY_EXISTING ~ar0305.are~ ~override~ // dagg01 (num 10) has assigned 3 to stack 1 charges 0 in header 1
              ~ar0334.are~ ~override~ // bow01 (num 5) has assigned 2 to stack 1 charges 0 in header 1
              ~ar0505.are~ ~override~ // bow01 (num 19) has assigned 2 to stack 1 charges 0 in header 1
              ~ar0530.are~ ~override~ // sw2h01 (num 3) has assigned 2 to stack 1 charges 0 in header 1
              ~ar0801.are~ ~override~ // misc6w (num 0) has assigned 3 to stack 1 charges 0 in header 1
              ~ar0903.are~ ~override~ // dagg01 (num 15) has assigned 4 to stack 1 charges 0 in header 1
              ~ar1202.are~ ~override~ // key07 (num 4) has assigned 4 to stack 1 charges 0 in header 1
              ~ar2400.are~ ~override~ // misc3o (num 4) has assigned 3 to max 0 in header 2
              ~ar3016.are~ ~override~ // wand18 (num 44) has assigned 6 to max 5 in header 2
              ~ar3021.are~ ~override~ // wand19 (num 2) has assigned 1 to max 0 in header 2
              ~ar3022.are~ ~override~ // wand18 (num 10) has assigned 6 to max 5 in header 2
              ~ar5502.are~ ~override~ // sw1h05 (num 5) has assigned 2 to stack 1 charges 0 in header 1
              ~ar6300.are~ ~override~ // plot16a (num 6) has assigned 2 to stack 1 charges 0 in header 1
  READ_SHORT 0x76 "itm_num" ELSE 0
  READ_LONG  0x78 "itm_off" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" +        ("%index%" * 0x14)) "item"
    PATCH_IF (("%item%" STRING_COMPARE_CASE "bow01" = 0) OR      // composite long bow
              ("%item%" STRING_COMPARE_CASE "bow03" = 0) OR      // long bow
              ("%item%" STRING_COMPARE_CASE "bow05" = 0) OR      // short bow
              ("%item%" STRING_COMPARE_CASE "dagg01" = 0) OR     // dagger
              ("%item%" STRING_COMPARE_CASE "key07" = 0) OR      // chapel key
              ("%item%" STRING_COMPARE_CASE "misc6w" = 0) OR     // wooden stake
              ("%item%" STRING_COMPARE_CASE "plot16a" = 0) OR    // bounty notice
              ("%item%" STRING_COMPARE_CASE "sw1h01" = 0) OR     // bastard sword
              ("%item%" STRING_COMPARE_CASE "sw1h05" = 0) OR     // long sword +1
              ("%item%" STRING_COMPARE_CASE "sw2h01" = 0)) BEGIN // 2h sword
      WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 0 // unchargable/unstackable items
      WRITE_SHORT ("%itm_off%" + 0x0c + ("%index%" * 0x14)) 0
      WRITE_SHORT ("%itm_off%" + 0x0e + ("%index%" * 0x14)) 0
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "misc3o" = 0) BEGIN // methlid's harp
      WRITE_SHORT ("%itm_off%" + 0x0c + ("%index%" * 0x14)) 0 // no secondary charges
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "wand18" = 0) BEGIN // wand of spell striking
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge2%" > 5) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + ("%index%" * 0x14)) 5 // max 5 secondary charges
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "wand19" = 0) BEGIN // wand of cursing
      WRITE_SHORT ("%itm_off%" + 0x0c + ("%index%" * 0x14)) 0 // no secondary charges
      WRITE_SHORT ("%itm_off%" + 0x0e + ("%index%" * 0x14)) 0 // no tertiary charges
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes zero charge items
COPY_EXISTING ~ar0018.are~ ~override~ // ttwand (num 5) has assigned 0 to stack 1 charges 100 in header 1
              ~ar0311.are~ ~override~ // ax1h04 (num 1) has assigned 0 to stack 10 charges 1 in header 1
              ~ar0317.are~ ~override~ // wand05 (num 3) has assigned 0 to stack 1 charges 50 in header 1
              ~ar0329.are~ ~override~ // ring26 (num 7) has assigned 0 to stack 1 charges 1 in header 1
              ~ar0405.are~ ~override~ // bolt01 (num 36) has assigned 0 to stack 40 charges 1 in header 1
              ~ar0527.are~ ~override~ // wand03 (num 0) has assigned 0 to stack 1 charges 100 in header 1
              ~ar0706.are~ ~override~ // ax1h04 (num 1) has assigned 0 to stack 10 charges 1 in header 1
              ~ar1202.are~ ~override~ // misc3h (num 20) has assigned 0 to stack 1 charges 1 in header 1
              ~ar1302.are~ ~override~ // dart03 (num 74) has assigned 0 to stack 40 charges 1 in header 1
              ~ar1514.are~ ~override~ // arow05 (num 53) has assigned 0 to stack 40 charges 1 in header 1
  READ_SHORT 0x76 "itm_num" ELSE 0
  READ_LONG  0x78 "itm_off" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" +        ("%index%" * 0x14)) "item"
    PATCH_IF (("%item%" STRING_COMPARE_CASE "ax1h04" = 0) OR     // throwing axes
              ("%item%" STRING_COMPARE_CASE "wand03" = 0)) BEGIN // wand of magic missiles, never has >10 charges anywhere else
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 10
      END
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "arow05" = 0) OR     // arrows of biting
              ("%item%" STRING_COMPARE_CASE "bolt01" = 0) OR     // bolts
              ("%item%" STRING_COMPARE_CASE "bolt04" = 0)) BEGIN // bolts of biting
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 40
      END
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "bow10" = 0) OR      // heartseeker +3
              ("%item%" STRING_COMPARE_CASE "sw1h32" = 0)) BEGIN // dragonslayer
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + ("%index%" * 0x14)) 1
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "dart03" = 0) BEGIN // darts of stunning
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 20 // never appears in stacks > 20
      END
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "misc3h" = 0) OR     // horn of blasting
              ("%item%" STRING_COMPARE_CASE "ring26" = 0)) BEGIN // ring of djinni summoning
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 1
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "ttwand" = 0) BEGIN // wand of the heavens (tutorial version)
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 8 // non-tut version never appears with >8 charges
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "wand05" = 0) BEGIN // wand of fire
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 10
      END
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + ("%index%" * 0x14)) 10
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Correct the position of the Western Tunnels map note in the Underdark (aVENGER)
COPY_EXISTING ~AR2100.are~ ~override~
  READ_LONG  0xc4 "note_off"
  READ_LONG  0xc8 "note_num"
    FOR (index = 0; index < note_num; index = index + 1) BEGIN // cycle through automap notes
      READ_SHORT ("%note_off%" +        ("%index%" * 0x34)) "x_coord"
      READ_SHORT ("%note_off%" + 0x02 + ("%index%" * 0x34)) "y_coord"
      PATCH_IF (("%x_coord%" = 335) AND  ("%y_coord%" = 1569)) BEGIN // Western Tunnels map note
       WRITE_SHORT ("%note_off%" +        ("%index%" * 0x34)) "250" // Coordinate X (250)
       WRITE_SHORT ("%note_off%" + 0x02 + ("%index%" * 0x34)) "1830" // Coordinate Y (1830)
      END
    END  
BUT_ONLY_IF_IT_CHANGES

// Killing unrelated baatezu outside Ka'rashur's room should not turn him and his cohort in Watcher's Keep hostile (see also yssum2.bcs) (Wisp)
ACTION_IF GAME_IS tob BEGIN  
  COPY_EXISTING ar3005.are override
                ar3006.are override
                ar3009.are override
    READ_LONG 0xc0 rest ELSE 0
    FOR (i=0;i<10;i+=1) BEGIN
      READ_ASCII rest + 0x48 + 0x8*i cre ELSE blank
      PATCH_IF "%cre%" STRING_EQUAL_CASE gorbat5 BEGIN
        WRITE_ASCII rest + 0x48 + 0x8*i dbonef01 #8
      END
    END
  BUT_ONLY

  COPY_EXISTING ar6012.are override
    READ_LONG  0x54 act_off ELSE 0
    READ_SHORT 0x58 num_act ELSE 0
    FOR (i=0;i<num_act;i+=1) BEGIN
      READ_ASCII act_off + 0x110*i + 0x80 cre ELSE blank
      PATCH_IF "%cre%" STRING_EQUAL_CASE gorbat5 BEGIN
        WRITE_ASCII act_off + 0x110*i + 0x80 dbonef01 #8
      END
    END
  BUT_ONLY
END

/////                                                  \\\\\
///// creature file fixes                              \\\\\
/////                                                  \\\\\

// why is a statue chaotic evil?
COPY_EXISTING ~shaava01.cre~ ~override~
  WRITE_BYTE 0x27b 0 // alignment: none
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~balth.cre~    ~override~ // Balthazar
              ~c6bran.cre~   ~override~ // Branet Al-Thon
              ~c6eric.cre~   ~override~ // Eric Vanstraaten
              ~c6eric3.cre~  ~override~ // Eric Vanstraaten
              ~c6nerit.cre~  ~override~ // Nerit
              ~c6will.cre~   ~override~ // William Reirrac
              ~cutbalth.cre~ ~override~ // Balthazar
              ~garren.cre~   ~override~ // Garren Windspear
              ~hdragsil.cre~ ~override~ // Dragon
              ~pwauk2.cre~   ~override~ // Haletlatess Jillian
              ~sarmag01.cre~ ~override~ // Errard
              ~sleepdw.cre~  ~override~ // Sleeping Dwarf
              ~suelle.cre~   ~override~ // Ellesime
              ~suelle2.cre~  ~override~ // Ellesime
              ~suelleap.cre~ ~override~ // Ellesime
              ~uhogre01.cre~ ~override~ // Madulf
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 17 // alignment: lawful good
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~bamng01.cre~  ~override~ // Amnish Guard
              ~bamng02.cre~  ~override~ // Amnish Guard
              ~bdact05.cre~  ~override~ // Zaren
              ~bdhigg01.cre~ ~override~ // Higgold
              ~bdprst01.cre~ ~override~ // Shvanana
              ~bhelm.cre~    ~override~ // Guardian Vottnar
              ~civamng1.cre~ ~override~ // Amnish Soldier
              ~cowenf02.cre~ ~override~ // Cowled Enforcer
              ~cowenf1.cre~  ~override~ // Cowled Enforcer
              ~cowenf2.cre~  ~override~ // Cowled Enforcer
              ~cowenf3.cre~  ~override~ // Cowled Enforcer
              ~cowenf4.cre~  ~override~ // Cowled Enforcer
              ~cowld.cre~    ~override~ // Cowled Wizard
              ~cowled.cre~   ~override~ // Cowled Wizard
              ~cowled01.cre~ ~override~ // Cowled Wizard
              ~cscowl1.cre~  ~override~ // Cowled Wizard
              ~cscowl2.cre~  ~override~ // Cowled Wizard
              ~cscowl3.cre~  ~override~ // Cowled Wizard
              ~cscowl4.cre~  ~override~ // Cowled Wizard
              ~cscowl5.cre~  ~override~ // Cowled Wizard
              ~cscowl6.cre~  ~override~ // Cowled Wizard
              ~cscowl7.cre~  ~override~ // Cowled Wizard
              ~cscowl8.cre~  ~override~ // Cowled Wizard
              ~cscowl9.cre~  ~override~ // Cowled Wizard
              ~cucow1.cre~   ~override~ // Cowled Enforcer
              ~cucow2.cre~   ~override~ // Cowled Enforcer
              ~cucow3.cre~   ~override~ // Cowled Enforcer
              ~cuwiz1.cre~   ~override~ // Cowled Enforcer
              ~cuwiz2.cre~   ~override~ // Cowled Enforcer
              ~cuwiz3.cre~   ~override~ // Cowled Enforcer
              ~cuwiz4.cre~   ~override~ // Cowled Enforcer
              ~cuwiz5.cre~   ~override~ // Cowled Enforcer
              ~cuwiz6.cre~   ~override~ // Cowled Enforcer
              ~cuwizc.cre~   ~override~ // Cowled Enforcer
              ~cuwizsu.cre~  ~override~ // Cowled Enforcer
              ~fulord.cre~   ~override~ // Lord Milsire Donderbeg
              ~jugjer01.cre~ ~override~ // Jermien
              ~killmonk.cre~ ~override~ // Monk
              ~kpdomo01.cre~ ~override~ // Major Domo
              ~loutm02.cre~  ~override~ // Mercenary of Riatvin
              ~mage16c.cre~  ~override~ // Cowled Wizard
              ~mage18a.cre~  ~override~ // Cowled Wizard
              ~mage18z.cre~  ~override~ // Zallanora
              ~mgteos01.cre~ ~override~ // Teos
              ~noblem1.cre~  ~override~ // Nobleman
              ~noblem2.cre~  ~override~ // Nobleman
              ~noblem3.cre~  ~override~ // Lord Ophal
              ~pirsal01.cre~ ~override~ // Sailor
              ~pirsal02.cre~ ~override~ // Sailor
              ~plmetg01.cre~ ~override~ // Metrich Footman
              ~plmetg02.cre~ ~override~ // Metrich Yeoman
              ~ppcowled.cre~ ~override~ // Perth the Adept
              ~quint.cre~    ~override~ // Quint Roenal
              ~shth02.cre~   ~override~ // Goshan
              ~shthlt01.cre~ ~override~ // Jariel
              ~shthstor.cre~ ~override~ // Rattell
              ~trax.cre~     ~override~ // Trax
              ~uddear03.cre~ ~override~ // Finderlig
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 18 // alignment: lawful neutral
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~anno1.cre~    ~override~ // Announcer
              ~aran.cre~     ~override~ // Aran Linvail
              ~aran02.cre~   ~override~ // Aran Linvail
              ~argrim.cre~   ~override~ // Lord Ketlaar Argrim
              ~army01.cre~   ~override~ // Orc
              ~behobs01.cre~ ~override~ // Beholder
              ~bhaal01.cre~  ~override~ // Bhaal
              ~booter.cre~   ~override~ // Booter
              ~booter02.cre~ ~override~ // Booter
              ~bounha02.cre~ ~override~ // Bounty Hunter
              ~bounha03.cre~ ~override~ // Bounty Hunter
              ~cederil.cre~  ~override~ // Deril
              ~cguard1.cre~  ~override~ // Cultist Guard
              ~cguard2.cre~  ~override~ // Cultist Guard
              ~chalslay.cre~ ~override~ // Slayer
              ~copamb02.cre~ ~override~ // Copper Coronet Guard
              ~copamb05.cre~ ~override~ // Copper Coronet Guard
              ~copgreet.cre~ ~override~ // Frankie
              ~corneil.cre~  ~override~ // Corneil
              ~daabol.cre~   ~override~ // Aboleth
              ~degard.cre~   ~override~ // Degardan
              ~dempit.cre~   ~override~ // Pit Fiend
              ~dempit01.cre~ ~override~ // Pit Fiend
              ~dempitsu.cre~ ~override~ // Pit Fiend
              ~docsol03.cre~ ~override~ // Guard Captain
              ~drslayer.cre~ ~override~ // Slayer
              ~duearc01.cre~ ~override~ // Duergar
              ~duecla01.cre~ ~override~ // Ilyich
              ~duegau01.cre~ ~override~ // Duergar
              ~duegau02.cre~ ~override~ // Duergar
              ~duemag01.cre~ ~override~ // Mage
              ~duemag02.cre~ ~override~ // Mage
              ~duergar.cre~  ~override~ // Duergar
              ~duergar1.cre~ ~override~ // Duergar
              ~duergar2.cre~ ~override~ // Duergar
              ~duergar3.cre~ ~override~ // Duergar
              ~elehob01.cre~ ~override~ // Goblin Commando
              ~gphil02.cre~  ~override~ // Philosopher
              ~guard2.cre~   ~override~ // Copper Coronet Guard
              ~guard3.cre~   ~override~ // Copper Coronet Guard
              ~hamek.cre~    ~override~ // Mekrath
              ~hgskl01.cre~  ~override~ // Skeleton Cleric
              ~hgskl02.cre~  ~override~ // Skeleton Assassin
              ~hgskl03.cre~  ~override~ // Skeleton Mage
              ~hgslv01.cre~  ~override~ // Slave Woman
              ~hlmafer.cre~  ~override~ // Maferan
              ~hlolaf.cre~   ~override~ // Olaf Rassmusen
              ~hlrevan.cre~  ~override~ // Revanek
              ~isaea.cre~    ~override~ // Isaea Roenal
              ~jaga1.cre~    ~override~ // Bessen
              ~korgoo01.cre~ ~override~ // Goon
              ~korgoo02.cre~ ~override~ // Goon
              ~korscroo.cre~ ~override~ // Scrooloose
              ~korshag.cre~  ~override~ // Shagbag
              ~lehtin.cre~   ~override~ // Lehtinan
              ~llynis.cre~   ~override~ // Llynis
              ~madam.cre~    ~override~ // Madam Nin
              ~mage8a.cre~   ~override~ // Zyntris
              ~mage8b.cre~   ~override~ // Zyntris
              ~mdrak.cre~    ~override~ // Maharajah
              ~mekimp01.cre~ ~override~ // Imp
              ~mgass01.cre~  ~override~ // Sergeant Natula
              ~mgass02.cre~  ~override~ // Tyrian
              ~mgass03.cre~  ~override~ // Vilhelm
              ~mgket01.cre~  ~override~ // Lord Ketlaar Argrim
              ~mgketg01.cre~ ~override~ // Man-at-Arms
              ~mgketg02.cre~ ~override~ // Archer
              ~mgkhol01.cre~ ~override~ // Khollynnus Paac
              ~mugger1.cre~  ~override~ // Shady Character
              ~mugger2.cre~  ~override~ // Shady Character
              ~mugger3.cre~  ~override~ // Shady Character
              ~mvguard1.cre~ ~override~ // Assassin
              ~naldirt.cre~  ~override~ // Officer Dirth
              ~obssah02.cre~ ~override~ // Sahuagin Priestess
              ~parfig16.cre~ ~override~ // Jalin Tix
              ~parmonk.cre~  ~override~ // Mahar
              ~pirmur03.cre~ ~override~ // Front
              ~pirmur04.cre~ ~override~ // Guard
              ~pirmur05.cre~ ~override~ // Guard Capt
              ~pirmur06.cre~ ~override~ // Guard Capt
              ~pirmur08.cre~ ~override~ // Guard
              ~pirmur11.cre~ ~override~ // Guard
              ~pirmur12.cre~ ~override~ // Guard
              ~pirmur13.cre~ ~override~ // Guard Capt
              ~pirpir06.cre~ ~override~ // Sailor
              ~plshhg01.cre~ ~override~ // Hobgoblin Slayer
              ~plshhg02.cre~ ~override~ // Hobgoblin Wizard
              ~ppaltk1.cre~  ~override~ // Kobold Shaman
              ~ppbhaal.cre~  ~override~ // Bhaal
              ~ppright.cre~  ~override~ // Dunbar
              ~rakmah01.cre~ ~override~ // Maharajah
              ~rakraj01.cre~ ~override~ // Rajah
              ~rakruh01.cre~ ~override~ // Ruhk
              ~raksha01.cre~ ~override~ // Rakshasa
              ~ralej.cre~    ~override~ // Rayic Gethras
              ~reband03.cre~ ~override~ // Bandit
              ~rerak01.cre~  ~override~ // Traveler
              ~rerak02.cre~  ~override~ // Traveler
              ~rerak03.cre~  ~override~ // Traveler
              ~rerak04.cre~  ~override~ // Traveler
              ~rerak05.cre~  ~override~ // Traveler
              ~rerak06.cre~  ~override~ // Traveler
              ~resuna.cre~   ~override~ // Suna Seni
              ~rethie02.cre~ ~override~ // Slaver
              ~rethie03.cre~ ~override~ // Slaver
              ~rethug01.cre~ ~override~ // Thug
              ~rethug02.cre~ ~override~ // Mage
              ~rethug03.cre~ ~override~ // Thug
              ~rethug04.cre~ ~override~ // Thug
              ~rigen01.cre~  ~override~ // Lord Igen Tombelthen
              ~rumar01.cre~  ~override~ // Umar
              ~sargrd05.cre~ ~override~ // Thief
              ~sargrd06.cre~ ~override~ // Mage
              ~sargrd09.cre~ ~override~ // Thief
              ~sevpat02.cre~ ~override~ // Sorcerous Amon
              ~sevpat03.cre~ ~override~ // Pooky
              ~sewarc01.cre~ ~override~ // Orc Archer
              ~sewarc02.cre~ ~override~ // Orc Archer
              ~sewrak01.cre~ ~override~ // Rakshasa
              ~sewyag02.cre~ ~override~ // Orc Archer
              ~shth05.cre~   ~override~ // Joster
              ~slayer.cre~   ~override~ // Slayer
              ~stolethf.cre~ ~override~ // Shadow Thief
              ~suadsaan.cre~ ~override~ // Adsaan
              ~surakmah.cre~ ~override~ // Maharajah
              ~surakraj.cre~ ~override~ // Rajah
              ~surakruh.cre~ ~override~ // Ruhk
              ~suraksha.cre~ ~override~ // Rakshasa
              ~surakw1.cre~  ~override~ // Rakshasa
              ~surakw2.cre~  ~override~ // Rakshasa
              ~surakw3.cre~  ~override~ // Rakshasa
              ~surakw4.cre~  ~override~ // Rakshasa
              ~surly.cre~    ~override~ // Surly
              ~suziyaad.cre~ ~override~ // Ziyaad
              ~tantug01.cre~ ~override~ // Thug
              ~tantug02.cre~ ~override~ // Thug
              ~tantug03.cre~ ~override~ // Thug
              ~telpit2.cre~  ~override~ // Pit Fiend
              ~thief7.cre~   ~override~ // Anishai
              ~tiana.cre~    ~override~ // Tiana
              ~tolmag01.cre~ ~override~ // Mage
              ~tolmag02.cre~ ~override~ // Mage
              ~trrak02.cre~  ~override~ // Saadat
              ~trrak03.cre~  ~override~ // Jalaal
              ~udmaster.cre~ ~override~ // The Master Brain
              ~vaelag.cre~   ~override~ // Vaelag
              ~yaga02.cre~   ~override~ // Lieutenant Mage
              ~yaga04.cre~   ~override~ // Lieutenant Cleric
              ~ysgrunt.cre~  ~override~ // Yaga-Shura Soldier
              ~ysguar02.cre~ ~override~ // Yaga-Shura Soldier
              ~ysguar03.cre~ ~override~ // Yaga-Shura Mage
              ~ysguar04.cre~ ~override~ // Yaga-Shura Soldier
              ~ysguar05.cre~ ~override~ // Yaga-Shura Soldier
              ~ysguar06.cre~ ~override~ // Yaga-Shura Officer
              ~ysmage01.cre~ ~override~ // Yaga-Shura Mage
              ~yssold01.cre~ ~override~ // Yaga-Shura Soldier
              ~yssold02.cre~ ~override~ // Yaga-Shura Soldier
              ~yssold03.cre~ ~override~ // Yaga-Shura Officer
              ~yssold13.cre~ ~override~ // Yaga-Shura Soldier
              ~yssold14.cre~ ~override~ // Yaga-Shura Mage
              ~yssold15.cre~ ~override~ // Yaga-Shura Officer
              ~zilarc01.cre~ ~override~ // Black Reaver
              ~zilfgt01.cre~ ~override~ // Black Reaver
              ~zilfgt02.cre~ ~override~ // Black Reaver
              ~zilmag01.cre~ ~override~ // Black Reaver
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 19 // alignment: lawful evil
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~acolyte2.cre~ ~override~ // Dawnbringer Alvanna
              ~amcler01.cre~ ~override~ // Priest of Waukeen
              ~bharval.cre~  ~override~ // High Mornmaster Arval
              ~c6harp.cre~   ~override~ // Malchor Harpell
              ~cscleric.cre~ ~override~ // Dawnmaster Kreel
              ~ELEMchan.cre~ ~override~ // Chan
              ~latlara.cre~  ~override~ // Acolyte Lara
              ~mourner5.cre~ ~override~ // Mourner
              ~proplat.cre~  ~override~ // Morning Knight
              ~radeel.cre~   ~override~ // Radeel
              ~renfeld.cre~  ~override~ // Renfeld
              ~scsain.cre~   ~override~ // Dawnbringer Sain
              ~trskin01.cre~ ~override~ // Raissa
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 33 // alignment: neutral good
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~amcler02.cre~ ~override~ // Chyil
              ~amfsleep.cre~ ~override~ // Sleeping Woman
              ~bfishw1.cre~  ~override~ // Commoner
              ~cefgt02.cre~  ~override~ // Shadow Druid
              ~cefgt04.cre~  ~override~ // Shadow Druid
              ~cpchick1.cre~ ~override~ // Party's Dog
              ~cpchick2.cre~ ~override~ // Surly's Dog
              ~dgdru01.cre~  ~override~ // Druid
              ~dogwisu.cre~  ~override~ // Rabid Dog
              ~drshlo01.cre~ ~override~ // Loren
              ~drshlo02.cre~ ~override~ // Loren
              ~drshsp01.cre~ ~override~ // Spirit of the Grove
              ~drush.cre~    ~override~ // Drush
              ~ffbiff01.cre~ ~override~ // Biff The Understudy
              ~ffcook.cre~   ~override~ // Uda the Cook
              ~ffcrowd1.cre~ ~override~ // Nobleman
              ~ffcrowd5.cre~ ~override~ // Commoner
              ~figpit.cre~   ~override~ // Storekeep
              ~gdruid.cre~   ~override~ // Druid
              ~golem01.cre~  ~override~ // Clay Golem
              ~grhog01.cre~  ~override~ // Groundhog
              ~igolem02.cre~ ~override~ // Jailkeep Golem
              ~iotyugh.cre~  ~override~ // Otyugh
              ~jaguarsu.cre~ ~override~ // Jaguar
              ~jahaboam.cre~ ~override~ // Jahaboam
              ~kelzomb.cre~  ~override~ // Zombie
              ~merchant.cre~ ~override~ // Bel Dalemark
              ~moose.cre~    ~override~ // Moose
              ~obsgol01.cre~ ~override~ // Guardian Golem
              ~otyugh.cre~   ~override~ // Otyugh
              ~otyugh01.cre~ ~override~ // Otyugh
              ~pheas01.cre~  ~override~ // Pheasant
              ~postul6.cre~  ~override~ // Nobleman
              ~ppiron.cre~   ~override~ // Clay Golem
              ~rabbit.cre~   ~override~ // Rabbit
              ~sbutler.cre~  ~override~ // Commoner
              ~scjerlia.cre~ ~override~ // Jerlia the Ore Merchant
              ~scqar.cre~    ~override~ // Qar Jysstev
              ~sevdru01.cre~ ~override~ // Alatelo De Bonito
              ~shop01.cre~   ~override~ // Mira
              ~shop02.cre~   ~override~ // Arnolinus
              ~shop04.cre~   ~override~ // Enge
              ~shop05.cre~   ~override~ // Perter
              ~shop06.cre~   ~override~ // Hes
              ~shop07.cre~   ~override~ // Storekeep
              ~shop1.cre~    ~override~ // Storekeep
              ~shop2.cre~    ~override~ // Storekeep
              ~shop3.cre~    ~override~ // Storekeep
              ~shop4.cre~    ~override~ // Storekeep
              ~shop5.cre~    ~override~ // Perter
              ~shop6.cre~    ~override~ // Hes
              ~shop7.cre~    ~override~ // Storekeep
              ~shop8.cre~    ~override~ // Galoomp the Bookkeeper
              ~sleepfh.cre~  ~override~ // Sleeping Woman
              ~sleepmh.cre~  ~override~ // Sleeping Man
              ~slshop01.cre~ ~override~ // Black Market Thief
              ~squirl.cre~   ~override~ // Squirrel
              ~squirr.cre~   ~override~ // Squirrel
              ~tdr10a.cre~   ~override~ // Kyland Lind
              ~tdr10b.cre~   ~override~ // Shadow Druid
              ~tdr6a.cre~    ~override~ // Shadow Druid
              ~tdr8a.cre~    ~override~ // Shadow Druid
              ~tdr8b.cre~    ~override~ // Shadow Druid
              ~trcar01.cre~  ~override~ // Raafee
              ~trcar04.cre~  ~override~ // Caravan Merchant
              ~trcut02.cre~  ~override~ // Nobleman
              ~trevil02.cre~ ~override~ // Guardian of the Source
              ~trevil03.cre~ ~override~ // Master Verthan
              ~trmer01.cre~  ~override~ // Peddler
              ~trmer02.cre~  ~override~ // Merchant
              ~trnobm01.cre~ ~override~ // Sir Parick
              ~trple04.cre~  ~override~ // Customer
              ~trskin02.cre~ ~override~ // Tiris
              ~trtavp05.cre~ ~override~ // Alenina
              ~ttser1.cre~   ~override~ // Jospil
              ~ttser2.cre~   ~override~ // Servant
              ~ttskel.cre~   ~override~ // Skeleton
              ~uddear02.cre~ ~override~ // Uder Mordin
              ~uddoor07.cre~ ~override~ // Skeleton
              ~udduer01.cre~ ~override~ // Carlig
              ~udgolem.cre~  ~override~ // Brain Golem
              ~udtrap02.cre~ ~override~ // Raevilin Strathi
              ~uhogre03.cre~ ~override~ // Minotaur
              ~wauksqu.cre~  ~override~ // Squirrel
              ~welther.cre~  ~override~ // Welther
              ~wmart1.cre~   ~override~ // Joluv
              ~yarin.cre~    ~override~ // Yarin
              ~yscara01.cre~ ~override~ // Merchant
              ~yscara02.cre~ ~override~ // Merchant
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 34 // alignment: true neutral
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~amsmug01.cre~ ~override~ // Smuggler
              ~antenos.cre~  ~override~ // Antenos
              ~arntra02.cre~ ~override~ // Trainee
              ~arntra06.cre~ ~override~ // Shadow Thief
              ~bdock1.cre~   ~override~ // Dockhand Ogre
              ~bdock2.cre~   ~override~ // Dockhand Ogre
              ~beast.cre~    ~override~ // Beastmaster
              ~bmugg1.cre~   ~override~ // Mugger
              ~chtaz02.cre~  ~override~ // Tamoko
              ~copcust3.cre~ ~override~ // Nobleman
              ~cujon.cre~    ~override~ // Jon Irenicus
              ~cujon2.cre~   ~override~ // Jon Irenicus
              ~cujon3.cre~   ~override~ // Jon Irenicus
              ~cujon4.cre~   ~override~ // Jon Irenicus
              ~dedsmug.cre~  ~override~ // Smuggler
              ~dpjon01.cre~  ~override~ // Jon Irenicus
              ~dpjon02.cre~  ~override~ // Jon Irenicus
              ~dream2.cre~   ~override~ // Jon Irenicus
              ~driren.cre~   ~override~ // Jon Irenicus
              ~drjon.cre~    ~override~ // Jon Irenicus
              ~elemep01.cre~ ~override~ // Ooze Mephit
              ~elemep02.cre~ ~override~ // Steam Mephit
              ~elemep03.cre~ ~override~ // Salt Mephit
              ~elemep04.cre~ ~override~ // Fire Mephit
              ~elemep05.cre~ ~override~ // Magma Mephit
              ~elemep06.cre~ ~override~ // Earth Mephit
              ~elemep07.cre~ ~override~ // Mineral Mephit
              ~elemep08.cre~ ~override~ // Dust Mephit
              ~elemhydr.cre~ ~override~ // Olhydra
              ~firamb02.cre~ ~override~ // Gerg
              ~firban04.cre~ ~override~ // Orc
              ~firban05.cre~ ~override~ // Orc
              ~firorc02.cre~ ~override~ // Derg the Orc
              ~gorch.cre~    ~override~ // Gorch
              ~gpfam1.cre~   ~override~ // Pitch
              ~hellho01.cre~ ~override~ // Hell Hound
              ~hellslay.cre~ ~override~ // Slayer
              ~hlmage.cre~   ~override~ // Mage
              ~jadermin.cre~ ~override~ // Dermin Courtierdale
              ~jaga3.cre~    ~override~ // Nadinal
              ~jamage1.cre~  ~override~ // Gracien
              ~jamage2.cre~  ~override~ // Malacazar
              ~jarlaxle.cre~ ~override~ // Jarlaxle
              ~jon1.cre~     ~override~ // Jon Irenicus
              ~korcrazy.cre~ ~override~ // Crazyface
              ~kproen01.cre~ ~override~ // Lord Roenall
              ~legdor.cre~   ~override~ // Legdoril
              ~lin.cre~      ~override~ // Lin
              ~obsfir02.cre~ ~override~ // Fire Mephit
              ~obsfir03.cre~ ~override~ // Magma Mephit
              ~obsfir04.cre~ ~override~ // Smoke Mephit
              ~obsfir05.cre~ ~override~ // Hell Hound
              ~obsice02.cre~ ~override~ // Ice Mephit
              ~pardru.cre~   ~override~ // Sorsha
              ~pbhunt04.cre~ ~override~ // Bounty Hunter
              ~pcapt02.cre~  ~override~ // Prison Captain
              ~pcapt03.cre~  ~override~ // Prison Captain
              ~pcapt04.cre~  ~override~ // Prison Captain
              ~pcapt05.cre~  ~override~ // Prison Captain
              ~pcapt06.cre~  ~override~ // Prison Captain
              ~ppireni1.cre~ ~override~ // Coordinator
              ~ppireni2.cre~ ~override~ // Jon Irenicus
              ~reband04.cre~ ~override~ // Bandit
              ~reband05.cre~ ~override~ // Bandit
              ~recler02.cre~ ~override~ // Cleric
              ~redilav.cre~  ~override~ // Dilav
              ~reeldar.cre~  ~override~ // Eldarin
              ~remage02.cre~ ~override~ // Slaver Wizard
              ~rengaa.cre~   ~override~ // Rengaard
              ~sargrd07.cre~ ~override~ // Fighter
              ~sargrd08.cre~ ~override~ // Fighter
              ~sargrd10.cre~ ~override~ // Fighter
              ~sargrd11.cre~ ~override~ // Fighter
              ~sethle.cre~   ~override~ // Sethle
              ~sewdue01.cre~ ~override~ // Duergar Sapper
              ~sewdue02.cre~ ~override~ // Duergar Sapper
              ~seworo01.cre~ ~override~ // Elite Orog
              ~sewyag01.cre~ ~override~ // Duergar Sapper
              ~sewyag03.cre~ ~override~ // Elite Orog
              ~shagbag.cre~  ~override~ // Shagbag
              ~sujon.cre~    ~override~ // Jon Irenicus
              ~sujon2.cre~   ~override~ // Jon Irenicus
              ~teltief1.cre~ ~override~ // Tiefling
              ~terrece.cre~  ~override~ // Terrece
              ~trcut05.cre~  ~override~ // Lady Lilith Lurraxol
              ~trcut06.cre~  ~override~ // Lord Skarmaen Alibakkar
              ~trfued01.cre~ ~override~ // Lady Lilith Lurraxol
              ~trfued05.cre~ ~override~ // Lord Skarmaen Alibakkar
              ~yaga03.cre~   ~override~ // Lieutenant Fighter
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 35 // alignment: neutral evil
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~c6elf1.cre~   ~override~ // Elven Warrior
              ~c6elhan.cre~  ~override~ // Elhan
              ~c6elven2.cre~ ~override~ // Elven War Guard
              ~c6elvenw.cre~ ~override~ // Elven War Guard
              ~chgood04.cre~ ~override~ // Elven Warrior
              ~chgood05.cre~ ~override~ // Elven Warrior
              ~cupris1.cre~  ~override~ // Elven Warrior
              ~cupris2.cre~  ~override~ // Elven Warrior
              ~daelf.cre~    ~override~ // Elven Mage
              ~daelf2.cre~   ~override~ // Elven Mage
              ~dreself1.cre~ ~override~ // Elf Male
              ~dreself2.cre~ ~override~ // Elf Female
              ~dreself3.cre~ ~override~ // Elf Male
              ~dreself4.cre~ ~override~ // Elf Female
              ~dreself5.cre~ ~override~ // Elf Male
              ~dreself6.cre~ ~override~ // Elf Female
              ~dreself7.cre~ ~override~ // Elf Male
              ~hellgen.cre~  ~override~ // Enslaved Genie
              ~jarev4.cre~   ~override~ // Harper
              ~m05elf1.cre~  ~override~ // Elven Warrior
              ~m05elf2.cre~  ~override~ // Elven Warrior
              ~m05spir1.cre~ ~override~ // Elven Spirit
              ~m05spir2.cre~ ~override~ // Elven Spirit
              ~pirmur09.cre~ ~override~ // Golin
              ~sarelf01.cre~ ~override~ // Elven Man
              ~sarelf02.cre~ ~override~ // Elven Man
              ~sarelf03.cre~ ~override~ // Elven Woman
              ~sarelf04.cre~ ~override~ // Elven Woman
              ~sarelf05.cre~ ~override~ // Elf
              ~sarelf06.cre~ ~override~ // Elf
              ~suavatar.cre~ ~override~ // Avatar of Rillifane
              ~sudead01.cre~ ~override~ // Elven Warrior
              ~sudead02.cre~ ~override~ // Elven Warrior
              ~sudead03.cre~ ~override~ // Elven Warrior
              ~sudemin.cre~  ~override~ // Priestess Demin
              ~suelf1.cre~   ~override~ // Elf
              ~suelf10.cre~  ~override~ // Reirra
              ~suelf12.cre~  ~override~ // Captain Aduo'on
              ~suelf13.cre~  ~override~ // Elven Warrior
              ~suelf2.cre~   ~override~ // Elf
              ~suelf3.cre~   ~override~ // Elven Warrior
              ~suelf6.cre~   ~override~ // Elven Warrior
              ~suelf7.cre~   ~override~ // Elven Warrior
              ~suelf8.cre~   ~override~ // Elven Warrior
              ~suelfw1.cre~  ~override~ // Elven Warrior
              ~suelfw10.cre~ ~override~ // Elven Battle Mage
              ~suelfw11.cre~ ~override~ // Elven Battle Mage
              ~suelfw12.cre~ ~override~ // Elven Battle Mage
              ~suelfw13.cre~ ~override~ // Elven Archer
              ~suelfw14.cre~ ~override~ // Elven Archer
              ~suelfw15.cre~ ~override~ // Elven Archer
              ~suelfw2.cre~  ~override~ // Elven Warrior
              ~suelfw3.cre~  ~override~ // Elven Warrior
              ~suelfw4.cre~  ~override~ // Elven Warrior
              ~suelfw5.cre~  ~override~ // Elven Warrior
              ~suelfw6.cre~  ~override~ // Elven Warrior
              ~suelfw7.cre~  ~override~ // Elven Warrior
              ~suelfw8.cre~  ~override~ // Elven Warrior
              ~suelfw9.cre~  ~override~ // Elven Battle Mage
              ~suelhan.cre~  ~override~ // Elhan
              ~suelleg1.cre~ ~override~ // Elven Warrior
              ~suendel1.cre~ ~override~ // Elven Warrior
              ~suendel2.cre~ ~override~ // Elven Warrior
              ~suendel3.cre~ ~override~ // Elf Male
              ~suendel4.cre~ ~override~ // Elf Female
              ~suendel5.cre~ ~override~ // Elf
              ~suendel6.cre~ ~override~ // Elf
              ~suendel7.cre~ ~override~ // Elven Warrior
              ~suendel8.cre~ ~override~ // Elven Warrior
              ~sumoon.cre~   ~override~ // Elven Warrior
              ~udelf01.cre~  ~override~ // War Elf
              ~udelf02.cre~  ~override~ // War Elf
              ~udelf03.cre~  ~override~ // War Elf
              ~udelf04.cre~  ~override~ // War Elf
              ~udelf05.cre~  ~override~ // War Elf
              ~warsage.cre~  ~override~ // Elven War Sage
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 49 // alignment: chaotic good
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~c6lanf.cre~   ~override~ // Lanfear
              ~clrani01.cre~ ~override~ // Rania
              ~crothf01.cre~ ~override~ // Tiiro
              ~crothf02.cre~ ~override~ // Aulava
              ~gereth.cre~   ~override~ // Gereth
              ~gorcamb.cre~  ~override~ // Aesgareth
              ~gorsal.cre~   ~override~ // Saladrex
              ~gromnir.cre~  ~override~ // Gromnir Il-Khan
              ~lout.cre~     ~override~ // Vittorio
              ~rngwlf01.cre~ ~override~ // Anath
              ~rngwlf02.cre~ ~override~ // Anath
              ~rngwlf03.cre~ ~override~ // Anath
              ~rngwlf04.cre~ ~override~ // Anath
              ~rngwlf05.cre~ ~override~ // Anath
              ~sarthf01.cre~ ~override~ // Hectan
              ~sarthf02.cre~ ~override~ // Squip
              ~shth01.cre~   ~override~ // Hanz
              ~shth03.cre~   ~override~ // Kretor
              ~shth04.cre~   ~override~ // Morsa
              ~shth06.cre~   ~override~ // Varia
              ~shthdr01.cre~ ~override~ // Brannel
              ~shthlt02.cre~ ~override~ // Lathan
              ~slcent.cre~   ~override~ // Amnish Centurion
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 50 // alignment: chaotic neutral
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~acolyte1.cre~ ~override~ // Talon Zogas
              ~ar18prie.cre~ ~override~ // Priest of Cyric
              ~bazeye01.cre~ ~override~ // Iycanth the Mad
              ~bazeye02.cre~ ~override~ // Iycanth the Mad
              ~c6drow1.cre~  ~override~ // Drow
              ~caehan.cre~   ~override~ // Caehan
              ~cldad.cre~    ~override~ // Talon Nirkhas
              ~clstkn01.cre~ ~override~ // Storm Knight
              ~cltalp01.cre~ ~override~ // Weather Master
              ~daqilue.cre~  ~override~ // Qilue
              ~dvampfl.cre~  ~override~ // Vampire
              ~eletro02.cre~ ~override~ // Troll
              ~gnlcap01.cre~ ~override~ // Gnoll Captain
              ~gnleli01.cre~ ~override~ // Gnoll Elite
              ~gnlsla01.cre~ ~override~ // Gnoll Slasher
              ~gnlvet01.cre~ ~override~ // Gnoll Veteran
              ~gnlwar01.cre~ ~override~ // Gnoll
              ~gnoll01.cre~  ~override~ // Gnoll
              ~gnollsu.cre~  ~override~ // Gnoll Elite
              ~gpmage1.cre~  ~override~ // N'ashtar
              ~gppri1.cre~   ~override~ // Chandrilla
              ~gpsimb.cre~   ~override~ // Simbja
              ~hlketta.cre~  ~override~ // Ketta
              ~hlketta2.cre~ ~override~ // Ketta
              ~hlskull.cre~  ~override~ // Golden Skull
              ~hobarc01.cre~ ~override~ // Hobgoblin Archer
              ~hobarc02.cre~ ~override~ // Hobgoblin Archer
              ~hobcap01.cre~ ~override~ // Hobgoblin Captain
              ~hobeli01.cre~ ~override~ // Hobgoblin Elite
              ~hobwar01.cre~ ~override~ // Hobgoblin Warrior
              ~hobwiz01.cre~ ~override~ // Hobgoblin Wizard
              ~jaerto1.cre~  ~override~ // Jarden
              ~jaerto2.cre~  ~override~ // Turg
              ~jaerto3.cre~  ~override~ // Tamile
              ~jaerto4.cre~  ~override~ // Wurn
              ~jaertof.cre~  ~override~ // Ertof Dand
              ~jaga2.cre~    ~override~ // Kail
              ~jaga4.cre~    ~override~ // Iko
              ~kalah.cre~    ~override~ // Kalah
              ~kalah2.cre~   ~override~ // Kalah
              ~kaol.cre~     ~override~ // Kaol
              ~kaypal01.cre~ ~override~ // Anarg
              ~nalla.cre~    ~override~ // Stormherald Nallabir
              ~obshal01.cre~ ~override~ // Entu
              ~obshal03.cre~ ~override~ // Necre
              ~obshal06.cre~ ~override~ // Taibela
              ~ogre01.cre~   ~override~ // Ogre
              ~pirmur01.cre~ ~override~ // Galvena
              ~pirmur02.cre~ ~override~ // Assassin
              ~pirpir01.cre~ ~override~ // Pirate
              ~pirpir02.cre~ ~override~ // Andar the Pirate
              ~pirpir03.cre~ ~override~ // Olben the Pirate
              ~pirpir05.cre~ ~override~ // Chremy
              ~pirpir07.cre~ ~override~ // Pirate Bill
              ~pirpir08.cre~ ~override~ // Pirate Dan
              ~pirpir09.cre~ ~override~ // Pirate Jimmy
              ~pirpir10.cre~ ~override~ // Pirate Scotty
              ~pirpir11.cre~ ~override~ // Pirate Paul
              ~pirpir12.cre~ ~override~ // Pirate Newf
              ~pirsea01.cre~ ~override~ // Pirate Captain
              ~pirsea02.cre~ ~override~ // Pirate
              ~pirsea03.cre~ ~override~ // Pirate
              ~plass02.cre~  ~override~ // Assassin
              ~plass03.cre~  ~override~ // Assassin
              ~plass04.cre~  ~override~ // Assassin
              ~ppdesh.cre~   ~override~ // Desharik
              ~ppdesh2.cre~  ~override~ // Desharik
              ~ppdoor.cre~   ~override~ // Pirate Door Guard
              ~ppduel1.cre~  ~override~ // Andante
              ~ppduel2.cre~  ~override~ // Dirbish the Black
              ~ppduelc.cre~  ~override~ // Duel Coordinator
              ~ppguard.cre~  ~override~ // Pirate
              ~ppguarda.cre~ ~override~ // Pirate
              ~pplackey.cre~ ~override~ // Pirate
              ~ppldr01.cre~  ~override~ // Pirate Leader
              ~ppmag01.cre~  ~override~ // Pirate Mage
              ~pppirate.cre~ ~override~ // Pirate
              ~ppsail01.cre~ ~override~ // Pirate
              ~ppsail02.cre~ ~override~ // Pirate
              ~ppsail03.cre~ ~override~ // Pirate
              ~ppthf01.cre~  ~override~ // Pirate
              ~ppthf02.cre~  ~override~ // Pirate
              ~pptiax.cre~   ~override~ // Tiax
              ~pptiax2.cre~  ~override~ // Tiax
              ~ppumb01.cre~  ~override~ // Priestess of Umberlee
              ~reband01.cre~ ~override~ // Bandit
              ~reband02.cre~ ~override~ // Bandit
              ~rorcs01.cre~  ~override~ // Orog
              ~ruffian.cre~  ~override~ // Amalas
              ~sahkng01.cre~ ~override~ // King Ixilthetocal
              ~sahkng02.cre~ ~override~ // King Ixilthetocal
              ~samia.cre~    ~override~ // Samia
              ~sarbul04.cre~ ~override~ // Gromnir Soldier
              ~sarbul05.cre~ ~override~ // Gromnir Soldier
              ~sarbul06.cre~ ~override~ // Il-Khan Soldier
              ~sarbul07.cre~ ~override~ // Il-Khan Soldier
              ~scyarryl.cre~ ~override~ // Talon Yarryl
              ~sevpat01.cre~ ~override~ // Mencar Pebblecrusher
              ~sevpat04.cre~ ~override~ // Smaeluv Orcslicer
              ~shadel.cre~   ~override~ // Shade Lord
              ~slapri.cre~   ~override~ // Priest of Cyric
              ~talkni01.cre~ ~override~ // Storm Knight
              ~talkni02.cre~ ~override~ // Storm Knight
              ~talmiss.cre~  ~override~ // Mistress Ada
              ~talmiss2.cre~ ~override~ // Mistress Ada
              ~talvilon.cre~ ~override~ // Acolyte Vilon
              ~tanthf01.cre~ ~override~ // Rune Assassin
              ~telsuc1.cre~  ~override~ // Alu-Fiend
              ~teltief3.cre~ ~override~ // Tiefling
              ~trevil01.cre~ ~override~ // Lord Khellon Menold
              ~trskin03.cre~ ~override~ // Rejiek Hidesman
              ~trskin06.cre~ ~override~ // Darsidian Moor
              ~trskin3b.cre~ ~override~ // Rejiek Hidesman
              ~trskin6b.cre~ ~override~ // Darsidian Moor
              ~trskind2.cre~ ~override~ // Darsidian Moor
              ~uddoor01.cre~ ~override~ // Drow
              ~uddoor02.cre~ ~override~ // Drow
              ~uddoor03.cre~ ~override~ // Drow
              ~uddrow06.cre~ ~override~ // Ilmryn
              ~uddrow12.cre~ ~override~ // Drow
              ~uddrow14.cre~ ~override~ // Drow
              ~uddrow15.cre~ ~override~ // Drow
              ~uddrow18.cre~ ~override~ // Drow
              ~uddrow20.cre~ ~override~ // Egg Guard
              ~uddrow21.cre~ ~override~ // Egg Guard
              ~uddrow23.cre~ ~override~ // Drow
              ~uddrow24.cre~ ~override~ // Drow
              ~uddrow25.cre~ ~override~ // Drow
              ~uddrow26.cre~ ~override~ // Drow
              ~uddrow27.cre~ ~override~ // Drow
              ~uddrow28.cre~ ~override~ // Drow
              ~uddrow29.cre~ ~override~ // Drow
              ~uddrow31.cre~ ~override~ // Drow
              ~uddrow36.cre~ ~override~ // Handmaiden of Lolth
              ~uddrow37.cre~ ~override~ // Drow
              ~udrunner.cre~ ~override~ // Drow
              ~vampbat.cre~  ~override~ // Vampire
              ~vicg2.cre~    ~override~ // Fanatic
              ~yssold04.cre~ ~override~ // Yaga-Shura Elite
              ~yssold16.cre~ ~override~ // Cleric Of Talos
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 51 // alignment: chaotic evil
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~BDTURM03.CRE~ ~override~
              ~CLCOTI01.CRE~ ~override~
              ~COWENF1.CRE~  ~override~
              ~COWENF3.CRE~  ~override~
              ~COWENF4.CRE~  ~override~
              ~EYEVIG01.CRE~ ~override~
              ~FIRMAG01.CRE~ ~override~
              ~FSMAGE01.CRE~ ~override~
              ~FSMAGE02.CRE~ ~override~
              ~FSMAGE03.CRE~ ~override~
              ~HLLAYEN.CRE~  ~override~
              ~HSPECTR2.CRE~ ~override~
              ~RIFTG03.CRE~  ~override~
              ~SAHBEH03.CRE~ ~override~
              ~SLVIC02.CRE~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 1 // human
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~ALUFIE01.CRE~ ~override~
              ~ARNMAN07.CRE~ ~override~
              ~BOUNHA.CRE~   ~override~
              ~CHEVIL09.CRE~ ~override~
              ~COPAMB03.CRE~ ~override~
              ~CSIREN.CRE~   ~override~
              ~CSJON.CRE~    ~override~
              ~CUJON.CRE~    ~override~
              ~CUJON2.CRE~   ~override~
              ~CUJON3.CRE~   ~override~
              ~CUJON4.CRE~   ~override~
              ~D1MOTHEL.CRE~ ~override~
              ~DEMFIG02.CRE~ ~override~
              ~DPJON01.CRE~  ~override~
              ~DPJON02.CRE~  ~override~
              ~DREAM2.CRE~   ~override~
              ~DRIREN.CRE~   ~override~
              ~DRJON.CRE~    ~override~
              ~EYESNT01.CRE~ ~override~
              ~GORSTA02.CRE~ ~override~
              ~GORSTA09.CRE~ ~override~
              ~GORSTA11.CRE~ ~override~
              ~HARPASS1.CRE~ ~override~
              ~HELLJON.CRE~  ~override~
              ~HELLJON2.CRE~ ~override~
              ~HLARCH.CRE~   ~override~
              ~HSPECTR1.CRE~ ~override~
              ~HSPECTR3.CRE~ ~override~
              ~JADE1.CRE~    ~override~
              ~JAHEI1.CRE~   ~override~
              ~JAREV1.CRE~   ~override~
              ~JON1.CRE~     ~override~
              ~LIFE01.CRE~   ~override~
              ~LIFE02.CRE~   ~override~
              ~LIFE03.CRE~   ~override~
              ~LIFE04.CRE~   ~override~
              ~MGAPPR01.CRE~ ~override~
              ~PPDRA2.CRE~   ~override~
              ~PPDRADEE.CRE~ ~override~
              ~PPIRENI1.CRE~ ~override~
              ~PPIRENI2.CRE~ ~override~
              ~PPSUNA.CRE~   ~override~
              ~RIELEV.CRE~   ~override~
              ~SENANI01.CRE~ ~override~
              ~SENANI02.CRE~ ~override~
              ~SENDRO01.CRE~ ~override~
              ~SENDRO02.CRE~ ~override~
              ~SENFOD01.CRE~ ~override~
              ~SENFOD02.CRE~ ~override~
              ~SENGUA01.CRE~ ~override~
              ~SENKEN01.CRE~ ~override~
              ~SUELF10.CRE~  ~override~
              ~SUJON.CRE~    ~override~
              ~SUJON2.CRE~   ~override~
              ~SUNA.CRE~     ~override~
              ~THRAXI.CRE~   ~override~
              ~TOLMAG02.CRE~ ~override~
              ~VALRAN01.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 2 // elf
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~BEAST.CRE~    ~override~
              ~DKHALID.CRE~  ~override~
              ~DKHALID2.CRE~ ~override~
              ~KAYSMG01.CRE~ ~override~
              ~LIN.CRE~      ~override~
              ~SHANK.CRE~    ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 3 // half-elf
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~D1MOTHDW.CRE~ ~override~
              ~DRUFF2.CRE~   ~override~
              ~DUEMAG01.CRE~ ~override~
              ~DUEMAG02.CRE~ ~override~
              ~GORSTA04.CRE~ ~override~
//              ~NEB.CRE~      ~override~
              ~SARDW01.CRE~  ~override~
              ~SARDW02.CRE~  ~override~
              ~SLEEPDW.CRE~  ~override~
              ~TOBPAR05.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 4 // dwarf
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~BBEGG2.CRE~   ~override~
              ~CHGOOD01.CRE~ ~override~
              ~D1MOTHHA.CRE~ ~override~
              ~DISRUP01.CRE~ ~override~
              ~ESCORT2.CRE~  ~override~
              ~ESCORT2A.CRE~ ~override~
              ~MOURNER6.CRE~ ~override~
              ~SARBHA02.CRE~ ~override~
              ~SARHAL.CRE~   ~override~
              ~TREVIL01.CRE~ ~override~
              ~WELLYN.CRE~   ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 5 // halfling
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~EYESEK01.CRE~ ~override~
              ~UDSVIR07.CRE~ ~override~
              ~UDSVIR08.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 6 // gnome
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~EYEGOR01.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 102 // basilisk
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~GIBBER01.CRE~ ~override~
              ~GIBBERSU.CRE~ ~override~
              ~FSGIBB.CRE~   ~override~
              ~TTGIBB.CRE~   ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 109 // gibberling
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~HLMAFER.CRE~ ~override~
  WRITE_BYTE 0x0272 110 // gnoll
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~HOBELI01.CRE~ ~override~
              ~HOBGOB01.CRE~ ~override~
              ~HOBGOBSU.CRE~ ~override~
  WRITE_BYTE 0x0272 111 // hobgoblin
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~FSGOBL.CRE~  ~override~
              ~ICGOB03.CRE~ ~override~
              ~ICGOB04.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 112 // kobold
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~CEGLUT.CRE~   ~override~
              ~GORSTA12.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 113 // ogre
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~SAHSKEL.CRE~  ~override~
              ~SKELWA02.CRE~ ~override~
              ~SKELWA03.CRE~ ~override~
              ~SKELWASU.CRE~ ~override~
  WRITE_BYTE 0x0272 115 // skeleton
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~SLIFIS01.CRE~ ~override~
              ~SLIFIS02.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 119 // slime
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~HAMASU.CRE~   ~override~
              ~KSLAVE01.CRE~ ~override~
              ~RSPIRIT1.CRE~ ~override~
  WRITE_BYTE 0x0272 120 // fairy
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~AEWERE2.CRE~ ~override~
              ~AEWERE3.CRE~ ~override~
              ~AEWERE4.CRE~ ~override~
              ~AEWERE5.CRE~ ~override~
              ~AEWERE6.CRE~ ~override~
  WRITE_BYTE 0x0272 122 // lycanthrope
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~GORMIND.CRE~  ~override~
              ~MINDUL01.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 124 // mindflayer
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~OTYUGH01.CRE~ ~override~
  WRITE_BYTE 0x0272 127 // otyugh
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~RAKRUH01.CRE~ ~override~
  WRITE_BYTE 0x0272 128 // rakshasa
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~kptrol01.cre~ ~override~
              ~kptrol02.cre~ ~override~
              ~kptrol03.cre~ ~override~
              ~kptrol04.cre~ ~override~
              ~kptrol05.cre~ ~override~
              ~kptrol06.cre~ ~override~
              ~trolde01.cre~ ~override~
              ~trolde02.cre~ ~override~
              ~trolfr01.cre~ ~override~
              ~trolfr02.cre~ ~override~
              ~trolgi01.cre~ ~override~
              ~trolgi02.cre~ ~override~
              ~trolic01.cre~ ~override~
              ~trolic02.cre~ ~override~
              ~trolic03.cre~ ~override~
              ~trolic04.cre~ ~override~
              ~troll01.cre~  ~override~
              ~troll02.cre~  ~override~
              ~troll03.cre~  ~override~
              ~trollens.cre~ ~override~
              ~trollsm2.cre~ ~override~
              ~trolsi01.cre~ ~override~
              ~trolsi02.cre~ ~override~
              ~trolsn01.cre~ ~override~
              ~trolsn02.cre~ ~override~
              ~trolsp01.cre~ ~override~
              ~trolsp02.cre~ ~override~
              ~troluo01.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 129 // troll
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~SAHANGU.CRE~ ~override~
  WRITE_BYTE 0x0272 131 // sahuagin
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~BODFGT01.CRE~ ~override~
              ~BODFGT02.CRE~ ~override~
              ~DRSHSP01.CRE~ ~override~
              ~ELEARB01.CRE~ ~override~
              ~ELEARB02.CRE~ ~override~
              ~ELEARB03.CRE~ ~override~
              ~ELEARB04.CRE~ ~override~
              ~ELEARB05.CRE~ ~override~
              ~ELEARB06.CRE~ ~override~
              ~ELEARB07.CRE~ ~override~
              ~ELEARB08.CRE~ ~override~
              ~ELEARB09.CRE~ ~override~
              ~ELEARB10.CRE~ ~override~
              ~ELEARB11.CRE~ ~override~
              ~ELEPUZ01.CRE~ ~override~
              ~ELEPUZ02.CRE~ ~override~
              ~ELEPUZ03.CRE~ ~override~
              ~ELEPUZ04.CRE~ ~override~
              ~SENSTALK.CRE~ ~override~
              ~STALKE.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 133 // spectre
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~BANSHE01.CRE~ ~override~
              ~EYEDED01.CRE~ ~override~
              ~FIRMON01.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 134 // wraith
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~HAKSU.CRE~    ~override~
              ~NISHRUSU.CRE~ ~override~
  WRITE_BYTE 0x0272 136 // mist
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~COPLION.CRE~  ~override~
              ~JAGUARSU.CRE~ ~override~
              ~NCAT.CRE~     ~override~
              ~SLCAT.CRE~    ~override~
              ~SPIRLION.CRE~ ~override~
              ~TRANIM03.CRE~ ~override~
  WRITE_BYTE 0x0272 137 // cat
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~GIAFIR01.CRE~ ~override~
              ~YAGASPIR.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 142 // giant
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~AR18FIG.CRE~  ~override~
              ~GROMG02.CRE~  ~override~
              ~HLOLAF.CRE~   ~override~
              ~KCHILD1.CRE~  ~override~
              ~KCHILD2.CRE~  ~override~
              ~SARBUL04.CRE~ ~override~
              ~TOBBAN02.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 143 // orc
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~PLYSALA.CRE~ ~override~
  WRITE_BYTE 0x0272 145 // elemental
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~SAHZOMB.CRE~  ~override~
              ~ZOMBIE01.CRE~ ~override~
              ~ZOMBSE01.CRE~ ~override~
  WRITE_BYTE 0x0272 148 // zombie
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~CEDELICH.CRE~ ~override~
              ~HGSKU01.CRE~  ~override~
              ~HLSKULL.CRE~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 150 // lich
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~RABBIT.CRE~   ~override~
              ~RABBIT01.CRE~ ~override~
  WRITE_BYTE 0x0272 151 // rabbit
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~BOUNHA04.CRE~ ~override~
              ~ICLIZ01.CRE~  ~override~
              ~ICLIZ02.CRE~  ~override~
  WRITE_BYTE 0x0272 154 // yuanti
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~PLANET01.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 158 // planatar [sic]
  END
  BUT_ONLY_IF_IT_CHANGES

// clasify ettins as ettin race so Crom Faeyr will work
COPY_EXISTING ~pettin.cre~   ~override~
              ~plshfg01.cre~ ~override~
              ~plshfg02.cre~ ~override~
              ~sahoty01.cre~ ~override~
  WRITE_BYTE 0x272 199 // race: ettin
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~STATUE01.CRE~ ~override~
              ~STATUE02.CRE~ ~override~
              ~STATUE03.CRE~ ~override~
              ~STATUE04.CRE~ ~override~
              ~STATUE05.CRE~ ~override~
              ~STATUE06.CRE~ ~override~
              ~SWORD01.CRE~  ~override~
              ~SWORD02.CRE~  ~override~
              ~SWORD03.CRE~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 201 // sword
  END
  BUT_ONLY_IF_IT_CHANGES

// racial fixes
COPY_EXISTING ~DAABOL.CRE~  ~override~
              ~MEPHSP1.CRE~ ~override~
              ~MEPHSP2.CRE~ ~override~
              ~MEPHSP3.CRE~ ~override~
              ~MEPHSP4.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0272 255 // unk
  END
  BUT_ONLY_IF_IT_CHANGES

// yuan-ti class fixes
COPY_EXISTING ~icyuan03.cre~ ~override~
              ~icyuan05.cre~ ~override~
              ~kpsham01.cre~ ~override~
              ~pbhunt03.cre~ ~override~
              ~pbhunt04.cre~ ~override~
              ~planet01.cre~ ~override~
              ~planevil.cre~ ~override~
              ~plangood.cre~ ~override~
              ~planwish.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x273 1 // mage
  END
  BUT_ONLY_IF_IT_CHANGES

// yuan-ti class fixes
COPY_EXISTING ~icyuan01.cre~ ~override~
              ~icyuan02.cre~ ~override~
              ~icyuan04.cre~ ~override~
              ~kpyuan01.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x273 2 // fighter
  END
  BUT_ONLY_IF_IT_CHANGES

// devas need to be a spellcasting classs, otherwise dispel magic cast at level 1 and fails
COPY_EXISTING ~devagood.cre~ ~override~
              ~devaevil.cre~ ~override~
              ~devast01.cre~ ~override~
              ~devmon01.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x273 3 // cleric
  END
  BUT_ONLY_IF_IT_CHANGES

// class fixes
COPY_EXISTING ~nwyvbab.cre~  ~override~
              ~plywyvrn.cre~ ~override~
              ~wyvbab01.cre~ ~override~
              ~wyvern01.cre~ ~override~
              ~wyvgre01.cre~ ~override~
  WRITE_BYTE 0x273 149 // wyvern
  BUT_ONLY_IF_IT_CHANGES

// class fixes
COPY_EXISTING ~gorjelf2.cre~ ~override~
              ~gorjelfu.cre~ ~override~
              ~pudden01.cre~ ~override~
              ~pudden02.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x273 151 // mustard jelly
  END
  BUT_ONLY_IF_IT_CHANGES

// class fixes
COPY_EXISTING ~jelgra01.cre~ ~override~
  WRITE_BYTE 0x273 153 // gray ooze
  BUT_ONLY_IF_IT_CHANGES

// class fixes
COPY_EXISTING ~gorjelgr.cre~ ~override~
              ~jelgre01.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x273 154 // green slime
  END
  BUT_ONLY_IF_IT_CHANGES

// class fixes
COPY_EXISTING ~OTYUGH01.CRE~ ~override~
  WRITE_BYTE 0x0273 165 // otyugh
  BUT_ONLY_IF_IT_CHANGES

// class fixes. note that dgtrol0[12] are excluded so as to not break druid grove scripts
COPY_EXISTING ~trolde01.cre~ ~override~
              ~trolde02.cre~ ~override~
              ~trolfr01.cre~ ~override~
              ~trolfr02.cre~ ~override~
              ~trolgi01.cre~ ~override~
              ~trolgi02.cre~ ~override~
              ~trolic01.cre~ ~override~
              ~trolic02.cre~ ~override~
              ~trolic03.cre~ ~override~
              ~trolic04.cre~ ~override~
              ~troll01.cre~  ~override~
              ~troll02.cre~  ~override~
              ~troll03.cre~  ~override~
              ~trollens.cre~ ~override~
              ~trollsm2.cre~ ~override~
              ~trolsi01.cre~ ~override~
              ~trolsi02.cre~ ~override~
              ~trolsn01.cre~ ~override~
              ~trolsn02.cre~ ~override~
              ~trolsp01.cre~ ~override~
              ~trolsp02.cre~ ~override~
              ~troluo01.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x273 167 // class: troll
  END
  BUT_ONLY_IF_IT_CHANGES
  
// class fixes
COPY_EXISTING ~pettin.cre~   ~override~
  WRITE_BYTE 0x273 180 // giant
  BUT_ONLY_IF_IT_CHANGES

// yuan-ti class fixes
COPY_EXISTING ~elemchan.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x273 186 // elemental: air
  END
  BUT_ONLY_IF_IT_CHANGES

// Wave halberd should work against salamanders
COPY_EXISTING ~plysala.cre~ ~override~
  WRITE_BYTE 0x273 187 // class: elemental_fire
  BUT_ONLY_IF_IT_CHANGES
  
// class fixes
COPY_EXISTING ~sahzomb.cre~   ~override~
  WRITE_BYTE 0x273 198 // zombie_normal
  BUT_ONLY_IF_IT_CHANGES
  
// class fixes
COPY_EXISTING ~chickdef.cre~ ~override~
              ~chicke.cre~   ~override~
              ~chicker.cre~  ~override~
              ~cow.cre~      ~override~
              ~cowh.cre~     ~override~
              ~deadcow1.cre~ ~override~
              ~deadcow2.cre~ ~override~
              ~gorstalk.cre~ ~override~
              ~mephsp1.cre~  ~override~
              ~mephsp2.cre~  ~override~
              ~mephsp3.cre~  ~override~
              ~mephsp4.cre~  ~override~
              ~nchick.cre~   ~override~
              ~ncow.cre~     ~override~
              ~senstalk.cre~ ~override~
              ~stalke.cre~   ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x273 255 // no class
  END
  BUT_ONLY_IF_IT_CHANGES

// general field fixes
COPY_EXISTING ~KCHILD1.CRE~  ~override~
              ~KCHILD2.CRE~  ~override~
              ~KUOARC20.CRE~ ~override~
              ~KUOCLE20.CRE~ ~override~
              ~SAHCHF01.CRE~ ~override~
              ~SHAGRL01.CRE~ ~override~
              ~TOWNC01.CRE~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0271 1 // humanoid
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~EYEEGL01.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0271 2 // animal
  END
  BUT_ONLY_IF_IT_CHANGES

// general field fixes
COPY_EXISTING ~BODTAN.CRE~   ~override~
              ~CEDELICH.CRE~ ~override~
              ~D1GHOST.CRE~  ~override~
              ~D1GORI.CRE~   ~override~
              ~D1MOTHDW.CRE~ ~override~
              ~D1MOTHEL.CRE~ ~override~
              ~D1MOTHHA.CRE~ ~override~
              ~D1MOTHHU.CRE~ ~override~
              ~D1SKEL.CRE~   ~override~
              ~HLSKULL.CRE~  ~override~
              ~LAUNE.CRE~    ~override~
              ~RSPIRIT1.CRE~ ~override~
              ~SAHBEH02.CRE~ ~override~
              ~SDSHADFI.CRE~ ~override~
              ~SDSHADOW.CRE~ ~override~
              ~SKELDED.CRE~  ~override~
              ~WELLYN.CRE~   ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0271 4 // undead
  END
  BUT_ONLY_IF_IT_CHANGES

// general field fixes
COPY_EXISTING ~dgtrol01.cre~ ~override~
              ~dgtrol02.cre~ ~override~
              ~DRUEAR01.CRE~ ~override~
              ~ELAIRL01.CRE~ ~override~
              ~ELAIRSU1.CRE~ ~override~
              ~ELAIRSU2.CRE~ ~override~
              ~ELAIRSU3.CRE~ ~override~
              ~ELAIRSUW.CRE~ ~override~
              ~ELEARPR.CRE~  ~override~
              ~ELEARPR2.CRE~ ~override~
              ~ELEARPR3.CRE~ ~override~
              ~ELEARSU2.CRE~ ~override~
              ~ELEARSU3.CRE~ ~override~
              ~ELEARSU4.CRE~ ~override~
              ~ELEARSUW.CRE~ ~override~
              ~ELFIRL01.CRE~ ~override~
              ~ELFIRSUW.CRE~ ~override~
              ~GENIE02.CRE~  ~override~
              ~GORAIR01.CRE~ ~override~
              ~GORSTA12.CRE~ ~override~
              ~GIAFIR01.CRE~ ~override~
              ~IGOLFLE3.CRE~ ~override~
              ~kptrol01.cre~ ~override~
              ~kptrol02.cre~ ~override~
              ~kptrol03.cre~ ~override~
              ~kptrol04.cre~ ~override~
              ~kptrol05.cre~ ~override~
              ~kptrol06.cre~ ~override~
              ~MDEARTH.CRE~  ~override~
              ~MDEARTH2.CRE~ ~override~
              ~MEKEAR01.CRE~ ~override~
              ~OBSGOL02.CRE~ ~override~
              ~plangood.cre~ ~override~
              ~PLSHFG01.CRE~ ~override~
              ~PLSHFG02.CRE~ ~override~
              ~SAHOTY01.CRE~ ~override~
              ~SARFAKI2.CRE~ ~override~
              ~SARFAKIE.CRE~ ~override~
              ~SUELEW2.CRE~  ~override~
              ~SWAAIR01.CRE~ ~override~
              ~SWAAIR02.CRE~ ~override~
              ~SWAEAR01.CRE~ ~override~
              ~SWAEAR02.CRE~ ~override~
              ~SWAFIR01.CRE~ ~override~
              ~SWAAIR01.CRE~ ~override~
              ~TORGAL.CRE~   ~override~
              ~trolde01.cre~ ~override~
              ~trolde02.cre~ ~override~
              ~trolfr01.cre~ ~override~
              ~trolfr02.cre~ ~override~
              ~trolgi01.cre~ ~override~
              ~trolgi02.cre~ ~override~
              ~trolic01.cre~ ~override~
              ~trolic02.cre~ ~override~
              ~trolic03.cre~ ~override~
              ~trolic04.cre~ ~override~
              ~troll01.cre~  ~override~
              ~troll02.cre~  ~override~
              ~troll03.cre~  ~override~
              ~trollens.cre~ ~override~
              ~trollsm2.cre~ ~override~
              ~trolsi01.cre~ ~override~
              ~trolsi02.cre~ ~override~
              ~trolsn01.cre~ ~override~
              ~trolsn02.cre~ ~override~
              ~trolsp01.cre~ ~override~
              ~trolsp02.cre~ ~override~
              ~troluo01.cre~ ~override~
              ~UHOGRE03.CRE~ ~override~
              ~YSCARA03.CRE~ ~override~
              ~YSGUAR01.CRE~ ~override~
              ~YSSOLD10.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0271 5 // giant humanoid
  END
  BUT_ONLY_IF_IT_CHANGES

// general field fixes
COPY_EXISTING ~STATUE01.CRE~ ~override~
              ~STATUE02.CRE~ ~override~
              ~STATUE03.CRE~ ~override~
              ~STATUE04.CRE~ ~override~
              ~STATUE05.CRE~ ~override~
              ~STATUE06.CRE~ ~override~
              ~SWORD01.CRE~  ~override~
              ~SWORD02.CRE~  ~override~
              ~SWORD03.CRE~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0271 101 // weapon
  END
  BUT_ONLY_IF_IT_CHANGES

// general fixes
COPY_EXISTING ~BOUNHA04.CRE~ ~override~
              ~DAABOL.CRE~   ~override~
              ~DASPITRO.CRE~ ~override~
              ~DRAGBLAC.cre~ ~override~
              ~dragshad.cre~ ~override~
              ~FINSOL04.CRE~ ~override~
              ~GLBEAR.CRE~   ~override~
              ~GORMIM01.CRE~ ~override~
              ~GORMIM02.CRE~ ~override~
              ~GORMIM03.CRE~ ~override~
              ~GORMIM04.CRE~ ~override~
              ~HAKSU.CRE~    ~override~
              ~HDRAGSIL.cre~ ~override~
              ~HDRAGRED.cre~ ~override~
              ~ICSALCOL.CRE~ ~override~
              ~ICSALFIR.CRE~ ~override~
              ~JUGMIM01.CRE~ ~override~
//              ~KPTROL05.CRE~ ~override~
              ~MEPHSP1.CRE~  ~override~
              ~MEPHSP2.CRE~  ~override~
              ~MEPHSP3.CRE~  ~override~
              ~MEPHSP4.CRE~  ~override~
              ~MIMIC01.CRE~  ~override~
              ~NISHRUSU.CRE~ ~override~
              ~OBSDEM04.CRE~ ~override~
              ~PLANEVIL.CRE~ ~override~
              ~PLANWISH.CRE~ ~override~
//              ~PPTROLL1.CRE~ ~override~
              ~RIFTCR04.CRE~ ~override~
//              ~TROLSI01.CRE~ ~override~
//              ~TROLSI02.CRE~ ~override~
//              ~TROLSN01.CRE~ ~override~
//              ~TROLSN02.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0271 255 // monster
  END
  BUT_ONLY_IF_IT_CHANGES

// sex fixes
COPY_EXISTING ~BAZLIZ01.CRE~ ~override~
              ~BAZLIZ02.CRE~ ~override~
              ~C6GOFUS.CRE~  ~override~
              ~C6KACH.CRE~   ~override~
              ~COWENF1.CRE~  ~override~
              ~cscleric.cre~ ~override~
              ~DERRICK.CRE~  ~override~
              ~dpmon01.cre~  ~override~
              ~DROFOD03.CRE~ ~override~
              ~ESCORT3.CRE~  ~override~
              ~KAYSMG01.CRE~ ~override~
              ~KPSOLD10.CRE~ ~override~
              ~KUOARC20.CRE~ ~override~
              ~PALERN.CRE~   ~override~
              ~PALKNI02.CRE~ ~override~
              ~PALKNI04.CRE~ ~override~
              ~PALKNI05.CRE~ ~override~
              ~PCAPT02.CRE~  ~override~
              ~SARBHA01.CRE~ ~override~
              ~SLVIC02.CRE~  ~override~
              ~TOBPAR04.CRE~ ~override~
              ~trfued02.cre~ ~override~
              ~WINNKEEP.CRE~ ~override~
              ~YARMY03.CRE~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0237 1 // male
  END
  BUT_ONLY_IF_IT_CHANGES

// more sex fixes
COPY_EXISTING ~AMFEM01.CRE~  ~override~
              ~AMFEM02.CRE~  ~override~
              ~AMGIRL01.CRE~ ~override~
              ~AMMONK08.CRE~ ~override~
              ~AR18ARCH.CRE~ ~override~
              ~C6CATTI.CRE~  ~override~
              ~C6CATTI2.CRE~ ~override~
              ~C6CLER3.CRE~  ~override~
              ~C6DEL.CRE~    ~override~
              ~C6GUEN.CRE~   ~override~
              ~C6GUEN2.CRE~  ~override~
              ~CEFALD02.CRE~ ~override~
              ~CHICKDEF.CRE~ ~override~
              ~CHICKE.CRE~   ~override~
              ~CHICKER.CRE~  ~override~
              ~COW.CRE~      ~override~
              ~CSHECK3.CRE~  ~override~
              ~CSSUPP2.CRE~  ~override~
              ~DEADCOW1.CRE~ ~override~
              ~DEADCOW2.CRE~ ~override~
              ~DEER01.CRE~   ~override~
              ~DEVAEVIL.CRE~ ~override~
              ~DEVAST01.CRE~ ~override~
              ~DEVMON01.CRE~ ~override~
              ~DPFEMALE.CRE~ ~override~
              ~DPSTAT05.CRE~ ~override~
              ~DROFOD02.CRE~ ~override~ // Drow, female mage (Wisp)
              ~DROFOD04.CRE~ ~override~
              ~DROW04.CRE~   ~override~
              ~DSBODY01.CRE~ ~override~
              ~FANGEL01.CRE~ ~override~
              ~FINSOL01.CRE~ ~override~
              ~garkid01.cre~ ~override~
              ~GEMCH01.CRE~  ~override~
              ~GEMCH02.CRE~  ~override~
              ~GORSTA05.CRE~ ~override~
              ~HLSHYR.CRE~   ~override~
              ~HSPECTR1.CRE~ ~override~
              ~JADE1.CRE~    ~override~
              ~JAHEI1.CRE~   ~override~
              ~JAREV1.CRE~   ~override~
              ~MGKHOL01.CRE~ ~override~
              ~NCHICK.CRE~   ~override~
              ~NCOW.CRE~     ~override~
              ~NYMPHSU.CRE~  ~override~
              ~PIRFSH02.CRE~ ~override~
              ~PIRSAL02.CRE~ ~override~
              ~PLANET01.CRE~ ~override~
              ~PLANEVIL.CRE~ ~override~
              ~PLANGOOD.CRE~ ~override~
              ~PLANWISH.CRE~ ~override~
              ~PPMAG01.CRE~  ~override~
              ~SENDAI7.CRE~  ~override~
              ~sleepfh.cre~  ~override~ // Sleeping Woman
              ~SOLAR.CRE~    ~override~
              ~SOLAR01.CRE~  ~override~
              ~SUENDEL2.CRE~ ~override~
              ~SUENDEL4.CRE~ ~override~
              ~SUENDEL6.CRE~ ~override~
              ~SUENDEL8.CRE~ ~override~
              ~TOBPAR02.CRE~ ~override~
              ~TRFTOW04.CRE~ ~override~
              ~TRSKIN01.CRE~ ~override~
              ~UDDOOR06.CRE~ ~override~
              ~UDDROW35.CRE~ ~override~
              ~VAMPAER.CRE~  ~override~
              ~VAMPJAH.CRE~  ~override~
              ~VAMPVIC.CRE~  ~override~
              ~VVMADMAN.CRE~ ~override~
              ~WPWENCH1.CRE~ ~override~
              ~YARMY01.CRE~  ~override~
              ~YSMAGE02.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0237 2 // female
  END
  BUT_ONLY_IF_IT_CHANGES

// yet more sex fixes
COPY_EXISTING ~STATUE01.CRE~ ~override~
              ~STATUE02.CRE~ ~override~
              ~STATUE03.CRE~ ~override~
              ~STATUE04.CRE~ ~override~
              ~STATUE05.CRE~ ~override~
              ~STATUE06.CRE~ ~override~
              ~SWORD01.CRE~  ~override~
              ~SWORD02.CRE~  ~override~
              ~SWORD03.CRE~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0237 3 // neither
  END
  BUT_ONLY_IF_IT_CHANGES

// gender fixes
COPY_EXISTING ~BAZLIZ01.CRE~ ~override~
              ~BAZLIZ02.CRE~ ~override~
              ~BDOCK1.CRE~   ~override~
              ~C6GOFUS.CRE~  ~override~
              ~C6KACH.CRE~   ~override~
              ~COWENF1.CRE~  ~override~
              ~DADROW2.CRE~  ~override~
              ~DADROW8.CRE~  ~override~
              ~DADROW9.CRE~  ~override~
              ~DADROW15.CRE~ ~override~
              ~dagnoll.cre~  ~override~ // Gnoll (ar2200.are)
              ~daumber.cre~  ~override~ // Umber Hulk (ar2200.are)
              ~DERRICK.CRE~  ~override~
              ~dgtrol01.CRE~ ~override~
              ~dgtrol02.CRE~ ~override~
              ~DORKUS.CRE~   ~override~
              ~DPMON01.CRE~  ~override~
              ~DROFOD02.CRE~ ~override~
              ~DROFOD03.CRE~ ~override~
              ~ESCORT3.CRE~  ~override~
              ~GITH05.CRE~   ~override~
              ~GITH06.CRE~   ~override~
              ~GORAPR.CRE~   ~override~
              ~GORGUA04.CRE~ ~override~
              ~GORGUA05.CRE~ ~override~
              ~HLMAGE.CRE~   ~override~
              ~JONDAL.CRE~   ~override~
              ~KAYSMG01.CRE~ ~override~
              ~KCHILD1.CRE~  ~override~
              ~KCHILD2.CRE~  ~override~
              ~KPROEN03.CRE~ ~override~
              ~KPSOLD10.CRE~ ~override~
              ~kptrol01.cre~ ~override~
              ~kptrol02.cre~ ~override~
              ~kptrol03.cre~ ~override~
              ~kptrol04.cre~ ~override~
              ~kptrol05.cre~ ~override~
              ~kptrol06.cre~ ~override~
              ~KRUIN.CRE~    ~override~
              ~KUOARC20.CRE~ ~override~
              ~LAVOK02.CRE~  ~override~
              ~OGRE01.CRE~   ~override~
              ~OGRHAL01.CRE~ ~override~
              ~OGRILL01.CRE~ ~override~
              ~PALERN.CRE~   ~override~
              ~PALKNI02.CRE~ ~override~
              ~PALKNI03.CRE~ ~override~
              ~PALKNI04.CRE~ ~override~
              ~PALKNI05.CRE~ ~override~
              ~PCAPT02.CRE~  ~override~
              ~PETTIN.CRE~   ~override~
              ~PLYOGRE.CRE~  ~override~
              ~PLYSALA.CRE~  ~override~
              ~RETHUG02.CRE~ ~override~
              ~RIFTG03.CRE~  ~override~
              ~SAHBEH03.CRE~ ~override~
              ~SAHOTY01.CRE~ ~override~
              ~SARBHA01.CRE~ ~override~
              ~SEWERM.CRE~   ~override~
              ~SHTH03.CRE~   ~override~
              ~SLVIC02.CRE~  ~override~
              ~TOBBAN01.CRE~ ~override~
              ~TOBPAR04.CRE~ ~override~
              ~TOLGER.CRE~   ~override~
              ~TOLGER2.CRE~  ~override~
              ~TOWNC01.CRE~  ~override~
              ~TRCUT06.CRE~  ~override~
              ~TRFUED02.CRE~ ~override~
              ~TRFUED05.CRE~ ~override~
              ~trolde01.cre~ ~override~
              ~trolde02.cre~ ~override~
              ~trolfr01.cre~ ~override~
              ~trolfr02.cre~ ~override~
              ~trolgi01.cre~ ~override~
              ~trolgi02.cre~ ~override~
              ~trolic01.cre~ ~override~
              ~trolic02.cre~ ~override~
              ~trolic03.cre~ ~override~
              ~trolic04.cre~ ~override~
              ~troll01.cre~  ~override~
              ~troll02.cre~  ~override~
              ~troll03.cre~  ~override~
              ~trollens.cre~ ~override~
              ~trollsm2.cre~ ~override~
              ~trolsi01.cre~ ~override~
              ~trolsi02.cre~ ~override~
              ~trolsn01.cre~ ~override~
              ~trolsn02.cre~ ~override~
              ~trolsp01.cre~ ~override~
              ~trolsp02.cre~ ~override~
              ~troluo01.cre~ ~override~
              ~WINNKEEP.CRE~ ~override~
              ~YARMY03.CRE~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0275 1 // male
  END
  BUT_ONLY_IF_IT_CHANGES

// gender fixes
COPY_EXISTING ~AMMONK08.CRE~ ~override~
              ~AR18ARCH.CRE~ ~override~
              ~C6CATTI.CRE~  ~override~
              ~C6CATTI2.CRE~ ~override~
              ~C6CLER3.CRE~  ~override~
              ~C6DEL.CRE~    ~override~
              ~C6GUEN2.CRE~  ~override~
              ~CEFALD02.CRE~ ~override~
              ~CHICKDEF.CRE~ ~override~
              ~CHICKE.CRE~   ~override~
              ~CHICKER.CRE~  ~override~
              ~COPLION.CRE~  ~override~
              ~COW.CRE~      ~override~
              ~CSHECK1.CRE~  ~override~
              ~CSHECK3.CRE~  ~override~
              ~CSSUPP2.CRE~  ~override~
              ~DADROW10.CRE~ ~override~
              ~DADROW23.CRE~ ~override~
              ~DAGHAUN1.CRE~ ~override~
              ~DAGHAUN2.CRE~ ~override~
              ~DEADCOW1.CRE~ ~override~
              ~DEADCOW2.CRE~ ~override~
              ~DEER01.CRE~   ~override~
//              ~DEVAGOOD.CRE~ ~override~
//              ~DEVAEVIL.CRE~ ~override~
              ~DEVAST01.CRE~ ~override~
              ~DEVMON01.CRE~ ~override~
              ~DPFEMALE.CRE~ ~override~
              ~DPSTAT05.CRE~ ~override~
              ~DROFOD04.CRE~ ~override~
              ~DROW04.CRE~   ~override~
              ~DSBODY01.CRE~ ~override~
              ~FANGEL01.CRE~ ~override~
              ~FINSOL01.CRE~ ~override~
              ~GEMCH01.CRE~  ~override~
              ~GEMCH02.CRE~  ~override~
              ~GORSTA05.CRE~ ~override~
              ~HLSHYR.CRE~   ~override~
              ~HSPECTR1.CRE~ ~override~
              ~JADE1.CRE~    ~override~
              ~JAHEI1.CRE~   ~override~
              ~JAREV1.CRE~   ~override~
              ~JAMERONI.CRE~ ~override~
              ~MGKHOL01.CRE~ ~override~
              ~NCHICK.CRE~   ~override~
              ~NCOW.CRE~     ~override~
              ~PIRFSH02.CRE~ ~override~
              ~PIRSAL02.CRE~ ~override~
              ~PLANET01.CRE~ ~override~
//              ~PLANGOOD.CRE~ ~override~
//              ~PLANEVIL.CRE~ ~override~
              ~PLANWISH.CRE~ ~override~
              ~PPBODHI3.CRE~ ~override~
              ~PPMAG01.CRE~  ~override~
              ~PPVALEN.CRE~  ~override~
              ~REMAGE01.CRE~ ~override~
              ~SENDAI7.CRE~  ~override~
              ~sleepfh.cre~  ~override~ // Sleeping Woman
              ~SUENDEL2.CRE~ ~override~
              ~SUENDEL4.CRE~ ~override~
              ~SUENDEL6.CRE~ ~override~
              ~SUENDEL8.CRE~ ~override~
              ~TOBPAR02.CRE~ ~override~
              ~TRFTOW04.CRE~ ~override~
              ~TRSKIN01.CRE~ ~override~
              ~UDDOOR06.CRE~ ~override~
              ~UDDROW35.CRE~ ~override~
              ~VAMANC01.CRE~ ~override~
              ~VAMEMI01.CRE~ ~override~
              ~VAMMAT01.CRE~ ~override~
              ~VAMPAT01.CRE~ ~override~
              ~VAMVER01.CRE~ ~override~
              ~VAMPAER.CRE~  ~override~
              ~VAMPJAH.CRE~  ~override~
              ~VAMPVIC.CRE~  ~override~
              ~VVBODHI.CRE~  ~override~
              ~VVDEL.CRE~    ~override~
              ~VVPARIS.CRE~  ~override~
              ~VVSALIA.CRE~  ~override~
              ~VVTANOV.CRE~  ~override~
              ~WPWENCH1.CRE~ ~override~
              ~YARMY01.CRE~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0275 2 // female
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~ABISRED1.CRE~ ~override~
              ~ABYDEM01.CRE~ ~override~
              ~AR18SKEL.CRE~ ~override~
              ~BEHHIV01.CRE~ ~override~
              ~BHGHOUL2.CRE~ ~override~
              ~BHGHOUL4.CRE~ ~override~
              ~DACEMIST.CRE~ ~override~
              ~DEADDEM1.CRE~ ~override~
              ~DEATHKNI.CRE~ ~override~
              ~DECK615.CRE~  ~override~
              ~DELMIST.CRE~  ~override~
              ~DEMABI01.CRE~ ~override~
              ~DEMCOR01.CRE~ ~override~
              ~DEMGLA01.CRE~ ~override~
              ~DEMPIT01.CRE~ ~override~
              ~DEMILICH.CRE~ ~override~
              ~demnab02.cre~ ~override~ // Nabassu (ar2800.are)
              ~DEMOSUM1.CRE~ ~override~
              ~DEMOSUM2.CRE~ ~override~
              ~DEMOSUM3.CRE~ ~override~
              ~DGLAB01.CRE~  ~override~
              ~DPDEM01.CRE~  ~override~
              ~DPMON02.CRE~  ~override~
              ~ELEARB01.CRE~ ~override~
              ~ELEARB02.CRE~ ~override~
              ~ELEARB03.CRE~ ~override~
              ~ELEARB04.CRE~ ~override~
              ~ELEARB05.CRE~ ~override~
              ~ELEARB06.CRE~ ~override~
              ~ELEARB07.CRE~ ~override~
              ~ELEARB08.CRE~ ~override~
              ~ELEARB09.CRE~ ~override~
              ~ELEARB10.CRE~ ~override~
              ~ELEARB11.CRE~ ~override~
              ~ELEPUZ01.CRE~ ~override~
              ~ELEPUZ02.CRE~ ~override~
              ~ELEPUZ03.CRE~ ~override~
              ~ELEPUZ04.CRE~ ~override~
              ~FIRLCH01.CRE~ ~override~
              ~FIRWRA01.CRE~ ~override~
              ~FSSKEL.CRE~   ~override~
              ~GHOGR01.CRE~  ~override~
              ~GLBEAR.CRE~   ~override~
              ~GORBAT1.CRE~  ~override~
              ~GORBAT3.CRE~  ~override~
              ~GORCAMB.CRE~  ~override~
              ~GORCHR.CRE~   ~override~
              ~gormistp.cre~ ~override~ // Poison Mist (ar3016.bcs)
              ~GORTAN1.CRE~  ~override~
              ~GORTAN4.CRE~  ~override~
              ~GORWOM05.CRE~ ~override~
              ~GRSKEL1.CRE~  ~override~
              ~GRSKEL2.CRE~  ~override~
              ~HELLFEAR.CRE~ ~override~
              ~HELLGREE.CRE~ ~override~
              ~HELLPRID.CRE~ ~override~
              ~HELLSELF.CRE~ ~override~
              ~HGMIS02.CRE~  ~override~
              ~HGSKL01.CRE~  ~override~
              ~HGSKL02.CRE~  ~override~
              ~HGSKL03.CRE~  ~override~
              ~HGWRA01.CRE~  ~override~
              ~HLDEMI.CRE~   ~override~
              ~HLSKULL.CRE~  ~override~
              ~ICFUNG02.CRE~ ~override~
              ~ICMYC01.CRE~  ~override~
              ~ICMYC02.CRE~  ~override~
              ~IGOLFLE3.CRE~ ~override~
              ~IGOLFLE4.CRE~ ~override~
              ~KELZOMB.CRE~  ~override~
              ~KSHADOW.CRE~  ~override~
              ~LESTER.CRE~   ~override~
              ~MISTHO01.CRE~ ~override~
              ~MISTWA01.CRE~ ~override~
              ~NEVM2.CRE~    ~override~
              ~OBSDEM01.CRE~ ~override~
              ~PMASTER.CRE~  ~override~
              ~PPDEMON.CRE~  ~override~
              ~PWARDEN.CRE~  ~override~
              ~PPNAB01.CRE~  ~override~
              ~PPNAB02.CRE~  ~override~
              ~PPNAB03.CRE~  ~override~
              ~RNGSHA.CRE~   ~override~
              ~RNGSHA01.CRE~ ~override~
              ~RNGSHA02.CRE~ ~override~
              ~RNGSHA03.CRE~ ~override~
              ~RNGSHA04.CRE~ ~override~
              ~RNGSHA2D.CRE~ ~override~
              ~RSKEL01.CRE~  ~override~
              ~RSKEL03.CRE~  ~override~
              ~RUMAR02.CRE~  ~override~
              ~SDSHADFI.CRE~ ~override~
              ~SDSHADOW.CRE~ ~override~
              ~SENDARK.CRE~  ~override~
              ~SEWSHA01.CRE~ ~override~
              ~SEWSHA02.CRE~ ~override~
              ~SEWSHA03.CRE~ ~override~
              ~SHADEL.CRE~   ~override~
              ~SHADELD.CRE~  ~override~
              ~SHADFI01.CRE~ ~override~
              ~SHADFI02.CRE~ ~override~
              ~SHADOW01.CRE~ ~override~
              ~SHAPE.CRE~    ~override~
              ~SHAWOL01.CRE~ ~override~
              ~SHAWOL02.CRE~ ~override~
              ~SKELAR01.CRE~ ~override~
              ~SKELAR02.CRE~ ~override~
              ~SKELE2.CRE~   ~override~
              ~SKELET01.CRE~ ~override~
              ~SKELHP1.CRE~  ~override~
              ~SLIFIS01.CRE~ ~override~
              ~SLIFIS02.CRE~ ~override~
              ~SWORD03.CRE~  ~override~
              ~TANARI01.CRE~ ~override~
              ~TANOMIST.CRE~ ~override~
              ~TELBAL1.CRE~  ~override~
              ~telcam1.cre~  ~override~ // Cambion (ar3007.are)
              ~TELCOR1.CRE~  ~override~
              ~TELPIT1.CRE~  ~override~
              ~TELPIT2.CRE~  ~override~
              ~TELSLAV.CRE~  ~override~
              ~TELTAN1.CRE~  ~override~
              ~TELTAN2.CRE~  ~override~
              ~TELWRAI.CRE~  ~override~
              ~UDDEATH.CRE~  ~override~
              ~UDDEATH2.CRE~ ~override~
              ~uddoor07.cre~ ~override~ // Skeleton (ar2402.are)
              ~UDNABA.CRE~   ~override~
              ~UHCREAT.CRE~  ~override~
              ~VALEMIST.CRE~ ~override~
              ~wish02.cre~   ~override~
              ~WOLFZO01.CRE~ ~override~
              ~WRAITH01.CRE~ ~override~
              ~WRASHI01.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x0275 4 // neither
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes summoned creature gender
COPY_EXISTING ~bearblsu.cre~ ~override~
              ~beargrsu.cre~ ~override~
              ~ettercsu.cre~ ~override~
              ~sumdjinn.cre~ ~override~
              ~sword02.cre~  ~override~
              ~worgsu.cre~   ~override~
              ~xvartsu.cre~  ~override~
  WRITE_BYTE 0x275 6 // summoned
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// creatures with invalid item fixes                \\\\\
/////                                                  \\\\\

// creatures needing items

ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB stuff
  // bow but no arrows
  COPY_EXISTING ~amarch01.cre~ ~override~
    ADD_CRE_ITEM ~arow01~ #20 #0 #0 ~NONE~ ~QUIVER1 QUIVER2 QUIVER3~

  // monk has no fist
  COPY_EXISTING ~ammonk03.cre~ ~override~
    ADD_CRE_ITEM ~mfist8~ #0 #0 #0 ~UNSTEALABLE&UNDROPPABLE~ ~WEAPON1 WEAPON2 WEAPON3 WEAPON4~ EQUIP
END

// add golem immunity items
COPY_EXISTING ~arngol01.cre~ ~override~
              ~csgolem.cre~  ~override~
              ~golem01.cre~  ~override~
              ~icbone01.cre~ ~override~
              ~igolem01.cre~ ~override~
              ~igolem02.cre~ ~override~
  ADD_CRE_ITEM ~golcla~ #0 #0 #0 ~NONE~ ~RRING~
  BUT_ONLY_IF_IT_CHANGES

// sling but no bullets
COPY_EXISTING ~edwin12.cre~ ~override~
              ~edwin13.cre~ ~override~
  ADD_CRE_ITEM ~bull01~ #20 #0 #0 ~NONE~ ~QUIVER1 QUIVER2 QUIVER3~

// arrows but no bow
COPY_EXISTING ~prisonk1.cre~ ~override~
  ADD_CRE_ITEM ~bow01~ #0 #0 #0 ~NONE~ ~WEAPON3 WEAPON4~ // already has weapon equipped

ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB stuff

  // add golem immunity items
  COPY_EXISTING ~golice01.cre~   ~override~
    ADD_CRE_ITEM ~golstone~ #0 #0 #0 ~NONE~ ~AMULET~
    BUT_ONLY_IF_IT_CHANGES

END

// arrows but no bow
COPY_EXISTING ~refigh01.cre~ ~override~
  ADD_CRE_ITEM ~bow01~ #0 #0 #0 ~NONE~ ~WEAPON2 WEAPON3 WEAPON4~ // already has weapon equipped

// juggernaut golem missing weapon and has wrong immunity
COPY_EXISTING ~tomegol4.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG  0x2bc "itm_off" ELSE 0
    READ_LONG  0x2c0 "itm_num" ELSE 0
    FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
      READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
      PATCH_IF ("%item%" STRING_COMPARE_CASE "immune1" = 0) BEGIN // find invalid resref
        WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "immune2" #8 // corrected resref
        SET "index" = "%itm_num%" // kills loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// add golem immunity items
COPY_EXISTING ~xgolem.cre~   ~override~
  ADD_CRE_ITEM ~golfle~ #0 #0 #0 ~NONE~ ~RRING~
  BUT_ONLY_IF_IT_CHANGES

// bow but no arrows
COPY_EXISTING ~yoshi11.cre~ ~override~
  ADD_CRE_ITEM ~arow01~ #20 #0 #0 ~NONE~ ~QUIVER1~
  ADD_CRE_ITEM ~arow01~ #20 #0 #0 ~NONE~ ~QUIVER2~
  ADD_CRE_ITEM ~arow01~ #20 #0 #0 ~NONE~ ~QUIVER3~

// incorrct item entries, either due to typos or other errors

// resref typo
COPY_EXISTING ~genie01.cre~  ~override~
              ~genie02.cre~  ~override~
              ~genie03.cre~  ~override~
              ~genie04.cre~  ~override~
              ~ppdjinn.cre~  ~override~
              ~trgeni02.cre~ ~override~
              ~trgeni03.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "b3-18" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "b3-18m3" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// resref typo
COPY_EXISTING ~cor.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "2hsw02" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "sw2h02" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// resref typo
COPY_EXISTING ~pirexe01.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "blunt06" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "blun06" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// resref typo
COPY_EXISTING ~senani03.cre~ ~override~
              ~sendro03.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "bwbolt01" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "dwbolt01" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// resref typo
COPY_EXISTING ~gorje.cre~  ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "cham01" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "chan01" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// resref typo
COPY_EXISTING ~cuphaer.cre~  ~override~
              ~drow05.cre~   ~override~
              ~udchal.cre~   ~override~
              ~udphae02.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "dwcha01" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "dwchan01" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// resref typo
COPY_EXISTING ~sahspc01.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "ghost01" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "ghost" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// resref typo
COPY_EXISTING ~pirsea01.cre~  ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "leath01" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "leat01" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// resref typo
COPY_EXISTING ~cultist1.cre~ ~override~
              ~excult1.cre~  ~override~
              ~excult2.cre~  ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "leath04" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "leat04" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// resref typo
COPY_EXISTING ~gorwom01.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "rdntre03" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "rndtre03" #8 // corrected resref
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "rdntre04" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "rndtre04" #8 // corrected resref
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// resref typo
COPY_EXISTING ~demosum4.cre~ ~override~
              ~gorcamb.cre~  ~override~
              ~gorcamb6.cre~ ~override~
              ~gorcamb7.cre~ ~override~
              ~hgfel01.cre~  ~override~
              ~telimp1.cre~  ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "rngdemn" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "ringdemn" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// resref typo
COPY_EXISTING ~arntra01.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "sh1h04" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "sw1h04" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// resref typo
COPY_EXISTING ~tirthold.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "staff01" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "staf01" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// resref typo
COPY_EXISTING ~gorsta10.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "umber1" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "umber01" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// resref typo
COPY_EXISTING ~laune.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "vamp01" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "vamp1" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// ringloup makes creatures well-nigh invincible as using old BG immunity (unused in BG2)
COPY_EXISTING ~firwlf01.cre~ ~override~
              ~firwlf02.cre~ ~override~
              ~rngwlf01.cre~ ~override~
              ~rngwlf02.cre~ ~override~
              ~rngwlf03.cre~ ~override~
              ~rngwlf04.cre~ ~override~
              ~rngwlf05.cre~ ~override~
              ~weregr01.cre~ ~override~
              ~weregrdr.cre~ ~override~
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "ringloup" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "ringwolf" #8 // corrected resref
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Varscona is unique; repacing all references except Ribald's with generic +2 sword
COPY_EXISTING ~C6BRAN.cre~   ~override~ // Branet Al-Thon
              ~c6catti.cre~  ~override~ // catti-brie
              ~c6catti2.cre~ ~override~ // catti-brie
              ~C6ELF1.cre~   ~override~ // Elven Warrior
              ~C6FAKE.cre~   ~override~ // Elhan
              ~C6GENER.cre~  ~override~ // General Sovalidaas
              ~C6GOD.cre~    ~override~ // Elven God
              ~C6KACH2.cre~  ~override~ // Kachiko
              ~C6KALDEN.cre~ ~override~ // Kalden
              ~C6LEVIN.cre~  ~override~ // Levin Rayn
              ~C6NERIT.cre~  ~override~ // Nerit
              ~C6WILL.cre~   ~override~ // William Reirrac
              ~CUPRIS1.cre~  ~override~ // Elven Warrior
              ~CUPRIS2.cre~  ~override~ // Elven Warrior
              ~E34.cre~      ~override~ // Coran
//              ~RIBALD.cre~   ~override~ // Ribald
              ~SUELF12.cre~  ~override~ // Captain Aduo'on
              ~SUELF13.cre~  ~override~ // Elven Warrior
              ~SUELLEG1.cre~ ~override~ // Elven Warrior
              ~SUENDEL1.cre~ ~override~ // Elven Warrior
              ~SUENDEL2.cre~ ~override~ // Elven Warrior
              ~SUENDEL3.cre~ ~override~ // Elf Male
              ~SUENDEL4.cre~ ~override~ // Elf Female
              ~SUENDEL5.cre~ ~override~ // Elf
              ~SUENDEL6.cre~ ~override~ // Elf
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "sw1h06" = 0) BEGIN // find Varscona
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "sw1h41" #8 // replace with Long Sword +2
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// creatures with items not assigned

// items to be deleted
COPY_EXISTING ~amwyvern.cre~ ~override~
              ~bazdra03.cre~ ~override~
              ~bearbr01.cre~ ~override~
              ~bearca01.cre~ ~override~
              ~bearpo01.cre~ ~override~
              ~bhelm.cre~    ~override~
              ~bodhi.cre~    ~override~
              ~bodhi2.cre~   ~override~
              ~bodhiamb.cre~ ~override~
              ~braiwa2.cre~  ~override~
              ~c6bodhi.cre~  ~override~
              ~c6drizz.cre~  ~override~
              ~c6drizz2.cre~ ~override~
              ~c6drizz3.cre~ ~override~
              ~c6guen.cre~   ~override~
              ~c6guen2.cre~  ~override~
              ~catjag01.cre~ ~override~
              ~catjagsu.cre~ ~override~
              ~catjagwp.cre~ ~override~
              ~catlio01.cre~ ~override~
              ~catliosu.cre~ ~override~
              ~catliowp.cre~ ~override~
              ~catlis01.cre~ ~override~
              ~catpan01.cre~ ~override~
              ~cefald02.cre~ ~override~
              ~chevil02.cre~ ~override~
              ~cubodhi.cre~  ~override~
              ~deck622.cre~  ~override~
              ~dopgre01.cre~ ~override~
              ~dopple01.cre~ ~override~
              ~dragyell.cre~ ~override~
              ~drizzt.cre~   ~override~
              ~e32.cre~      ~override~
              ~famcat.cre~   ~override~
              ~famcat25.cre~ ~override~
              ~famimp.cre~   ~override~
              ~famqua25.cre~ ~override~
              ~famquas.cre~  ~override~
              ~famrab.cre~   ~override~
              ~firkra02.cre~ ~override~
              ~fsridd.cre~   ~override~
              ~genie1.cre~   ~override~
              ~golsan01.cre~ ~override~
              ~hellho01.cre~ ~override~
              ~hellil01.cre~ ~override~
              ~idjinni.cre~  ~override~
              ~kgenie1.cre~  ~override~
              ~kgenie2.cre~  ~override~
              ~korgan8.cre~  ~override~
              ~korgan9.cre~  ~override~
              ~korgan11.cre~ ~override~
              ~korgan12.cre~ ~override~
              ~lacedo01.cre~ ~override~
              ~lacedo02.cre~ ~override~
              ~mumgre01.cre~ ~override~
              ~nwyvbab.cre~  ~override~
              ~obsdem04.cre~ ~override~
              ~plywyvrn.cre~ ~override~
              ~ppbhaal.cre~  ~override~
              ~pries12c.cre~ ~override~
              ~resuna.cre~   ~override~
              ~riftcr03.cre~ ~override~
              ~rngsta01.cre~ ~override~
              ~rskel01.cre~  ~override~
              ~sahlace.cre~  ~override~
              ~sendai2.cre~  ~override~
              ~sahoty01.cre~ ~override~
              ~shape.cre~    ~override~
              ~skele2.cre~   ~override~
              ~skelet01.cre~ ~override~
              ~skelhp1.cre~  ~override~
              ~tranim03.cre~ ~override~
              ~trevil05.cre~ ~override~
              ~trgeni01.cre~ ~override~
              ~uddeath2.cre~ ~override~
              ~udlesa.cre~   ~override~
              ~vbearca.cre~  ~override~
              ~vvamn1.cre~   ~override~
              ~weregrdr.cre~ ~override~
              ~wolfdi01.cre~ ~override~
              ~wraithsu.cre~ ~override~
              ~wyvbab01.cre~ ~override~
              ~ysfire02.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  READ_LONG  0x2c4 "fx_off" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               (
                 ("%item%" STRING_COMPARE_CASE "ax1h02" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "korgan8" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "korgan9" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "korgan11" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "korgan12" = 0)
                 )
               )
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "b1-8" = 0) AND
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "bearbr01" = 0)
               )
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "b1-10" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "bearca01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "vbearca" = 0)
                 )
               )
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "b1-12" = 0) AND
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "bearpo01" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "b2-8" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "sahoty01" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "b3-18" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "genie1" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "idjinni" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "kgenie1" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "kgenie2" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "trgeni01" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "blun21" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "sendai2" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "boot01" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6drizz" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6drizz2" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6drizz3" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "drizzt" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "chan01" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "vvamn1" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "dragyell" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "bazdra03" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "dragyell" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "dwsw1h02" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "udlesa" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "ghast1" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "lacedo02" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "ghoul1" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "lacedo01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "sahlace" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "giafir2" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "ysfire02" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "hastring" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "famcat" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "famcat25" = 0)
                 )
               )
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "immune1" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "famimp" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "famqua25" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "famquas" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "fsridd" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "golsan01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "mumgre01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "riftcr03" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "shape" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "leat04" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "e32" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "misc50" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "rskel01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "skele2" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "skelet01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "skelhp1" = 0)
                 )
               )
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "misc52" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "amwyvern" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "firkra02" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "nwyvbab" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "plywyvrn" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "wyvbab01" = 0)
                 )
               )
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "p1-8" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6guen" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6guen2" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "catjag01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "catjagsu" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "catjagwp" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "catpan01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "cefald02" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "tranim03" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "trevil05" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "wolfdi01" = 0)
                 )
               )
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "p1-10" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "catlio01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "catliosu" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "catliowp" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "hellho01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "hellil01" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "p1-12" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "catlis01" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "plat01" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "braiwa2" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "pries12c" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "rabring" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "famrab" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "rods05" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "obsdem04" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "s1-8" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "wraithsu" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "s1-12" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6drizz" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6drizz2" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6drizz3" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "chevil02" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "dopgre01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "dopple01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "drizzt" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "s1-12m2" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "weregrdr" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "s2-16" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "bodhi" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "bodhi2" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "bodhiamb" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6bodhi" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "cubodhi" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "s3-8m3" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "deck622" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "scrl25" = 0) AND
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "bhelm" = 0)
               )
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "sw1h01" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "ppbhaal" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "resuna" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "sw2h01" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "uddeath2" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "vampreg2" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "bodhiamb" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "" = 0) AND
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "rngsta01" = 0)
               )
             ) BEGIN
      FOR (index2 = 0 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through slots to alter references
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%ref%" = "%index%") BEGIN // if deleted item
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) 0xffff // removes reference
        END ELSE
        PATCH_IF (("%ref%" > "%index%") AND ("%ref%" != 0xffff)) BEGIN // if higher index than delted
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) ("%ref%" - 1) // decrements by one
        END
      END
      DELETE_BYTES ("%itm_off%" + (0x14 * "%index%")) 0x14 // deletes item
      SET "itm_num" = ("%itm_num%" - 1)
      WRITE_LONG  0x2c0 "%itm_num%"
      SET "index" = ("%index%" - 1)
      PATCH_IF ("%fx_off%" > "%itm_off%") BEGIN
        SET "fx_off" = ("%fx_off%" - 0x14)
        WRITE_LONG  0x2c4 "%fx_off%"
      END
      PATCH_IF ("%slot_off%" > "%itm_off%") BEGIN
        SET "slot_off" = ("%slot_off%" - 0x14)
        WRITE_LONG  0x2b8 "%slot_off%"
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// helms
COPY_EXISTING ~garock.cre~ ~override~
              ~rock.cre~   ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               ("%item%" STRING_COMPARE_CASE "helm01" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "garock" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "rock" = 0)
               )
             ) BEGIN
      FOR (index2 = 0 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through slots and add reference to first null slot
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%ref%" = 0xffff) BEGIN // if null reference in helm
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "%index%" // adds reference to item
          SET "index2" = 36 // kills loop
        END
        PATCH_IF ("%index2%" = 0) BEGIN // if end of helm slots, skip ahead to inventory
          SET "index2" = 20 // otherwise go to inventory slots
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// armor: mel01, meliss01, and cutmelis not modified--appearance changed too dramatically
COPY_EXISTING ~aerie9.cre~   ~override~
              ~c6god.cre~    ~override~
              ~hobcap01.cre~ ~override~
              ~jondal.cre~   ~override~
              ~plfarm06.cre~ ~override~
              ~tethto.cre~   ~override~
              ~tethto2.cre~  ~override~
              ~udduer01.cre~ ~override~
              ~uhogre03.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               ("%item%" STRING_COMPARE_CASE "chan02" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "tethto" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "tethto2" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "chan04" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "hobcap01" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "uhogre03" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "leat01" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "udduer01" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "leat04" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "aerie9" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "plat01" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "jondal" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "plfarm06" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "plat14" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "c6god" = 0)
             ) BEGIN
      FOR (index2 = 1 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through slots and add reference to first null slot
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%ref%" = 0xffff) BEGIN // if null reference in armor
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "%index%" // adds reference to item
          SET "index2" = 36 // kills loop
        END
        PATCH_IF ("%index2%" = 1) BEGIN // if end of armor slots, skip ahead to inventory
          SET "index2" = 20 // otherwise go to inventory slots
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// shields
COPY_EXISTING ~plfarm03.cre~ ~override~
              ~plmetr01.cre~ ~override~
              ~tethto.cre~   ~override~
              ~tethto2.cre~  ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               ("%item%" STRING_COMPARE_CASE "shld03" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "plfarm03" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "plmetr01" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "shld04" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "tethto" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "tethto2" = 0)
               )
             ) BEGIN
      FOR (index2 = 2 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through slots and add reference to first null slot
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%ref%" = 0xffff) BEGIN // if null reference in shield
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "%index%" // adds reference to item
          SET "index2" = 36 // kills loop
        END
        PATCH_IF ("%index2%" = 2) BEGIN // if end of shield slots, skip ahead to inventory
          SET "index2" = 20 // otherwise go to inventory slots
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// rings/amulets
COPY_EXISTING ~c6elven2.cre~ ~override~
              ~c6elvenw.cre~ ~override~
//              ~centeo01.cre~ ~override~
              ~d1ghost.cre~  ~override~
              ~dacemist.cre~ ~override~
              ~delmist.cre~  ~override~
              ~ghogr01.cre~  ~override~
              ~imp01.cre~    ~override~
              ~impqua01.cre~ ~override~
              ~lester.cre~   ~override~
              ~riftcr01.cre~ ~override~
              ~rumar03.cre~  ~override~
              ~sahimp01.cre~ ~override~
              ~sahimp02.cre~ ~override~
              ~sahimp03.cre~ ~override~
              ~sahimp04.cre~ ~override~
              ~sahimp05.cre~ ~override~
              ~sahimp06.cre~ ~override~
              ~sahimp07.cre~ ~override~
              ~suziyaad.cre~ ~override~
              ~udimp.cre~    ~override~
              ~tanomist.cre~ ~override~
              ~valemist.cre~ ~override~
              ~warsage.cre~  ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               ("%item%" STRING_COMPARE_CASE "ghost3" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "d1ghost" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "immune1" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "ghogr01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "imp01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "impqua01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "riftcr01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "rumar03" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "sahimp01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "sahimp02" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "sahimp03" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "sahimp04" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "sahimp05" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "sahimp06" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "sahimp07" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "udimp" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "immune2" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "suziyaad" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "mage06" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "lester" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "minhp1" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6elven2" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "c6elvenw" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "dacemist" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "delmist" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "tanomist" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "valemist" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "warsage" = 0)
                 )
               )
             ) OR (
               (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "centeo01" = 0) AND (
                   ("%item%" STRING_COMPARE_CASE "ring18" = 0) OR
                   ("%item%" STRING_COMPARE_CASE "ring23" = 0)
                 )
               )
             ) BEGIN
      FOR (index2 = 4 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through quiver slots and add reference to first null slot
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%ref%" = 0xffff) BEGIN // first null reference in rings, amulets
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "%index%" // adds reference to item
          SET "index2" = 36 // kills loop
        END
        PATCH_IF ("%index2%" = 6) BEGIN // if end of jewelry slots, skip ahead to inventory
          SET "index2" = 20
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// weapons
COPY_EXISTING ~c6coran.cre~  ~override~
//              ~centeo01.cre~ ~override~
              ~cowled.cre~   ~override~
              ~duearc01.cre~ ~override~
              ~e32.cre~      ~override~
              ~firmon02.cre~ ~override~
              ~gith04.cre~   ~override~
              ~gorgith2.cre~ ~override~
              ~gorkuo05.cre~ ~override~
              ~jaerto1.cre~  ~override~
              ~jaerto2.cre~  ~override~
              ~kchild1.cre~  ~override~
              ~kuowhi01.cre~ ~override~
              ~pirmur02.cre~ ~override~
              ~pries18c.cre~ ~override~
              ~rumar01.cre~  ~override~
              ~sahextra.cre~ ~override~
              ~sarjai01.cre~ ~override~
              ~swshaman.cre~ ~override~
              ~tethto.cre~   ~override~
              ~tethto2.cre~  ~override~
              ~tomegol4.cre~ ~override~
              ~vvshad1.cre~  ~override~
              ~vvshad4.cre~  ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               ("%item%" STRING_COMPARE_CASE "ax1h01" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "duearc01" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "b1-2" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "kchild1" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "blun04" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "pries18c" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "blun05" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "tethto" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "tethto2" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "bow01" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "firmon02" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "bow03" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "c6coran" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "dagg01" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "vvshad1" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "vvshad4" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "dart01" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "cowled" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "goltome4" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "tomegol4" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "staf02" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "rumar01" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "sw1h01" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "jaerto1" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "jaerto2" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "ppbhaal" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "resuna" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "sw1h05" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "sarjai01" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "sw1h07" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "pirmur02" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "sw1h08" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "swshaman" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "sw2h01" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "e32" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "gith04" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "gorgith2" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "uddeath2" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "sw2h06" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "centeo01" = 0)
             ) OR (
               (
                 ("%item%" STRING_COMPARE_CASE "xbow01" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "sahextra" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "gorkuo05" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "kuowhi01" = 0)
                 )
               )
             ) BEGIN
      FOR (index2 = 9 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through slots and add reference to first null slot
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%ref%" = 0xffff) BEGIN // first null reference in weapons
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "%index%" // adds reference to item
          SET "index2" = 36 // kills loop
        END
        PATCH_IF ("%index2%" = 12) BEGIN // if end of weapon slots, skip ahead to inventory
          SET "index2" = 20
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// items for quiver
COPY_EXISTING ~bhaal01.cre~  ~override~
              ~dragblac.cre~ ~override~
              ~elekob01.cre~ ~override~
              ~kobcom01.cre~ ~override~
              ~kobsla01.cre~ ~override~
              ~plmetg02.cre~ ~override~
              ~sahcpt02.cre~ ~override~
              ~sahpri02.cre~ ~override~
              ~sahramb1.cre~ ~override~
              ~sahrnt01.cre~ ~override~
              ~sarevok.cre~  ~override~
              ~swsfoll1.cre~ ~override~
              ~swsfoll6.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               (
                 ("%item%" STRING_COMPARE_CASE "arow01" = 0) AND (
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "elekob01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "kobcom01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "kobsla01" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "swsfoll1" = 0) OR
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "swsfoll6" = 0)
                 )
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "arow07" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "plmetg02" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "dragblac" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "arow11" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "dragblac" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "bolt01" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "sahpri02" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "bolt04" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "sahrnt01" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "bolt06" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "bhaal01" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "sarevok" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "dragblac" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "bull03" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "dragblac" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "sahbolt" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "sahrnt01" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "sahcpt02" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "sahramb1" = 0)
               )
             ) BEGIN
      FOR (index2 = 13 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through quiver slots and add reference to first null slot
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%ref%" = 0xffff) BEGIN // first null reference in quivers
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "%index%" // adds reference to item
          SET "index2" = 36 // kills loop
        END
        PATCH_IF ("%index2%" = 16) BEGIN // if end of quiver slots, skip ahead to inventory
          SET "index2" = 20
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// quickslot items
COPY_EXISTING //~centeo01.cre~ ~override~
              ~chgood09.cre~ ~override~
              ~cowled.cre~   ~override~
//              ~davaeo.cre~   ~override~
//              ~gorion.cre~   ~override~
              ~hamasu.cre~   ~override~
              ~imoen.cre~    ~override~
              ~sahbeh04.cre~ ~override~
              ~teltief3.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               ("%item%" STRING_COMPARE_CASE "potn02" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "davaeo" = 0)
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "potn08" = 0) AND
               (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "cowled" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "gorion" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "hamasu" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "imoen" = 0)
               )
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "potn09" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "imoen" = 0)
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "potn20" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "hamasu" = 0)
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "potn32" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "sahbeh04" = 0)
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "potn55" = 0) AND
               (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "chgood09" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "teltief3" = 0)
               )
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "scrl1g" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "cowled" = 0)
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "scrl1q" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "cowled" = 0)
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "scrl77" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "gorion" = 0)
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "scrl84" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "gorion" = 0)
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "wand02" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "davaeo" = 0)
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "wand06" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "centeo01" = 0)
             ) BEGIN
      FOR (index2 = 18 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through quick slots/inventory and add reference to first null slot
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%ref%" = 0xffff) BEGIN // if null reference
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "%index%" // adds reference to item
          SET "index2" = 36 // kills loop
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// generic inventory/quickslot
COPY_EXISTING ~aegnoll.cre~  ~override~
              ~ammerc07.cre~ ~override~
              ~c6lanf.cre~   ~override~
//              ~centeo01.cre~ ~override~
              ~chgood09.cre~ ~override~
              ~cowled.cre~   ~override~
              ~dagnoll.cre~  ~override~
//              ~davaeo.cre~   ~override~
              ~dragblac.cre~ ~override~
              ~garkid02.cre~ ~override~
              ~gibbersu.cre~ ~override~
              ~gibmut01.cre~ ~override~
              ~gnleli01.cre~ ~override~
              ~gnlwar01.cre~ ~override~
              ~gnoll01.cre~  ~override~
              ~gnollhp1.cre~ ~override~
//              ~gorion.cre~   ~override~
              ~hamasu.cre~   ~override~
              ~hobcap01.cre~ ~override~
              ~icliz01.cre~  ~override~
              ~icliz02.cre~  ~override~
              ~imoen.cre~    ~override~
              ~sahbeh04.cre~ ~override~
              ~tasloisu.cre~ ~override~
              ~teltief3.cre~ ~override~
              ~xvartsu.cre~  ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               ("%item%" STRING_COMPARE_CASE "dart04" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "dragblac" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "misc90" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "centeo01" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "potn02" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "davaeo" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "potn08" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "cowled" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "gorion" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "hamasu" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "imoen" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "potn09" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "imoen" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "potn20" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "hamasu" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "potn32" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "sahbeh04" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "potn55" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "chgood09" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "teltief3" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "rndtre02" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "ammerc07" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "c6lanf" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "garkid02" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "gibbersu" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "gibmut01" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "tasloisu" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "xvartsu" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "rndtre03" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "hobcap01" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "rndtre04" = 0) AND (
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "aegnoll" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "dagnoll" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "gnleli01" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "gnlwar01" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "gnoll01" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "gnollhp1" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "icliz01" = 0) OR
                 ("%SOURCE_RES%" STRING_COMPARE_CASE "icliz02" = 0)
               )
             ) OR (
               ("%item%" STRING_COMPARE_CASE "scrl1g" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "cowled" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "scrl1q" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "cowled" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "scrl77" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "gorion" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "scrl84" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "gorion" = 0)
             ) OR
             (
               ("%item%" STRING_COMPARE_CASE "wand02" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "davaeo" = 0)
             ) OR (
               ("%item%" STRING_COMPARE_CASE "wand06" = 0) AND
               ("%SOURCE_RES%" STRING_COMPARE_CASE "centeo01" = 0)
             ) BEGIN
      FOR (index2 = 21 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through inventory and add reference to first null slot
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%ref%" = 0xffff) BEGIN // if null reference
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "%index%" // adds reference to item
          SET "index2" = 36 // kills loop
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// item in wrong slots, dupe entries, etc.

// icgob02 has overlapping refs
COPY_EXISTING ~icgob02.cre~  ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  SET "dupe" = 0
  FOR (index2 = 13 ; index2 < 17 ; index2 = index2 + 1) BEGIN // search through quiver slots
    READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
    PATCH_IF ("%ref%" = 3) BEGIN // dupe reference in quivers
      PATCH_IF ("%dupe%" = 0) BEGIN
        SET "dupe" = 1
      END ELSE BEGIN
        WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) 1 // removes dupe reference
        SET "index2" = 17 // kills loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// both have dupe ring ref in weapon slot instead of weapon
COPY_EXISTING ~impqua01.cre~ ~override~
              ~kuocle20.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ((("%item%" STRING_COMPARE_CASE "impqua" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "impqua01" = 0)) OR
              (("%item%" STRING_COMPARE_CASE "blun33" = 0) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "kuocle20" = 0))) BEGIN
      WRITE_SHORT ("%slot_off%" + 0x12) "%index%" // puts in primary weapon slot
    END
  END
  BUT_ONLY_IF_IT_CHANGES

  // has ring in weapon slots
COPY_EXISTING ~amlich01.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  FOR (index = 9 ; index < 13 ; index = index + 1) BEGIN // quick slots/inventory
    READ_SHORT ("%slot_off%" + (0x02 * "%index%")) "ref" ELSE 0xffff
    PATCH_IF ("%ref%" != 0xffff) BEGIN
      READ_ASCII ("%itm_off%" + (0x14 * "%ref%")) "item"
      PATCH_IF ("%item%" STRING_COMPARE_CASE "ring46" = 0) BEGIN
        READ_SHORT ("%slot_off%" + 0x08) "lring" // read lring slot
        READ_SHORT ("%slot_off%" + 0x0a) "rring" // read rring slot
        PATCH_IF ("%lring%" = 0xffff) BEGIN // if lring slot open
          WRITE_SHORT ("%slot_off%" + 0x08) "%ref%" // write reference
          WRITE_SHORT ("%slot_off%" + (0x02 * "%index%")) 0xffff // removes old reference
        END ELSE
        PATCH_IF ("%rring%" = 0xffff) BEGIN // if rring slot open
          WRITE_SHORT ("%slot_off%" + 0x0a) "%ref%" // write reference
          WRITE_SHORT ("%slot_off%" + (0x02 * "%index%")) 0xffff // removes old reference
        END
        SET "index" = 13 //kills loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// has armor in weapon slot, weapon not assigned (fixed later)
COPY_EXISTING ~ppsail03.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "leat01" = 0) BEGIN
      WRITE_SHORT ("%slot_off%" + 0x02) "%index%" // puts in armor slot
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "sw1h20" = 0) BEGIN
      WRITE_SHORT ("%slot_off%" + 0x18) "%index%" // puts in primary weapon slot
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// rskel03 has dupe entries for throwing axes
COPY_EXISTING ~rskel03.cre~  ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "ax1h04" = 0) BEGIN
      SET "exists" = 0
      SET "insert" = 0
      FOR (index2 = 9 ; index2 < 13 ; index2 = index2 + 1) BEGIN // search through weapon slots
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%index%" = "%ref%") BEGIN
          SET "exists" = 1
          SET "index2" = 17 // kills loop
        END ELSE
        PATCH_IF (("%insert%" = 0) AND ("%ref%" = 0xffff)) BEGIN // if null entry, set insert point
          SET "insert" = "%index2%"
        END
      END
      PATCH_IF ("%exists%" = 0) BEGIN
        PATCH_IF ("%insert%" = 0) BEGIN // no insert point found already
          FOR (index3 = 21 ; index3 < 36 ; index3 = index3 + 1) BEGIN // search through weapon slots
            READ_SHORT ("%slot_off%" + ("%index3%" * 0x02)) "ref"
            PATCH_IF ("%ref%" = 0xffff) BEGIN
              WRITE_SHORT ("%slot_off%" + ("%index3%" * 0x02)) "%index%" // adds reference
            END
          END
        END ELSE BEGIN
          WRITE_SHORT ("%slot_off%" + ("%insert%" * 0x02)) "%index%" // adds reference
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// sewyag03 has dupe quiver reference
COPY_EXISTING ~sewyag03.cre~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG  0x2b8 "slot_off" ELSE 0
    READ_LONG  0x2bc "itm_off" ELSE 0
    READ_LONG  0x2c0 "itm_num" ELSE 0
    SET "dupe" = 0
    FOR (index2 = 18 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through quiver slots
      READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
      PATCH_IF ("%ref%" = 4) BEGIN // dupe reference in quivers
        PATCH_IF ("%dupe%" = 0) BEGIN
          SET "dupe" = 1
        END ELSE BEGIN
          WRITE_SHORT ("%slot_off%" + ("%index2%" * 0x02)) 3 // removes dupe reference
          SET "index2" = 36 // kills loop
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// number of creatures with dupe entries for rndtre05
COPY_EXISTING ~drush.cre~    ~override~
              ~ogrema01.cre~ ~override~
              ~ogrmag01.cre~ ~override~
              ~plshom01.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "rndtre05" = 0) BEGIN
      SET "exists" = 0
      SET "insert" = 0
      FOR (index2 = 18 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through quick slots & inventory
        READ_SHORT ("%slot_off%" + ("%index2%" * 0x02)) "ref"
        PATCH_IF ("%index%" = "%ref%") BEGIN
          SET "exists" = 1
          SET "index2" = 36 // kills loop
        END ELSE
        PATCH_IF (("%insert%" = 0) AND ("%ref%" = 0xffff)) BEGIN // if null entry, set insert point
          SET "insert" = "%index2%"
        END
      END
      PATCH_IF ("%exists%" = 0) BEGIN
        FOR (index3 = 21 ; index3 < 36 ; index3 = index3 + 1) BEGIN // search through weapon slots
          READ_SHORT ("%slot_off%" + ("%index3%" * 0x02)) "ref"
          PATCH_IF ("%ref%" = 0xffff) BEGIN
            WRITE_SHORT ("%slot_off%" + ("%index3%" * 0x02)) "%index%" // adds reference
            SET "index3" = 36 // kills loop
          END
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// has shield in armor slot, armor not assigned
COPY_EXISTING ~kpsold06.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "chan04" = 0) BEGIN
      WRITE_SHORT ("%slot_off%" + 0x02) "%index%" // puts in armor slot
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "shld05" = 0) BEGIN
      WRITE_SHORT ("%slot_off%" + 0x04) "%index%" // puts in shield slot
    END
  END
  BUT_ONLY_IF_IT_CHANGES

  // has helm in quickslot/inventory
COPY_EXISTING ~gorfirg.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG  0x2b8 "slot_off" ELSE 0
    READ_LONG  0x2bc "itm_off" ELSE 0
    FOR (index = 18 ; index < 37 ; index = index + 1) BEGIN // quick slots/inventory
      READ_SHORT ("%slot_off%" + (0x02 * "%index%")) "ref"
      PATCH_IF ("%ref%" != 0xffff) BEGIN
        READ_ASCII ("%itm_off%" + (0x14 * "%ref%")) "item"
        PATCH_IF ("%item%" STRING_COMPARE_CASE "helm31" = 0) BEGIN
          READ_SHORT ("%slot_off%") "helm" // read helm slot
          PATCH_IF ("%helm%" = 0xffff) BEGIN // if helm slot open
            WRITE_SHORT ("%slot_off%") "%ref%" // write reference
            WRITE_SHORT ("%slot_off%" + (0x02 * "%index%")) 0xffff // removes old reference
          END
          SET "index" = 37 //kills loop
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// has dupe armor entry in weapon slot; properly equipping weapon is handled in mass patch
COPY_EXISTING ~ppsail03.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off"  ELSE 0
  FOR (index = 9 ; index < 13 ; index = index + 1) BEGIN // search through weapon slots
    READ_SHORT ("%slot_off%" + ("%index%" * 0x02)) "ref"
    PATCH_IF ("%ref%" != 0xffff) BEGIN // if legit reference
      READ_ASCII ("%itm_off%" + (0x14 * "%ref%")) "item"
      PATCH_IF ("%item%" STRING_COMPARE_CASE "leat01" = 0) BEGIN
        WRITE_SHORT ("%slot_off%" + ("%index%" * 0x02)) 0xffff // blanks reference
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// has armor in cloak/quickslots/inventory
COPY_EXISTING ~aerie10.cre~  ~override~
              ~elearb01.cre~ ~override~
              ~elearb02.cre~ ~override~
              ~elearb03.cre~ ~override~
              ~elearb04.cre~ ~override~
              ~elearb05.cre~ ~override~
              ~elearb06.cre~ ~override~
              ~elearb07.cre~ ~override~
              ~elearb08.cre~ ~override~
              ~elearb09.cre~ ~override~
              ~elearb10.cre~ ~override~
              ~elearb11.cre~ ~override~
              ~flyfgt04.cre~ ~override~
              ~gmage14.cre~  ~override~
              ~gorsta11.cre~ ~override~
              ~gromg05.cre~  ~override~
              ~gromg08.cre~  ~override~
              ~gromg13.cre~  ~override~
              ~hlsion.cre~   ~override~
              ~jangit02.cre~ ~override~
              ~loveone5.cre~ ~override~
              ~rigen02.cre~  ~override~
              ~rumar01.cre~  ~override~
              ~sarmag01.cre~ ~override~
              ~shugmg01.cre~ ~override~
              ~shupol01.cre~ ~override~
              ~stein.cre~    ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  FOR (index = 17 ; index < 37 ; index = index + 1) BEGIN
  READ_SHORT ("%slot_off%" + (0x02 * "%index%")) "ref" ELSE 0xffff // slots starting with cloak
    PATCH_IF ("%ref%" != 0xffff) BEGIN
      READ_ASCII ("%itm_off%" + (0x14 * "%ref%")) "item"
      PATCH_IF (
                 ("%item%" STRING_COMPARE_CASE "clck10" = 0) OR
                 ("%item%" STRING_COMPARE_CASE "clck13" = 0) OR
                 ("%item%" STRING_COMPARE_CASE "clck14" = 0) OR
                 ("%item%" STRING_COMPARE_CASE "clck15" = 0) OR
                 ("%item%" STRING_COMPARE_CASE "clck16" = 0) OR
                 ("%item%" STRING_COMPARE_CASE "leat04" = 0)
               ) BEGIN
        READ_SHORT ("%slot_off%" + 0x02) "armor" // read armor slot
        PATCH_IF ("%armor%" = 0xffff) BEGIN // if armor slot open
          WRITE_SHORT ("%slot_off%" + 0x02) "%ref%" // add as armor
          WRITE_SHORT ("%slot_off%" + (0x02 * "%index%")) 0xffff // removes old reference
        END
        SET "index" = 37 //kills loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// has shield in quickslot/inventory
COPY_EXISTING ~trfued05.cre~ ~override~
              ~yaga01.cre~   ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  FOR (index = 18 ; index < 37 ; index = index + 1) BEGIN // quick slots/inventory
    READ_SHORT ("%slot_off%" + (0x02 * "%index%")) "ref" ELSE 0xffff
    PATCH_IF ("%ref%" != 0xffff) BEGIN
      READ_ASCII ("%itm_off%" + (0x14 * "%ref%")) "item"
      PATCH_IF (
                 ("%item%" STRING_COMPARE_CASE "shld01" = 0) OR
                 ("%item%" STRING_COMPARE_CASE "shld04" = 0) OR
                 ("%item%" STRING_COMPARE_CASE "shld32" = 0)
               ) BEGIN
        READ_SHORT ("%slot_off%" + 0x04) "shld" // read shld slot
        PATCH_IF ("%shld%" = 0xffff) BEGIN // if shld slot open
          WRITE_SHORT ("%slot_off%" + 0x04) "%ref%" // write reference
          WRITE_SHORT ("%slot_off%" + (0x02 * "%index%")) 0xffff // removes old reference
        END
        SET "index" = 37 //kills loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// has bracers in quickslot/inventory
COPY_EXISTING ~gorwom03.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  FOR (index = 18 ; index < 37 ; index = index + 1) BEGIN // quick slots/inventory
    READ_SHORT ("%slot_off%" + (0x02 * "%index%")) "ref" ELSE 0xffff
    PATCH_IF ("%ref%" != 0xffff) BEGIN
      READ_ASCII ("%itm_off%" + (0x14 * "%ref%")) "item"
      PATCH_IF ("%item%" STRING_COMPARE_CASE "brac21" = 0) BEGIN
        READ_SHORT ("%slot_off%" + 0x06) "brac" // read helm slot
        PATCH_IF ("%brac%" = 0xffff) BEGIN // if helm slot open
          WRITE_SHORT ("%slot_off%" + 0x06) "%ref%" // write reference
          WRITE_SHORT ("%slot_off%" + (0x02 * "%index%")) 0xffff // removes old reference
        END
        SET "index" = 37 //kills loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// have ring in quickslot/inventory
COPY_EXISTING ~aran02.cre~  ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  FOR (index = 18 ; index < 37 ; index = index + 1) BEGIN // quick slots, inventory
    READ_SHORT ("%slot_off%" + (0x02 * "%index%")) "ref"
    PATCH_IF ("%ref%" != 0xffff) BEGIN
      READ_ASCII ("%itm_off%" + (0x14 * "%ref%")) "item"
      PATCH_IF ("%item%" STRING_COMPARE_CASE "ring07" = 0) BEGIN // RoP +2
        FOR (index2 = 4 ; index2 < 37 ; index2 = index2 + 1) BEGIN // start at ring slots
          READ_SHORT ("%slot_off%" + (0x02 * "%index2%")) "ref2"
          PATCH_IF ("%ref2%" = 0xffff) BEGIN // empty slot
            WRITE_SHORT ("%slot_off%" + (0x02 * "%index2%")) "%ref%"
            WRITE_SHORT ("%slot_off%" + (0x02 * "%index%")) 0xffff
            SET "index" = 21 //kills loop
            SET "index2" = 37 // kills loop
          END
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// have weapons in quickslot/inventory
COPY_EXISTING ~anomen6.cre~  ~override~
              ~anomen7.cre~  ~override~
              ~anomen8.cre~  ~override~
              ~anomen9.cre~  ~override~
              ~anomen10.cre~ ~override~
              ~bshop01.cre~  ~override~
              ~corneil.cre~  ~override~
              ~dario.cre~    ~override~
              ~DSHOP01.cre~  ~override~
              ~edwin12.cre~  ~override~
              ~edwin13.cre~  ~override~
              ~elders.cre~   ~override~
              ~ffactor2.cre~ ~override~
              ~garrick.cre~  ~override~
              ~gerhardt.cre~ ~override~
              ~jaga4.cre~    ~override~
              ~jamage1.cre~  ~override~
              ~jamage2.cre~  ~override~
              ~jameroni.cre~ ~override~
              ~jan15.cre~    ~override~
              ~nalia8.cre~   ~override~
              ~nalia10.cre~  ~override~
              ~nalia11.cre~  ~override~
              ~nalia13.cre~  ~override~
              ~nalia15.cre~  ~override~
              ~pwarden.cre~  ~override~
              ~scyarryl.cre~ ~override~
              ~surly.cre~    ~override~
              ~temsup.cre~   ~override~
              ~thief5.cre~   ~override~
              ~valyg9.cre~   ~override~
              ~valyg11.cre~  ~override~
              ~valyg12.cre~  ~override~
              ~vara.cre~     ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  FOR (index = 18 ; index < 37 ; index = index + 1) BEGIN // quick slots, inventory
    READ_SHORT ("%slot_off%" + (0x02 * "%index%")) "ref" ELSE 0xffff
    PATCH_IF ("%ref%" != 0xffff) BEGIN
      READ_ASCII ("%itm_off%" + (0x14 * "%ref%")) "item"
      PATCH_IF (
                 (
                   ("%item%" STRING_COMPARE_CASE "blun02" = 0) AND
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "gerhardt" = 0)
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "blun03" = 0) AND
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "temsup" = 0)
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "blun20" = 0) AND
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "scyarryl" = 0)
                 ) OR (
                   (
                     ("%item%" STRING_COMPARE_CASE "bow03" = 0) OR
                     ("%item%" STRING_COMPARE_CASE "sper01" = 0)
                   ) AND (
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "valyg9" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "valyg11" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "valyg12" = 0)
                   )
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "bow05" = 0) AND (
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "nalia8" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "nalia10" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "nalia11" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "nalia13" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "nalia15" = 0)
                   )
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "dagg01" = 0) AND (
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "bshop01" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "ffactor2" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "thief5" = 0)
                   )
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "hamm01" = 0) AND
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "surly" = 0)
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "slng01" = 0) AND (
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "anomen6" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "anomen7" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "anomen8" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "anomen9" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "anomen10" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "edwin12" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "edwin13" = 0)
                   )
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "staf01" = 0) AND (
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "corneil" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "dario" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "elders" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "jamage1" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "jamage2" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "vara" = 0)
                   )
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "sw1h07" = 0) AND
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "DSHOP01" = 0)
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "sw1h35" = 0) AND
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "pwarden" = 0)
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "xbow04" = 0) AND (
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "garrick" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "jaga4" = 0) OR
                     ("%SOURCE_RES%" STRING_COMPARE_CASE "jameroni" = 0)
                   )
                 ) OR (
                   ("%item%" STRING_COMPARE_CASE "xbow12" = 0) AND
                   ("%SOURCE_RES%" STRING_COMPARE_CASE "jan15" = 0)
                 )
               ) BEGIN
        FOR (index2 = 9 ; index2 < 37 ; index2 = index2 + 1) BEGIN // start at weapon slots
          READ_SHORT ("%slot_off%" + (0x02 * "%index2%")) "ref2"
          PATCH_IF ("%ref2%" = 0xffff) BEGIN // empty slot
            WRITE_SHORT ("%slot_off%" + (0x02 * "%index2%")) "%ref%"
            WRITE_SHORT ("%slot_off%" + (0x02 * "%index%")) 0xffff
            SET "index" = 21 //kills loop
            READ_SHORT ("%slot_off%" + 0x4c) "equipped"
            PATCH_IF (("%index2%" < 13) AND ("%equipped%" = 0xffff)) BEGIN
              WRITE_SHORT ("%slot_off%" + 0x4c) ("%index2%" - 9) // equipped weapon
            END
            SET "index2" = 37 // kills loop
          END
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// have ammo in quickslot/inventory
COPY_EXISTING ~elekob01.cre~ ~override~
              ~kobcom01.cre~ ~override~
              ~swsfoll1.cre~ ~override~
              ~swsfoll6.cre~ ~override~
  READ_LONG  0x2b8 "slot_off" ELSE 0
  READ_LONG  0x2bc "itm_off" ELSE 0
  FOR (index = 18 ; index < 37 ; index = index + 1) BEGIN // quick slots, inventory
    READ_SHORT ("%slot_off%" + (0x02 * "%index%")) "ref"
    PATCH_IF ("%ref%" != 0xffff) BEGIN
      READ_ASCII ("%itm_off%" + (0x14 * "%ref%")) "item"
      PATCH_IF ("%item%" STRING_COMPARE_CASE "arow08" = 0) BEGIN
        FOR (index2 = 13 ; index2 < 17 ; index2 = index2 + 1) BEGIN //quiver slots
          READ_SHORT ("%slot_off%" + (0x02 * "%index2%")) "ref2"
          PATCH_IF ("%ref2%" = 0xffff) BEGIN // empty slot
            WRITE_SHORT ("%slot_off%" + (0x02 * "%index2%")) "%ref%"
            WRITE_SHORT ("%slot_off%" + (0x02 * "%index%")) 0xffff
            SET "index" = 37 //kills loop
            SET "index2" = 17 // kills loop
          END
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// amnish guards shouldn't be using bows and arrows, especially w/o animation
COPY_EXISTING ~bamng01.cre~ ~override~
              ~bamng02.cre~ ~override~
              ~circg1.cre~  ~override~
  READ_LONG  0x2b8 "slot_off"
  READ_LONG  0x2bc "itm_off"
  FOR (index = 0; index < 4; index = index + 1) BEGIN // cycles through weapon slots
    READ_SHORT ("%slot_off%" + 0x12 + ("%index%" * 0x02)) "slot_num"
    PATCH_IF ("%slot_num%" < 37) BEGIN
      READ_ASCII ("%itm_off%" + ("%slot_num%" * 0x14)) "weapon"
      PATCH_IF ("sw1h04" STRING_COMPARE_CASE "%weapon%" = 0) BEGIN // if long sword
        WRITE_SHORT ("%slot_off%" + 0x4c) "%index%" // sets weapon slot to selected weapon
        SET "index" = 4
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// zombies shouldn't be using bows and arrows, especially w/o animation
COPY_EXISTING ~bhghoul5.cre~ ~override~
  READ_LONG  0x2bc "itm_off"
  READ_LONG  0x2c0 "itm_num"
  WHILE ("%itm_num%" > 0) BEGIN
    SET "itm_num" = ("%itm_num%" - 1)
    READ_ASCII ("%itm_off%" + (0x14 * "%itm_num%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "arrw01" = 0) BEGIN
      WRITE_ASCII ("%itm_off%" +        (0x14 * "%itm_num%")) ~arow01~ #8
      READ_BYTE   ("%itm_off%" + 0x10 + (0x14 * "%itm_num%")) "flags"
      WRITE_BYTE  ("%itm_off%" + 0x10 + (0x14 * "%itm_num%")) ("%flags%" BOR   0b00001010) // adds unstealable, undroppable flags
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "bow03" = 0) BEGIN
      WRITE_ASCII ("%itm_off%" +        (0x14 * "%itm_num%")) ~b3-12~ #8 // replace bow with zombie attack item
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// have incorrect equipped weapon reference
COPY_EXISTING ~aemess.cre~   ~override~
              ~alex.cre~     ~override~
              ~AMMAJIRA.CRE~ ~OVERRIDE~
              ~AMTCLE01.CRE~ ~override~
              ~AMTCLER0.CRE~ ~override~
              ~ANTENOS.CRE~  ~override~
              ~ARLED.cre~    ~override~
              ~BAZEYE01.CRE~ ~override~
              ~BGUARD1.cre~  ~override~
              ~boo.CRE~      ~override~
              ~BOUNHA02.cre~ ~override~
              ~BOUNHA03.cre~ ~override~
              ~C6KACH2.cre~  ~override~
              ~ch3mag01.CRE~ ~override~
              ~CHGOOD09.CRE~ ~override~
              ~CHSAM01.CRE~  ~override~
              ~CHSAM02.CRE~  ~override~
              ~COPAMB01.cre~ ~override~
              ~COPAMB03.cre~ ~override~
              ~COPAMB04.cre~ ~override~
              ~DADROW11.CRE~ ~override~
              ~DADROW17.CRE~ ~override~
              ~DADROW20.CRE~ ~override~
              ~DADROW4.CRE~  ~override~
              ~DAQILUE.CRE~  ~override~
              ~DAWNMAS.cre~  ~override~
              ~democler.CRE~ ~override~
              ~DERRICK.cre~  ~override~
              ~DROW04.CRE~   ~override~
              ~EYEEGL01.CRE~ ~override~
              ~firorc02.cre~ ~override~
              ~firorc03.cre~ ~override~
              ~glad2.cre~    ~override~
              ~GORCAMB2.CRE~ ~override~
              ~GORCAMB3.CRE~ ~override~
              ~GORPRI1.CRE~  ~override~
              ~gromg05.CRE~  ~override~
              ~gromg08.CRE~  ~override~
              ~GROMG13.CRE~  ~override~
              ~HGBER01.CRE~  ~override~
              ~HGNYA01.CRE~  ~override~
              ~HGSKL01.CRE~  ~override~
              ~HGSKL03.CRE~  ~override~
              ~hlassa.cre~   ~override~
              ~hlketta.cre~  ~override~
              ~hlketta2.cre~ ~override~
              ~HLMAGE.CRE~   ~override~
              ~hprelate.cre~ ~override~
              ~jolus.cre~    ~override~
              ~kendak.cre~   ~override~
              ~kuocle20.cre~ ~override~
              ~magetest.CRE~ ~override~
              ~MVPRIES.CRE~  ~override~
              ~pace.cre~     ~override~
              ~PCAPT04.CRE~  ~override~
              ~pettin.CRE~   ~override~
              ~PIRMUR09.CRE~ ~override~
              ~PPALTK1.CRE~  ~override~
              ~PPALTK2.CRE~  ~override~
              ~ppguard3.cre~ ~override~
              ~ppsail03.cre~ ~override~ // armor in weapon slot fixed elsewhere
              ~ppsuna.cre~   ~override~
              ~REBAND05.CRE~ ~override~
              ~RECLER01.CRE~ ~override~
              ~RECLER02.CRE~ ~override~
              ~rethie01.cre~ ~override~
              ~RETHUG03.CRE~ ~override~
              ~RIGEN02.CRE~  ~override~
              ~ribald.cre~   ~override~
              ~ryan.cre~     ~override~
              ~sahamb03.cre~ ~override~
              ~sahamb06.cre~ ~override~
              ~salvanas.cre~ ~override~
              ~sarcult.cre~  ~override~
              ~sarcult2.cre~ ~override~
              ~sarculto.cre~ ~override~
              ~sarhal.cre~   ~override~
              ~SARMAG01.CRE~ ~override~
              ~SARTEM01.CRE~ ~override~
              ~SENDAI.CRE~   ~override~
              ~SENDAI2.CRE~  ~override~
              ~SENDAI8.CRE~  ~override~
              ~senorc01.cre~ ~override~
              ~senorc03.cre~ ~override~
              ~SENPRI01.CRE~ ~override~
              ~SHUGMG01.CRE~ ~override~
              ~SHUGPR01.CRE~ ~override~
              ~SNAKE01.CRE~  ~override~
              ~SNAKEG01.CRE~ ~override~
              ~suna.cre~     ~override~
              ~TELTIEF3.CRE~ ~override~
              ~temsup.cre~   ~override~
              ~thief5.cre~   ~override~
              ~TOBPAR05.CRE~ ~override~
              ~tomegol4.CRE~ ~override~
              ~TREVIL01.CRE~ ~override~
              ~TRTHF02.CRE~  ~override~
              ~turn.CRE~     ~override~
              ~UDDEAR02.CRE~ ~override~
              ~UDDROW14.CRE~ ~override~
              ~UDDROW15.CRE~ ~override~
              ~UDDROW31.CRE~ ~override~
              ~UDDROW35.CRE~ ~override~
              ~UDDUER01.CRE~ ~override~
              ~UDELF05.CRE~  ~override~
              ~udgirl.CRE~   ~override~
              ~udtrap05.cre~ ~override~
              ~UHMER02.CRE~  ~override~
              ~vorsquir.CRE~ ~override~
              ~wauksna.CRE~  ~override~
              ~yaga02.CRE~   ~override~
              ~yaga04.CRE~   ~override~
              ~YSSOLD14.CRE~ ~override~
              ~YSSOLD16.CRE~ ~override~
              ~zilmag01.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG  0x2b8 "slot_off" ELSE 0
    FOR (index = 0 ; index < 4 ; index = index + 1) BEGIN // search through weapon slots
      READ_SHORT ("%slot_off%" + 0x12 + ("%index%" * 0x02)) "ref"
      PATCH_IF ("%ref%" != 0xffff) BEGIN // if valid reference in weapon slots
        WRITE_SHORT ("%slot_off%" + 0x4c) "%index%" // equipped weapon
        SET "index" = 4 // kills loop and prevents next patch_if
      END ELSE
      PATCH_IF ("%index%" = 3) BEGIN // if value hits 12, means no weapon slots are valid
        WRITE_SHORT ("%slot_off%" + 0x4c) 0xffff // equipped weapon is null, -1
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// eliminates pickpocket exploits
COPY_EXISTING ~ankheg01.cre~ ~override~
              ~bazdra02.cre~ ~override~
              ~cltiva01.cre~ ~override~
              ~firmag01.cre~ ~override~
              ~gemch02.cre~  ~override~
              ~hellgen.cre~  ~override~
              ~hlkang.cre~   ~override~
              ~jarlich.cre~  ~override~ // non-helm in helm slot for non-legit critical protection
              ~neb.cre~      ~override~ // non-helm in helm slot for non-legit critical protection
              ~ppjoye2.cre~  ~override~ // non-helm in helm slot for non-legit critical protection
              ~pptroll1.cre~ ~override~ // non-helm in helm slot for non-legit critical protection
//              ~sctelwyn.cre~ ~override~
              ~trolsi01.cre~ ~override~ // non-helm in helm slot for non-legit critical protection
              ~trolsi02.cre~ ~override~ // non-helm in helm slot for non-legit critical protection
              ~trolsp01.cre~ ~override~ // non-helm in helm slot for non-legit critical protection
              ~trolsp02.cre~ ~override~ // non-helm in helm slot for non-legit critical protection
              ~trrak01.cre~  ~override~
              ~udprince.cre~ ~override~
  READ_LONG 0x2b8 "slot_off" ELSE 0
  READ_LONG 0x2bc "itm_off"  ELSE 0
  READ_LONG 0x2c0 "itm_num"  ELSE 0
  SET "added" = 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               (
                 ("%item%" STRING_COMPARE_CASE "bazplo02" = 0) OR // draconis' head
                 ("%item%" STRING_COMPARE_CASE "ghost3"   = 0) OR // item w/ visual effects
                 ("%item%" STRING_COMPARE_CASE "illblur"  = 0) OR // item w/ visual effects
                 ("%item%" STRING_COMPARE_CASE "misc12"   = 0) OR // ankheg shell
                 ("%item%" STRING_COMPARE_CASE "misc7f"   = 0) OR // Ti'Vael's head
                 ("%item%" STRING_COMPARE_CASE "misc8k"   = 0) OR // ihtafeer's head
                 ("%item%" STRING_COMPARE_CASE "misc9h"   = 0) OR // neb's head
                 ("%item%" STRING_COMPARE_CASE "misca7"   = 0) OR // sahuagin prince's blood
                 ("%item%" STRING_COMPARE_CASE "miscb7"   = 0) OR // tears of bhaal
                 ("%item%" STRING_COMPARE_CASE "miscbg"   = 0)    // lich's tooth
               ) OR (
                 ("%item%" STRING_COMPARE_CASE "misc6z" = 0) AND    // beljuril
                 ("gemch02" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) // from chicken
               ) OR (
                 ("%item%" STRING_COMPARE_CASE "key09" = 0) AND   // firkraag's prison key
                 ("firmag01" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) // from conster
               ) OR (
                 ("%item%" STRING_COMPARE_CASE "ring39" = 0) AND   // ring of gaxx
                 ("hlkang" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) // from kangaxx
               )
             ) BEGIN
      FOR (index2 = 0 ; index2 < 36 ; index2 = index2 + 1) BEGIN // search through item slots
        READ_SHORT ("%slot_off%" + (0x02 * "%index2%")) "ref"
        PATCH_IF (("%index2%" = 1) OR ("%index2%" = 3) OR (("%index2%" > 6) AND ("%index2%" < 18))) BEGIN // if legit slot (1, 3, 7-17)
          PATCH_IF ("%ref%" = "%index%") BEGIN // if item in question
            PATCH_IF ("%added%" = 0) BEGIN // if found in a legit slot
              SET "added" = 1
            END ELSE BEGIN // if already found
              WRITE_SHORT ("%slot_off%" + (0x02 * "%index2%")) 0xffff // nulls reference
            END
          END ELSE
          PATCH_IF (("%ref%" = 0xffff) AND ("%added%" = 0)) BEGIN // if empty, legit slot
            WRITE_SHORT ("%slot_off%" + (0x02 * "%index2%")) "%index%" // adds reference
            SET "added" = 1
          END
        END ELSE BEGIN // if non-legit spot
          PATCH_IF ("%ref%" = "%index%") BEGIN // if reference to item being moved and in non-legit spot
            WRITE_SHORT ("%slot_off%" + (0x02 * "%index2%")) 0xffff // nulls reference
          END
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// summoned creatures shouldn't drop items
COPY_EXISTING ~dagnoll.cre~  ~override~ // halb01.itm, rndtre04.itm, rndtre02.itm
              ~gibbersu.cre~ ~override~ // rndtre02.itm
              ~gnollsu.cre~  ~override~ // helm01.itm, halb01.itm
              ~hamasu.cre~   ~override~ // dagg01.itm, potn20.itm, potn08.itm
              ~hobgobsu.cre~ ~override~ // bow05.itm, arow01.itm, leat01.itm, sw1h01.itm
              ~koboldsu.cre~ ~override~ // sw1h07.itm, bow05.itm, arow08.itm, arow01.itm, helm01.itm
              ~ogremasu.cre~ ~override~ // sw1h02.itm
              ~sahangu.cre~  ~override~ // rndtre04.itm, sper01.itm
              ~sahlace.cre~  ~override~ // rndtre04.itm
              ~sahskel.cre~  ~override~ // sw2h02.itm, rndtre05.itm, helm08.itm
              ~tasloisu.cre~ ~override~ // rndtre02.itm, sper01.itm, slng01.itm, bull01.itm, helm01.itm
              ~wolfwisu.cre~ ~override~ // misc01.itm
              ~wolfwwsu.cre~ ~override~ // misc01.itm
              ~wyvernsu.cre~ ~override~ // misc52.itm
              ~xvartsu.cre~  ~override~ // sw1h07.itm, rndtre02.itm, helm01.itm
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c0 "item_num"
  FOR (index = 0 ; index < item_num ; index = index + 1) BEGIN
    READ_BYTE ("%item_off%" + 0x10 + ("%index%" * 0x14)) "flags"
    PATCH_IF (("%flags%" BAND 0b00001000) = 0b00000000) BEGIN // if droppable
      WRITE_BYTE ("%item_off%" + 0x10 + ("%index%" * 0x14)) ("%flags%" BOR 0b00001000) // adds undroppable flag
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// set this batch to use their filename as DV
COPY_EXISTING ~bodfgt01.cre~ ~override~
              ~bodfgt02.cre~ ~override~
              ~cattig01.cre~ ~override~
              ~cldad.cre~    ~override~
              ~ffcrowd1.cre~ ~override~
              ~ffcrowd2.cre~ ~override~
              ~ffcrowd3.cre~ ~override~
              ~ffcrowd4.cre~ ~override~
              ~ffcrowd5.cre~ ~override~
              ~gerhardt.cre~ ~override~
              ~guard3.cre~   ~override~
              ~hobarc02.cre~ ~override~
              ~kpumb01.cre~  ~override~
              ~mourner4.cre~ ~override~
              ~mugger3.cre~  ~override~
              ~nobl4.cre~    ~override~
//              ~pparan2.cre~  ~override~
              ~rskel01.cre~  ~override~
              ~spidgi01.cre~ ~override~
              ~swsfoll1.cre~ ~override~
              ~swsfoll2.cre~ ~override~
              ~swsfoll3.cre~ ~override~
              ~swsfoll4.cre~ ~override~
              ~swsfoll5.cre~ ~override~
              ~swsfoll6.cre~ ~override~
              ~toady.cre~    ~override~
              ~tolger2.cre~  ~override~
              ~tolmag01.cre~ ~override~
              ~uddoor02.cre~ ~override~
              ~vammat01.cre~ ~override~
              ~vamold01.cre~ ~override~
              ~wcust01.cre~  ~override~
              ~wcust02.cre~  ~override~
              ~wcust03.cre~  ~override~
              ~wcust04.cre~  ~override~
              ~wolfdi.cre~   ~override~
  WRITE_EVALUATED_ASCII 0x280 ~%SOURCE_RES%~ #18
  BUT_ONLY_IF_IT_CHANGES

// corrected demon animations from D0Tweak
COPY_EXISTING ~gordem.cre~   ~override~
              ~jondem02.cre~ ~override~
              ~jondem04.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_SHORT 0x28 4352
  END
  BUT_ONLY_IF_IT_CHANGES

// corrected demon animations from D0Tweak
COPY_EXISTING ~dempit01.cre~ ~override~
  WRITE_SHORT 0x28 32558
  BUT_ONLY_IF_IT_CHANGES

// corrected demon animations from D0Tweak
ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB check

  COPY_EXISTING ~demgla01.cre~ ~override~
                ~demglab.cre~  ~override~
                ~demglab2.cre~ ~override~
                ~demglasu.cre~ ~override~
                ~enddem01.cre~ ~override~
                ~enddem02.cre~ ~override~
                ~jondem01.cre~ ~override~
                ~jondem03.cre~ ~override~
                ~jondem05.cre~ ~override~
    WRITE_SHORT 0x28 57585
    BUT_ONLY_IF_IT_CHANGES

  COPY_EXISTING ~abisred1.cre~ ~override~
    WRITE_SHORT 0x28 57568
    BUT_ONLY_IF_IT_CHANGES

END

/*
// soundset fixes for carrion crawlers; unable to get this to work via 2da
COPY_EXISTING ~CARCRA01.CRE~ ~OVERRIDE~
              ~CARRIO.CRE~   ~OVERRIDE~
              ~CARRIOSU.CRE~ ~OVERRIDE~
              ~POLYCARR.CRE~ ~OVERRIDE~
              ~SEWCC.CRE~    ~OVERRIDE~
  SAY 0xc8 #5874
  SAY 0xcc #5875
  SAY 0xdc #5877
  SAY 0xe0 #5877
  SAY 0xe4 #5876
  SAY 0xec #5879
  SAY 0xf0 #5880
  SAY 0x010c #5872
  SAY 0x0110 #5873
  BUT_ONLY_IF_IT_CHANGES
*/  

// knows class- or alignment-restricted spell
COPY_EXISTING ~aerbod01.cre~ ~override~
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a4 "known_num"
  READ_LONG 0x2a8 "meminfo_off"
  READ_LONG 0x2b0 "mem_off"
  READ_LONG 0x2b8 "slot_off"
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c4 "fx_off"
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +        ("%index%" * 0x0c)) "resref"
    PATCH_IF (("%resref%" STRING_COMPARE_CASE "sppr105" = 0) OR
              ("%resref%" STRING_COMPARE_CASE "sppr314" = 0)) BEGIN
      DELETE_BYTES ("%known_off%" +        ("%index%" * 0x0c)) 0x0C
      SET "known_num" = ("%known_num%" - 1)
      PATCH_IF ("%meminfo_off%" >= "%known_off%") BEGIN
        SET "meminfo_off" = ("%meminfo_off%" - 0x0C)
      END
      PATCH_IF ("%mem_off%" >= "%known_off%") BEGIN
        SET "mem_off" = ("%mem_off%" - 0x0C)
      END
      PATCH_IF ("%slot_off%" >= "%known_off%") BEGIN
        SET "slot_off" = ("%slot_off%" - 0x0C)
      END
      PATCH_IF ("%item_off%" >= "%known_off%") BEGIN
        SET "item_off" = ("%item_off%" - 0x0C)
      END
      PATCH_IF ("%fx_off%" >= "%known_off%") BEGIN
        SET "fx_off" = ("%fx_off%" - 0x0C)
      END
    END
  END
  WRITE_LONG 0x2a0 "%known_off%"
  WRITE_LONG 0x2a4 "%known_num%"
  WRITE_LONG 0x2a8 "%meminfo_off%"
  WRITE_LONG 0x2b0 "%mem_off%"
  WRITE_LONG 0x2b8 "%slot_off%"
  WRITE_LONG 0x2bc "%item_off%"
  WRITE_LONG 0x2c4 "%fx_off%"
  BUT_ONLY_IF_IT_CHANGES
  
// norh paladin from rep trap has wrong DV, script
COPY_EXISTING ~alex.cre~ ~override~
  WRITE_ASCII 0x248 ~NOrder~ #8 // override script
  WRITE_ASCII 0x280 ~NobleOrder~ #18 // DV
  BUT_ONLY_IF_IT_CHANGES

// has typos in spell resrefs
COPY_EXISTING ~amcarras.cre~ ~override~
  READ_LONG 0x2a0 "known_off" ELSE 0
  READ_LONG 0x2a4 "known_num" ELSE 0
  READ_LONG 0x2b0 "mem_off"   ELSE 0
  READ_LONG 0x2b4 "mem_num"   ELSE 0
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +       (0x0c * "%index%")) "spell"
    PATCH_IF ("%spell%" STRING_COMPARE_REGEXP "^spw[0-9][0-9][0-9]$" = 0) BEGIN
      INSERT_BYTES ("%known_off%" + 0x03 + (0x0c * "%index%")) 1
      WRITE_ASCII  ("%known_off%" + 0x03 + (0x0c * "%index%")) "i"
      DELETE_BYTES ("%known_off%" + 0x08 + (0x0c * "%index%")) 1
    END
  END
  FOR (index2 = 0 ; index2 < mem_num ; index2 = index2 + 1) BEGIN
    READ_ASCII ("%mem_off%" +       (0x0c * "%index2%")) "spell"
    PATCH_IF ("%spell%" STRING_COMPARE_REGEXP "^spw[0-9][0-9][0-9]$" = 0) BEGIN
      INSERT_BYTES ("%mem_off%" + 0x03 + (0x0c * "%index2%")) 1
      WRITE_ASCII  ("%mem_off%" + 0x03 + (0x0c * "%index2%")) "i"
      DELETE_BYTES ("%mem_off%" + 0x08 + (0x0c * "%index2%")) 1
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// mem & known spell resref typos
COPY_EXISTING ~amelm01.cre~  ~override~
              ~jatermin.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) BEGIN
    READ_LONG 0x2a0 "known_off"
    READ_LONG 0x2a4 "known_num"
    READ_LONG 0x2a8 "meminfo_off"
    READ_LONG 0x2b0 "mem_off"
    READ_LONG 0x2b4 "mem_num"
    READ_LONG 0x2b8 "slot_off"
    READ_LONG 0x2bc "item_off"
    READ_LONG 0x2c4 "fx_off"     
    SET "delta_known" = 0
    FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
      READ_ASCII ("%known_off%" +       (0x0c * "%index%")) "spell"
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "sppr112" = 0) BEGIN
        DELETE_BYTES ("%known_off%" +       (0x0c * "%index%")) 0x0c
        SET "delta_known" = ("%delta_known%" - 1)
        SET "index" = ("%index%" - 1)
        SET "known_num" = ("%known_num%" - 1)
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi121" = 0) BEGIN
        WRITE_ASCII  ("%known_off%" +       (0x0c * "%index%")) "spwi125"
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi122" = 0) BEGIN
        DELETE_BYTES ("%known_off%" +       (0x0c * "%index%")) 0x0c
        SET "delta_known" = ("%delta_known%" - 1)
        SET "index" = ("%index%" - 1)
        SET "known_num" = ("%known_num%" - 1)
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi610" = 0) BEGIN
        WRITE_ASCII  ("%known_off%" +       (0x0c * "%index%")) "spwi624"
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi706" = 0) BEGIN
        WRITE_ASCII  ("%known_off%" +       (0x0c * "%index%")) "spwi719"
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi709" = 0) BEGIN
        WRITE_ASCII  ("%known_off%" +       (0x0c * "%index%")) "spwi718"
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi801" = 0) BEGIN
        WRITE_ASCII  ("%known_off%" +       (0x0c * "%index%")) "spwi802"
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi806" = 0) BEGIN
        WRITE_ASCII  ("%known_off%" +       (0x0c * "%index%")) "spwi816"
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi814" = 0) BEGIN
        WRITE_ASCII  ("%known_off%" +       (0x0c * "%index%")) "spwi817"
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi901" = 0) BEGIN
        WRITE_ASCII  ("%known_off%" +       (0x0c * "%index%")) "spwi917"
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi904" = 0) BEGIN
        DELETE_BYTES ("%known_off%" +       (0x0c * "%index%")) 0x0c
        SET "delta_known" = ("%delta_known%" - 1)
        SET "index" = ("%index%" - 1)
        SET "known_num" = ("%known_num%" - 1)
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi906" = 0) BEGIN
        DELETE_BYTES ("%known_off%" +       (0x0c * "%index%")) 0x0c
        SET "delta_known" = ("%delta_known%" - 1)
        SET "index" = ("%index%" - 1)
        SET "known_num" = ("%known_num%" - 1)
      END
    END
    WRITE_LONG 0x2a4 "%known_num%"
    SET "meminfo_off" = ("%meminfo_off%" + ("%delta_known%" * 0x0c))
    WRITE_LONG 0x2a8 "%meminfo_off%"
    SET "mem_off" = ("%mem_off%" + ("%delta_known%" * 0x0c))
    WRITE_LONG  0x2b0 "%mem_off%"
    SET "delta_mem" = 0
    FOR (index2 = 0 ; index2 < 17 ; index2 = index2 + 1) BEGIN
      READ_LONG ("%meminfo_off%" + 0x08 + ("%index2%" * 0x10)) "meminfo_idx"
      READ_LONG ("%meminfo_off%" + 0x0c + ("%index2%" * 0x10)) "meminfo_num"
      SET "meminfo_idx" = ("%meminfo_idx%" + "%delta_mem%")
      WRITE_LONG ("%meminfo_off%" + 0x08 + ("%index2%" * 0x10)) "%meminfo_idx%"
      FOR (index3 = 0 ; index3 < meminfo_num ; index3 = index3 + 1) BEGIN
        READ_ASCII ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spell"
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "sppr112" = 0) BEGIN
          DELETE_BYTES ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) 0x0c
          SET "delta_mem" = ("%delta_mem%" - 1)
          SET "index3" = ("%index3%" - 1)
          SET "meminfo_num" = ("%meminfo_num%" - 1)
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi121" = 0) BEGIN
          WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spwi125"
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi122" = 0) BEGIN
          DELETE_BYTES ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) 0x0c
          SET "delta_mem" = ("%delta_mem%" - 1)
          SET "index3" = ("%index3%" - 1)
          SET "meminfo_num" = ("%meminfo_num%" - 1)
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi610" = 0) BEGIN
          WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spwi624"
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi706" = 0) BEGIN
          WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spwi719"
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi709" = 0) BEGIN
          WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spwi718"
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi801" = 0) BEGIN
          WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spwi802"
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi806" = 0) BEGIN
          WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spwi816"
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi814" = 0) BEGIN
          WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spwi817"
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi901" = 0) BEGIN
          WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spwi917"
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi904" = 0) BEGIN
          DELETE_BYTES ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) 0x0c
          SET "delta_mem" = ("%delta_mem%" - 1)
          SET "index3" = ("%index3%" - 1)
          SET "meminfo_num" = ("%meminfo_num%" - 1)
        END ELSE
        PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi906" = 0) BEGIN
          DELETE_BYTES ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) 0x0c
          SET "delta_mem" = ("%delta_mem%" - 1)
          SET "index3" = ("%index3%" - 1)
          SET "meminfo_num" = ("%meminfo_num%" - 1)
        END
      END
      WRITE_LONG ("%meminfo_off%" + 0x0c + ("%index2%" * 0x10)) "%meminfo_num%"
    END
    WRITE_LONG  0x2b4 ("%mem_num%" + "%delta_mem%")
    SET "offset" = (0x0c * ("%delta_mem%" + "%delta_known%"))
    PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2b8 ("%slot_off%" + "%offset%")
    END
    PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2bc ("%item_off%" + "%offset%")
    END
    PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2c4 ("%fx_off%" + "%offset%")
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// knows class- or alignment-restricted spell
COPY_EXISTING ~ammajira.cre~ ~override~
              ~chgood09.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG  0x2a0 "known_off"
    READ_LONG  0x2a4 "known_num"
    READ_LONG 0x2a8 "meminfo_off"
    READ_LONG 0x2b0 "mem_off"
    READ_LONG 0x2b8 "slot_off"
    READ_LONG 0x2bc "item_off"
    READ_LONG 0x2c4 "fx_off"
    FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
      READ_ASCII ("%known_off%" +        ("%index%" * 0x0c)) "resref"
      PATCH_IF (("%resref%" STRING_COMPARE_CASE "sppr506" = 0) OR
                ("%resref%" STRING_COMPARE_CASE "sppr517" = 0) OR
                ("%resref%" STRING_COMPARE_CASE "sppr605" = 0) OR
                ("%resref%" STRING_COMPARE_CASE "sppr702" = 0) OR
                ("%resref%" STRING_COMPARE_CASE "sppr717" = 0)) BEGIN
        DELETE_BYTES ("%known_off%" +        ("%index%" * 0x0c)) 0x0C
        SET "known_num" = ("%known_num%" - 1)
        PATCH_IF ("%meminfo_off%" >= "%known_off%") BEGIN
          SET "meminfo_off" = ("%meminfo_off%" - 0x0C)
        END
        PATCH_IF ("%mem_off%" >= "%known_off%") BEGIN
          SET "mem_off" = ("%mem_off%" - 0x0C)
        END
        PATCH_IF ("%slot_off%" >= "%known_off%") BEGIN
          SET "slot_off" = ("%slot_off%" - 0x0C)
        END
        PATCH_IF ("%item_off%" >= "%known_off%") BEGIN
          SET "item_off" = ("%item_off%" - 0x0C)
        END
        PATCH_IF ("%fx_off%" >= "%known_off%") BEGIN
          SET "fx_off" = ("%fx_off%" - 0x0C)
        END
      END
    END
    WRITE_LONG 0x2a0 "%known_off%"
    WRITE_LONG 0x2a4 "%known_num%"
    WRITE_LONG 0x2a8 "%meminfo_off%"
    WRITE_LONG 0x2b0 "%mem_off%"
    WRITE_LONG 0x2b8 "%slot_off%"
    WRITE_LONG 0x2bc "%item_off%"
    WRITE_LONG 0x2c4 "%fx_off%"
  END  
  BUT_ONLY_IF_IT_CHANGES

// eliminates non-STs from using ST soundset
COPY_EXISTING ~amsi.cre~     ~override~
              ~gpthief1.cre~ ~override~
  WRITE_LONG 0xcc 0xffffffff
  BUT_ONLY_IF_IT_CHANGES

// cre changes to match new kit.ids
COPY_EXISTING ~anomen6.cre~  ~override~
              ~anomen7.cre~  ~override~
              ~anomen8.cre~  ~override~
              ~anomen9.cre~  ~override~
              ~anomen10.cre~ ~override~
              ~anomen12.cre~ ~override~
              ~imoen.cre~    ~override~
              ~imoen6.cre~   ~override~
              ~imoen10.cre~  ~override~
              ~imoen15.cre~  ~override~
              ~imoen211.cre~ ~override~
              ~imoen213.cre~ ~override~
              ~mazzy8.cre~   ~override~
              ~mazzy9.cre~   ~override~
              ~mazzy11.cre~  ~override~
              ~mazzy12.cre~  ~override~
              ~mazzy15.cre~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG 0x244 "current_kit_value"
    PATCH_IF ("%current_kit_value%" = 0x00000000) BEGIN
      WRITE_LONG 0x244 0x40000000
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// aerie spellbook fix, should know flame blade
COPY_EXISTING ~aerie6.cre~  ~override~
              ~aerie7.cre~  ~override~
              ~aerie9.cre~  ~override~
              ~aerie10.cre~ ~override~
              ~aerie11.cre~ ~override~
              ~aerie12.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    ADD_KNOWN_SPELL ~sppr206~ #1 ~priest~
  END
  BUT_ONLY_IF_IT_CHANGES

// aerie7 has an extra star; need to remove spurious club prof
COPY_EXISTING ~aerie7.cre~ ~override~
  READ_LONG 0x2a0 "kspl_off"
  READ_LONG 0x2a8 "minfo_off"
  READ_LONG 0x2b0 "mspl_off"
  READ_LONG 0x2b8 "itmslot_off"
  READ_LONG 0x2bc "itm_off"
  READ_LONG 0x2c4 "fx_off"
  READ_LONG 0x2c8 "fx_num"
  SET "delta" = 0
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_LONG ("%fx_off%" + 0x08 + ("%index%" * 0x108)) "type"
    READ_LONG ("%fx_off%" + 0x18 + ("%index%" * 0x108)) "weap"
    PATCH_IF (("%type%" = 233) AND ("%weap%" = 115)) BEGIN // club prof
      DELETE_BYTES ("%fx_off%" + ("%index%" * 0x108)) 0x108
      SET "delta" = "%delta%" - 1
      SET "index" = "%fx_num%" // kills loop
    END
  END
  WRITE_LONG 0x2c8 ("%fx_num%" + "%delta%")
  SET "offset" = ("%delta%" * 0x108)
  PATCH_IF NOT ("%fx_off%" > "%kspl_off%") BEGIN
    WRITE_LONG 0x2a0 ("%kspl_off%" + "%offset%")
  END
  PATCH_IF NOT ("%fx_off%" > "%minfo_off%") BEGIN
    WRITE_LONG 0x2a8 ("%minfo_off%" + "%offset%")
  END
  PATCH_IF NOT ("%fx_off%" > "%mspl_off%") BEGIN
    WRITE_LONG 0x2b0 ("%mspl_off%" + "%offset%")
  END
  PATCH_IF NOT ("%fx_off%" > "%itmslot_off%") BEGIN
    WRITE_LONG 0x2b8 ("%itmslot_off%" + "%offset%")
  END
  PATCH_IF NOT ("%fx_off%" > "%itm_off%") BEGIN
    WRITE_LONG 0x2bc ("%itm_off%" + "%offset%")
  END
  BUT_ONLY_IF_IT_CHANGES
  
// anomen save fix
COPY_EXISTING ~anomen6.cre~ ~override~
  WRITE_BYTE 0x57 12 // save v breath
  BUT_ONLY_IF_IT_CHANGES

// anomen spellbook fix, remove fire seeds
COPY_EXISTING ~anomen6.cre~  ~override~
              ~anomen7.cre~  ~override~
              ~anomen8.cre~  ~override~
              ~anomen9.cre~  ~override~
              ~anomen10.cre~ ~override~
              ~anomen12.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG 0x2a0 "known_off"
    READ_LONG 0x2a4 "known_num"
    READ_LONG 0x2a8 "meminfo_off"
    READ_LONG 0x2b0 "mem_off"
    READ_LONG 0x2b4 "mem_num"
    READ_LONG 0x2b8 "slot_off"
    READ_LONG 0x2bc "item_off"
    READ_LONG 0x2c4 "fx_off"
    FOR (index2 = 0 ; index2 < mem_num ; index2 = index2 + 1) BEGIN // spellbook adjustments
      READ_ASCII ("%mem_off%" + ("%index2%" * 0x0C)) "spell"
      PATCH_IF ("sppr606" STRING_COMPARE_CASE "%spell%" = 0) BEGIN
        WRITE_ASCII ("%mem_off%" + ("%index2%" * 0x0C)) ~sppr607~ #8
      END
    END
    FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN // spellbook adjustments
      READ_ASCII ("%known_off%" + ("%index%" * 0x0C)) "spell"
      PATCH_IF ("sppr606" STRING_COMPARE_CASE "%spell%" = 0) BEGIN
        DELETE_BYTES ("%known_off%" + ("%index%" * 0x0C)) 0x0C
        SET "known_num" = ("%known_num%" - 1)
        SET "index" = ("%index%" - 1)
        PATCH_IF ("%meminfo_off%" >= "%known_off%") BEGIN
          SET "meminfo_off" = ("%meminfo_off%" - 0x0C)
        END
        PATCH_IF ("%mem_off%" >= "%known_off%") BEGIN
          SET "mem_off" = ("%mem_off%" - 0x0C)
        END
        PATCH_IF ("%slot_off%" >= "%known_off%") BEGIN
          SET "slot_off" = ("%slot_off%" - 0x0C)
        END
        PATCH_IF ("%item_off%" >= "%known_off%") BEGIN
          SET "item_off" = ("%item_off%" - 0x0C)
        END
        PATCH_IF ("%fx_off%" >= "%known_off%") BEGIN
          SET "fx_off" = ("%fx_off%" - 0x0C)
        END
      END
    END
    WRITE_LONG 0x2a4 "%known_num%"
    WRITE_LONG 0x2a8 "%meminfo_off%"
    WRITE_LONG 0x2b0 "%mem_off%"
    WRITE_LONG 0x2b8 "%slot_off%"
    WRITE_LONG 0x2bc "%item_off%"
    WRITE_LONG 0x2c4 "%fx_off%"
    ADD_KNOWN_SPELL ~sppr206~ #1 ~priest~
    ADD_KNOWN_SPELL ~sppr314~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr414~ #3 ~priest~
  END
  BUT_ONLY_IF_IT_CHANGES

// anomen short 4 stars from f > c dual (revised by Wisp)
COPY_EXISTING ~anomen6.cre~  ~override~
              ~anomen7.cre~  ~override~
              ~anomen8.cre~  ~override~
              ~anomen9.cre~  ~override~
              ~anomen10.cre~ ~override~
              ~anomen12.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_ASCII 0x3c ~NANOMENM~  // portrait fix for anomen9 in SoA
    SET_BG2_PROFICIENCY 98 2 //spears
    SET_BG2_PROFICIENCY 102 1 //staffs
    SET_BG2_PROFICIENCY 112 2 //sword & shield
    SET_BG2_PROFICIENCY 97 "%SOURCE_RES%" STRING_CONTAINS_REGEXP "1[02]" ? 1 : 2 //war hammers
  END
  BUT_ONLY_IF_IT_CHANGES

// skeleton warrior anim fix
COPY_EXISTING ~ar18skel.cre~ ~override~
  WRITE_SHORT 0x28 60176

// assigning names to creatures; from UB
COPY_EXISTING ~ARNBOY01.CRE~ ~override~  // Apprentice Torturer Douglas
  SAY NAME1 #38998
  SAY NAME2 #38998

// Suryris's Blade is unique; repacing all cre references (still for sale at Ribald's)
COPY_EXISTING ~bazliz04.cre~ ~override~ // lizard man captain
              ~gorsta02.cre~ ~override~ // wk statue
              ~gorsta09.cre~ ~override~ // wk statue
              ~jarevia.cre~  ~override~ // reviane
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "halb03" = 0) BEGIN // find Suryris's Blade
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "halb07" #8 // replace with generic halberd +2
      SET "index" = "%itm_num%" // kills loop
    END
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~bazpat03.cre~ ~override~ // typo
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_ASCII 0x268 ~wtasight~ #8
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~bonebld.cre~ ~override~
              ~sword01.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) BEGIN
    WRITE_BYTE 0x23a 25 // lower int to allowed range
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~boy1.cre~     ~override~ //typo
              ~vvstand3.cre~ ~override~ //typo
  WRITE_ASCII 0x258 ~runenemy~ #8
  BUT_ONLY_IF_IT_CHANGES

// DV changes
COPY_EXISTING ~brus.cre~  ~override~
              ~brus2.cre~ ~override~
  WRITE_ASCII 0x280 ~brus~ #18

// catti should not attack mages randomly
COPY_EXISTING ~C6CATTI.CRE~ ~OVERRIDE~
  WRITE_ASCII 0x0250 ~~ #8
  BUT_ONLY_IF_IT_CHANGES

// added paladiny stats to c6eric; replaces harbinger with party-friendly version
// both are also patched to LG alignment in the Oversight alignment section
COPY_EXISTING ~c6eric.cre~  ~override~
              ~c6eric3.cre~ ~override~
  WRITE_BYTE 0x238 15 // str
  WRITE_BYTE 0x23b 16 // wis
  WRITE_BYTE 0x23d 12 // con
  WRITE_BYTE 0x23e 18 // chr
  READ_LONG  0x2bc "itm_off"
  READ_LONG  0x2c0 "itm_num"
  WHILE ("%itm_num%" > 0) BEGIN
    SET "itm_num" = ("%itm_num%" - 1)
    READ_ASCII ("%itm_off%" + (0x14 * "%itm_num%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "sw2h07" = 0) BEGIN
      WRITE_ASCII ("%itm_off%" + (0x14 * "%itm_num%")) "cdsw2h07"
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// cernd spellbook fixes
COPY_EXISTING ~cernd10.cre~  ~override~
              ~cernd12.cre~  ~override~
              ~cernd13.cre~  ~override~
              ~cernd13b.cre~ ~override~
              ~cernd14.cre~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG 0x2a0 "known_off"
    READ_LONG 0x2a4 "known_num"
    READ_LONG 0x2a8 "meminfo_off"
    READ_LONG 0x2b0 "mem_off"
    READ_LONG 0x2b4 "mem_num"
    READ_LONG 0x2b8 "slot_off"
    READ_LONG 0x2bc "item_off"
    READ_LONG 0x2c4 "fx_off"
    FOR (index2 = 0 ; index2 < mem_num ; index2 = index2 + 1) BEGIN // spellbook adjustments
      READ_ASCII ("%mem_off%" + ("%index2%" * 0x0C)) "spell"
      PATCH_IF ("sppr405" STRING_COMPARE_CASE "%spell%" = 0) BEGIN // call woodland beings for mental domination
        WRITE_ASCII ("%mem_off%" + ("%index2%" * 0x0C)) ~sppr410~ #8
      END ELSE
      PATCH_IF ("sppr318" STRING_COMPARE_CASE "%spell%" = 0) BEGIN // cure disease for ZoSA
        WRITE_ASCII ("%mem_off%" + ("%index2%" * 0x0C)) ~sppr317~ #8
      END
    END
    FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN // spellbook adjustments
      READ_ASCII ("%known_off%" + ("%index%" * 0x0C)) "spell"
      PATCH_IF (("sppr318" STRING_COMPARE_CASE "%spell%" = 0) OR
                ("sppr405" STRING_COMPARE_CASE "%spell%" = 0) OR
                ("sppr507" STRING_COMPARE_CASE "%spell%" = 0)) BEGIN
        DELETE_BYTES ("%known_off%" + ("%index%" * 0x0C)) 0x0C
        SET "known_num" = ("%known_num%" - 1)
        SET "index" = ("%index%" - 1)
        PATCH_IF ("%meminfo_off%" >= "%known_off%") BEGIN
          SET "meminfo_off" = ("%meminfo_off%" - 0x0C)
        END
        PATCH_IF ("%mem_off%" >= "%known_off%") BEGIN
          SET "mem_off" = ("%mem_off%" - 0x0C)
        END
        PATCH_IF ("%slot_off%" >= "%known_off%") BEGIN
          SET "slot_off" = ("%slot_off%" - 0x0C)
        END
        PATCH_IF ("%item_off%" >= "%known_off%") BEGIN
          SET "item_off" = ("%item_off%" - 0x0C)
        END
        PATCH_IF ("%fx_off%" >= "%known_off%") BEGIN
          SET "fx_off" = ("%fx_off%" - 0x0C)
        END
      END
    END
    WRITE_LONG 0x2a4 "%known_num%"
    WRITE_LONG 0x2a8 "%meminfo_off%"
    WRITE_LONG 0x2b0 "%mem_off%"
    WRITE_LONG 0x2b8 "%slot_off%"
    WRITE_LONG 0x2bc "%item_off%"
    WRITE_LONG 0x2c4 "%fx_off%"
    ADD_KNOWN_SPELL ~sppr317~ #2 ~priest~
  END
  BUT_ONLY_IF_IT_CHANGES

// cernd12 missing star in single weapon style
COPY_EXISTING ~cernd12.cre~  ~override~
  READ_LONG 0x2a0 "kspl_off"
  READ_LONG 0x2a8 "minfo_off"
  READ_LONG 0x2b0 "mspl_off"
  READ_LONG 0x2b8 "itmslot_off"
  READ_LONG 0x2bc "itm_off"
  READ_LONG 0x2c4 "fx_off"
  READ_LONG 0x2c8 "fx_num"
  SET "delta" = 1
  INSERT_BYTES  "%fx_off%" 0x108 // inserting new prof effect
    WRITE_LONG  ("%fx_off%" + 0x08) 233    // opcode
    WRITE_LONG  ("%fx_off%" + 0x14) 1      // stars
    WRITE_LONG  ("%fx_off%" + 0x18) 113    // prof - single weapon style
    WRITE_LONG  ("%fx_off%" + 0x1c) 9      // timing
    WRITE_SHORT ("%fx_off%" + 0x24) 100    // prob
//    WRITE_ASCII ("%fx_off%" + 0x68) ~None~ // vvc
  WRITE_LONG 0x2c8 ("%fx_num%" + "%delta%")
  SET "offset" = ("%delta%" * 0x108)
  PATCH_IF NOT ("%fx_off%" > "%kspl_off%") BEGIN
    WRITE_LONG 0x2a0 ("%kspl_off%" + "%offset%")
  END
  PATCH_IF NOT ("%fx_off%" > "%minfo_off%") BEGIN
    WRITE_LONG 0x2a8 ("%minfo_off%" + "%offset%")
  END
  PATCH_IF NOT ("%fx_off%" > "%mspl_off%") BEGIN
    WRITE_LONG 0x2b0 ("%mspl_off%" + "%offset%")
  END
  PATCH_IF NOT ("%fx_off%" > "%itmslot_off%") BEGIN
    WRITE_LONG 0x2b8 ("%itmslot_off%" + "%offset%")
  END
  PATCH_IF NOT ("%fx_off%" > "%itm_off%") BEGIN
    WRITE_LONG 0x2bc ("%itm_off%" + "%offset%")
  END
  BUT_ONLY_IF_IT_CHANGES

// highest level cernds missing their override script, removing BG profs
COPY_EXISTING ~cernd13.cre~  ~override~
              ~cernd13b.cre~ ~override~
  WRITE_BYTE  0x6e 0
  WRITE_BYTE  0x6f 0
  WRITE_BYTE  0x70 0
  WRITE_BYTE  0x75 0
  WRITE_ASCII 0x248 ~CERND~ #8
  BUT_ONLY_IF_IT_CHANGES

// ToB cernd also missing his override script
COPY_EXISTING ~cernd14.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_ASCII 0x248 ~CERN25~ #8
    WRITE_BYTE  0x6e 0
    WRITE_BYTE  0x6f 0
    WRITE_BYTE  0x70 0
    WRITE_BYTE  0x75 0
  END
  BUT_ONLY_IF_IT_CHANGES

// prevents Tamoko from running away and making PP challenge unfinishable, see cdtamoko.bcs for other half
COPY_EXISTING ~chtaz02.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_ASCII 0x268 ~cdtamoko~ #8
  END
  BUT_ONLY_IF_IT_CHANGES

// Ellesime clone in Chateau Irenicus
COPY_EXISTING ~clone1.cre~ ~override~
  WRITE_LONG 0x28 32561
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~dadrow9.cre~ ~override~ // typo
  WRITE_ASCII 0x250 ~mage8a~ #8
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~dadrow10.cre~ ~override~ //typo
  WRITE_ASCII 0x250 ~pries10b~ #8
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~dadrow12.cre~ ~override~ //typo
  WRITE_ASCII 0x250 ~pries14t~ #8
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~dadrow15.cre~ ~override~ //typo
  WRITE_ASCII 0x258 ~mage8a~ #8
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~daghaun1.cre~ ~override~ //typo
  WRITE_ASCII 0x258 ~pries14t~ #8
  BUT_ONLY_IF_IT_CHANGES

// lots o' bugs in ddguard series, easier to clone a friend
COPY_EXISTING ~ddguard1.cre~ ~override/ddguard2.cre~
              ~ddguard1.cre~ ~override/ddguard3.cre~
              ~ddguard1.cre~ ~override/ddguard4.cre~
              ~ddguard1.cre~ ~override/ddguard5.cre~
              ~ddguard1.cre~ ~override/ddguard6.cre~
  WRITE_EVALUATED_ASCII 0x280 ~%DEST_RES%~ #18
  WRITE_EVALUATED_ASCII 0x2CC ~%DEST_RES%~ #8
  READ_LONG             0x2BC "itm_off"
  READ_SHORT            0x2C0 "itm_num"
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + ("%index%" * 0x14)) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "key14" = 0) BEGIN
      PATCH_IF ("%DEST_RES%" STRING_COMPARE_CASE "ddguard2" = 0) BEGIN
        WRITE_ASCII ("%itm_off%" + ("%index%" * 0x14)) ~key15~ #8
      END ELSE
      PATCH_IF ("%DEST_RES%" STRING_COMPARE_CASE "ddguard3" = 0) BEGIN
        WRITE_ASCII ("%itm_off%" + ("%index%" * 0x14)) ~key16~ #8
      END ELSE
      PATCH_IF ("%DEST_RES%" STRING_COMPARE_CASE "ddguard4" = 0) BEGIN
        WRITE_ASCII ("%itm_off%" + ("%index%" * 0x14)) ~key17~ #8
      END ELSE
      PATCH_IF ("%DEST_RES%" STRING_COMPARE_CASE "ddguard5" = 0) BEGIN
        WRITE_ASCII ("%itm_off%" + ("%index%" * 0x14)) ~key18~ #8
      END ELSE BEGIN
        WRITE_ASCII ("%itm_off%" + ("%index%" * 0x14)) ~key19~ #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// illegal CON scores
COPY_EXISTING ~deadb01.cre~  ~override~
              ~deadb02.cre~  ~override~
              ~deadb03.cre~  ~override~
              ~firwlf01.cre~ ~override~
              ~firwlf02.cre~ ~override~
              ~rngwlf01.cre~ ~override~
              ~rngwlf02.cre~ ~override~
              ~rngwlf03.cre~ ~override~
              ~rngwlf04.cre~ ~override~
              ~rngwlf05.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) BEGIN
    WRITE_BYTE 0x23d 25 // lower con to allowed range
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~demgla01.cre~ ~override~ // has summoned script, so destroys allies in shade lord dungeon
              ~demnab02.cre~ ~override~ // script reference broken, changed so they'll use actual powers instead of just melee
  WRITE_ASCII 0x248 ~tanari~ #8
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~dempit01.cre~ ~override~ //assigned to dempit.cre
              ~telpit2.cre~  ~override~ //assigned to dempit.cre
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_ASCII 0x248 ~dempit~ #8
  END  
  BUT_ONLY_IF_IT_CHANGES

// ferric runs away since he uses Yoshimo's script
COPY_EXISTING ~deshar.cre~ ~override~
  WRITE_ASCII 0x258 ~thief14t~ #8
  BUT_ONLY_IF_IT_CHANGES

// fallen devas using normal deva script
COPY_EXISTING ~devaevil.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) BEGIN // protects against invalid files
    WRITE_ASCII 0x248 ~devaevil~ // override script
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes good deva's spells
// sets devas to lev 25 to match fallen devas and planetars
COPY_EXISTING ~devagood.cre~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x234 25
    READ_LONG  0x2a0 "known_off"
    READ_LONG  0x2a8 "mem_info"
    READ_LONG  0x2b0 "mem_off"
    READ_LONG  0x2b4 "mem_num"
    READ_LONG  0x2b8 "slot_off"
    READ_LONG  0x2bc "item_off"
    READ_LONG  0x2c4 "fx_off"
    SET "mem_delta" = 0
    FOR (index = 4 ; index < 17 ; index = index + 1) BEGIN
      PATCH_IF (("%index%" = 4) OR ("%index%" = 6)) BEGIN
        READ_SHORT  ("%mem_info%" + 0x02 + ("%index%" * 0x10)) "num_mem1"
        READ_SHORT  ("%mem_info%" + 0x04 + ("%index%" * 0x10)) "num_mem2"
        READ_LONG   ("%mem_info%" + 0x08 + ("%index%" * 0x10)) "mem_idx"
        READ_SHORT  ("%mem_info%" + 0x0c + ("%index%" * 0x10)) "mem_count"
        WRITE_SHORT ("%mem_info%" + 0x02 + ("%index%" * 0x10)) ("%num_mem1%" + 2)
        WRITE_SHORT ("%mem_info%" + 0x04 + ("%index%" * 0x10)) ("%num_mem2%" + 2)
        SET "mem_idx" = "%mem_idx%" + "%mem_delta%"
        WRITE_LONG  ("%mem_info%" + 0x08 + ("%index%" * 0x10)) "%mem_idx%"
        WRITE_SHORT ("%mem_info%" + 0x0c + ("%index%" * 0x10)) ("%mem_count%" + 2)
        FOR (index2 = 0 ; index2 < 2 ; index2 = index2 + 1) BEGIN
          INSERT_BYTES    ("%mem_off%" +        (0x0c * ("%mem_delta%" + "%mem_idx%"))) 0x0c
            PATCH_IF ("%index%" = 4) BEGIN
              WRITE_ASCII ("%mem_off%" +        (0x0c * ("%mem_delta%" + "%mem_idx%"))) ~sppr502~
            END ELSE BEGIN
              WRITE_ASCII ("%mem_off%" +        (0x0c * ("%mem_delta%" + "%mem_idx%"))) ~sppr725~
            END
            WRITE_SHORT   ("%mem_off%" + 0x08 + (0x0c * ("%mem_delta%" + "%mem_idx%"))) 1
        END
        SET "mem_delta" = "%mem_delta%" + 2
      END ELSE BEGIN // adjust indices for other levels
        READ_LONG   ("%mem_info%" + 0x08 + ("%index%" * 0x10)) "mem_idx"
        WRITE_LONG  ("%mem_info%" + 0x08 + ("%index%" * 0x10)) ("%mem_idx%" + "%mem_delta%")
      END
    END
    WRITE_LONG 0x2b4 ("%mem_num%" + "%mem_delta%")
    // final wrapup; correct # of memorized spells and offsets
    SET "offset_delta" = ("%mem_delta%" * 0x0c)
    PATCH_IF ("%known_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2a0 ("%known_off%" + "%offset_delta%")
    END
    PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2b8 ("%slot_off%" + "%offset_delta%")
    END
    PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2bc ("%item_off%" + "%offset_delta%")
    END
    PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2c4 ("%fx_off%" + "%offset_delta%")
    END
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~drow06.cre~   ~override~
              ~uddrow19.cre~ ~override~
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a4 "known_num"
  READ_LONG 0x2a8 "meminfo_off"
  READ_LONG 0x2b0 "mem_off"
  READ_LONG 0x2b4 "mem_num"
  READ_LONG 0x2b8 "slot_off"
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c4 "fx_off"
  SET "delta_known" = 0
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +       (0x0c * "%index%")) "spell"
    PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi801" = 0) BEGIN
      WRITE_ASCII ("%known_off%" +       (0x0c * "%index%")) "spwi811"
    END
  END
  WRITE_LONG 0x2a4 "%known_num%"
  SET "meminfo_off" = ("%meminfo_off%" + ("%delta_known%" * 0x0c))
  WRITE_LONG 0x2a8 "%meminfo_off%"
  SET "mem_off" = ("%mem_off%" + ("%delta_known%" * 0x0c))
  WRITE_LONG  0x2b0 "%mem_off%"
  SET "delta_mem" = 0
  FOR (index2 = 0 ; index2 < 17 ; index2 = index2 + 1) BEGIN
    READ_LONG ("%meminfo_off%" + 0x08 + ("%index2%" * 0x10)) "meminfo_idx"
    READ_LONG ("%meminfo_off%" + 0x0c + ("%index2%" * 0x10)) "meminfo_num"
    SET "meminfo_idx" = ("%meminfo_idx%" + "%delta_mem%")
    WRITE_LONG ("%meminfo_off%" + 0x08 + ("%index2%" * 0x10)) "%meminfo_idx%"
    FOR (index3 = 0 ; index3 < meminfo_num ; index3 = index3 + 1) BEGIN
      READ_ASCII ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spell"
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi801" = 0) BEGIN
        WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spwi811"
      END
    END
    WRITE_LONG ("%meminfo_off%" + 0x0c + ("%index2%" * 0x10)) "%meminfo_num%"
  END
  WRITE_LONG  0x2b4 ("%mem_num%" + "%delta_mem%")
  SET "offset" = (0x0c * ("%delta_mem%" + "%delta_known%"))
  PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2b8 ("%slot_off%" + "%offset%")
  END
  PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2bc ("%item_off%" + "%offset%")
  END
  PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2c4 ("%fx_off%" + "%offset%")
  END
  BUT_ONLY_IF_IT_CHANGES

// create 'dead' or 'knocked down' versions of 'special' trolls (revised by Nythrun)
COPY_EXISTING 
drshnl01.cre ~override/drshnl11.cre~
eletro01.cre ~override/eletro03.cre~
kptrol03.cre ~override/kptrol23.cre~
pptroll1.cre ~override/pptroll2.cre~
sutroll.cre  ~override/sutroll2.cre~
torgal.cre   ~override/torgal2.cre~
  WRITE_SHORT    0x24    1 // current HP
  WRITE_SHORT    0x46   10 // natural AC
  WRITE_SHORT    0x48   10 // effective AC
  WRITE_BYTE     0x5a  100 // resist cold
  WRITE_BYTE     0x5b  100 // resist electricity
  WRITE_BYTE     0x5f  100 // resist magic cold
  WRITE_BYTE     0x60  100 // resist slashing
  WRITE_BYTE     0x61  100 // resist crushing
  WRITE_BYTE     0x62  100 // resist piercing
  WRITE_BYTE     0x63  100 // resist missile
  WRITE_BYTE     0x23c   9 // dexterity
  WRITE_BYTE     0x270 255 // enemy
  PATCH_IF          "%SOURCE_RES%" STRING_EQUAL_CASE kptrol03 BEGIN
    WRITE_ASCII  0x248 kptrol13   // override script
  END ELSE PATCH_IF "%SOURCE_RES%" STRING_EQUAL_CASE drshnl01 BEGIN
    WRITE_ASCII  0x248 drshnl21
  END ELSE PATCH_IF "%SOURCE_RES%" STRING_EQUAL_CASE torgal   BEGIN
    WRITE_ASCII  0x248 torgal3 #8 
  END ELSE BEGIN
    WRITE_ASCIIE 0x248 ~%SOURCE_RES%~ // new script
  END
  WRITE_ASCII    0x250 ~~ #32         // blanks all other script references
  WRITE_ASCII    0x2cc ~~ #8          // blanks dialog file
  REMOVE_CRE_ITEM  monhp1 trollreg trollspi
  REPLACE_CRE_ITEM trolldie #0 #0 #0 ~UNSTEALABLE&UNDROPPABLE~ BELT

// add monhp1 item to trolls to prevent death; assign script to force transformation to dead form at low HP
COPY_EXISTING ~drshnl01.cre~ ~override~
              ~eletro01.cre~ ~override~
              ~kptrol03.cre~ ~override~
              ~pptroll1.cre~ ~override~
              ~sutroll.cre~  ~override~
              ~torgal.cre~   ~override~
  ADD_CRE_ITEM ~monhp1~ #0 #0 #0 ~NONE~ ~AMULET~
  PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "kptrol03" = 0) BEGIN
    WRITE_ASCII 0x248 ~kptrol23~
  END ELSE
  PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "drshnl01" = 0) BEGIN
    WRITE_ASCII 0x248 ~drshnl11~
    WRITE_ASCII 0x258 ~drshnl01~ // restore Nith's attack script, pt 2: assign script
  END ELSE
  PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "eletro01" = 0) BEGIN
    WRITE_ASCII 0x248 ~eletro03~
  END ELSE
  PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "pptroll1" = 0) BEGIN
    WRITE_ASCII 0x248 ~pptroll2~
  END ELSE
  PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "sutroll" = 0) BEGIN
    WRITE_ASCII 0x248 ~sutroll2~
  END ELSE
  PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "torgal" = 0) BEGIN
    WRITE_ASCII 0x258 ~torgal2~ #8 // race script
  END

// one-off change for Nilthiri to prevent repeating dialogue after regenerating
COPY_EXISTING ~drshnl01.cre~ ~override/drshnl21.cre~
  WRITE_ASCII 0x250 ~~ #8 // no approach and speak script
  WRITE_BYTE  0x270 255   // enemy
  WRITE_ASCII 0x2cc ~~ #8 // no dialogue file

// makes druidad DestroySelf() if player is great druid; druidad.baf is compiled in the folder
COPY_EXISTING ~druidad.cre~ ~override~
  WRITE_ASCII 0x248 ~druidad~ #8 // override script
  WRITE_ASCII 0x250 ~initdlg~ #8 // class script
  BUT_ONLY_IF_IT_CHANGES
  
// edwin spell slot fix
// this is long and ugly. Edwin has one additional slot per level; so we remove all
// of his memorized mage spells and rebuild the section completely. The same methodology
// is also used to rebuild haer15, minsc8,9,10,12 and nalia8,9,13 and valyg8,9,11,12,13,16.
COPY_EXISTING ~edwin7.cre~  ~override~
              ~edwin9.cre~  ~override~
              ~edwin11.cre~ ~override~
              ~edwin12.cre~ ~override~
              ~edwin13.cre~ ~override~
              ~edwin15.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG 0x18  "xp"
    READ_BYTE 0x234 "level"
    READ_LONG 0x2a0 "known_off"
    READ_LONG 0x2a8 "mem_info"
    READ_LONG 0x2b0 "mem_off"
    READ_LONG 0x2b4 "mem_num"
    READ_LONG 0x2b8 "slot_off"
    READ_LONG 0x2bc "item_off"
    READ_LONG 0x2c4 "fx_off"
    READ_LONG    ("%mem_info%" + 0x08 + (7  * 0x10)) "idx_start"
    READ_LONG    ("%mem_info%" + 0x08 + (16 * 0x10)) "idx_end"
    DELETE_BYTES ("%mem_off%" + (0x0c * "%idx_start%")) (("%idx_end%" - "%idx_start%") * 0x0c)
    SET "delta" = 0

    // level 1
    SET "lev1" = 5
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    PATCH_IF ("%xp%" > 1200000) BEGIN
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi120~
    END ELSE BEGIN
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi119~
    END
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi119~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi112~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi112~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi104~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi102~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi101~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 7)
    PATCH_IF ("%level%" > 12) BEGIN
      SET "lev1" = ("%lev1%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      PATCH_IF ("%xp%" > 1200000) BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi106~
      END ELSE BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi102~
      END
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    WRITE_SHORT ("%mem_info%" + 0x02 + (7 * 0x10)) "%lev1%"
    WRITE_SHORT ("%mem_info%" + 0x04 + (7 * 0x10)) "%lev1%"
    WRITE_SHORT ("%mem_info%" + 0x0c + (7 * 0x10)) ("%lev1%" + 2)
  
    //level 2 fixes
    SET "lev2" = 4
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    PATCH_IF ("%xp%" > 1200000) BEGIN
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi201~
    END ELSE BEGIN
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi211~
    END
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi220~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi215~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi212~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi211~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi205~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 6)
    PATCH_IF ("%level%" > 10) BEGIN
      SET "lev2" = ("%lev2%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      PATCH_IF ("%xp%" > 1200000) BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi217~
      END ELSE BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi205~
      END
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    PATCH_IF ("%level%" > 12) BEGIN
      SET "lev2" = ("%lev2%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      PATCH_IF ("%xp%" > 1200000) BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi209~
      END ELSE BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi220~
      END
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    WRITE_SHORT ("%mem_info%" + 0x02 + (8 * 0x10)) "%lev2%"
    WRITE_SHORT ("%mem_info%" + 0x04 + (8 * 0x10)) "%lev2%"
    WRITE_LONG  ("%mem_info%" + 0x08 + (8 * 0x10)) (("%idx_start%" + "%delta%") - ("%lev2%" + 2))
    WRITE_SHORT ("%mem_info%" + 0x0c + (8 * 0x10)) ("%lev2%" + 2)
  
    //level 3 fixes
    SET "lev3" = 4
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi314~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi309~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi305~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi304~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi303~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi302~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 6)
    PATCH_IF ("%level%" > 10) BEGIN
      SET "lev3" = ("%lev3%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      PATCH_IF ("%xp%" > 1200000) BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi308~
      END ELSE BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi305~
      END
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    PATCH_IF ("%level%" > 12) BEGIN
      SET "lev3" = ("%lev3%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      PATCH_IF ("%xp%" > 1200000) BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi307~
      END ELSE BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi304~
      END
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    WRITE_SHORT ("%mem_info%" + 0x02 + (9 * 0x10)) "%lev3%"
    WRITE_SHORT ("%mem_info%" + 0x04 + (9 * 0x10)) "%lev3%"
    WRITE_LONG  ("%mem_info%" + 0x08 + (9 * 0x10)) (("%idx_start%" + "%delta%") - ("%lev3%" + 2))
    WRITE_SHORT ("%mem_info%" + 0x0c + (9 * 0x10)) ("%lev3%" + 2)
  
    //level 4 fixes
    SET "lev4" = 3
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    PATCH_IF ("%xp%" > 1200000) BEGIN
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi408~
    END ELSE BEGIN
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi406~
    END
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi416~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi407~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi406~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi403~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 5)
    PATCH_IF ("%level%" > 10) BEGIN
      SET "lev4" = ("%lev4%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      PATCH_IF ("%xp%" > 1200000) BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi405~
      END ELSE BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi407~
      END
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    PATCH_IF ("%level%" > 11) BEGIN
      SET "lev4" = ("%lev4%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      PATCH_IF ("%xp%" > 1200000) BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi401~
      END ELSE BEGIN
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi403~
      END
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    WRITE_SHORT ("%mem_info%" + 0x02 + (10 * 0x10)) "%lev4%"
    WRITE_SHORT ("%mem_info%" + 0x04 + (10 * 0x10)) "%lev4%"
    WRITE_LONG  ("%mem_info%" + 0x08 + (10 * 0x10)) (("%idx_start%" + "%delta%") - ("%lev4%" + 2))
    WRITE_SHORT ("%mem_info%" + 0x0c + (10 * 0x10)) ("%lev4%" + 2)
  
    //level 5 fixes
    SET "lev5" = 2
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi522~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi516~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi505~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi504~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 4)
    PATCH_IF ("%level%" > 10) BEGIN
      SET "lev5" = ("%lev5%" + 2)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi521~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi520~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 2)
    END
    PATCH_IF ("%level%" > 11) BEGIN
      SET "lev5" = ("%lev5%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi502~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    WRITE_SHORT ("%mem_info%" + 0x02 + (11 * 0x10)) "%lev5%"
    WRITE_SHORT ("%mem_info%" + 0x04 + (11 * 0x10)) "%lev5%"
    WRITE_LONG  ("%mem_info%" + 0x08 + (11 * 0x10)) (("%idx_start%" + "%delta%") - ("%lev5%" + 2))
    WRITE_SHORT ("%mem_info%" + 0x0c + (11 * 0x10)) ("%lev5%" + 2)
  
    //level 6 fixes
    SET "lev6" = 0
    PATCH_IF ("%level%" > 11) BEGIN
      SET "lev6" = ("%lev6%" + 2) // not an error
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi619~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi612~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi605~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi601~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 4)
    END
    PATCH_IF ("%level%" > 12) BEGIN
      SET "lev6" = ("%lev6%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi620~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    WRITE_SHORT ("%mem_info%" + 0x02 + (12 * 0x10)) "%lev6%"
    WRITE_SHORT ("%mem_info%" + 0x04 + (12 * 0x10)) "%lev6%"
    PATCH_IF ("%lev6%" > 0) BEGIN
      WRITE_LONG  ("%mem_info%" + 0x08 + (12 * 0x10)) (("%idx_start%" + "%delta%") - ("%lev6%" + 2))
      WRITE_SHORT ("%mem_info%" + 0x0c + (12 * 0x10)) ("%lev6%" + 2)
    END ELSE BEGIN
      WRITE_LONG  ("%mem_info%" + 0x08 + (12 * 0x10)) ("%idx_start%" + "%delta%")
      WRITE_SHORT ("%mem_info%" + 0x0c + (12 * 0x10)) 0
    END

    // wrapping up; correcting indexes for remaining wizard spells and innates
    SET "loops" = 0
    WHILE ("%loops%" < 3) BEGIN
      SET "loops" = ("%loops%" + 1)
      WRITE_SHORT ("%mem_info%" + 0x02 + (("%loops%" + 12) * 0x10)) 0
      WRITE_SHORT ("%mem_info%" + 0x04 + (("%loops%" + 12) * 0x10)) 0
      WRITE_LONG  ("%mem_info%" + 0x08 + (("%loops%" + 12) * 0x10)) ("%idx_start%" + "%delta%")
      WRITE_SHORT ("%mem_info%" + 0x0c + (("%loops%" + 12) * 0x10)) 0
    END
    WRITE_LONG  ("%mem_info%" + 0x08 + (16 * 0x10)) ("%idx_start%" + "%delta%")
    
    // final wrapup; correct # of memorized spells and offsets
    WRITE_LONG 0x2b4 (("%idx_start%" + "%delta%" + "%mem_num%") - "%idx_end%")
    SET "offset_delta" = ((("%delta%" + "%idx_start%") - "%idx_end%") * 0x0c)
    PATCH_IF ("%known_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2a0 ("%known_off%" + "%offset_delta%")
    END
    PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2b8 ("%slot_off%" + "%offset_delta%")
    END
    PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2bc ("%item_off%" + "%offset_delta%")
    END
    PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2c4 ("%fx_off%" + "%offset_delta%")
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// 'knocked down' troll can be killed by anything
COPY_EXISTING ~firamb05.cre~ ~override~
  WRITE_SHORT           0x24    1            // current HP
  WRITE_SHORT           0x46   10            // natural AC
  WRITE_SHORT           0x48   10            // effective AC
  WRITE_BYTE            0x5a  100            // resist cold
  WRITE_BYTE            0x5b  100            // resist electricity
  WRITE_BYTE            0x5f  100            // resist magic cold
  WRITE_BYTE            0x60  100            // resist slashing
  WRITE_BYTE            0x61  100            // resist crushing
  WRITE_BYTE            0x62  100            // resist piercing
  WRITE_BYTE            0x63  100            // resist missile
  WRITE_BYTE            0x23c   9            // dexterity
  WRITE_BYTE            0x270 255            // enemy
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// familiar fixes                                   \\\\\
/////                                                  \\\\\

// see also string fixes

// soa pseudo-dragon
COPY_EXISTING ~fampsd.cre~   ~override~
  WRITE_SHORT 0x46  2 // AC
  WRITE_SHORT 0x48  2 // AC
  WRITE_BYTE  0x5d 50 // resist magic
  READ_LONG 0x2bc "itm_off"
  READ_LONG 0x2c0 "itm_num"
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "s1-3" = 0) BEGIN
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) ~cdfampsd~ #8
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// soa ferret
COPY_EXISTING ~famfer.cre~ ~override~
  WRITE_BYTE  0x45 30 // hide in shadows
  WRITE_SHORT 0x46 4  // natural ac
  WRITE_SHORT 0x48 4  // effective ac
  WRITE_BYTE  0x68 30 // move silently
  WRITE_BYTE  0x69 15 // find/disarm traps
  WRITE_BYTE  0x6a 65 // pick pockets
  BUT_ONLY_IF_IT_CHANGES

// soa imp
COPY_EXISTING ~famimp.cre~ ~override~
  WRITE_SHORT 0x46 6  // natural ac
  WRITE_SHORT 0x48 6  // effective ac
  BUT_ONLY_IF_IT_CHANGES
  
// soa rabbit
COPY_EXISTING ~famrab.cre~   ~override~
  WRITE_BYTE  0x45 20 // hide in shadows
  WRITE_SHORT 0x46 5  // natural ac
  WRITE_SHORT 0x48 5  // effective ac
  WRITE_BYTE  0x59 75 // resist fire
  WRITE_BYTE  0x5c 0  // resist acid
  WRITE_BYTE  0x5d 65 // resist magic
  WRITE_BYTE  0x5e 75 // resist magic fire
  WRITE_BYTE  0x68 20 // move silently
  WRITE_BYTE  0x69 45 // find/disarm traps
  WRITE_BYTE  0x6a 0  // pick pockets
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "mepfir" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "s1-2" #8 // corrected resref
    END
  END
  // rabtring deleted elsewhere
  BUT_ONLY_IF_IT_CHANGES

// soa dust mephit
COPY_EXISTING ~famdust.cre~   ~override~
  WRITE_SHORT 0x46 10 // natural ac
  WRITE_SHORT 0x48 10 // effective ac
  BUT_ONLY_IF_IT_CHANGES
  
// soa fairy dragon
COPY_EXISTING ~famfair.cre~   ~override~
  WRITE_SHORT 0x46 8 // natural ac
  WRITE_SHORT 0x48 8 // effective ac
  WRITE_BYTE  0x59 0 // resist fire
  WRITE_BYTE  0x5b 0 // resist electricity
  WRITE_BYTE  0x5e 0 // resist magic fire
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "meplig" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "s1-2" #8 // corrected resref
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// soa cat
COPY_EXISTING ~famcat.cre~   ~override~
  WRITE_BYTE  0x45 89 // hide in shadows
  WRITE_SHORT 0x46 4  // natural ac
  WRITE_SHORT 0x48 4  // effective ac
  WRITE_BYTE  0x68 89 // move silently
  // sound restorations
  SAY 0xa4 @126
  SAY 0xc8 @126
  SAY 0xec @126
  SAY 0xf0 @126
  SAY 0x010c @126
  SAY 0x0110 @126
  // hastring deleted elsewhere
  BUT_ONLY_IF_IT_CHANGES
  
// soa quasit
COPY_EXISTING ~famquas.cre~   ~override~
  WRITE_SHORT 0x46 6  // natural ac
  WRITE_SHORT 0x48 6  // effective ac
  READ_LONG  0x2bc "itm_off" ELSE 0
  READ_LONG  0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "impqua" = 0) BEGIN // find invalid resref
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "s1-6" #8 // corrected resref
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // tob familiars
  
  // tob pseudo-dragon
  COPY_EXISTING ~fampsd25.cre~   ~override~
    WRITE_SHORT 0x46  2 // AC
    WRITE_SHORT 0x48  2 // AC
    WRITE_BYTE  0x5d 50 // resist magic
    WRITE_BYTE 0x238 15 // strength
    BUT_ONLY_IF_IT_CHANGES
  
  // tob ferret
  COPY_EXISTING ~famfer25.cre~ ~override~
    WRITE_BYTE  0x45 50 // hide in shadows
    WRITE_SHORT 0x46 0  // natural ac
    WRITE_SHORT 0x48 0  // effective ac
    WRITE_BYTE  0x68 50 // move silently
    WRITE_BYTE  0x69 55 // find/disarm traps
    WRITE_BYTE  0x6a 85 // pick pockets
    WRITE_BYTE 0x238 15 // strength
    BUT_ONLY_IF_IT_CHANGES

  // tob imp
  COPY_EXISTING ~famimp25.cre~ ~override~
    WRITE_SHORT 0x46 2  // natural ac
    WRITE_SHORT 0x48 2  // effective ac
    BUT_ONLY_IF_IT_CHANGES
  
  // tob rabbit
  COPY_EXISTING ~famrab25.cre~ ~override~
    WRITE_BYTE  0x45 50 // hide in shadows
    WRITE_SHORT 0x46 5  // natural ac
    WRITE_SHORT 0x48 5  // effective ac
    WRITE_BYTE  0x59 75 // resist fire
    WRITE_BYTE  0x5a 75 // resist cold
    WRITE_BYTE  0x5b 75 // resist electricity
    WRITE_BYTE  0x5e 75 // resist magic fire
    WRITE_BYTE  0x5f 75 // resist magic cold
    WRITE_BYTE  0x68 50 // move silently
    WRITE_BYTE  0x69 80 // find/disarm traps
    WRITE_BYTE  0x6a 0  // pick pockets
    BUT_ONLY_IF_IT_CHANGES
  
  // tob dust mephit
  COPY_EXISTING ~famdus25.cre~ ~override~
    WRITE_SHORT 0x46 7  // natural ac
    WRITE_SHORT 0x48 7  // effective ac
    ADD_MEMORIZED_SPELL ~spwi224~ #1 ~wizard~     // glitterdust
    ADD_MEMORIZED_SPELL ~spin935~ #0 ~innate~ (2) // 2x glass dust
    BUT_ONLY_IF_IT_CHANGES

  // tob fairy dragon
  COPY_EXISTING ~famfai25.cre~   ~override~
    WRITE_SHORT 0x24 48 // current hp
    WRITE_SHORT 0x26 48 // max hp
    WRITE_SHORT 0x46 4  // natural ac
    WRITE_SHORT 0x48 4  // effective ac
    READ_LONG  0x2bc "itm_off" ELSE 0
    READ_LONG  0x2c0 "itm_num" ELSE 0
    FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN // searches through items
      READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
      PATCH_IF ("%item%" STRING_COMPARE_CASE "meplig" = 0) BEGIN // find invalid resref
        WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) "s1-2" #8 // corrected resref
      END
    END
    BUT_ONLY_IF_IT_CHANGES
    
  // tob cat
  COPY_EXISTING ~famcat25.cre~   ~override~
    WRITE_BYTE  0x45 89 // hide in shadows
    WRITE_SHORT 0x46 0  // natural ac
    WRITE_SHORT 0x48 0  // effective ac
    WRITE_BYTE  0x68 89 // move silently
    WRITE_BYTE  0x69 55 // find/disarm traps
    WRITE_BYTE  0x6a 50 // pick pockets
    // hastring deleted elsewhere
    BUT_ONLY_IF_IT_CHANGES
    
  // tob quasit
  COPY_EXISTING ~famqua25.cre~   ~override~
    WRITE_SHORT 0x46 2  // natural ac
    WRITE_SHORT 0x48 2  // effective ac
    BUT_ONLY_IF_IT_CHANGES
  
END

// removes stolen flag from item
COPY_EXISTING ~GORSTA09.CRE~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG 0x2bc "itm_off"
    READ_LONG 0x2c0 "itm_num"
    WHILE ("%itm_num%" > 0) BEGIN
      SET "itm_num" = ("%itm_num%" - 1)
      READ_ASCII ("%itm_off%" + (0x14 * "%itm_num%")) "item"
      PATCH_IF ("%item%" STRING_COMPARE_CASE "halb07" = 0) BEGIN
        READ_BYTE  ("%itm_off%" + 0x10 + (0x14 * "%itm_num%")) "flags"
        WRITE_BYTE ("%itm_off%" + 0x10 + (0x14 * "%itm_num%")) ("%flags%" BAND 0b11111011)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// haer's elemental resistances and kit.ids fixes
COPY_EXISTING ~haer10.cre~ ~override~
              ~haer11.cre~ ~override~
              ~haer13.cre~ ~override~
              ~haer15.cre~ ~override~
              ~haer19.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x59 25 // these w_b are fixes for haer's elemental resistances
    WRITE_BYTE 0x5a 50
    WRITE_BYTE 0x5b 25
    WRITE_BYTE 0x5c 0
    WRITE_BYTE 0x5d 0
    WRITE_BYTE 0x5e 25
    WRITE_BYTE 0x5f 50
    WRITE_BYTE 0x60 15
    WRITE_BYTE 0x61 15
    WRITE_BYTE 0x62 15
    WRITE_BYTE 0x63 15
    WRITE_BYTE 0x6A 50 //pickpocketing, overwritten below for haer10, 11, 13
    READ_LONG 0x244 "current_kit_value"
    PATCH_IF ("%current_kit_value%" = 0x00000020) BEGIN
      WRITE_LONG 0x244 0x400d0000
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// hd pickpocket fixes
COPY_EXISTING ~haer10.cre~ ~override~
  WRITE_BYTE 0x6A 25 //pickpocketing

COPY_EXISTING ~haer11.cre~ ~override~
  WRITE_BYTE 0x6A 30 //pickpocketing

COPY_EXISTING ~haer13.cre~ ~override~
  WRITE_BYTE 0x6A 40 //pickpocketing

// haer'dalis spell issues
COPY_EXISTING ~haer15.cre~ ~override~
  ADD_KNOWN_SPELL ~spwi106~ #0 ~wizard~
  ADD_KNOWN_SPELL ~spwi112~ #0 ~wizard~
  ADD_KNOWN_SPELL ~spwi113~ #0 ~wizard~
  ADD_KNOWN_SPELL ~spwi116~ #0 ~wizard~
  ADD_KNOWN_SPELL ~spwi201~ #1 ~wizard~
  ADD_KNOWN_SPELL ~spwi206~ #1 ~wizard~
  ADD_KNOWN_SPELL ~spwi209~ #1 ~wizard~
  ADD_KNOWN_SPELL ~spwi212~ #1 ~wizard~
  ADD_KNOWN_SPELL ~spwi303~ #2 ~wizard~
  ADD_KNOWN_SPELL ~spwi305~ #2 ~wizard~
  ADD_KNOWN_SPELL ~spwi312~ #2 ~wizard~
  ADD_KNOWN_SPELL ~spwi401~ #3 ~wizard~
  ADD_KNOWN_SPELL ~spwi406~ #3 ~wizard~
  ADD_KNOWN_SPELL ~spwi408~ #3 ~wizard~
  ADD_KNOWN_SPELL ~spwi508~ #4 ~wizard~
  ADD_KNOWN_SPELL ~spwi510~ #4 ~wizard~
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a8 "mem_info"
  READ_LONG 0x2b0 "mem_off"
  READ_LONG 0x2b4 "mem_num"
  READ_LONG 0x2b8 "slot_off"
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c4 "fx_off"
  READ_LONG    ("%mem_info%" + 0x08 + (7  * 0x10)) "idx_start"
  READ_LONG    ("%mem_info%" + 0x08 + (16 * 0x10)) "idx_end"
  DELETE_BYTES ("%mem_off%" + (0x0c * "%idx_start%")) (("%idx_end%" - "%idx_start%") * 0x0c)
  SET "delta" = 0

  // level 1
  SET "lev1" = 3
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi113~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi112~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi106~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 3)
  WRITE_SHORT ("%mem_info%" + 0x02 + (7 * 0x10)) "%lev1%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (7 * 0x10)) "%lev1%"
  WRITE_SHORT ("%mem_info%" + 0x0c + (7 * 0x10)) "%lev1%"

  //level 2 fixes
  SET "lev2" = 3
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi209~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi206~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi201~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 3)
  WRITE_SHORT ("%mem_info%" + 0x02 + (8 * 0x10)) "%lev2%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (8 * 0x10)) "%lev2%"
  WRITE_LONG  ("%mem_info%" + 0x08 + (8 * 0x10)) (("%idx_start%" + "%delta%") - "%lev2%")
  WRITE_SHORT ("%mem_info%" + 0x0c + (8 * 0x10)) "%lev2%"

  //level 3 fixes
  SET "lev3" = 3
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi312~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi305~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi303~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 3)
  WRITE_SHORT ("%mem_info%" + 0x02 + (9 * 0x10)) "%lev3%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (9 * 0x10)) "%lev3%"
  WRITE_LONG  ("%mem_info%" + 0x08 + (9 * 0x10)) (("%idx_start%" + "%delta%") - "%lev3%")
  WRITE_SHORT ("%mem_info%" + 0x0c + (9 * 0x10)) "%lev3%"

  //level 4 fixes
  SET "lev4" = 3
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi408~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi406~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi401~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 3)
  WRITE_SHORT ("%mem_info%" + 0x02 + (10 * 0x10)) "%lev4%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (10 * 0x10)) "%lev4%"
  WRITE_LONG  ("%mem_info%" + 0x08 + (10 * 0x10)) (("%idx_start%" + "%delta%") - "%lev4%")
  WRITE_SHORT ("%mem_info%" + 0x0c + (10 * 0x10)) "%lev4%"

  //level 5 fixes
  SET "lev5" = 2
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi510~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi508~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 2)
  WRITE_SHORT ("%mem_info%" + 0x02 + (11 * 0x10)) "%lev5%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (11 * 0x10)) "%lev5%"
  WRITE_LONG  ("%mem_info%" + 0x08 + (11 * 0x10)) (("%idx_start%" + "%delta%") - "%lev5%")
  WRITE_SHORT ("%mem_info%" + 0x0c + (11 * 0x10)) "%lev5%"

  // wrapping up; correcting indexes for remaining wizard spells and innates
  SET "loops" = 0
  WHILE ("%loops%" < 4) BEGIN
    SET "loops" = ("%loops%" + 1)
    WRITE_SHORT ("%mem_info%" + 0x02 + (("%loops%" + 11) * 0x10)) 0
    WRITE_SHORT ("%mem_info%" + 0x04 + (("%loops%" + 11) * 0x10)) 0
    WRITE_LONG  ("%mem_info%" + 0x08 + (("%loops%" + 11) * 0x10)) ("%idx_start%" + "%delta%")
    WRITE_SHORT ("%mem_info%" + 0x0c + (("%loops%" + 11) * 0x10)) 0
  END
  WRITE_LONG  ("%mem_info%" + 0x08 + (16 * 0x10)) ("%idx_start%" + "%delta%")
  
  // final wrapup; correct # of memorized spells and offsets
  WRITE_LONG 0x2b4 (("%idx_start%" + "%delta%" + "%mem_num%") - "%idx_end%")
  SET "offset_delta" = ((("%delta%" + "%idx_start%") - "%idx_end%") * 0x0c)
  PATCH_IF ("%known_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2a0 ("%known_off%" + "%offset_delta%")
  END
  PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2b8 ("%slot_off%" + "%offset_delta%")
  END
  PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2bc ("%item_off%" + "%offset_delta%")
  END
  PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2c4 ("%fx_off%" + "%offset_delta%")
  END

// knows class- or alignment-restricted spell
COPY_EXISTING ~heartg3.cre~ ~override~
              ~heartg4.cre~ ~override~
              ~heartg5.cre~ ~override~
  READ_LONG  0x2a0 "known_off"
  READ_LONG  0x2a4 "known_num"
  READ_LONG 0x2a8 "meminfo_off"
  READ_LONG 0x2b0 "mem_off"
  READ_LONG 0x2b8 "slot_off"
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c4 "fx_off"
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +        ("%index%" * 0x0c)) "resref"
    PATCH_IF (("%resref%" STRING_COMPARE_CASE "sppr105" = 0) OR
              ("%resref%" STRING_COMPARE_CASE "sppr314" = 0) OR
              ("%resref%" STRING_COMPARE_CASE "sppr605" = 0) OR
              ("%resref%" STRING_COMPARE_CASE "sppr606" = 0)) BEGIN
      DELETE_BYTES ("%known_off%" +        ("%index%" * 0x0c)) 0x0C
      SET "known_num" = ("%known_num%" - 1)
      PATCH_IF ("%meminfo_off%" >= "%known_off%") BEGIN
        SET "meminfo_off" = ("%meminfo_off%" - 0x0C)
      END
      PATCH_IF ("%mem_off%" >= "%known_off%") BEGIN
        SET "mem_off" = ("%mem_off%" - 0x0C)
      END
      PATCH_IF ("%slot_off%" >= "%known_off%") BEGIN
        SET "slot_off" = ("%slot_off%" - 0x0C)
      END
      PATCH_IF ("%item_off%" >= "%known_off%") BEGIN
        SET "item_off" = ("%item_off%" - 0x0C)
      END
      PATCH_IF ("%fx_off%" >= "%known_off%") BEGIN
        SET "fx_off" = ("%fx_off%" - 0x0C)
      END
    END
  END
  WRITE_LONG 0x2a0 "%known_off%"
  WRITE_LONG 0x2a4 "%known_num%"
  WRITE_LONG 0x2a8 "%meminfo_off%"
  WRITE_LONG 0x2b0 "%mem_off%"
  WRITE_LONG 0x2b8 "%slot_off%"
  WRITE_LONG 0x2bc "%item_off%"
  WRITE_LONG 0x2c4 "%fx_off%"
  BUT_ONLY_IF_IT_CHANGES

// improved continuity fixes from Oversight
COPY_EXISTING ~hellslay.cre~ ~override~
  SAY BATTLE_CRY1 #60501
  SAY BATTLE_CRY2 #60502
  SAY SELECT_COMMON1 #60500
  SAY DAMAGE #60503
  SAY DYING #60504

COPY_EXISTING ~helmbyr.cre~  ~override~ // replaces nonexistent initpc
              ~latlara.cre~  ~override~
              ~talvilon.cre~ ~override~
  WRITE_ASCII 0x250 ~initmain~ #8
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~jael01.cre~   ~override~
              ~ppumb01.cre~  ~override~
              ~pries18b.cre~ ~override~
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a4 "known_num"
  READ_LONG 0x2a8 "meminfo_off"
  READ_LONG 0x2b0 "mem_off"
  READ_LONG 0x2b4 "mem_num"
  READ_LONG 0x2b8 "slot_off"
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c4 "fx_off"
  SET "delta_known" = 0
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +       (0x0c * "%index%")) "spell"
    PATCH_IF ("%spell%" STRING_COMPARE_CASE "sppr714" = 0) BEGIN
      WRITE_ASCII  ("%known_off%" +       (0x0c * "%index%")) "sppr706"
    END
  END
  WRITE_LONG 0x2a4 "%known_num%"
  SET "meminfo_off" = ("%meminfo_off%" + ("%delta_known%" * 0x0c))
  WRITE_LONG 0x2a8 "%meminfo_off%"
  SET "mem_off" = ("%mem_off%" + ("%delta_known%" * 0x0c))
  WRITE_LONG  0x2b0 "%mem_off%"
  SET "delta_mem" = 0
  FOR (index2 = 0 ; index2 < 17 ; index2 = index2 + 1) BEGIN
    READ_LONG ("%meminfo_off%" + 0x08 + ("%index2%" * 0x10)) "meminfo_idx"
    READ_LONG ("%meminfo_off%" + 0x0c + ("%index2%" * 0x10)) "meminfo_num"
    SET "meminfo_idx" = ("%meminfo_idx%" + "%delta_mem%")
    WRITE_LONG ("%meminfo_off%" + 0x08 + ("%index2%" * 0x10)) "%meminfo_idx%"
    FOR (index3 = 0 ; index3 < meminfo_num ; index3 = index3 + 1) BEGIN
      READ_ASCII ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spell"
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "sppr714" = 0) BEGIN
        WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "sppr706"
      END
    END
    WRITE_LONG ("%meminfo_off%" + 0x0c + ("%index2%" * 0x10)) "%meminfo_num%"
  END
  WRITE_LONG  0x2b4 ("%mem_num%" + "%delta_mem%")
  SET "offset" = (0x0c * ("%delta_mem%" + "%delta_known%"))
  PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2b8 ("%slot_off%" + "%offset%")
  END
  PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2bc ("%item_off%" + "%offset%")
  END
  PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2c4 ("%fx_off%" + "%offset%")
  END
  BUT_ONLY_IF_IT_CHANGES

// trolls lacking the correct 1hp items
COPY_EXISTING ~hgtrl01.cre~  ~override~ // fire troll
              ~kptrol01.cre~ ~override~ // kptrol0[1-4] are trolls from de'Arnise keep
              ~kptrol02.cre~ ~override~
//              ~kptrol03.cre~ ~override~ handled in special batch above
              ~kptrol04.cre~ ~override~
              ~obsice01.cre~ ~override~ // snow troll from planar sphere
              ~trolgi01.cre~ ~override~ // generic giant troll
              ~trollens.cre~ ~override~ // giant troll
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    ADD_CRE_ITEM ~monhp1~ #0 #0 #0 ~NONE~ ~AMULET~ // either adds it new, or forces minhp1 into inventory (and unequipped)
  END
  BUT_ONLY_IF_IT_CHANGES

// removes duplicate Sir Donalus
COPY_EXISTING ~HELMPR.CRE~ ~OVERRIDE~
  SAY 0x08 #17221
  SAY 0x0c #17221
  BUT_ONLY_IF_IT_CHANGES

//shyressa is a female vamp, but uses male vamp avatar
COPY_EXISTING ~hlshyr.cre~ ~override~
  WRITE_SHORT 0x28 32546
  BUT_ONLY_IF_IT_CHANGES

// lesser clay golems not immune to backstab
COPY_EXISTING ~igolfle1.cre~ ~override~
              ~igolfle2.cre~ ~override~
              ~igolfle3.cre~ ~override~
              ~igolfle4.cre~ ~override~
  ADD_CRE_ITEM ~golcla~ #0 #0 #0 ~NONE~ ~LRING RRING AMULET~
  BUT_ONLY_IF_IT_CHANGES

// imoen's thieving, script, prof, and thac0 fixes
COPY_EXISTING ~imoen10.cre~  ~override~
              ~imoen15.cre~  ~override~
              ~imoen211.cre~ ~override~
              ~imoen213.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG 0x2a0 "kspl_off"
    READ_LONG 0x2a8 "minfo_off"
    READ_LONG 0x2b0 "mspl_off"
    READ_LONG 0x2b8 "itmslot_off"
    READ_LONG 0x2bc "itm_off"
    READ_LONG 0x2c4 "fx_off"
    READ_LONG 0x2c8 "fx_num"
    SET "delta" = 1
    PATCH_IF (("%SOURCE_RES%" STRING_COMPARE_CASE "imoen15" = 0) OR  // restore battlecry and correct
              ("%SOURCE_RES%" STRING_COMPARE_CASE "imoen211" = 0) OR // Imoen's bio post-Spellhold
              ("%SOURCE_RES%" STRING_COMPARE_CASE "imoen213" = 0)) BEGIN
      SAY 0xd0  #11035
      SAY 0x1cc @102
    END
    PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "imoen213" = 0) BEGIN
      WRITE_ASCII 0x248 ~imoen2~ #8 // override script missing from imoen213
    END
    WRITE_BYTE 0x67 75 // open locks
    WRITE_BYTE 0x69 85 // find/disarm traps
    WRITE_BYTE 0x6a 10 // pickpocketing
    PATCH_IF (("%SOURCE_RES%" STRING_COMPARE_CASE "imoen10" = 0) OR
              ("%SOURCE_RES%" STRING_COMPARE_CASE "imoen211" = 0)) BEGIN // thac0 adjustment for low level versions
      WRITE_BYTE 0x52 17 // thac0
    END ELSE BEGIN                                                       // extra prof for high level versions
      SET "delta" = 2
      INSERT_BYTES  "%fx_off%" 0x108 // inserting new prof effect
        WRITE_LONG  ("%fx_off%" + 0x08) 233    // opcode
        WRITE_LONG  ("%fx_off%" + 0x14) 1      // stars
        WRITE_LONG  ("%fx_off%" + 0x18) 113    // prof - single weapon
        WRITE_LONG  ("%fx_off%" + 0x1c) 9      // timing
        WRITE_SHORT ("%fx_off%" + 0x24) 100    // prob
        WRITE_ASCII ("%fx_off%" + 0x68) ~None~ // vvc
    END
    INSERT_BYTES  "%fx_off%" 0x108 // inserting new prof effect
      WRITE_LONG  ("%fx_off%" + 0x08) 233    // opcode
      WRITE_LONG  ("%fx_off%" + 0x14) 1      // stars
      WRITE_LONG  ("%fx_off%" + 0x18) 91     // prof - short sword
      WRITE_LONG  ("%fx_off%" + 0x1c) 9      // timing
      WRITE_SHORT ("%fx_off%" + 0x24) 100    // prob
      WRITE_ASCII ("%fx_off%" + 0x68) ~None~ // vvc
    WRITE_LONG 0x2c8 ("%fx_num%" + "%delta%")
    SET "offset" = ("%delta%" * 0x108)
    PATCH_IF NOT ("%fx_off%" > "%kspl_off%") BEGIN
      WRITE_LONG 0x2a0 ("%kspl_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%minfo_off%") BEGIN
      WRITE_LONG 0x2a8 ("%minfo_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%mspl_off%") BEGIN
      WRITE_LONG 0x2b0 ("%mspl_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%itmslot_off%") BEGIN
      WRITE_LONG 0x2b8 ("%itmslot_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%itm_off%") BEGIN
      WRITE_LONG 0x2bc ("%itm_off%" + "%offset%")
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// assign galvarey a script that won't cause him to stutter (see soa-dlg.d for dialogue trigger change)
COPY_EXISTING ~jagalvar.cre~ ~override~
  WRITE_ASCII 0x250 ~initin15~ // class script
  BUT_ONLY_IF_IT_CHANGES
  
// jaheira thac0 and spellbook fixes... many
COPY_EXISTING ~jaheir7.cre~  ~override~
              ~jaheir8.cre~  ~override~
              ~jaheir11.cre~ ~override~
              ~jaheir12.cre~ ~override~
              ~jahei14.cre~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_BYTE 0x234 "level1"
    WRITE_BYTE 0x52 (21 - "%level1%") // thac0
    READ_LONG 0x2a0 "known_off"
    READ_LONG 0x2a4 "known_num"
    READ_LONG 0x2a8 "meminfo_off"
    READ_LONG 0x2b0 "mem_off"
    READ_LONG 0x2b4 "mem_num"
    READ_LONG 0x2b8 "slot_off"
    READ_LONG 0x2bc "item_off"
    READ_LONG 0x2c4 "fx_off"
    FOR (index2 = 0 ; index2 < mem_num ; index2 = index2 + 1) BEGIN // spellbook adjustments
      READ_ASCII ("%mem_off%" + ("%index2%" * 0x0C)) "spell"
      PATCH_IF ("sppr208" STRING_COMPARE_CASE "%spell%" = 0) BEGIN // entangle for remove fear
        WRITE_ASCII ("%mem_off%" + ("%index2%" * 0x0C)) ~sppr105~ #8
      END ELSE
      PATCH_IF ("sppr318" STRING_COMPARE_CASE "%spell%" = 0) BEGIN // summon insects for ZoSA
        WRITE_ASCII ("%mem_off%" + ("%index2%" * 0x0C)) ~sppr319~ #8
      END ELSE
      PATCH_IF ("sppr405" STRING_COMPARE_CASE "%spell%" = 0) BEGIN // cause serious wounds for mental domination
        WRITE_ASCII ("%mem_off%" + ("%index2%" * 0x0C)) ~sppr414~ #8
      END ELSE
      PATCH_IF ("sppr507" STRING_COMPARE_CASE "%spell%" = 0) BEGIN // true seeing for champion's strength
        WRITE_ASCII ("%mem_off%" + ("%index2%" * 0x0C)) ~sppr505~ #8
      END
    END
    FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN // spellbook adjustments
      READ_ASCII ("%known_off%" + ("%index%" * 0x0C)) "spell"
      PATCH_IF (("sppr108" STRING_COMPARE_CASE "%spell%" = 0) OR
                ("sppr318" STRING_COMPARE_CASE "%spell%" = 0) OR
                ("sppr405" STRING_COMPARE_CASE "%spell%" = 0) OR
                ("sppr507" STRING_COMPARE_CASE "%spell%" = 0)) BEGIN
        DELETE_BYTES ("%known_off%" + ("%index%" * 0x0C)) 0x0C
        SET "known_num" = ("%known_num%" - 1)
        SET "index" = ("%index%" - 1)
        PATCH_IF ("%meminfo_off%" >= "%known_off%") BEGIN
          SET "meminfo_off" = ("%meminfo_off%" - 0x0C)
        END
        PATCH_IF ("%mem_off%" >= "%known_off%") BEGIN
          SET "mem_off" = ("%mem_off%" - 0x0C)
        END
        PATCH_IF ("%slot_off%" >= "%known_off%") BEGIN
          SET "slot_off" = ("%slot_off%" - 0x0C)
        END
        PATCH_IF ("%item_off%" >= "%known_off%") BEGIN
          SET "item_off" = ("%item_off%" - 0x0C)
        END
        PATCH_IF ("%fx_off%" >= "%known_off%") BEGIN
          SET "fx_off" = ("%fx_off%" - 0x0C)
        END
      END
    END
    WRITE_LONG 0x2a4 "%known_num%"
    WRITE_LONG 0x2a8 "%meminfo_off%"
    WRITE_LONG 0x2b0 "%mem_off%"
    WRITE_LONG 0x2b8 "%slot_off%"
    WRITE_LONG 0x2bc "%item_off%"
    WRITE_LONG 0x2c4 "%fx_off%"
    ADD_KNOWN_SPELL ~sppr317~ #2 ~priest~
    PATCH_IF ("%level1%" = 8) BEGIN // jaheir11
      ADD_KNOWN_SPELL ~sppr501~ #4 ~priest~
      ADD_KNOWN_SPELL ~sppr502~ #4 ~priest~
      ADD_KNOWN_SPELL ~sppr505~ #4 ~priest~
      ADD_KNOWN_SPELL ~sppr506~ #4 ~priest~
      ADD_KNOWN_SPELL ~sppr508~ #4 ~priest~
      ADD_KNOWN_SPELL ~sppr509~ #4 ~priest~
      ADD_KNOWN_SPELL ~sppr510~ #4 ~priest~
      ADD_KNOWN_SPELL ~sppr514~ #4 ~priest~
      ADD_KNOWN_SPELL ~sppr516~ #4 ~priest~
      ADD_KNOWN_SPELL ~sppr517~ #4 ~priest~
      ADD_KNOWN_SPELL ~sppr602~ #5 ~priest~
      ADD_KNOWN_SPELL ~sppr604~ #5 ~priest~
      ADD_KNOWN_SPELL ~sppr605~ #5 ~priest~
      ADD_KNOWN_SPELL ~sppr606~ #5 ~priest~
      ADD_KNOWN_SPELL ~sppr607~ #5 ~priest~
      ADD_KNOWN_SPELL ~sppr608~ #5 ~priest~
      ADD_KNOWN_SPELL ~sppr610~ #5 ~priest~
      ADD_KNOWN_SPELL ~sppr611~ #5 ~priest~
      ADD_KNOWN_SPELL ~sppr613~ #5 ~priest~
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes Jahs' missing prof star and inconsistent dex at higher levels
COPY_EXISTING ~JAHEIR12.cre~ ~override~
              ~JAHEI14.cre~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG 0x2c4 "fx_off"
    READ_LONG 0x2c8 "fx_num"
    WRITE_BYTE 0x23c 17 // sets dex to 17
    WHILE ("%fx_num%" > 0) BEGIN
      SET "fx_num" = ("%fx_num%" - 1)
      READ_LONG ("%fx_off%" + 0x08 + ("%fx_num%" * 0x108)) "type"
      READ_LONG ("%fx_off%" + 0x18 + ("%fx_num%" * 0x108)) "wpn"
      PATCH_IF (("%type%" = 233) AND ("%wpn%" = 95)) BEGIN      // if scimitar prof
        WRITE_LONG ("%fx_off%" + 0x14 + ("%fx_num%" * 0x108)) 2 // set to 2 stars
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// jan's thieving skills incorrect
COPY_EXISTING ~jan10.cre~ ~override~
   WRITE_BYTE 0x45  0 // Hide in Shadows
   WRITE_BYTE 0x64 60 // Detect Illusions
   WRITE_BYTE 0x65 20 // Set Traps
   WRITE_BYTE 0x67 75 // Open Locks
   WRITE_BYTE 0x68  0 // Move Silently
   WRITE_BYTE 0x69 65 // Find Traps
   WRITE_BYTE 0x6a 45 // Pickpockets

COPY_EXISTING ~jan11.cre~ ~override~
   WRITE_BYTE 0x45  0 // Hide in Shadows
   WRITE_BYTE 0x64 70 // Detect Illusions
   WRITE_BYTE 0x65 25 // Set Traps
   WRITE_BYTE 0x67 75 // Open Locks
   WRITE_BYTE 0x68  0 // Move Silently
   WRITE_BYTE 0x69 75 // Find Traps
   WRITE_BYTE 0x6a 45 // Pickpockets

// jan12 and jan15 shortchanged one prof star, thieving skill fixes
COPY_EXISTING ~jan12.cre~  ~override~
              ~jan15.cre~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x45  5 // Hide in Shadows
    WRITE_BYTE 0x64 76 // Detect Illusions
    WRITE_BYTE 0x65 34 // Set Traps
    WRITE_BYTE 0x67 78 // Open Locks
    WRITE_BYTE 0x68 0  // Move Silently
    WRITE_BYTE 0x69 77 // Find Traps
    WRITE_BYTE 0x6a 45 // Pickpockets
    READ_LONG 0x2a0 "kspl_off"
    READ_LONG 0x2a8 "minfo_off"
    READ_LONG 0x2b0 "mspl_off"
    READ_LONG 0x2b8 "itmslot_off"
    READ_LONG 0x2bc "itm_off"
    READ_LONG 0x2c4 "fx_off"
    READ_LONG 0x2c8 "fx_num"
    SET "delta" = 1
    INSERT_BYTES  "%fx_off%" 0x108 // inserting new prof effect
      WRITE_LONG  ("%fx_off%" + 0x08) 233    // opcode
      WRITE_LONG  ("%fx_off%" + 0x14) 1      // stars
      WRITE_LONG  ("%fx_off%" + 0x18) 106    // prof - dart
      WRITE_LONG  ("%fx_off%" + 0x1c) 9      // timing
      WRITE_SHORT ("%fx_off%" + 0x24) 100    // prob
    WRITE_LONG 0x2c8 ("%fx_num%" + "%delta%")
    SET "offset" = ("%delta%" * 0x108)
    PATCH_IF NOT ("%fx_off%" > "%kspl_off%") BEGIN
      WRITE_LONG 0x2a0 ("%kspl_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%minfo_off%") BEGIN
      WRITE_LONG 0x2a8 ("%minfo_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%mspl_off%") BEGIN
      WRITE_LONG 0x2b0 ("%mspl_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%itmslot_off%") BEGIN
      WRITE_LONG 0x2b8 ("%itmslot_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%itm_off%") BEGIN
      WRITE_LONG 0x2bc ("%itm_off%" + "%offset%")
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// mimics should actually be inside its chest
COPY_EXISTING ~jugmim01.cre~ ~override~ // killer mimic
  ADD_CRE_ITEM ~wallpass~ #0 #0 #0 ~NONE~ ~AMULET LRING RRING~
  BUT_ONLY_IF_IT_CHANGES

// keldorn's initial saves are too high
COPY_EXISTING ~keldor8.cre~  ~override~  
              ~keldor9.cre~  ~override~
              ~keldor10.cre~ ~override~
              ~keldor12.cre~ ~override~
              ~keldor14.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    FOR (index = 0 ; index < 5 ; index = index + 1) BEGIN
      READ_BYTE  (0x54 + "%index%") "save"
      WRITE_BYTE (0x54 + "%index%") ("%save%" - 2)
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
//Keldorn proficiency fix
COPY_EXISTING ~keldor9.cre~ ~override~
  READ_LONG 0x2a0 "kspl_off"
  READ_LONG 0x2a8 "minfo_off"
  READ_LONG 0x2b0 "mspl_off"
  READ_LONG 0x2b8 "itmslot_off"
  READ_LONG 0x2bc "itm_off"
  READ_LONG 0x2c4 "fx_off"
  READ_LONG 0x2c8 "fx_num"
  SET "orig_fx_num" = "%fx_num%"
  SET "patch" = 0
  WHILE (("%fx_num%" > 0) AND ("%patch%" = 0)) BEGIN
    SET "fx_num" = ("%fx_num%" - 1)
    READ_LONG ("%fx_off%" + 0x08 + ("%fx_num%" * 0x108)) "type"
    READ_LONG ("%fx_off%" + 0x18 + ("%fx_num%" * 0x108)) "weap"
    PATCH_IF (("%type%" = 233) AND ("%weap%" = 90)) BEGIN // if longsword prof exists
      WRITE_LONG ("%fx_off%" + 0x14 + ("%fx_num%" * 0x108)) 2
      SET "patch" = 1
    END
  END
  PATCH_IF ("%patch%" = 0) BEGIN // if not present and adjusted
    INSERT_BYTES  "%fx_off%" 0x108 // inserting new prof effect
      WRITE_LONG  ("%fx_off%" + 0x08) 233    // opcode
      WRITE_LONG  ("%fx_off%" + 0x14) 2      // stars
      WRITE_LONG  ("%fx_off%" + 0x18) 90     // prof
      WRITE_LONG  ("%fx_off%" + 0x1c) 9      // timing
      WRITE_SHORT ("%fx_off%" + 0x24) 100    // prob
      WRITE_ASCII ("%fx_off%" + 0x68) ~None~ // vvc
    SET "patch" = 2
  END
  PATCH_IF ("%patch%" = 2) BEGIN // fixes offsets if bytes were inserted
    WRITE_LONG 0x2c8 ("%orig_fx_num%" + 1)
    PATCH_IF ("%fx_off%" < "%kspl_off%") BEGIN
      WRITE_LONG 0x2a0 ("%kspl_off%" + 0x108)
    END
    PATCH_IF ("%fx_off%" < "%minfo_off%") BEGIN
      WRITE_LONG 0x2a8 ("%minfo_off%" + 0x108)
    END
    PATCH_IF ("%fx_off%" < "%mspl_off%") BEGIN
      WRITE_LONG 0x2b0 ("%mspl_off%" + 0x108)
    END
    PATCH_IF ("%fx_off%" < "%itmslot_off%") BEGIN
      WRITE_LONG 0x2b8 ("%itmslot_off%" + 0x108)
    END
    PATCH_IF ("%fx_off%" < "%itm_off%") BEGIN
      WRITE_LONG 0x2bc ("%itm_off%" + 0x108)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// assigning names to creatures; from UB
COPY_EXISTING ~KORCRAZY.CRE~ ~override~  // Crazyface, Korgan's old cohort
  SAY NAME1 #30508
  SAY NAME2 #30509

// korgan's kit.ids fixes
COPY_EXISTING ~korgan8.cre~  ~override~
              ~korgan9.cre~  ~override~
              ~korgan11.cre~ ~override~
              ~korgan12.cre~ ~override~
              ~korgan15.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG 0x244 "current_kit_value"
    PATCH_IF ("%current_kit_value%" = 0x00010000) BEGIN
      WRITE_LONG 0x244 0x40010000
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// assigning names to creatures; from UB
COPY_EXISTING ~KORPIMG1.CRE~ ~override~  // Pimlico Guard
  SAY NAME1 #30490
  SAY NAME2 #30490

// keep dogs don't go hostile when oty attacked
COPY_EXISTING ~kpdog01.cre~ ~override~
              ~kpdog02.cre~ ~override~
              ~kpdog03.cre~ ~override~
              ~kpdog04.cre~ ~override~
  WRITE_ASCII 0x248 ~cdkpdog~ #8
  BUT_ONLY_IF_IT_CHANGES

// live/dead troll versions have mismatching XP
COPY_EXISTING ~kptrol01.cre~ ~override~
              ~kptrol02.cre~ ~override~
              ~kptrol03.cre~ ~override~
              ~kptrol04.cre~ ~override~
              ~rogtro01.cre~ ~override~
  WRITE_LONG 0x14 1400
  BUT_ONLY_IF_IT_CHANGES

// revived version of kptrol03
COPY_EXISTING ~kptrol03.cre~ ~override/kptrol13.cre~

// there can be only one. Paac.
COPY_EXISTING ~mage16c.cre~ ~override~
  SAY 0x08 #15232
  SAY 0x0c #15232
  BUT_ONLY_IF_IT_CHANGES

//Mazzy proficiency fix
COPY_EXISTING ~mazzy9.cre~  ~override~
              ~mazzy12.cre~ ~override~
              ~mazzy15.cre~ ~override~
  READ_BYTE 0x234 "level" ELSE 0
  READ_LONG 0x2c4 "fx_off" ELSE 0
  READ_LONG 0x2c8 "fx_num" ELSE 0
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_LONG ("%fx_off%" + 0x08 + ("%index%" * 0x108)) "type"
    READ_LONG ("%fx_off%" + 0x18 + ("%index%" * 0x108)) "weap"
    PATCH_IF (("%type%" = 233) AND ("%weap%" = 91)) BEGIN // ss prof
      PATCH_IF ("%level%" < 10) BEGIN
        WRITE_LONG ("%fx_off%" + 0x14 + ("%index%" * 0x108)) 2
      END ELSE BEGIN
        WRITE_LONG ("%fx_off%" + 0x14 + ("%index%" * 0x108)) 3
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// DV change
COPY_EXISTING ~mddust.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_ASCII 0x280 ~DUSTMEP~ #18
  END
  BUT_ONLY_IF_IT_CHANGES

// eliminates soundsets for mindflayers as no other ones have sounds
COPY_EXISTING ~melsum06.cre~ ~override~
              ~mindal01.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_LONG 0xc8  0xffffffff
    WRITE_LONG 0xcc  0xffffffff
    WRITE_LONG 0xec  0xffffffff
    WRITE_LONG 0xf0  0xffffffff
    WRITE_LONG 0x10c 0xffffffff
    WRITE_LONG 0x110 0xffffffff
    WRITE_LONG 0x1b8 0xffffffff
  END
  BUT_ONLY_IF_IT_CHANGES

//one mephit portal has inconsistent dexterity
COPY_EXISTING ~mephsp1.cre~ ~override~
  WRITE_BYTE 0x23c 20 // dex
  BUT_ONLY_IF_IT_CHANGES

// ice mephit should have ice shard memorized, not magma ball
COPY_EXISTING ~mepice01.cre~ ~override~
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a4 "known_num"
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" + ("%index%" * 0x0c)) "spell"
    PATCH_IF ("%spell%" STRING_COMPARE_CASE "spin930" = 0) BEGIN // if magma ball
      WRITE_ASCII ("%known_off%" + ("%index%" * 0x0c)) ~spin936~ // replace with ice shard
    END
  END
  // rest of these reads are to fix obsice02, mepice02 below
  READ_ASCII 0x2c  "color" (6)        // entire coloring block
  READ_LONG  0x46  "ac"               // natural and effective AC
  READ_ASCII 0x59  "resistances" (11) // entire resistances block
  READ_BYTE  0x23c "dex"              // dexterity
  BUT_ONLY_IF_IT_CHANGES

// fixes other two ice mephits
COPY_EXISTING ~mepice02.cre~ ~override~
              ~obsice02.cre~ ~override~
  // writes in correct values from mepice01
  WRITE_EVALUATED_ASCII 0x2c  "%color%" #6        // entire coloring block
  WRITE_LONG            0x46  "%ac%"              // natural and effective AC
  WRITE_EVALUATED_ASCII 0x59  "%resistances%" #11 // entire resistances block
  WRITE_BYTE            0x23c "%dex%"             // dexterity
  SAY NAME1 #22553
  SAY NAME2 #22553
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a4 "known_num"
  READ_LONG 0x2b8 "slot_offset"
  READ_LONG 0x2bC "item_offset"
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" + ("%index%" * 0x0c)) "spell"
    PATCH_IF ("%spell%" STRING_COMPARE_CASE "spin930" = 0) BEGIN // if magma ball
      WRITE_ASCII ("%known_off%" + ("%index%" * 0x0c)) ~spin936~ // replace with ice shard
    END
  END
  READ_SHORT  ("%slot_offset%" + 0x12) "item_index" // reads location of primary weapon
  WRITE_ASCII ("%item_offset%" +        (0x14 * "%item_index%")) ~mepice~ #8 // replaces it with ice mephit weapon
  WRITE_LONG  ("%item_offset%" + 0x08 + (0x14 * "%item_index%")) 0
  WRITE_LONG  ("%item_offset%" + 0x0c + (0x14 * "%item_index%")) 0
  WRITE_LONG  ("%item_offset%" + 0x10 + (0x14 * "%item_index%")) 0
  BUT_ONLY_IF_IT_CHANGES

// fixes minsc spells
COPY_EXISTING ~minsc8.cre~  ~override~
              ~minsc9.cre~  ~override~
              ~minsc10.cre~ ~override~
              ~minsc12.cre~ ~override~
  READ_BYTE 0x234 "level"
  ADD_KNOWN_SPELL ~sppr101~ #0 ~priest~
  ADD_KNOWN_SPELL ~sppr103~ #0 ~priest~
  ADD_KNOWN_SPELL ~sppr104~ #0 ~priest~
  ADD_KNOWN_SPELL ~sppr105~ #0 ~priest~
  ADD_KNOWN_SPELL ~sppr110~ #0 ~priest~
  ADD_KNOWN_SPELL ~sppr111~ #0 ~priest~
  ADD_KNOWN_SPELL ~sppr113~ #0 ~priest~
  PATCH_IF ("%level%" > 9) BEGIN
    ADD_KNOWN_SPELL ~sppr202~ #1 ~priest~
    ADD_KNOWN_SPELL ~sppr204~ #1 ~priest~
    ADD_KNOWN_SPELL ~sppr205~ #1 ~priest~
    ADD_KNOWN_SPELL ~sppr206~ #1 ~priest~
    ADD_KNOWN_SPELL ~sppr207~ #1 ~priest~
    ADD_KNOWN_SPELL ~sppr209~ #1 ~priest~
    ADD_KNOWN_SPELL ~sppr210~ #1 ~priest~
    ADD_KNOWN_SPELL ~sppr212~ #1 ~priest~
  END
  PATCH_IF ("%level%" > 11) BEGIN
    ADD_KNOWN_SPELL ~sppr302~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr303~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr305~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr306~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr309~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr310~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr311~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr312~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr315~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr317~ #2 ~priest~
    ADD_KNOWN_SPELL ~sppr319~ #2 ~priest~
  END
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a8 "mem_info"
  READ_LONG 0x2b0 "mem_off"
  READ_LONG 0x2b4 "mem_num"
  READ_LONG 0x2b8 "slot_off"
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c4 "fx_off"
  READ_LONG    ("%mem_info%" + 0x08              ) "idx_start"
  READ_LONG    ("%mem_info%" + 0x08 + (16 * 0x10)) "idx_end"
  DELETE_BYTES ("%mem_off%" + (0x0c * "%idx_start%")) (("%idx_end%" - "%idx_start%") * 0x0c)
  SET "delta" = 0

  // level 1
  SET "lev1" = 1
  PATCH_IF ("%level%" > 8) BEGIN
    SET "lev1" = ("%lev1%" + 1)
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~sppr103~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 1)
  END
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~sppr104~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 1)
  WRITE_SHORT ("%mem_info%" + 0x02) "%lev1%"
  WRITE_SHORT ("%mem_info%" + 0x04) "%lev1%"
  WRITE_SHORT ("%mem_info%" + 0x0c) "%lev1%"

  //level 2 fixes
  SET "lev2" = 0
  PATCH_IF ("%level%" > 9) BEGIN
    SET "lev2" = ("%lev2%" + 1)
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~sppr202~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 1)
  END
  PATCH_IF ("%level%" > 11) BEGIN
    SET "lev2" = ("%lev2%" + 1)
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~sppr204~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 1)
  END
  WRITE_SHORT ("%mem_info%" + 0x02 + (1 * 0x10)) "%lev2%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (1 * 0x10)) "%lev2%"
  WRITE_LONG  ("%mem_info%" + 0x08 + (1 * 0x10)) (("%idx_start%" + "%delta%") - "%lev2%")
  WRITE_SHORT ("%mem_info%" + 0x0c + (1 * 0x10)) "%lev2%"

  //level 3 fixes
  SET "lev3" = 0
  PATCH_IF ("%level%" > 11) BEGIN
    SET "lev3" = ("%lev3%" + 1)
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~sppr315~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 1)
  END
  WRITE_SHORT ("%mem_info%" + 0x02 + (2 * 0x10)) "%lev3%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (2 * 0x10)) "%lev3%"
  WRITE_LONG  ("%mem_info%" + 0x08 + (2 * 0x10)) (("%idx_start%" + "%delta%") - "%lev3%")
  WRITE_SHORT ("%mem_info%" + 0x0c + (2 * 0x10)) "%lev3%"

  // wrapping up; correcting indexes for remaining spells
  SET "loops" = 0
  WHILE ("%loops%" < 13) BEGIN
    SET "loops" = ("%loops%" + 1)
    WRITE_SHORT ("%mem_info%" + 0x02 + (("%loops%" + 2) * 0x10)) 0
    WRITE_SHORT ("%mem_info%" + 0x04 + (("%loops%" + 2) * 0x10)) 0
    WRITE_LONG  ("%mem_info%" + 0x08 + (("%loops%" + 2) * 0x10)) ("%idx_start%" + "%delta%")
    WRITE_SHORT ("%mem_info%" + 0x0c + (("%loops%" + 2) * 0x10)) 0
  END
  WRITE_LONG  ("%mem_info%" + 0x08 + (16 * 0x10)) ("%idx_start%" + "%delta%")
  
  // final wrapup; correct # of memorized spells and offsets
  WRITE_LONG 0x2b4 (("%idx_start%" + "%delta%" + "%mem_num%") - "%idx_end%")
  SET "offset_delta" = ((("%delta%" + "%idx_start%") - "%idx_end%") * 0x0c)
  PATCH_IF ("%known_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2a0 ("%known_off%" + "%offset_delta%")
  END
  PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2b8 ("%slot_off%" + "%offset_delta%")
  END
  PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2bc ("%item_off%" + "%offset_delta%")
  END
  PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2c4 ("%fx_off%" + "%offset_delta%")
  END

// nalia short one prof star at all levels
COPY_EXISTING ~nalia8.cre~  ~override~
              ~nalia10.cre~ ~override~
              ~nalia11.cre~ ~override~
              ~nalia13.cre~ ~override~
              ~nalia15.cre~ ~override~
              ~nalia18.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG 0x2a0 "kspl_off"
    READ_LONG 0x2a8 "minfo_off"
    READ_LONG 0x2b0 "mspl_off"
    READ_LONG 0x2b8 "itmslot_off"
    READ_LONG 0x2bc "itm_off"
    READ_LONG 0x2c4 "fx_off"
    READ_LONG 0x2c8 "fx_num"
    SET "delta" = 1
    FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
      READ_LONG ("%fx_off%" + 0x08 + ("%index%" * 0x108)) "type"
      READ_LONG ("%fx_off%" + 0x18 + ("%index%" * 0x108)) "weap"
      PATCH_IF (("%type%" = 233) AND ("%weap%" = 106)) BEGIN // dart
        WRITE_LONG ("%fx_off%" + 0x18 + ("%index%" * 0x108)) 107 // change to sling
      END
    END
    INSERT_BYTES  "%fx_off%" 0x108 // inserting new prof effect
      WRITE_LONG  ("%fx_off%" + 0x08) 233    // opcode
      WRITE_LONG  ("%fx_off%" + 0x14) 1      // stars
      WRITE_LONG  ("%fx_off%" + 0x18) 106    // prof - dart
      WRITE_LONG  ("%fx_off%" + 0x1c) 9      // timing
      WRITE_SHORT ("%fx_off%" + 0x24) 100    // prob
    WRITE_LONG 0x2c8 ("%fx_num%" + "%delta%")
    SET "offset" = ("%delta%" * 0x108)
    PATCH_IF NOT ("%fx_off%" > "%kspl_off%") BEGIN
      WRITE_LONG 0x2a0 ("%kspl_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%minfo_off%") BEGIN
      WRITE_LONG 0x2a8 ("%minfo_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%mspl_off%") BEGIN
      WRITE_LONG 0x2b0 ("%mspl_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%itmslot_off%") BEGIN
      WRITE_LONG 0x2b8 ("%itmslot_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%itm_off%") BEGIN
      WRITE_LONG 0x2bc ("%itm_off%" + "%offset%")
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// more heinous spell slot fixes; nalia8 and nalia9 have one extra fifth
// level spell, nalia13 one extra 6th level spell and 0 arrows
COPY_EXISTING ~nalia8.cre~  ~override~
              ~nalia10.cre~ ~override~
              ~nalia13.cre~ ~override~
  READ_BYTE 0x234 "level"
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a8 "mem_info"
  READ_LONG 0x2b0 "mem_off"
  READ_LONG 0x2b4 "mem_num"
  READ_LONG 0x2b8 "slot_off"
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c0 "item_num"
  READ_LONG 0x2c4 "fx_off"

  // first let's get the arrows out of the way
  WHILE ("%item_num%" > 0) BEGIN
    SET "item_num" = ("%item_num%" - 1)
    READ_ASCII ("%item_off%" + (0x14 * "%item_num%")) "itemname"
    PATCH_IF ("arow01" STRING_COMPARE_CASE "%itemname%" = 0) BEGIN
      WRITE_SHORT ("%item_off%" + 0x0a + (0x14 * "%item_num%")) 20 // quantity
    END
  END

  READ_LONG    ("%mem_info%" + 0x08 + (7  * 0x10)) "idx_start"
  READ_LONG    ("%mem_info%" + 0x08 + (16 * 0x10)) "idx_end"
  DELETE_BYTES ("%mem_off%" + (0x0c * "%idx_start%")) (("%idx_end%" - "%idx_start%") * 0x0c)
  SET "delta" = 0

  // level 1
  SET "lev1" = 4
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi118~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi115~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi110~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi105~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 4)
  WRITE_SHORT ("%mem_info%" + 0x02 + (7 * 0x10)) "%lev1%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (7 * 0x10)) "%lev1%"
  WRITE_SHORT ("%mem_info%" + 0x0c + (7 * 0x10)) "%lev1%"

  //level 2 fixes
  SET "lev2" = 3
  PATCH_IF ("%level%" > 10) BEGIN
    SET "lev2" = ("%lev2%" + 1)
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi211~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 1)
  END
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi215~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi214~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi212~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 3)
  WRITE_SHORT ("%mem_info%" + 0x02 + (8 * 0x10)) "%lev2%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (8 * 0x10)) "%lev2%"
  WRITE_LONG  ("%mem_info%" + 0x08 + (8 * 0x10)) (("%idx_start%" + "%delta%") - "%lev2%")
  WRITE_SHORT ("%mem_info%" + 0x0c + (8 * 0x10)) "%lev2%"

  //level 3 fixes
  SET "lev3" = 3
  PATCH_IF ("%level%" > 10) BEGIN
    SET "lev3" = ("%lev3%" + 1)
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi305~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 1)
  END
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi312~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi308~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi306~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 3)
  WRITE_SHORT ("%mem_info%" + 0x02 + (9 * 0x10)) "%lev3%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (9 * 0x10)) "%lev3%"
  WRITE_LONG  ("%mem_info%" + 0x08 + (9 * 0x10)) (("%idx_start%" + "%delta%") - "%lev3%")
  WRITE_SHORT ("%mem_info%" + 0x0c + (9 * 0x10)) "%lev3%"

  //level 4 fixes
  SET "lev4" = 2
  PATCH_IF ("%level%" > 10) BEGIN
    SET "lev4" = ("%lev4%" + 2)
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi403~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi415~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 2)
  END
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi416~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi408~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 2)
  WRITE_SHORT ("%mem_info%" + 0x02 + (10 * 0x10)) "%lev4%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (10 * 0x10)) "%lev4%"
  WRITE_LONG  ("%mem_info%" + 0x08 + (10 * 0x10)) (("%idx_start%" + "%delta%") - "%lev4%")
  WRITE_SHORT ("%mem_info%" + 0x0c + (10 * 0x10)) "%lev4%"

  //level 5 fixes
  SET "lev5" = 1
  PATCH_IF ("%level%" > 10) BEGIN
    SET "lev5" = ("%lev5%" + 3)
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi508~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi506~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi502~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 3)
  END
  INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
    WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~spwi505~
    WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
  SET "delta" = ("%delta%" + 1)
  WRITE_SHORT ("%mem_info%" + 0x02 + (11 * 0x10)) "%lev5%"
  WRITE_SHORT ("%mem_info%" + 0x04 + (11 * 0x10)) "%lev5%"
  WRITE_LONG  ("%mem_info%" + 0x08 + (11 * 0x10)) (("%idx_start%" + "%delta%") - "%lev5%")
  WRITE_SHORT ("%mem_info%" + 0x0c + (11 * 0x10)) "%lev5%"

  // wrapping up; correcting indexes for remaining wizard spells and innates
  SET "loops" = 0
  WHILE ("%loops%" < 4) BEGIN
    SET "loops" = ("%loops%" + 1)
    WRITE_SHORT ("%mem_info%" + 0x02 + (("%loops%" + 11) * 0x10)) 0
    WRITE_SHORT ("%mem_info%" + 0x04 + (("%loops%" + 11) * 0x10)) 0
    WRITE_LONG  ("%mem_info%" + 0x08 + (("%loops%" + 11) * 0x10)) ("%idx_start%" + "%delta%")
    WRITE_SHORT ("%mem_info%" + 0x0c + (("%loops%" + 11) * 0x10)) 0
  END
  WRITE_LONG  ("%mem_info%" + 0x08 + (16 * 0x10)) ("%idx_start%" + "%delta%")
  
  // final wrapup; correct # of memorized spells and offsets
  WRITE_LONG 0x2b4 (("%idx_start%" + "%delta%" + "%mem_num%") - "%idx_end%")
  SET "offset_delta" = ((("%delta%" + "%idx_start%") - "%idx_end%") * 0x0c)
  PATCH_IF ("%known_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2a0 ("%known_off%" + "%offset_delta%")
  END
  PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2b8 ("%slot_off%" + "%offset_delta%")
  END
  PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2bc ("%item_off%" + "%offset_delta%")
  END
  PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2c4 ("%fx_off%" + "%offset_delta%")
  END

// Nalia's saves
COPY_EXISTING ~nalia13.cre~ ~override~
              ~nalia15.cre~ ~override~
              ~nalia18.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x54 11
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes name
COPY_EXISTING ~pirpir06.cre~ ~override~
  READ_LONG  0x08 "name"
  WRITE_LONG 0x0c "%name%"
  BUT_ONLY_IF_IT_CHANGES

// hostile planetars via wish would still cast spells to benefit the party
COPY_EXISTING ~planet01.cre~ ~override~ // unused?
              ~planwish.cre~ ~override~ // hostile planetar summoned via wish
  PATCH_IF (SOURCE_SIZE > 0x2d3) BEGIN // protects against invalid files
    WRITE_ASCII 0x248 ~planet~   #8 // override script
    WRITE_ASCII 0x268 ~wtasight~ #8 // default script
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes evil planetar's class and spell list
COPY_EXISTING ~planevil.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG  0x2a0  "known_off"
    READ_LONG  0x2a4  "known_num"
    READ_LONG  0x2b0  "mem_off"
    READ_LONG  0x2b4  "mem_num"
    WHILE ("%known_num%" > 0) BEGIN
      SET "known_num" = ("%known_num%" - 1)
      READ_ASCII ("%known_off%" + ("%known_num%" * 0x0c)) "spell"
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "sppr307" = 0) BEGIN
        WRITE_ASCII ("%known_off%" + ("%known_num%" * 0x0c)) "sppr303"
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "sppr710" = 0) BEGIN
        WRITE_ASCII ("%known_off%" + ("%known_num%" * 0x0c)) "sppr715"
      END
    END
    WHILE ("%mem_num%" > 0) BEGIN
      SET "mem_num" = ("%mem_num%" - 1)
      READ_ASCII  ("%mem_off%" +        ("%mem_num%" * 0x0c)) "spell"
      WRITE_SHORT ("%mem_off%" + 0x08 + ("%mem_num%" * 0x0c)) 1
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "sppr307" = 0) BEGIN
        WRITE_ASCII ("%mem_off%" + ("%mem_num%" * 0x0c)) "sppr303"
      END ELSE
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "sppr710" = 0) BEGIN
        WRITE_ASCII ("%mem_off%" + ("%mem_num%" * 0x0c)) "sppr715"
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes regen rate for good planetars, along with class/general field fixes
COPY_EXISTING ~plangood.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG  0x2c4 "fx_off"
    READ_LONG  0x2c8 "fx_num"
    WHILE ("%fx_num%" > 0) BEGIN
      SET "fx_num" = ("%fx_num%" - 1)
      READ_LONG ("%fx_off%" + 0x08 + ("%fx_num%" * 0x108)) "type"
      PATCH_IF ("%type%" = 98) BEGIN // regerneration
        WRITE_LONG ("%fx_off%" + 0x14 + ("%fx_num%" * 0x108)) 4 // hp per sec
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Tyrianna fix, part 2 (first is ar0415 extend)
COPY_EXISTING ~plgirl01.cre~ ~override~
  WRITE_ASCII 0x248 ~~ #8
  BUT_ONLY_IF_IT_CHANGES

// dradeel is an elf but uses a human avatar
COPY_EXISTING ~ppdra2.cre~   ~override~
              ~ppdradee.cre~ ~override~
              ~redrad01.cre~ ~override~
  WRITE_SHORT 0x28 25089 // male elf mage
  BUT_ONLY_IF_IT_CHANGES

// changes Asylum Irenicus to use minhp1 instead of jonhp1 (Baldurdash)
// race and alignment corrections in Oversight code blocks, above
COPY_EXISTING ~ppireni1.cre~ ~override~
              ~ppireni2.cre~ ~override~
  READ_LONG 0x2bc "itm_off"
  READ_LONG 0x2c0 "itm_num"
  WHILE ("%itm_num%" > 0) BEGIN
    SET "itm_num" = ("%itm_num%" - 1)
    READ_ASCII ("%itm_off%" + (0x14 * "%itm_num%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "jonhp1" = 0) BEGIN
      WRITE_ASCII ("%itm_off%" + (0x14 * "%itm_num%")) "minhp1"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// adds a charge to Arbane on Suna Seni
COPY_EXISTING ~resuna.cre~ ~override~
  READ_LONG 0x2bc "itm_off"
  READ_LONG 0x2c0 "itm_num"
  WHILE ("%itm_num%" > 0) BEGIN
    SET "itm_num" = ("%itm_num%" - 1)
    READ_ASCII ("%itm_off%" + (0x14 * "%itm_num%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "sw1h27" = 0) BEGIN
      WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%itm_num%")) 1
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// wrong DV for roger's sea troll (active); if killed instantly (rather than via fire/acid) roger won't know
COPY_EXISTING ~rogtro01.cre~ ~override~
  WRITE_ASCII 0x280 ~rogtro02~ #20 // death variable
  BUT_ONLY_IF_IT_CHANGES

// assigns amalas.bcs to Amalas as his override script
COPY_EXISTING ~ruffian.cre~ ~override~
  WRITE_ASCII 0x248 ~AMALAS~ #8

// fixes sahzomb flags
COPY_EXISTING ~sahzomb.cre~ ~override~
  WRITE_LONG 0x10 0
  BUT_ONLY_IF_IT_CHANGES

// fixes to Sarevok's saves
COPY_EXISTING ~sarevok.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x57 4
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~sarpro01.cre~ ~override~ // typo
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_ASCII 0x268 ~wtrunsgt~ #8
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~sendro05.cre~ ~override~ //typo
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_ASCII 0x268 ~cassa20b~ #8
  END
  BUT_ONLY_IF_IT_CHANGES

// assigning names to creatures; from UB
COPY_EXISTING ~SHOP03.CRE~  ~override~    // Maheer, the Blacksmith
  SAY NAME1 #23302
  SAY NAME2 #23303

COPY_EXISTING ~shthdr01.cre~ ~override~
  WRITE_ASCII 0x250 ~BRANNEL~ #8 // class script

COPY_EXISTING ~slmage2.cre~   ~override~
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a4 "known_num"
  READ_LONG 0x2a8 "meminfo_off"
  READ_LONG 0x2b0 "mem_off"
  READ_LONG 0x2b4 "mem_num"
  READ_LONG 0x2b8 "slot_off"
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c4 "fx_off"
  SET "delta_known" = 0
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +       (0x0c * "%index%")) "spell"
    PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi422" = 0) BEGIN
      DELETE_BYTES ("%known_off%" +       (0x0c * "%index%")) 0x0c
      SET "delta_known" = ("%delta_known%" - 1)
      SET "index" = ("%index%" - 1)
      SET "known_num" = ("%known_num%" - 1)
    END
  END
  WRITE_LONG 0x2a4 "%known_num%"
  SET "meminfo_off" = ("%meminfo_off%" + ("%delta_known%" * 0x0c))
  WRITE_LONG 0x2a8 "%meminfo_off%"
  SET "mem_off" = ("%mem_off%" + ("%delta_known%" * 0x0c))
  WRITE_LONG  0x2b0 "%mem_off%"
  SET "delta_mem" = 0
  FOR (index2 = 0 ; index2 < 17 ; index2 = index2 + 1) BEGIN
    READ_LONG ("%meminfo_off%" + 0x08 + ("%index2%" * 0x10)) "meminfo_idx"
    READ_LONG ("%meminfo_off%" + 0x0c + ("%index2%" * 0x10)) "meminfo_num"
    SET "meminfo_idx" = ("%meminfo_idx%" + "%delta_mem%")
    WRITE_LONG ("%meminfo_off%" + 0x08 + ("%index2%" * 0x10)) "%meminfo_idx%"
    FOR (index3 = 0 ; index3 < meminfo_num ; index3 = index3 + 1) BEGIN
      READ_ASCII ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spell"
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "spwi422" = 0) BEGIN
        WRITE_ASCII  ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spwi408"
      END
    END
    WRITE_LONG ("%meminfo_off%" + 0x0c + ("%index2%" * 0x10)) "%meminfo_num%"
  END
  WRITE_LONG  0x2b4 ("%mem_num%" + "%delta_mem%")
  SET "offset" = (0x0c * ("%delta_mem%" + "%delta_known%"))
  PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2b8 ("%slot_off%" + "%offset%")
  END
  PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2bc ("%item_off%" + "%offset%")
  END
  PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2c4 ("%fx_off%" + "%offset%")
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~sppain.cre~  ~override~
              ~vakola.cre~ ~override~
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a4 "known_num"
  READ_LONG 0x2a8 "meminfo_off"
  READ_LONG 0x2b0 "mem_off"
  READ_LONG 0x2b4 "mem_num"
  READ_LONG 0x2b8 "slot_off"
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c4 "fx_off"
  SET "delta_known" = 0
  FOR (index = 0 ; index < known_num ; index = index + 1) BEGIN
    READ_ASCII ("%known_off%" +       (0x0c * "%index%")) "spell"
    PATCH_IF ("%spell%" STRING_COMPARE_CASE "sppr112" = 0) BEGIN
      DELETE_BYTES ("%known_off%" +       (0x0c * "%index%")) 0x0c
      SET "delta_known" = ("%delta_known%" - 1)
      SET "index" = ("%index%" - 1)
      SET "known_num" = ("%known_num%" - 1)
    END
  END
  WRITE_LONG 0x2a4 "%known_num%"
  SET "meminfo_off" = ("%meminfo_off%" + ("%delta_known%" * 0x0c))
  WRITE_LONG 0x2a8 "%meminfo_off%"
  SET "mem_off" = ("%mem_off%" + ("%delta_known%" * 0x0c))
  WRITE_LONG  0x2b0 "%mem_off%"
  SET "delta_mem" = 0
  FOR (index2 = 0 ; index2 < 17 ; index2 = index2 + 1) BEGIN
    READ_LONG ("%meminfo_off%" + 0x08 + ("%index2%" * 0x10)) "meminfo_idx"
    READ_LONG ("%meminfo_off%" + 0x0c + ("%index2%" * 0x10)) "meminfo_num"
    SET "meminfo_idx" = ("%meminfo_idx%" + "%delta_mem%")
    WRITE_LONG ("%meminfo_off%" + 0x08 + ("%index2%" * 0x10)) "%meminfo_idx%"
    FOR (index3 = 0 ; index3 < meminfo_num ; index3 = index3 + 1) BEGIN
      READ_ASCII ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) "spell"
      PATCH_IF ("%spell%" STRING_COMPARE_CASE "sppr112" = 0) BEGIN
        DELETE_BYTES ("%mem_off%" +       (0x0c * ("%meminfo_idx%" + "%index3%"))) 0x0c
        SET "delta_mem" = ("%delta_mem%" - 1)
        SET "index3" = ("%index3%" - 1)
        SET "meminfo_num" = ("%meminfo_num%" - 1)
      END
    END
    WRITE_LONG ("%meminfo_off%" + 0x0c + ("%index2%" * 0x10)) "%meminfo_num%"
  END
  WRITE_LONG  0x2b4 ("%mem_num%" + "%delta_mem%")
  SET "offset" = (0x0c * ("%delta_mem%" + "%delta_known%"))
  PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2b8 ("%slot_off%" + "%offset%")
  END
  PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2bc ("%item_off%" + "%offset%")
  END
  PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
    WRITE_LONG 0x2c4 ("%fx_off%" + "%offset%")
  END
  BUT_ONLY_IF_IT_CHANGES

// adds many missing effects to Mordy swords (Baldurdash)
COPY_EXISTING ~sword01.cre~ ~override~
  READ_LONG 0x2a0 "known_off"
  READ_LONG 0x2a8 "mem_info"
  READ_LONG 0x2b0 "mem_off"
  READ_LONG 0x2b8 "slot_off"
  READ_LONG 0x2bc "item_off"
  READ_LONG 0x2c4 "fx_off"
  READ_LONG 0x2c8 "fx_num"
  // insert the 17 new immunity effect and types; the rest of the parameters are covered in the loop
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 135  // polymorph
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 134  // petrify
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 128  // confusion
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 109  // hold
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 106  // break morale
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 80   // deafness
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 78   // disease
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 76   // feeblemind
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 74   // blindness
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 45   // stun
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 39   // sleep
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 24   // panic
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x18) 5    // charm
  SET "new_immun" = 13
  WHILE ("%new_immun%" > 0) BEGIN
    SET "new_immun" = ("%new_immun%" - 1)
    WRITE_LONG  ("%fx_off%" + 0x08 + ("%new_immun%" * 0x108)) 101 // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x0c + ("%new_immun%" * 0x108)) 1   // target self
    WRITE_LONG  ("%fx_off%" + 0x1c + ("%new_immun%" * 0x108)) 1   // instant/permanent till death
    WRITE_SHORT ("%fx_off%" + 0x24 + ("%new_immun%" * 0x108)) 100 // probability
    WRITE_LONG  ("%fx_off%" + 0xc4 + ("%new_immun%" * 0x108)) 1   // secondary type
  END
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_ASCII ("%fx_off%" + 0x28) ~spin975~ // psionic domination
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_ASCII ("%fx_off%" + 0x28) ~spin974~ // psionic blast
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_ASCII ("%fx_off%" + 0x28) ~spin912~ // detonate
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_ASCII ("%fx_off%" + 0x28) ~spin911~ // ballsitic attack
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_ASCII ("%fx_off%" + 0x28) ~spin909~ // ego whip
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_ASCII ("%fx_off%" + 0x28) ~spin910~ // domination
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_ASCII ("%fx_off%" + 0x28) ~spin959~ // psionic blast
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_ASCII ("%fx_off%" + 0x28) ~spin834~ // psionic blast
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_ASCII ("%fx_off%" + 0x28) ~spin775~ // unk
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_ASCII ("%fx_off%" + 0x28) ~spin774~ // maze
  SET "new_spimmun" = 10
  WHILE ("%new_spimmun%" > 0) BEGIN
    SET "new_spimmun" = ("%new_spimmun%" - 1)
    WRITE_LONG  ("%fx_off%" + 0x08 + ("%new_spimmun%" * 0x108)) 206 // protection from spell
    WRITE_LONG  ("%fx_off%" + 0x0c + ("%new_spimmun%" * 0x108)) 1   // target self
    WRITE_LONG  ("%fx_off%" + 0x10 + ("%new_spimmun%" * 0x108)) 0   // power
    WRITE_LONG  ("%fx_off%" + 0x1c + ("%new_spimmun%" * 0x108)) 1   // instant/permanent till death
    WRITE_SHORT ("%fx_off%" + 0x24 + ("%new_spimmun%" * 0x108)) 100 // probability
    WRITE_LONG  ("%fx_off%" + 0x3c + ("%new_spimmun%" * 0x108)) (0 - 2)  // save bonus
    WRITE_LONG  ("%fx_off%" + 0x54 + ("%new_spimmun%" * 0x108)) 3   // dispel/bypass
    WRITE_ASCII ("%fx_off%" + 0x8c + ("%new_spimmun%" * 0x108)) ~misc9y~ // parent spell
    WRITE_LONG  ("%fx_off%" + 0xc0 + ("%new_spimmun%" * 0x108)) 10  // primary type
    WRITE_LONG  ("%fx_off%" + 0xc4 + ("%new_spimmun%" * 0x108)) 1   // secondary type
  END
  // new effects to suppress confusion string and graphic
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x08) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x0c) 1     // target self
    WRITE_LONG  ("%fx_off%" + 0x10) 0     // power
    WRITE_LONG  ("%fx_off%" + 0x14) 14782 // strref for "confused"
    WRITE_LONG  ("%fx_off%" + 0x1c) 1     // instant/permanent till death
    WRITE_SHORT ("%fx_off%" + 0x24) 100   // probability
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x08) 296        // disable animation
    WRITE_LONG  ("%fx_off%" + 0x0c) 1          // target self
    WRITE_LONG  ("%fx_off%" + 0x10) 0          // power
    WRITE_LONG  ("%fx_off%" + 0x1c) 1          // instant/permanent till death
    WRITE_SHORT ("%fx_off%" + 0x24) 100        // probability
    WRITE_ASCII ("%fx_off%" + 0x28) ~spconfus~ // vvc file
  INSERT_BYTES  ("%fx_off%"       ) 0x108
    WRITE_LONG  ("%fx_off%" + 0x08) 296        // disable animation
    WRITE_LONG  ("%fx_off%" + 0x0c) 1          // target self
    WRITE_LONG  ("%fx_off%" + 0x10) 0          // power
    WRITE_LONG  ("%fx_off%" + 0x1c) 1          // instant/permanent till death
    WRITE_SHORT ("%fx_off%" + 0x24) 100        // probability
    WRITE_ASCII ("%fx_off%" + 0x28) ~spmindat~ // vvc file
  WRITE_LONG 0x2c8 ("%fx_num%" + 26)
  SET "offset_delta" = (26 * 0x108)
  PATCH_IF ("%fx_off%" < "%known_off%") BEGIN
    WRITE_LONG 0x2a0 ("%known_off%" + "%offset_delta%")
  END
  PATCH_IF ("%fx_off%" < "%mem_info%") BEGIN
    WRITE_LONG 0x2a8 ("%mem_info%" + "%offset_delta%")
  END
  PATCH_IF ("%fx_off%" < "%mem_off%") BEGIN
    WRITE_LONG 0x2b0 ("%mem_off%" + "%offset_delta%")
  END
  PATCH_IF ("%fx_off%" < "%slot_off%") BEGIN
    WRITE_LONG 0x2b8 ("%slot_off%" + "%offset_delta%")
  END
  PATCH_IF ("%fx_off%" < "%item_off%") BEGIN
    WRITE_LONG 0x2bc ("%item_off%" + "%offset_delta%")
  END
  BUT_ONLY_IF_IT_CHANGES

// ring of the ram should have a charge
COPY_EXISTING ~tolger.cre~  ~override~
              ~tolger2.cre~ ~override~
  READ_LONG 0x2bc "itm_off"
  READ_LONG 0x2c0 "itm_num"
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "ring33" = 0) BEGIN
      WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%index%")) 1
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// one-off change for Tor'gal to prevent repeating dialogue after regenerating
COPY_EXISTING ~torgal.cre~ ~override/torgal3.cre~
  WRITE_ASCII 0x248 ~~ #8 // no approach and speak script
  WRITE_BYTE  0x270 255   // enemy
  WRITE_ASCII 0x2cc ~~ #8 // no dialogue file

// makes Logan's cre files consistent
COPY_EXISTING ~celogan.cre~ ~override/trcut07.cre~
  WRITE_ASCII 0x248 ~~ #40
  WRITE_ASCII 0x280 ~trcut07~ #18
  WRITE_ASCII 0x2cc ~trcut07~ #8

// trollens should require fire/acid to be killed
COPY_EXISTING ~trollens.cre~ ~override~
  WRITE_ASCII 0x258 ~troll01~ #8 // transform to fire/acid dead form at low HP
  BUT_ONLY_IF_IT_CHANGES

// restoring Adalon's sound set
COPY_EXISTING ~UDSILVER.CRE~ ~OVERRIDE~
  SAY 0xd0 @103
  SAY 0xd4 @104
  SAY 0x0110 @109
  SAY 0x0114 @110
  SAY 0x0118 @111
  BUT_ONLY_IF_IT_CHANGES

// assigning names to creatures; from UB
COPY_EXISTING ~VALRAN01.CRE~ ~override~  // Derrick, the ranger
  SAY NAME1 #2190
  SAY NAME2 #2190

// valyg11 should be level 10 instead of 11
COPY_EXISTING ~valyg11.cre~ ~override~
  WRITE_SHORT 0x24  78 // current hp
  WRITE_SHORT 0x26  78 // max hp
  WRITE_BYTE  0x45  78 // hide in shadows
  WRITE_BYTE  0x52  11 // THAC0
  WRITE_BYTE  0x54   8 // save v death
  WRITE_BYTE  0x55  10 // save v wand
  WRITE_BYTE  0x56   9 // save v polymorph
  WRITE_BYTE  0x57   9 // save v breath
  WRITE_BYTE  0x58  11 // save v spell
  WRITE_BYTE  0x68  78 // move silently
  WRITE_BYTE  0x234 10 // level
  BUT_ONLY_IF_IT_CHANGES

// Valygar spell fixes
COPY_EXISTING ~valyg8.cre~  ~override~
              ~valyg9.cre~  ~override~
              ~valyg11.cre~ ~override~
              ~valyg12.cre~ ~override~
              ~valyg14.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_BYTE 0x234 "level"
    ADD_KNOWN_SPELL ~sppr101~ #0 ~priest~
    ADD_KNOWN_SPELL ~sppr103~ #0 ~priest~
    ADD_KNOWN_SPELL ~sppr104~ #0 ~priest~
    ADD_KNOWN_SPELL ~sppr105~ #0 ~priest~
    ADD_KNOWN_SPELL ~sppr110~ #0 ~priest~
    ADD_KNOWN_SPELL ~sppr111~ #0 ~priest~
    ADD_KNOWN_SPELL ~sppr113~ #0 ~priest~
    PATCH_IF ("%level%" > 9) BEGIN
      ADD_KNOWN_SPELL ~sppr202~ #1 ~priest~
      ADD_KNOWN_SPELL ~sppr204~ #1 ~priest~
      ADD_KNOWN_SPELL ~sppr205~ #1 ~priest~
      ADD_KNOWN_SPELL ~sppr206~ #1 ~priest~
      ADD_KNOWN_SPELL ~sppr207~ #1 ~priest~
      ADD_KNOWN_SPELL ~sppr209~ #1 ~priest~
      ADD_KNOWN_SPELL ~sppr210~ #1 ~priest~
      ADD_KNOWN_SPELL ~sppr212~ #1 ~priest~
    END
    PATCH_IF ("%level%" > 11) BEGIN
      ADD_KNOWN_SPELL ~sppr302~ #2 ~priest~
      ADD_KNOWN_SPELL ~sppr303~ #2 ~priest~
      ADD_KNOWN_SPELL ~sppr305~ #2 ~priest~
      ADD_KNOWN_SPELL ~sppr306~ #2 ~priest~
      ADD_KNOWN_SPELL ~sppr309~ #2 ~priest~
      ADD_KNOWN_SPELL ~sppr310~ #2 ~priest~
      ADD_KNOWN_SPELL ~sppr311~ #2 ~priest~
      ADD_KNOWN_SPELL ~sppr312~ #2 ~priest~
      ADD_KNOWN_SPELL ~sppr315~ #2 ~priest~
      ADD_KNOWN_SPELL ~sppr317~ #2 ~priest~
      ADD_KNOWN_SPELL ~sppr319~ #2 ~priest~
      ADD_KNOWN_SPELL ~spra301~ #2 ~priest~
      ADD_KNOWN_SPELL ~spra302~ #2 ~priest~
      ADD_KNOWN_SPELL ~spra303~ #2 ~priest~
    END
    READ_LONG 0x2a0 "known_off"
    READ_LONG 0x2a8 "mem_info"
    READ_LONG 0x2b0 "mem_off"
    READ_LONG 0x2b4 "mem_num"
    READ_LONG 0x2b8 "slot_off"
    READ_LONG 0x2bc "item_off"
    READ_LONG 0x2c4 "fx_off"
    READ_LONG    ("%mem_info%" + 0x08              ) "idx_start"
    READ_LONG    ("%mem_info%" + 0x08 + (16 * 0x10)) "idx_end"
    DELETE_BYTES ("%mem_off%" + (0x0c * "%idx_start%")) (("%idx_end%" - "%idx_start%") * 0x0c)
    SET "delta" = 0

    // level 1
    SET "lev1" = 1
    PATCH_IF ("%level%" > 8) BEGIN
      SET "lev1" = ("%lev1%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~sppr113~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
      WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~sppr103~
      WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
    SET "delta" = ("%delta%" + 1)
    WRITE_SHORT ("%mem_info%" + 0x02) "%lev1%"
    WRITE_SHORT ("%mem_info%" + 0x04) "%lev1%"
    WRITE_SHORT ("%mem_info%" + 0x0c) "%lev1%"

    //level 2 fixes
    SET "lev2" = 0
    PATCH_IF ("%level%" > 9) BEGIN
      SET "lev2" = ("%lev2%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~sppr204~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    PATCH_IF ("%level%" > 11) BEGIN
      SET "lev2" = ("%lev2%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~sppr202~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    WRITE_SHORT ("%mem_info%" + 0x02 + (1 * 0x10)) "%lev2%"
    WRITE_SHORT ("%mem_info%" + 0x04 + (1 * 0x10)) "%lev2%"
    WRITE_LONG  ("%mem_info%" + 0x08 + (1 * 0x10)) (("%idx_start%" + "%delta%") - "%lev2%")
    WRITE_SHORT ("%mem_info%" + 0x0c + (1 * 0x10)) "%lev2%"

    //level 3 fixes
    SET "lev3" = 0
    PATCH_IF ("%level%" > 11) BEGIN
      SET "lev3" = ("%lev3%" + 1)
      INSERT_BYTES  ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) 0x0c
        WRITE_ASCII ("%mem_off%" +        (0x0c * ("%delta%" + "%idx_start%"))) ~sppr315~
        WRITE_SHORT ("%mem_off%" + 0x08 + (0x0c * ("%delta%" + "%idx_start%"))) 1
      SET "delta" = ("%delta%" + 1)
    END
    WRITE_SHORT ("%mem_info%" + 0x02 + (2 * 0x10)) "%lev3%"
    WRITE_SHORT ("%mem_info%" + 0x04 + (2 * 0x10)) "%lev3%"
    WRITE_LONG  ("%mem_info%" + 0x08 + (2 * 0x10)) (("%idx_start%" + "%delta%") - "%lev3%")
    WRITE_SHORT ("%mem_info%" + 0x0c + (2 * 0x10)) "%lev3%"
  
    // wrapping up; correcting indexes for remaining spells
    SET "loops" = 0
    WHILE ("%loops%" < 13) BEGIN
      SET "loops" = ("%loops%" + 1)
      WRITE_SHORT ("%mem_info%" + 0x02 + (("%loops%" + 2) * 0x10)) 0
      WRITE_SHORT ("%mem_info%" + 0x04 + (("%loops%" + 2) * 0x10)) 0
      WRITE_LONG  ("%mem_info%" + 0x08 + (("%loops%" + 2) * 0x10)) ("%idx_start%" + "%delta%")
      WRITE_SHORT ("%mem_info%" + 0x0c + (("%loops%" + 2) * 0x10)) 0
    END
    WRITE_LONG  ("%mem_info%" + 0x08 + (16 * 0x10)) ("%idx_start%" + "%delta%")

    // final wrapup; correct # of memorized spells and offsets
    WRITE_LONG 0x2b4 (("%idx_start%" + "%delta%" + "%mem_num%") - "%idx_end%")
    SET "offset_delta" = ((("%delta%" + "%idx_start%") - "%idx_end%") * 0x0c)
    PATCH_IF ("%known_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2a0 ("%known_off%" + "%offset_delta%")
    END
    PATCH_IF ("%slot_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2b8 ("%slot_off%" + "%offset_delta%")
    END
    PATCH_IF ("%item_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2bc ("%item_off%" + "%offset_delta%")
    END
    PATCH_IF ("%fx_off%" >= "%mem_off%") BEGIN
      WRITE_LONG 0x2c4 ("%fx_off%" + "%offset_delta%")
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// vic6 has incorrect class script
COPY_EXISTING ~viconi6.cre~ ~override~
  WRITE_ASCII 0x250 ~initrg10~
  BUT_ONLY_IF_IT_CHANGES

// Viconia proficiency fix, remove holy smite, fire seeds, add flame blade
COPY_EXISTING ~viconi6.cre~  ~override~
              ~viconi8.cre~  ~override~
              ~viconi9.cre~  ~override~
              ~viconi11.cre~ ~override~
              ~viconi13.cre~ ~override~
              ~viconi16.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_BYTE 0x234 "level"
    READ_LONG 0x2a0 "known_off"
    READ_LONG 0x2a4 "known_num"
    READ_LONG 0x2a8 "meminfo_off"
    READ_LONG 0x2b0 "mem_off"
    READ_LONG 0x2b4 "mem_num"
    READ_LONG 0x2b8 "slot_off"
    READ_LONG 0x2bc "item_off"
    READ_LONG 0x2c4 "fx_off"
    READ_LONG 0x2c8 "fx_num"
    SET "fx_delta" = 1
    FOR (index = known_num ; index > 0 ; index = index - 1) BEGIN // spellbook adjustments
      READ_ASCII ("%known_off%" + (("%index%" - 1) * 0x0C)) "spell"
      PATCH_IF (("SPPR313" STRING_COMPARE_CASE "%spell%" = 0) OR
                ("SPPR606" STRING_COMPARE_CASE "%spell%" = 0)) BEGIN
        DELETE_BYTES ("%known_off%" + (("%index%" - 1) * 0x0C)) 0x0C
        SET "known_num" = ("%known_num%" - 1)
        PATCH_IF ("%meminfo_off%" >= "%known_off%") BEGIN
          SET "meminfo_off" = ("%meminfo_off%" - 0x0C)
        END
        PATCH_IF ("%mem_off%" >= "%known_off%") BEGIN
          SET "mem_off" = ("%mem_off%" - 0x0C)
        END
        PATCH_IF ("%slot_off%" >= "%known_off%") BEGIN
          SET "slot_off" = ("%slot_off%" - 0x0C)
        END
        PATCH_IF ("%item_off%" >= "%known_off%") BEGIN
          SET "item_off" = ("%item_off%" - 0x0C)
        END
        PATCH_IF ("%fx_off%" >= "%known_off%") BEGIN
          SET "fx_off" = ("%fx_off%" - 0x0C)
        END
      END
    END
    FOR (index = mem_num ; index > 0 ; index = index - 1) BEGIN // spellbook adjustments
      READ_ASCII ("%mem_off%" + (("%index%" - 1) * 0x0C)) "spell"
      PATCH_IF ("SPPR313" STRING_COMPARE_CASE "%spell%" = 0) BEGIN
        WRITE_ASCII ("%mem_off%" + (("%index%" - 1) * 0x0C)) ~sppr314~ #8
      END ELSE
      PATCH_IF ("SPPR606" STRING_COMPARE_CASE "%spell%" = 0) BEGIN
        WRITE_ASCII ("%mem_off%" + (("%index%" - 1) * 0x0C)) ~sppr601~ #8
      END
    END
    INSERT_BYTES  "%fx_off%" 0x108 // inserting new prof effect
      WRITE_LONG  ("%fx_off%" + 0x08) 233    // opcode
      WRITE_LONG  ("%fx_off%" + 0x14) 1      // stars
      WRITE_LONG  ("%fx_off%" + 0x18) 112    // prof - sword & shield
      WRITE_LONG  ("%fx_off%" + 0x1c) 9      // timing
      WRITE_SHORT ("%fx_off%" + 0x24) 100    // prob
      WRITE_ASCII ("%fx_off%" + 0x68) ~None~ // vvc
    PATCH_IF ("%level%" > 12) BEGIN
      SET "fx_delta" = 2
      INSERT_BYTES  "%fx_off%" 0x108 // inserting new prof effect
        WRITE_LONG  ("%fx_off%" + 0x08) 233    // opcode
        WRITE_LONG  ("%fx_off%" + 0x14) 1      // stars
        WRITE_LONG  ("%fx_off%" + 0x18) 100    // prof - flail
        WRITE_LONG  ("%fx_off%" + 0x1c) 9      // timing
        WRITE_SHORT ("%fx_off%" + 0x24) 100    // prob
        WRITE_ASCII ("%fx_off%" + 0x68) ~None~ // vvc
    END
    PATCH_IF ("%known_off%" >= "%fx_off%") BEGIN
      SET "known_off" = ("%known_off%" + ("%fx_delta%" * 0x108))
    END
    PATCH_IF ("%meminfo_off%" >= "%fx_off%") BEGIN
      SET "meminfo_off" = ("%meminfo_off%" + ("%fx_delta%" * 0x108))
    END
    PATCH_IF ("%mem_off%" >= "%fx_off%") BEGIN
      SET "mem_off" = ("%mem_off%" + ("%fx_delta%" * 0x108))
    END
    PATCH_IF ("%slot_off%" >= "%fx_off%") BEGIN
      SET "slot_off" = ("%slot_off%" + ("%fx_delta%" * 0x108))
    END
    PATCH_IF ("%item_off%" >= "%fx_off%") BEGIN
      SET "item_off" = ("%item_off%" + ("%fx_delta%" * 0x108))
    END
    WRITE_LONG 0x2a0 "%known_off%"
    WRITE_LONG 0x2a4 "%known_num%"
    WRITE_LONG 0x2a8 "%meminfo_off%"
    WRITE_LONG 0x2b0 "%mem_off%"
    WRITE_LONG 0x2b8 "%slot_off%"
    WRITE_LONG 0x2bc "%item_off%"
    WRITE_LONG 0x2c4 "%fx_off%"
    WRITE_LONG 0x2c8 ("%fx_num%" + "%fx_delta%")
    ADD_KNOWN_SPELL ~sppr206~ #1 ~priest~
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes to Parisa's soundset
COPY_EXISTING ~VVPARIS.CRE~ ~OVERRIDE~
  SAY INITIAL_MEETING #61743
  SAY MORALE          #61749
  SAY BATTLE_CRY1     #61745
  SAY BATTLE_CRY2     #61746
  SAY DAMAGE          #61747
  SAY DYING           #61748
  SAY SELECT_COMMON1  #61741
  SAY SELECT_COMMON2  #61742
  SAY SELECT_COMMON3  #61743
  SAY SELECT_COMMON4  #61744
  SAY PICKED_POCKET   #61744

// wish01 and wish02 should be the same genie
COPY_EXISTING ~wish02.cre~ ~override/wish01.cre~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN
    WRITE_ASCII 0x280 ~wish01~ #18 // death var
    WRITE_ASCII 0x2cc ~wish~    #8 // dialogue
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~yarmy01.cre~ ~override~ //typo
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN
    WRITE_ASCII 0x258 ~cfigh20b~ #8
  END
  BUT_ONLY_IF_IT_CHANGES
  
// yoshimo has too many thieving points
COPY_EXISTING ~yoshi7.cre~  ~override~
              ~yoshi8.cre~  ~override~
              ~yoshi10.cre~ ~override~
  WRITE_BYTE 0x45 35 // hide in shadows
  WRITE_BYTE 0x68 40 // move silently
  BUT_ONLY_IF_IT_CHANGES
  
// yoshimo has too many thieving points
COPY_EXISTING ~yoshi11.cre~ ~override~
  WRITE_BYTE 0x45 40 // hide in shadows
  WRITE_BYTE 0x68 45 // move silently
  BUT_ONLY_IF_IT_CHANGES
  
// yoshimo has too many thieving points
COPY_EXISTING ~yoshi12.cre~ ~override~
  WRITE_BYTE 0x45 45 // hide in shadows
  WRITE_BYTE 0x65 15 // set traps
  WRITE_BYTE 0x68 50 // move silently
  BUT_ONLY_IF_IT_CHANGES

// overcharged items on creatures
COPY_EXISTING ~aerbod01.cre~ ~override~ // slng01 (num 2) has assigned 20 to max 1 in header 1
              ~aerie6.cre~   ~override~ // slng01 (num 2) has assigned 20 to max 1 in header 1
              ~amarch01.cre~ ~override~ // helm33 (num 0) has assigned 30 to max 1 in header 1
              ~amarch02.cre~ ~override~ // helm33 (num 1) has assigned 30 to max 1 in header 1
              ~ar18dwaf.cre~ ~override~ // ax1h04 (num 0) has assigned 1 to max 0 in header 2
              ~aran.cre~     ~override~ // helmnoan (num 0) has assigned 2 to max 1 in header 1
              ~aran02.cre~   ~override~ // misc6w (num 7) has assigned 3 to max 1 in header 1
              ~beast.cre~    ~override~ // arow01 (num 4) has assigned 20 to max 0 in header 2
              ~c6catti.cre~  ~override~ // ring05 (num 2) has assigned 10 to max 1 in header 1
              ~c6kngt1.cre~  ~override~ // bow01 (num 2) has assigned 20 to max 1 in header 1
              ~c6regis.cre~  ~override~ // ring05 (num 4) has assigned 6 to max 1 in header 1
              ~chang01.cre~  ~override~ // ring05 (num 6) has assigned 10 to max 1 in header 1
              ~chang02.cre~  ~override~ // ring05 (num 6) has assigned 10 to max 1 in header 1
              ~chgood08.cre~ ~override~ // ring05 (num 3) has assigned 10 to max 1 in header 1
              ~deckass1.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~deshar.cre~   ~override~ // ring05 (num 3) has assigned 5 to max 1 in header 1
              ~docsol01.cre~ ~override~ // chan01 (num 0) has assigned 20 to max 1 in header 1
              ~docsol02.cre~ ~override~ // chan01 (num 0) has assigned 20 to max 1 in header 1
              ~duearc01.cre~ ~override~ // ax1h01 (num 1) has assigned 20 to max 1 in header 1
              ~e33.cre~      ~override~ // sw1h10 (num 5) has assigned 10 to max 1 in header 1
              ~fshorde2.cre~ ~override~ // bow01 (num 0) has assigned 20 to max 1 in header 1
              ~fshorde6.cre~ ~override~ // bow03 (num 3) has assigned 20 to max 1 in header 1
              ~gordeck5.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~gordeck6.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~gordeck7.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~gordeck8.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~gordeck9.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~gordecka.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~gorkuo05.cre~ ~override~ // xbow01 (num 1) has assigned 20 to max 1 in header 1
              ~gororc02.cre~ ~override~ // bow03 (num 3) has assigned 20 to max 1 in header 1
              ~grvlch01.cre~ ~override~ // rods05 (num 6) has assigned 5 to max 1 in header 1
              ~hgskl02.cre~  ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~hobarc02.cre~ ~override~ // bow03 (num 4) has assigned 20 to max 1 in header 1
              ~icgob01.cre~  ~override~ // bow01 (num 0) has assigned 20 to max 1 in header 1
              ~icgob02.cre~  ~override~ // bow01 (num 0) has assigned 20 to max 1 in header 1
              ~jaga4.cre~    ~override~ // sw1h08 (num 4) has assigned 2 to max 1 in header 1
              ~keldor8.cre~  ~override~ // helm01 (num 1) has assigned 20 to max 1 in header 1
              ~kobarc01.cre~ ~override~ // bow01 (num 1) has assigned 20 to max 1 in header 1
              ~kobcap01.cre~ ~override~ // bow01 (num 0) has assigned 20 to max 1 in header 1
              ~kuowhi01.cre~ ~override~ // xbow01 (num 1) has assigned 20 to max 1 in header 1
              ~latkni01.cre~ ~override~ // bow01 (num 2) has assigned 20 to max 1 in header 1
              ~latkni02.cre~ ~override~ // bow01 (num 2) has assigned 20 to max 1 in header 1
              ~maevar.cre~   ~override~ // helmnoan (num 10) has assigned 2 to max 1 in header 1
              ~nalia13.cre~  ~override~ // bow05 (num 2) has assigned 20 to max 1 in header 1
              ~orc02.cre~    ~override~ // bow03 (num 3) has assigned 20 to max 1 in header 1
              ~pirsea02.cre~ ~override~ // chan01 (num 0) has assigned 20 to max 1 in header 1
              ~plshhg01.cre~ ~override~ // bow03 (num 4) has assigned 20 to max 1 in header 1
              ~pparan2.cre~  ~override~ // misc6w (num 7) has assigned 3 to max 1 in header 1
              ~ppguard1.cre~ ~override~ // bow01 (num 1) has assigned 20 to max 1 in header 1
              ~saerk.cre~    ~override~ // ring34 (num 8) has assigned 4 to max 1 in header 1
              ~sahuag01.cre~ ~override~ // xbow01 (num 2) has assigned 20 to max 1 in header 1
              ~sargrd05.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~sargrd09.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~sarkis01.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~sarkis02.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~sarkis03.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~sarkis04.cre~ ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
              ~senani05.cre~ ~override~ // leat02 (num 0) has assigned 5 to max 1 in header 1
              ~sendai.cre~   ~override~ // wand19 (num 5) has assigned 1 to max 0 in header 2
              ~sendro05.cre~ ~override~ // leat02 (num 0) has assigned 5 to max 1 in header 1
              ~sevpat05.cre~ ~override~ // ring05 (num 3) has assigned 4 to max 1 in header 1
              ~shabod01.cre~ ~override~ // bow01 (num 1) has assigned 20 to max 1 in header 1
              ~shadeld.cre~  ~override~ // clck25 (num 0) has assigned 1 to max 0 in header 2
              ~swsfoll4.cre~ ~override~ // bow01 (num 1) has assigned 20 to max 1 in header 1
              ~swsfoll5.cre~ ~override~ // bow01 (num 1) has assigned 20 to max 1 in header 1
              ~tanthf01.cre~ ~override~ // ring05 (num 6) has assigned 4 to max 1 in header 1
              ~waukni01.cre~ ~override~ // bow01 (num 2) has assigned 20 to max 1 in header 1
              ~yaga05.cre~   ~override~ // leat02 (num 1) has assigned 5 to max 1 in header 1
  READ_LONG 0x2bc "itm_off" ELSE 0
  READ_LONG 0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (("%item%" STRING_COMPARE_CASE "arow01" = 0) OR     // arrows
              ("%item%" STRING_COMPARE_CASE "ax1h04" = 0)) BEGIN // throwing axes
      WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 0 // no secondary charge
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "ax1h01" = 0) OR     // battle axe
              ("%item%" STRING_COMPARE_CASE "bow01" = 0) OR      // composite long bow
              ("%item%" STRING_COMPARE_CASE "bow03" = 0) OR      // long bow
              ("%item%" STRING_COMPARE_CASE "bow05" = 0) OR      // short bow
              ("%item%" STRING_COMPARE_CASE "chan01" = 0) OR     // chain mail
              ("%item%" STRING_COMPARE_CASE "helm01" = 0) OR     // generic helm
              ("%item%" STRING_COMPARE_CASE "helm33" = 0) OR     // gold-horned helm
              ("%item%" STRING_COMPARE_CASE "helmnoan" = 0) OR   // invisible helm
              ("%item%" STRING_COMPARE_CASE "leat02" = 0) OR     // leaher armor +1
              ("%item%" STRING_COMPARE_CASE "misc6w" = 0) OR     // wooden stake
              ("%item%" STRING_COMPARE_CASE "rods05" = 0) OR     // rod of terror
              ("%item%" STRING_COMPARE_CASE "slng01" = 0) OR     // sling
              ("%item%" STRING_COMPARE_CASE "sw1h08" = 0) OR     // short sword +1
              ("%item%" STRING_COMPARE_CASE "sw1h10" = 0) OR     // short sword of backstabbing
              ("%item%" STRING_COMPARE_CASE "xbow01" = 0)) BEGIN // heavy crossbow
      WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%index%")) 0 // no charges, not stackable
      WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 0
      WRITE_SHORT ("%itm_off%" + 0x0e + (0x14 * "%index%")) 0
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "clck25" = 0) OR     // cloak of the stars
              ("%item%" STRING_COMPARE_CASE "wand19" = 0)) BEGIN // wand of cursing
      WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 0 // no secondary charges
      WRITE_SHORT ("%itm_off%" + 0x0e + (0x14 * "%index%")) 0 // no tertiary charges
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "ring05" = 0) OR     // ring of invisibility
              ("%item%" STRING_COMPARE_CASE "ring34" = 0)) BEGIN // ring of spell turning
      WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%index%")) 1 // once per day
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// checking creatures for undercharged items
COPY_EXISTING ~aerie10.cre~  ~override~ // bull01 (num 1) has assigned 0 to stack 40 charges 1 in header 1
              ~aerie11.cre~  ~override~ // bull01 (num 3) has assigned 0 to stack 40 charges 1 in header 1
              ~aerie9.cre~   ~override~ // bull01 (num 2) has assigned 0 to stack 40 charges 1 in header 1
              ~amarch01.cre~ ~override~ // bow20 (num 3) has assigned 0 to max 1 in header 2
              ~amcarras.cre~ ~override~ // boot12 (num 7) has assigned 0 to stack 1 charges 2 in header 1
              ~ammerc08.cre~ ~override~ // arow11 (num 5) has assigned 0 to stack 40 charges 1 in header 1
              ~bdturm02.cre~ ~override~ // bolt03 (num 3) has assigned 0 to stack 40 charges 1 in header 1
              ~bhcrypt.cre~  ~override~ // sw1h36 (num 4) has assigned 0 to max 3 in header 2
              ~bonebld.cre~  ~override~ // ipsion (num 0) has assigned 0 to stack 1 charges 50 in header 1
              ~chalcy02.cre~ ~override~ // ring34 (num 5) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc01.cre~ ~override~ // ring29 (num 4) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc02.cre~ ~override~ // ring29 (num 4) has assigned 0 to max 1 in header 2
              ~chalpc03.cre~ ~override~ // amul22 (num 5) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc04.cre~ ~override~ // ring34 (num 3) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc05.cre~ ~override~ // amul22 (num 5) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc06.cre~ ~override~ // ring34 (num 3) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc07.cre~ ~override~ // amul22 (num 5) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc08.cre~ ~override~ // ring34 (num 3) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc09.cre~ ~override~ // amul22 (num 3) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc10.cre~ ~override~ // sw2h10 (num 10) has assigned 0 to max 3 in header 2
              ~chalpc11.cre~ ~override~ // ring34 (num 1) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc12.cre~ ~override~ // sw2h10 (num 10) has assigned 0 to max 3 in header 2
              ~chalpc13.cre~ ~override~ // ring34 (num 1) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc14.cre~ ~override~ // sw2h10 (num 10) has assigned 0 to max 3 in header 2
              ~chalpc15.cre~ ~override~ // ring34 (num 1) has assigned 0 to stack 1 charges 1 in header 1
              ~chalpc16.cre~ ~override~ // sw2h10 (num 10) has assigned 0 to max 3 in header 2
              ~chevil09.cre~ ~override~ // ring34 (num 5) has assigned 0 to stack 1 charges 1 in header 1
              ~chsam01.cre~  ~override~ // staf12 (num 4) has assigned 0 to max 10 in header 2
              ~chsam02.cre~  ~override~ // staf12 (num 4) has assigned 0 to max 10 in header 3
              ~chtaz01.cre~  ~override~ // clck20 (num 3) has assigned 0 to stack 1 charges 50 in header 1
              ~e33.cre~      ~override~ // amul01 (num 6) has assigned 0 to stack 1 charges 25 in header 1
              ~elemimix.cre~ ~override~ // halb10 (num 2) has assigned 0 to max 2 in header 2
              ~firkra02.cre~ ~override~ // sw2h10 (num 4) has assigned 1 to max 3 in header 2
              ~firmon01.cre~ ~override~ // sw1h32 (num 3) has assigned 0 to max 1 in header 2
              ~flyfgt03.cre~ ~override~ // arow01 (num 0) has assigned 0 to stack 40 charges 1 in header 1
              ~fsdragon.cre~ ~override~ // sw1h70 (num 4) has assigned 0 to max 1 in header 2
              ~gorlic01.cre~ ~override~ // slng08 (num 3) has assigned 0 to max 1 in header 2
              ~gorsta09.cre~ ~override~ // arow01 (num 6) has assigned 0 to stack 40 charges 1 in header 1
              ~gorwom02.cre~ ~override~ // helm16 (num 6) has assigned 0 to stack 1 charges 1 in header 1
              ~habib.cre~    ~override~ // sw1h57 (num 1) has assigned 0 to stack 10 charges 1 in header 1
              ~hgnya01.cre~  ~override~ // ring03 (num 5) has assigned 0 to stack 1 charges 100 in header 1
              ~hldemi.cre~   ~override~ // ring39 (num 1) has assigned 0 to stack 1 charges 1 in header 1
              ~hlkang.cre~   ~override~ // ring39 (num 3) has assigned 0 to max 3 in header 2
              ~jaylos.cre~   ~override~ // dagg05 (num 1) has assigned 0 to stack 10 charges 1 in header 1
              ~kaysmg01.cre~ ~override~ // arow01 (num 4) has assigned 0 to stack 40 charges 1 in header 1
              ~kproen03.cre~ ~override~ // wand07 (num 1) has assigned 0 to stack 1 charges 50 in header 1
              ~kuoarc20.cre~ ~override~ // kuobolt3 (num 3) has assigned 0 to stack 40 charges 1 in header 1
              ~latkni02.cre~ ~override~ // arow01 (num 3) has assigned 0 to stack 40 charges 1 in header 1
//              ~nalia13.cre~  ~override~ // arow01 (num 3) has assigned 0 to stack 40 charges 1 in header 1
              ~pbhunt03.cre~ ~override~ // clck20 (num 2) has assigned 0 to stack 1 charges 50 in header 1
              ~pcapt03.cre~  ~override~ // bolt03 (num 3) has assigned 0 to stack 40 charges 1 in header 1
              ~pcapt04.cre~  ~override~ // wand05 (num 1) has assigned 0 to stack 1 charges 50 in header 1
              ~pirexe01.cre~ ~override~ // bolt01 (num 1) has assigned 0 to stack 40 charges 1 in header 1
              ~pirmur07.cre~ ~override~ // dart02 (num 0) has assigned 0 to stack 40 charges 1 in header 1
              ~ppcowled.cre~ ~override~ // misc3a (num 1) has assigned 0 to stack 1 charges 1 in header 1
//              ~resuna.cre~   ~override~ // sw1h27 (num 3) has assigned 0 to max 1 in header 2
              ~rumar01.cre~  ~override~ // wand07 (num 4) has assigned 0 to stack 1 charges 50 in header 1
              ~sarkis04.cre~ ~override~ // figure01 (num 4) has assigned 0 to stack 1 charges 1 in header 1
              ~sarvie01.cre~ ~override~ // ring20 (num 4) has assigned 0 to stack 1 charges 50 in header 1
              ~sendai3.cre~  ~override~ // arow05 (num 3) has assigned 0 to stack 40 charges 1 in header 1
              ~sewdue01.cre~ ~override~ // fragsap (num 2) has assigned 0 to stack 1 charges 1 in header 1
              ~sewyag01.cre~ ~override~ // fragsap (num 2) has assigned 0 to stack 1 charges 1 in header 1
              ~shth01.cre~   ~override~ // bull01 (num 2) has assigned 0 to stack 40 charges 1 in header 1
              ~shth011.cre~  ~override~ // bull01 (num 2) has assigned 0 to stack 40 charges 1 in header 1
              ~shth03.cre~   ~override~ // arow05 (num 3) has assigned 0 to stack 40 charges 1 in header 1
              ~sword01.cre~  ~override~ // ipsion (num 1) has assigned 0 to stack 1 charges 50 in header 1
              ~swshaman.cre~ ~override~ // misc5t (num 1) has assigned 0 to max 1 in header 2
              ~teltief3.cre~ ~override~ // wand18 (num 4) has assigned 0 to max 5 in header 2
//              ~tolger.cre~   ~override~ // ring33 (num 2) has assigned 0 to stack 1 charges 1 in header 1
//              ~tolger2.cre~  ~override~ // ring33 (num 2) has assigned 0 to stack 1 charges 1 in header 1
              ~trrak01.cre~  ~override~ // amul22 (num 1) has assigned 0 to stack 1 charges 1 in header 1
              ~uhman02.cre~  ~override~ // bolt01 (num 3) has assigned 0 to stack 40 charges 1 in header 1
              ~uhogre04.cre~ ~override~ // arow01 (num 3) has assigned 0 to stack 40 charges 1 in header 1
              ~vakg02.cre~   ~override~ // bolt01 (num 2) has assigned 0 to stack 40 charges 1 in header 1
              ~viekang.cre~  ~override~ // ring20 (num 6) has assigned 0 to stack 1 charges 50 in header 1
              ~vulfgt02.cre~ ~override~ // dart01 (num 1) has assigned 0 to stack 40 charges 1 in header 1
              ~xappren1.cre~ ~override~ // wand03 (num 0) has assigned 0 to stack 1 charges 100 in header 1
  READ_LONG 0x2bc "itm_off" ELSE 0
  READ_LONG 0x2c0 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "amul01" = 0) BEGIN // necklace of missiles
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 25
      END
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "amul22" = 0) OR     // periapt of proof v poison
              ("%item%" STRING_COMPARE_CASE "figure01" = 0) OR   // shakti figurine
              ("%item%" STRING_COMPARE_CASE "fragsap" = 0) OR    // fragmentation skull
              ("%item%" STRING_COMPARE_CASE "misc3a" = 0) OR     // book of infinite spells
              ("%item%" STRING_COMPARE_CASE "ring33" = 0) OR     // ring of the ram
              ("%item%" STRING_COMPARE_CASE "ring34" = 0)) BEGIN // ring of spell turning
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%index%")) 1 // once per day
      END
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "arow01" = 0) OR     // arrows
              ("%item%" STRING_COMPARE_CASE "arow05" = 0) OR     // arrows
              ("%item%" STRING_COMPARE_CASE "bolt01" = 0) OR     // bolts
              ("%item%" STRING_COMPARE_CASE "bolt03" = 0) OR     // bolts of lightning
              ("%item%" STRING_COMPARE_CASE "dart01" = 0) OR     // darts
              ("%item%" STRING_COMPARE_CASE "dart02" = 0) OR     // darts +1
              ("%item%" STRING_COMPARE_CASE "kuobolt3" = 0) OR   // kuo-toa bolts +3
              ("%item%" STRING_COMPARE_CASE "ring03" = 0)) BEGIN // ring of animal friendship
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 20 // typical total for stacks
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "arow11" = 0) BEGIN // arrows +2
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 30 // typical total for stacks
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "boot12" = 0) BEGIN // gargoyle boots
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%index%")) 2 // two secondary charges
      END
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "bow20" = 0) OR
              ("%item%" STRING_COMPARE_CASE "misc5t" = 0) OR // shaman's staff
              ("%item%" STRING_COMPARE_CASE "slng08" = 0) OR // erinne sling
              ("%item%" STRING_COMPARE_CASE "sw1h27" = 0) OR // arbane
              ("%item%" STRING_COMPARE_CASE "sw1h32" = 0) OR // dragonslayer
              ("%item%" STRING_COMPARE_CASE "sw1h70" = 0)) BEGIN // hindo's doooooom
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 1 // one secondary charge
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "bull01" = 0) BEGIN // bullets
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 20 // typical total for stacks
      END
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "chalcy3" = 0) OR    // greenstone amulet
              ("%item%" STRING_COMPARE_CASE "clck20" = 0) OR     // cloak of the shield
              ("%item%" STRING_COMPARE_CASE "ipsion" = 0) OR     // greenstone amulet
              ("%item%" STRING_COMPARE_CASE "ring20" = 0)) BEGIN  // ring of energy
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 50 // max charges; none of the affected items can be dropped
      END
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "dagg05" = 0) OR // throwing daggers
              ("%item%" STRING_COMPARE_CASE "sw1h57" = 0)) BEGIN // habib's throwing daggers
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%index%")) 10
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "halb10" = 0) BEGIN // ravager +4
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 2 // two secondary charges
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "helm16" = 0) BEGIN // helm of brilliance
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      READ_SHORT  ("%itm_off%" + 0x0e + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%index%")) 1
      END
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 1
      END
      PATCH_IF ("%charge3%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0e + (0x14 * "%index%")) 1
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "ring29" = 0) BEGIN // ring of earth control
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%index%")) 1
      END
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 1
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "ring39" = 0) BEGIN // ring of gaxx
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%index%")) 1
      END
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 3
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "staf11" = 0) BEGIN // staff of the magi
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      READ_SHORT  ("%itm_off%" + 0x0e + ("%index%" * 0x14)) "charge3"
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 3
      END
      PATCH_IF ("%charge3%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0e + (0x14 * "%index%")) 1
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "staf12" = 0) BEGIN // staff of power
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      READ_SHORT  ("%itm_off%" + 0x0e + ("%index%" * 0x14)) "charge3"
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 10
      END
      PATCH_IF ("%charge3%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0e + (0x14 * "%index%")) 10
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "sw1h36" = 0) BEGIN // namarra
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 3
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "sw2h10" = 0) BEGIN // carsomyr
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 3
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "wand03" = 0) BEGIN // wand of magic missiles
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 10 // typical total for stacks
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "wand05" = 0) BEGIN // wand of fire
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + (0x14 * "%index%")) 10
      END
      PATCH_IF ("%charge2%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + (0x14 * "%index%")) 10
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "wand07" = 0) BEGIN // wand of lightning
      READ_SHORT  ("%itm_off%" + 0x0a + ("%index%" * 0x14)) "charge1"
      PATCH_IF ("%charge1%" = 0) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0a + ("%index%" * 0x14)) 8 // typical total for stacks
      END
    END ELSE
    PATCH_IF ("%item%" STRING_COMPARE_CASE "wand18" = 0) BEGIN // wand of spell striking
      READ_SHORT  ("%itm_off%" + 0x0c + ("%index%" * 0x14)) "charge2"
      PATCH_IF (("%charge2%" > 5) OR ("%charge2%" = 0)) BEGIN
        WRITE_SHORT ("%itm_off%" + 0x0c + ("%index%" * 0x14)) 5 // max 5 secondary charges
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// items expire due to timers
COPY_EXISTING "abydem01.cre" "override" // ringdemn
              "bdturm02.cre" "override" // bolt03
              "csiren.cre"   "override" // STAF01, RNDTRE04
              "deaddem2.cre" "override" // ringdemn
              "demosum2.cre" "override" // ringdemn, balor, immune3
              "demosum3.cre" "override" // ringdemn, immune2
              "dglab01.cre"  "override" // ringdemn, immune2
              "dquas01.cre"  "override" // ringdemn
              "duegau01.cre" "override" // BULL01
              "duegau02.cre" "override" // AX1H01, BULL01
              "duemag01.cre" "override" // STAF01, SLNG01, POTN08, BULL01
              "duemag02.cre" "override" // STAF01, SLNG01, POTN08, BULL01
              "duergar1.cre" "override" // BULL01
              "duergar3.cre" "override" // AX1H01, BULL01
              "gorbat1.cre"  "override" // RINGdemn, immune3, reghp2r
              "gorchr.cre"   "override" // ringdemn
              "gortan1.cre"  "override" // ringdemn, balor, immune3
              "gortan2.cre"  "override" // ringdemn
              "gortan3.cre"  "override" // ringdemn, dwplat01, dwsw1h01
              "gortan4.cre"  "override" // ringdemn, immune2
              "gortan5.cre"  "override" // ringdemn
              "lavok01.cre"  "override" // STAF01, RNDTRE04
              "lavok02.cre"  "override" // STAF01, RNDTRE04
              "melsum01.cre" "override" // ringdemn, immune2
              "melsum04.cre" "override" // ringdemn, balor, immune3
              "obsdem01.cre" "override" // S1-10, ringdemn
              "pmaster.cre"  "override" // S1-10, ringdemn
              "ppdemon.cre"  "override" // S1-10, ringdemn
              "shth01.cre"   "override" // BULL01
              "shth011.cre"  "override" // BULL01
              "shth03.cre"   "override" // AROW05
              "sumtan01.cre" "override" // ringdemn
              "sumtan02.cre" "override" // ringdemn
              "tanari01.cre" "override" // S1-10, ringdemn
              "teltan1.cre"  "override" // ringdemn
              "teltan2.cre"  "override" // ringdemn
              "teltief3.cre" "override" // wand18
              "tolger.cre"   "override" // STAF01, RNDTRE04
              "tolger2.cre"  "override" // STAF01, RNDTRE04
              "uddwarf.cre"  "override" // BULL01
              "uhman02.cre"  "override" // BOLT01
              "uhogre04.cre" "override" // AROW01
              "vakg02.cre"   "override" // XBOW01
  PATCH_IF (%SOURCE_SIZE% > 0x2d3) THEN BEGIN
    READ_LONG   0x2bc "io"
    READ_LONG   0x2c0 "ic"
    FOR ("i" = 0x00; "i" < (0x14 * "ic"); "i" += 0x14) BEGIN
      WRITE_SHORT  ("io" + "i" + 0x08) 0x00
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// anomen specifics fix
COPY_EXISTING ~anomen6.cre~  ~override~
              ~anomen7.cre~  ~override~
              ~anomen8.cre~  ~override~
              ~anomen9.cre~  ~override~
              ~anomen10.cre~ ~override~
              ~anomen12.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x274 0 //specifics
  END
  BUT_ONLY_IF_IT_CHANGES

// add sleeping flag to sleeping creatures
COPY_EXISTING ~arnman11.cre~ ~override~
              ~arnwar03.cre~ ~override~
  READ_BYTE  0x20 "state"
  WRITE_BYTE 0x20 ("%state%" BAND 0b11101111) // remove the STATE_INVISIBILITY flag
  BUT_ONLY_IF_IT_CHANGES

// These are all player accessible
COPY_EXISTING ~bearblsu.cre~ ~override~ // Black Bear (sppr501.spl -> spanim2.eff -> anisum02.2da)
              ~bearbrsu.cre~ ~override~ // Brown Bear (sppr501.spl -> spanim2.eff -> anisum02.2da)
              ~bearcasu.cre~ ~override~ // Cave Bear (sppr501.spl -> spanim2.eff -> anisum02.2da) (sppr602.spl -> spanim3.eff -> anisum03.2da)
              ~bearposu.cre~ ~override~ // Mountain Bear (sppr602.spl -> spanim3.eff -> anisum03.2da) (sppr604.spl -> spanim04.eff -> anisum04.2da)
              ~catliosu.cre~ ~override~ // Lion (sppr501.spl -> spanim2.eff -> anisum02.2da) (sppr602.spl -> spanim3.eff -> anisum03.2da)
              ~catliowp.cre~ ~override~ // Joolon (misc3d.itm -> figlion.eff)
              ~demglasu.cre~ ~override~ // Glabrezu (spwi807.spl -> spfiend.eff)
              ~djinnisu.cre~ ~override~ // Djinni (spwi718.spl -> spdj.eff)
              ~dogwasu.cre~  ~override~ // War Dog (sppr402.spl -> spani01.eff -> anisum01.2da)
              ~dogwisu.cre~  ~override~ // Rabid Dog (spwi309.spl -> spmon1.eff -> spwi309.spl)
              ~efreetsu.cre~ ~override~ // Efreeti (spwi717.spl -> spefreet.eff)
              ~ettercsu.cre~ ~override~ // Ettercap (spwi503.spl -> spmon3.eff -> monsum03.2da)
              ~ghastsu.cre~  ~override~ // Skeleton (sppr301.spl/spwi501.spl -> spandead.eff)
              ~gnollsu.cre~  ~override~ // Gnoll Elite (spwi407.spl -> spmon2.eff -> monsum02.2da)
              ~haksu.cre~    ~override~ // Hakeashar (spwi719.spl -> sphack.eff)
              ~hobgobsu.cre~ ~override~ // Hobgoblin Elite (spwi407.spl -> spmon2.eff -> monsum02.2da)
              ~koboldsu.cre~ ~override~ // Kobold Commando (spwi309.spl -> spmon1.eff -> spwi309.spl
              ~nishrusu.cre~ ~override~ // Nishruu (spwi624.spl -> spnish.eff)
              ~nymphsu.cre~  ~override~ // Nymph (sppr410.spl -> nymphsu.eff)
              ~ogregrsu.cre~ ~override~ // Ogre Berserker (spwi503.spl -> spmon3.eff -> monsum03.2da)
              ~rabbitsu.cre~ ~override~ // Rabbit (spwi919 -> wish02.cre -> spin735.spl -> rabbitsu.eff)
              ~servsu.cre~   ~override~ // Aerial Servant (sppr601.spl -> spserv.eff)
              ~skelwasu.cre~ ~override~ // Skeleton Warrior (sppr301.spl/spwi501 -> spandl15.eff)
              ~smoundsu.cre~ ~override~ // Shambling Mound (staf14.itm -> mound.eff)
              ~spidgisu.cre~ ~override~ // Giant Spider (spwi423.spl -> spidgisu.eff)
              ~spidphsu.cre~ ~override~ // Phase Spider (spwi423.spl -> spidphsu.eff)
              ~spidswsu.cre~ ~override~ // Sword Spider (spwi423.spl -> spidswsu.eff)
              ~stalke.cre~   ~override~ // Invisible Stalker (spwi601.spl -> spstalk.eff)
              ~sumdjinn.cre~ ~override~ // Djinni (ring26.itm -> sumdjinn.eff)
              ~sumelair.cre~ ~override~ // Lesser Air Elemental (staf15.itm -> staf15.eff)
              ~sumefree.cre~ ~override~ // Efreeti (misc3c.itm -> sumefr.eff)
              ~sumelear.cre~ ~override~ // Lesser Earth Elemental (staf16.itm -> staf16.eff)
              ~sumelfir.cre~ ~override~ // Lesser Fire Elemental (staf17.itm -> staf17.eff)
              ~tomegol1.cre~ ~override~ // Flesh Golem (tome01.itm -> tome01.eff)
              ~tomegol2.cre~ ~override~ // Clay Golem (tome02.itm -> tome02.eff)
              ~tomegol3.cre~ ~override~ // Stone Golem (tome03.itm -> tome03.eff
              ~tomegol4.cre~ ~override~ // Juggernaut Golem (tome04.itm -> tome04.eff)
              ~wish02.cre~   ~override~ // Djinni (spwi919.spl)
              ~wolfdisu.cre~ ~override~ // Dire Wolf (sppr402.spl -> spani01.eff -> anisum01.2da) (spwi407.spl -> spmon2.eff -> monsum02.2da)
              ~wolfwwsu.cre~ ~override~ // Winter Wolf (sppr602.spl -> spanim3.eff -> anisum03.2da)
              ~worgsu.cre~   ~override~ // Worg (spwi309.spl -> spmon1.eff -> spwi309.spl)
              ~wyvernsu.cre~ ~override~ // Wyvern (spwi619.spl -> wyvernsu.eff)
              // and these are enemy only but summoned in a familiar way
              ~c6guen.cre~   ~override~ // Guenhwyvar (c6drizz.cre -> c6drizz1.dlg)
              ~sahangu.cre~  ~override~ // Anguiliian (ar2300.are -> sahambo6.cre -> sahambo6.bcs)
              ~sahlace.cre~  ~override~ // Lacedon (ar2003.are -> sahambo3.cre -> sahambo3.bcs)
              ~sahskel.cre~  ~override~ // Skeleton Warrior (ar2003.are -> sahambo3.cre -> sahambo3.bcs)
              ~sahzomb.cre~  ~override~ // Sea Zombie (ar2003.are -> sahambo3.cre -> sahambo3.bcs)
              ~senstalk.cre~ ~override~ // Invisible Stalker (ar6108.bcs)
              ~telelfir.cre~ ~override~ // Greater Fire Elemental (ar3010.are -> teltan1.cre -> teltan1.bcs -> spin570.spl -> sutelfir.eff)
              ~telicesa.cre~ ~override~ // Ice Salamander (ar3010.are -> teltan2.cre -> teltan2.bcs -> spin569.spl -> sutelice.eff)
              // These are unused but of obvious intent for UB authors - spend the day ironing your doilies and polishing your lawn instead
              /*
              ~basilgsu.cre~ ~override~ // Greater Basilisk (spwi8)
              ~basillsu.cre~ ~override~ // Lesser Basilisk (spwi610.spl)
              ~beargrsu.cre~ ~override~ // Grizzly Bear
              ~catjagsu.cre~ ~override~ // Panther
              ~ghastgsu.cre~ ~override~ // Greater Ghast
              ~gibbersu.cre~ ~override~ // Gibberling
              ~hamasu.cre~   ~override~ // Hamadryad
              ~jaguarsu.cre~ ~override~ // Jaguar
              ~jellmusu.cre~ ~override~ // Mustard Jelly (spwi610.spl)
              ~ogremasu.cre~ ~override~ // Ogre Mage (spwi610.spl)
              ~sumtan01.cre~ ~override~ // Tanar'ri
              ~sumtan02.cre~ ~override~ // Tanar'ri
              ~tasloisu.cre~ ~override~ // Tasloi Elite Trooper (spwi706.spl)
              ~wolfsu.cre~   ~override~ // Wolf
              ~wolfwisu.cre~ ~override~ // Winter Wolf (spwi610.spl)
              ~wraithsu.cre~ ~override~ // Wraith
              ~xvartsu.cre~  ~override~ // Xvart Protector
              */
  PATCH_IF (SOURCE_SIZE > 0x02d3) THEN BEGIN
//    WRITE_LONG 0x0014 0x00  // XP
    WRITE_LONG 0x001c 0x00  // Gelt, just hobgobsu.cre
    WRITE_BYTE 0x0240 0x00  // "Don't check morale"
    READ_LONG  0x02bc ilo   // lazy overkill no-steal no-drop patch
    FOR (READ_LONG 0x02c0 ilc; ilc > 0x00; ilc -= 0x01) BEGIN
      READ_LONG  (ilo + (ilc * 0x14) - 0x04) flg
      WRITE_LONG (ilo + (ilc * 0x14) - 0x04) (flg | 0x0a)
    END
  END
  BUT_ONLY

// set 0 xp for player-accessible summons
COPY_EXISTING ~bearblsu.cre~ ~override~ // Black Bear (sppr501.spl -> spanim2.eff -> anisum02.2da)
              ~bearbrsu.cre~ ~override~ // Brown Bear (sppr501.spl -> spanim2.eff -> anisum02.2da)
              ~bearcasu.cre~ ~override~ // Cave Bear (sppr501.spl -> spanim2.eff -> anisum02.2da) (sppr602.spl -> spanim3.eff -> anisum03.2da)
              ~bearposu.cre~ ~override~ // Mountain Bear (sppr602.spl -> spanim3.eff -> anisum03.2da) (sppr604.spl -> spanim04.eff -> anisum04.2da)
              ~catliosu.cre~ ~override~ // Lion (sppr501.spl -> spanim2.eff -> anisum02.2da) (sppr602.spl -> spanim3.eff -> anisum03.2da)
              ~catliowp.cre~ ~override~ // Joolon (misc3d.itm -> figlion.eff)
              ~demglasu.cre~ ~override~ // Glabrezu (spwi807.spl -> spfiend.eff)
              ~djinnisu.cre~ ~override~ // Djinni (spwi718.spl -> spdj.eff)
              ~dogwasu.cre~  ~override~ // War Dog (sppr402.spl -> spani01.eff -> anisum01.2da)
              ~dogwisu.cre~  ~override~ // Rabid Dog (spwi309.spl -> spmon1.eff -> spwi309.spl)
              ~efreetsu.cre~ ~override~ // Efreeti (spwi717.spl -> spefreet.eff)
              ~ettercsu.cre~ ~override~ // Ettercap (spwi503.spl -> spmon3.eff -> monsum03.2da)
              ~ghastsu.cre~  ~override~ // Skeleton (sppr301.spl/spwi501.spl -> spandead.eff)
              ~gnollsu.cre~  ~override~ // Gnoll Elite (spwi407.spl -> spmon2.eff -> monsum02.2da)
              ~haksu.cre~    ~override~ // Hakeashar (spwi719.spl -> sphack.eff)
              ~hobgobsu.cre~ ~override~ // Hobgoblin Elite (spwi407.spl -> spmon2.eff -> monsum02.2da)
              ~koboldsu.cre~ ~override~ // Kobold Commando (spwi309.spl -> spmon1.eff -> spwi309.spl
              ~nishrusu.cre~ ~override~ // Nishruu (spwi624.spl -> spnish.eff)
              ~nymphsu.cre~  ~override~ // Nymph (sppr410.spl -> nymphsu.eff)
              ~ogregrsu.cre~ ~override~ // Ogre Berserker (spwi503.spl -> spmon3.eff -> monsum03.2da)
              ~rabbitsu.cre~ ~override~ // Rabbit (spwi919 -> wish02.cre -> spin735.spl -> rabbitsu.eff)
              ~servsu.cre~   ~override~ // Aerial Servant (sppr601.spl -> spserv.eff)
              ~skelwasu.cre~ ~override~ // Skeleton Warrior (sppr301.spl/spwi501 -> spandl15.eff)
              ~smoundsu.cre~ ~override~ // Shambling Mound (staf14.itm -> mound.eff)
              ~spidgisu.cre~ ~override~ // Giant Spider (spwi423.spl -> spidgisu.eff)
              ~spidphsu.cre~ ~override~ // Phase Spider (spwi423.spl -> spidphsu.eff)
              ~spidswsu.cre~ ~override~ // Sword Spider (spwi423.spl -> spidswsu.eff)
              ~stalke.cre~   ~override~ // Invisible Stalker (spwi601.spl -> spstalk.eff)
              ~sumdjinn.cre~ ~override~ // Djinni (ring26.itm -> sumdjinn.eff)
              ~sumelair.cre~ ~override~ // Lesser Air Elemental (staf15.itm -> staf15.eff)
              ~sumefree.cre~ ~override~ // Efreeti (misc3c.itm -> sumefr.eff)
              ~sumelear.cre~ ~override~ // Lesser Earth Elemental (staf16.itm -> staf16.eff)
              ~sumelfir.cre~ ~override~ // Lesser Fire Elemental (staf17.itm -> staf17.eff)
              ~tomegol1.cre~ ~override~ // Flesh Golem (tome01.itm -> tome01.eff)
              ~tomegol2.cre~ ~override~ // Clay Golem (tome02.itm -> tome02.eff)
              ~tomegol3.cre~ ~override~ // Stone Golem (tome03.itm -> tome03.eff
              ~tomegol4.cre~ ~override~ // Juggernaut Golem (tome04.itm -> tome04.eff)
              ~wish02.cre~   ~override~ // Djinni (spwi919.spl)
              ~wolfdisu.cre~ ~override~ // Dire Wolf (sppr402.spl -> spani01.eff -> anisum01.2da) (spwi407.spl -> spmon2.eff -> monsum02.2da)
              ~wolfwwsu.cre~ ~override~ // Winter Wolf (sppr602.spl -> spanim3.eff -> anisum03.2da)
              ~worgsu.cre~   ~override~ // Worg (spwi309.spl -> spmon1.eff -> spwi309.spl)
              ~wyvernsu.cre~ ~override~ // Wyvern (spwi619.spl -> wyvernsu.eff)
  PATCH_IF (SOURCE_SIZE > 0x02d3) THEN BEGIN
    WRITE_LONG 0x0014 0x00  // XP
  END
  BUT_ONLY

// wolfwere capt should have same DV for transformed, non-transformed creature files
COPY_EXISTING ~firamb04.cre~ ~override~
  WRITE_ASCII 0x280 ~firamb01~ #32

// lvl 6 trolls should be routed through a different knocked-down version
COPY_EXISTING ~firtrl01.cre~ ~override~
              ~kptrol01.cre~ ~override~
              ~kptrol02.cre~ ~override~
              ~kptrol04.cre~ ~override~
              ~kptrol05.cre~ ~override~
  WRITE_ASCII 0x248 ~cdtroll1~
  BUT_ONLY_IF_IT_CHANGES

// deirex killed during cutscene fix 2/2; see 2207.bcs
COPY_EXISTING ~jarlich.cre~ ~override~
  WRITE_BYTE 0x270 128 // make neutral
  BUT_ONLY_IF_IT_CHANGES

// create 'dead' or 'knocked down' versions of 'special' trolls
COPY_EXISTING ~obsice01.cre~ ~override/obsice11.cre~
  WRITE_SHORT           0x24    1            // current HP
  WRITE_SHORT           0x46   10            // natural AC
  WRITE_SHORT           0x48   10            // effective AC
  WRITE_BYTE            0x5a  100            // resist cold
  WRITE_BYTE            0x5b  100            // resist electricity
  WRITE_BYTE            0x5f  100            // resist magic cold
  WRITE_BYTE            0x60  100            // resist slashing
  WRITE_BYTE            0x61  100            // resist crushing
  WRITE_BYTE            0x62  100            // resist piercing
  WRITE_BYTE            0x63  100            // resist missile
  WRITE_BYTE            0x23c   9            // dexterity
  WRITE_BYTE            0x270 255            // enemy
  WRITE_EVALUATED_ASCII 0x248 ~%SOURCE_RES%~ // new script
  WRITE_ASCII           0x250 ~~ #32         // blanks all other script references
  WRITE_ASCII           0x2cc ~~ #8          // blanks dialog file
  // item changes
  READ_LONG 0x2bc "itm_off"
  READ_LONG 0x2c0 "itm_num"
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF (
               ("%item%" STRING_COMPARE_CASE "monhp1" = 0) OR // so they can die
               ("%item%" STRING_COMPARE_CASE "trollreg" = 0) OR // can't regenerate
               ("%item%" STRING_COMPARE_CASE "trollspi" = 0) // makes dead spirit troll invisible
             ) BEGIN
      WRITE_ASCII ("%itm_off%" + (0x14 * "%index%")) ~trolldie~
    END
  END

// add monhp1 item to trolls to prevent death; assign script to force transformation to dead form at low HP
COPY_EXISTING ~obsice01.cre~ ~override~
  ADD_CRE_ITEM ~monhp1~ #0 #0 #0 ~NONE~ ~AMULET~
  WRITE_ASCII 0x260 ~obsice11~

// attacking squatters in paladin-baron quest causes normal townspeople to turn hostile
COPY_EXISTING ~plfarm04.cre~ ~override~
              ~plfarm05.cre~ ~override~
              ~plfarm06.cre~ ~override~
  WRITE_ASCII 0x248 ~gensht01~ // override script
  BUT_ONLY_IF_IT_CHANGES

// prevent dupe CoC items; see also sahkng01.bcs, ar2300.bcs, sahpr2.dlg, string sets
COPY_EXISTING ~sahpr4.cre~ ~override~
  READ_LONG  0x2bc "itm_off"
  READ_LONG  0x2c0 "itm_num"
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" + (0x14 * "%index%")) "item"
    PATCH_IF ("%item%" STRING_COMPARE_CASE "misc8q" = 0) BEGIN
      READ_BYTE   ("%itm_off%" + 0x10 + (0x14 * "%index%")) "flags"
      WRITE_BYTE  ("%itm_off%" + 0x10 + (0x14 * "%index%")) ("%flags%" BOR   0b00001010) // adds unstealable, undroppable flags
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// name fixes
COPY_EXISTING ~sarbul04.cre~ ~override~
              ~sarbul05.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_LONG 0x08 68792
    WRITE_LONG 0x0c 68792
  END
  BUT_ONLY_IF_IT_CHANGES

// Orcs sound like orcs; blanks human sounds
COPY_EXISTING ~sarculto.cre~ ~override~
              ~sarorc01.cre~ ~override~
              ~saroro01.cre~ ~override~
              ~sarrein1.cre~ ~override~
              ~sartro01.cre~ ~override~
              ~sartro03.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_LONG 0xa4 0xffffffff
    WRITE_LONG 0xc8 0xffffffff
    WRITE_LONG 0xec 0xffffffff
    WRITE_LONG 0xf0 0xffffffff
    WRITE_LONG 0x10c 0xffffffff
    WRITE_LONG 0x198 0xffffffff
  END
  BUT_ONLY_IF_IT_CHANGES

// Silent Sapper (uses same soundset as sewdue01)
COPY_EXISTING ~sewdue02.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    SAY 0xa4 #4940
    SAY 0xec #12584
    SAY 0xf0 #12585
    SAY 0x10c #4939
    SAY 0x110 #4940
  END
  BUT_ONLY_IF_IT_CHANGES

// 'glowing pool' creature from lilarcor quest has dispellable invisibility (via mage item); add it directly as creature effect
COPY_EXISTING ~sewsw.cre~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    READ_LONG 0x2a0 "kspl_off"
    READ_LONG 0x2a8 "minfo_off"
    READ_LONG 0x2b0 "mspl_off"
    READ_LONG 0x2b8 "itmslot_off"
    READ_LONG 0x2bc "itm_off"
    READ_LONG 0x2c4 "fx_off"
    READ_LONG 0x2c8 "fx_num"
    SET "delta" = 1
    INSERT_BYTES  "%fx_off%" 0x108 // inserting new effect
      WRITE_LONG  ("%fx_off%" + 0x08)  20 // opcode: invis
      WRITE_LONG  ("%fx_off%" + 0x1c)   1 // instant/permanent
      WRITE_SHORT ("%fx_off%" + 0x24) 100 // prob
    WRITE_LONG 0x2c8 ("%fx_num%" + "%delta%")
    SET "offset" = ("%delta%" * 0x108)
    PATCH_IF NOT ("%fx_off%" > "%kspl_off%") BEGIN
      WRITE_LONG 0x2a0 ("%kspl_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%minfo_off%") BEGIN
      WRITE_LONG 0x2a8 ("%minfo_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%mspl_off%") BEGIN
      WRITE_LONG 0x2b0 ("%mspl_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%itmslot_off%") BEGIN
      WRITE_LONG 0x2b8 ("%itmslot_off%" + "%offset%")
    END
    PATCH_IF NOT ("%fx_off%" > "%itm_off%") BEGIN
      WRITE_LONG 0x2bc ("%itm_off%" + "%offset%")
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// add sleeping flag to sleeping creatures
COPY_EXISTING ~sleepdw.cre~ ~override~   // sleeping dwarf
              ~sleepfh.cre~ ~override~   // sleeping woman
              ~sleepmh.cre~ ~override~   // sleeping man
  READ_BYTE  0x20 "state"
  WRITE_BYTE 0x20 ("%state%" BOR 0b00000001) // add the STATE_SLEEPING flag
  BUT_ONLY_IF_IT_CHANGES

// knocked-down trolls should match their live counterparts
COPY_EXISTING ~troll02.cre~ ~override~
  WRITE_BYTE 0x234 8
  BUT_ONLY_IF_IT_CHANGES

// knocked-down trolls should match their live counterparts
COPY_EXISTING ~troll01.cre~ ~override/cdtroll1.cre~
              ~troll02.cre~ ~override/cdtroll2.cre~
  WRITE_BYTE   0x234 6
  WRITE_ASCIIE 0x248 ~%DEST_RES%~

// Correct a minor issue in Mazzy's soundset (aVENGER)
ACTION_FOR_EACH ~file~ IN                                                          // for each of the following files
               ~mazzy8~                                                            // Mazzy at level 8 (SoA)
               ~mazzy9~                                                            // Mazzy at level 9 (SoA)
              ~mazzy11~                                                            // Mazzy at level 11 (SoA)
              ~mazzy12~                                                            // Mazzy at level 12 (SoA)
              ~mazzy15~                                                            // Mazzy at level 15 (ToB)
BEGIN                                                                              // execute the following
ACTION_IF FILE_EXISTS_IN_GAME ~%file%.cre~ BEGIN                                   // if the file exists
COPY_EXISTING ~%file%.cre~ ~override~
PATCH_IF (%SOURCE_SIZE% > 0x2d3) THEN BEGIN                                        // file size sanity check (filters out 0 byte files i.e. ALLOW_MISSING)
  SAY EXISTANCE2 #29727 SAY EXISTANCE3 #-1                                         // assign the Spell Failed sound to the proper soundslot
END                                                                                // ends file size check
BUT_ONLY_IF_IT_CHANGES
END                                                                                // ends ACTION_IF FILE_EXISTS_IN_GAME block
END                                                                                // ends ACTION_FOR_EACH block

// Prevent Ice Trolls from losing their coloring upon death (aVENGER)
COPY_EXISTING ~TROLIC01.CRE~  ~override~ // Ice Troll
              ~TROLIC02.CRE~  ~override~ // Ice Troll
    READ_LONG 0x2c4 "fx_off"
    READ_LONG 0x2c8 "fx_num"
    FOR (index = 0; index < fx_num; index = index + 1) BEGIN
      READ_LONG  ("%fx_off%" + 0x08 + ("%index%" * 0x108)) "opcode"
      READ_LONG  ("%fx_off%" + 0x0c + ("%index%" * 0x108)) "target"
      READ_LONG  ("%fx_off%" + 0x1c + ("%index%" * 0x108)) "timing"
       PATCH_IF (("%opcode%" = "51") AND ("%target%" = "0")) BEGIN // effect #51: color strong/dark by rgb
         WRITE_LONG ("%fx_off%" + 0x0c + ("%index%" * 0x108)) "1" // change the target to 1 (target: self)
       END
       PATCH_IF (("%opcode%" = "51") AND ("%timing%" = "1")) BEGIN // effect #51: color strong/dark by rgb
         WRITE_LONG ("%fx_off%" + 0x1c + ("%index%" * 0x108)) "9" // change the timing mode to 9: permanent after death
       END
    END    
BUT_ONLY_IF_IT_CHANGES

// Correct mismatched names and tooltips (Nythrun and aVENGER)
// Part 1: Name -> Tooltip
ACTION_FOR_EACH ~file~ IN                          // for each of the following files
            ~alphonse~                             // alphonse - servant
            ~elesah02~                             // sahuagin baronial guard - baronial guard
            ~kuotoa01~                             // kuo-toa warrior - kuo-toa
            ~obssah03~                             // sahuagin baronial guard - baronial guard
            ~sahbar01~                             // sahuagin baronial guard - baronial guard
            ~sahextra~                             // sahuagin royal guard - royal guard
            ~sahgrd01~                             // sahuagin royal guard - royal guard
            ~sahgrd02~                             // sahuagin royal guard - royal guard
            ~sahgrd03~                             // sahuagin royal guard - royal guard
BEGIN                                              // execute the following
ACTION_IF FILE_EXISTS_IN_GAME ~%file%.cre~ BEGIN   // if the file exists
COPY_EXISTING ~%file%.cre~ ~override~
PATCH_IF (%SOURCE_SIZE% > 0x2d3) THEN BEGIN        // file size sanity check (filters out 0 byte files i.e. ALLOW_MISSING)
  READ_LONG  0x08 "name"                           // get the creature's name field strref
  WRITE_LONG 0x0c "%name%"                         // make the creature's tooltip match its name
END                                                // ends file size check
BUT_ONLY_IF_IT_CHANGES
END                                                // ends ACTION_IF FILE_EXISTS_IN_GAME block
END                                                // ends ACTION_FOR_EACH block

// Correct mismatched names and tooltips (Nythrun and aVENGER)
// Part 2: Tooltip -> Name
ACTION_FOR_EACH ~file~ IN                          // for each of the following files
            ~behobs01~                             // beholder - observer
            ~behspe01~                             // beholder - spectator
            ~gendjn01~                             // djinni - noble djinni
            ~genefn01~                             // efreeti - noble efreeti
            ~kptrol06~                             // troll - ice troll
             ~lasmist~                             // djinni - gaseous form
            ~obsfir01~                             // efreeti - noble efreeti
            ~ppbodbat~                             // vampire - vampire bat
            ~ppdjinn2~                             // djinni - noble djinni
            ~ppmind01~                             // mind flayer - ulitharid
            ~rngbeh01~                             // beholder - death tyrant
            ~tanomist~                             // vampire - gaseous form
            ~trolfr01~                             // troll - freshwater troll
            ~trolfr02~                             // troll - freshwater troll
            ~trolsn01~                             // troll - snow troll
            ~trolsn02~                             // troll - snow troll
             ~udelder~                             // beholder - elder orb
            ~valemist~                             // vampire - gaseous form
             ~vampbat~                             // vampire - vampire bat
BEGIN                                              // execute the following
ACTION_IF FILE_EXISTS_IN_GAME ~%file%.cre~ BEGIN   // if the file exists
COPY_EXISTING ~%file%.cre~ ~override~
PATCH_IF (%SOURCE_SIZE% > 0x2d3) THEN BEGIN        // file size sanity check (filters out 0 byte files i.e. ALLOW_MISSING)
  READ_LONG  0x0c "tooltip"                        // get the creature's tooltip field strref
  WRITE_LONG 0x08 "%tooltip%"                      // make the creature's name match its tooltip
END                                                // ends file size check
BUT_ONLY_IF_IT_CHANGES
END                                                // ends ACTION_IF FILE_EXISTS_IN_GAME block
END                                                // ends ACTION_FOR_EACH block

// Jan Jansen now properly receives his bonus spell per level for being a specialist mage (Nythrun)
COPY_EXISTING jan8.cre     override
              jan10.cre    override
              jan11.cre    override
              jan12.cre    override
              jan15.cre    override
  PATCH_IF SOURCE_SIZE > 0x2d3 BEGIN
    ADD_MEMORIZED_SPELL spwi118 #0 WIZARD
    ADD_MEMORIZED_SPELL spwi201 #1 WIZARD
    ADD_MEMORIZED_SPELL spwi302 #2 WIZARD
    PATCH_IF          ~%SOURCE_RES%~ STRING_EQUAL jan8  BEGIN
      ADD_MEMORIZED_SPELL spwi405 #3 WIZARD
    END ELSE PATCH_IF ~%SOURCE_RES%~ STRING_EQUAL jan10 BEGIN
      ADD_MEMORIZED_SPELL spwi405 #3 WIZARD
      ADD_MEMORIZED_SPELL spwi508 #4 WIZARD
    END ELSE BEGIN
      ADD_MEMORIZED_SPELL spwi401 #3 WIZARD
      ADD_MEMORIZED_SPELL spwi508 #4 WIZARD
    END
  END
BUT_ONLY

// Creatures shouldn't have two-handed items equipped alongside shields (Nythrun and devSin)
// Orc Archer
COPY_EXISTING firarc01.cre override
  REMOVE_CRE_ITEM shld05

// Rielev 
COPY_EXISTING rielev.cre override
  REMOVE_CRE_ITEM mage01

// Red Willy 
COPY_EXISTING trple01.cre override
  REMOVE_CRE_ITEM xbow01 bolt01

// Lady Beth
COPY_EXISTING bystand2.cre override
  WRITE_ASCII 0x250 ~~ #8
BUT_ONLY

/////                                                  \\\\\
///// item file fixes                                  \\\\\
/////                                                  \\\\\

/////                                                  \\\\\
///// big block of unusability stuff                   \\\\\
/////                                                  \\\\\

// BMU, scroll supposed to be completely restriction-free
COPY_EXISTING ~scrladj.itm~ ~override~
              ~secret01.itm~ ~override~
              ~secret02.itm~ ~override~
              ~secret03.itm~ ~override~
              ~secret04.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_LONG 0x1e 0
    WRITE_BYTE 0x29 0
    WRITE_BYTE 0x2b 0
    WRITE_BYTE 0x2d 0
    WRITE_BYTE 0x2f 0
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~hamm06.itm~  ~override~ // dwarven thrower
              ~misc5x.itm~  ~override~ // harper pin
              ~misca6.itm~  ~override~ // patrol leader helmet
              ~npbow.itm~   ~override~ // bow of arvoreen
              ~npsw01.itm~  ~override~ // sword of arvoreen
              ~ring35.itm~  ~override~ // ring of lock picking
              ~wa2ring.itm~ ~override~ // mercykiller ring
  READ_BYTE  0x1e "use"
  WRITE_BYTE 0x1e ("%use%" BOR 0b01000000) // adds bard flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac06.itm~ ~override~ // Gauntlets of Ogre Power
  READ_BYTE  0x1e "use"
  WRITE_BYTE 0x1e ("%use%" BAND 0b10111111) // removes bard flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npplat.itm~ ~override~ // Firecam Full-Plate Armor
              ~npsw03.itm~ ~override~ // hallowed redeemer
              ~waninja.itm~ ~override~ // scarlet ninja-to
  READ_BYTE  0x1e "use"
  WRITE_BYTE 0x1e ("%use%" BOR 0b00100000) // adds lc-axis neutral flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npchan.itm~ ~override~ // corthala family armor
              ~npsw04.itm~ ~override~ // Corthala Family Blade
  READ_BYTE  0x1e "use"
  WRITE_BYTE 0x1e ("%use%" BOR 0b00010000) // adds lawful flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npchan.itm~ ~override~ // corthala family armor
              ~npplat.itm~ ~override~ // Firecam Full-Plate Armor
              ~npsw03.itm~ ~override~ // hallowed redeemer
              ~npsw04.itm~ ~override~ // Corthala Family Blade
  READ_BYTE  0x1e "use"
  WRITE_BYTE 0x1e ("%use%" BOR 0b00001000) // adds ge-axis neutral flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npchan.itm~ ~override~ // corthala family armor
              ~npplat.itm~ ~override~ // Firecam Full-Plate Armor
              ~npsw03.itm~ ~override~ // hallowed redeemer
              ~npsw04.itm~ ~override~ // Corthala Family Blade
  READ_BYTE  0x1e "use"
  WRITE_BYTE 0x1e ("%use%" BOR 0b00000010) // adds evil flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npchan.itm~  ~override~ // corthala family armor
              ~npplat.itm~  ~override~ // Firecam Full-Plate Armor
              ~npsw03.itm~  ~override~ // hallowed redeemer
              ~npsw04.itm~  ~override~ // Corthala Family Blade
              ~waninja.itm~ ~override~ // scarlet ninja-to
  READ_BYTE  0x1e "use"
  WRITE_BYTE 0x1e ("%use%" BOR 0b00000001) // adds chaotic flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~hamm06.itm~ ~override~ // dwarven thrower
              ~dagg18.itm~ ~override~ // shadow thief dagger
              ~misc9q.itm~ ~override~ // scimitar
              ~npchan.itm~ ~override~ // corthala family armor
  READ_BYTE  0x1f "use"
  WRITE_BYTE 0x1f ("%use%" BOR 0b10000000) // adds f/m/c flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~misc9q.itm~ ~override~ // scimitar
              ~npchan.itm~ ~override~ // corthala family armor
  READ_BYTE  0x1f "use"
  WRITE_BYTE 0x1f ("%use%" BOR 0b01000000) // adds f/c flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac17.itm~ ~override~ // gloves of pickpocketing
              ~hamm06.itm~ ~override~ // dwarven thrower
              ~npbow.itm~  ~override~ // bow of arvoreen
              ~npchan.itm~ ~override~ // corthala family armor
              ~npsw01.itm~ ~override~ // sword of arvoreen
  READ_BYTE  0x1f "use"
  WRITE_BYTE 0x1f ("%use%" BOR 0b00100000) // adds f/m flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~misc4q.itm~  ~override~ // the ogre's sword
              ~npchan.itm~  ~override~ // corthala family armor
              ~rodmace.itm~ ~override~ // mace from rod o' lordly might
              ~rods01.itm~  ~override~ // rod of absorption
              ~rods04.itm~  ~override~ // rod of smiting
              ~sw1h46.itm~  ~override~ // wakizashi
              ~sw1h47.itm~  ~override~ // wakizashi +1
              ~sw1h66.itm~  ~override~ // yamato +4
              ~sw1h99.itm~  ~override~ // sword of chaos
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x1f "use"
    WRITE_BYTE 0x1f ("%use%" BOR 0b00010000) // adds f/d flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac17.itm~ ~override~ // gloves of pickpocketing
              ~npchan.itm~ ~override~ // corthala family armor
  READ_BYTE  0x1f "use"
  WRITE_BYTE 0x1f ("%use%" BOR 0b00001000) // adds f flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~hamm06.itm~ ~override~ // dwarven thrower
              ~misc9q.itm~ ~override~ // scimitar
              ~npchan.itm~ ~override~ // corthala family armor
  READ_BYTE  0x1f "use"
  WRITE_BYTE 0x1f ("%use%" BOR 0b00000100) // adds c/r flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~potn56.itm~ ~override~ // potion of frost giant strength
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x1f "use"
    WRITE_BYTE 0x1f ("%use%" BAND 0b11111101) // removes c/t flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~hamm06.itm~ ~override~ // dwarven thrower
              ~misc9q.itm~ ~override~ // scimitar
              ~npchan.itm~ ~override~ // corthala family armor
  READ_BYTE  0x1f "use"
  WRITE_BYTE 0x1f ("%use%" BOR 0b00000010) // adds c/t flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~hamm06.itm~  ~override~ // dwarven thrower
              ~npchan.itm~  ~override~ // corthala family armor
              ~ring35.itm~  ~override~ // ring of lock picking
              ~wa2ring.itm~ ~override~ // mercykiller ring
  READ_BYTE  0x1f "use"
  WRITE_BYTE 0x1f ("%use%" BOR 0b00000001) // adds c/m flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npsw03.itm~ ~override~ // hallowed redeemer
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BOR 0b10000000) // adds elf flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npsw04.itm~ ~override~ // Corthala Family Blade
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BAND 0b10111111) // removes thief flag
  BUT_ONLY_IF_IT_CHANGES


COPY_EXISTING ~scrl8e.itm~ ~override~ // protection from the elements
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BOR 0b01000000) // adds thief flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac17.itm~ ~override~ // gloves of pickpocketing
              ~hamm06.itm~ ~override~ // dwarven thrower
              ~npbow.itm~  ~override~ // bow of arvoreen
              ~npsw01.itm~ ~override~ // sword of arvoreen
              ~staf14.itm~ ~override~ // staff of woodlands
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BOR 0b00100000) // adds ranger flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~amul21.itm~ ~override~ // Amulet of power
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BAND 0b11011111) // removes ranger flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac17.itm~ ~override~ // gloves of pickpocketing
              ~hamm06.itm~ ~override~ // dwarven thrower
              ~misc3m.itm~ ~override~ // Harp of Discord
              ~misc3o.itm~ ~override~ // Methild's Harp
              ~npbow.itm~  ~override~ // bow of arvoreen
              ~npsw01.itm~ ~override~ // sword of arvoreen
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BOR 0b00010000) // adds paladin flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~amul21.itm~ ~override~ // Amulet of power
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BAND 0b11101111) // removes paladin flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~misca6.itm~ ~override~ // patrol leader helmet
              ~npbow.itm~  ~override~ // bow of arvoreen
              ~npsw01.itm~ ~override~ // sword of arvoreen
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BOR 0b00001000) // adds m/t flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~chan20.itm~ ~override~ // white dragon scale
              ~potn56.itm~ ~override~ // potion of frost giant strength
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x20 "use"
    WRITE_BYTE 0x20 ("%use%" BAND 0b11110111) // removes m/t flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~misca6.itm~ ~override~ // patrol leader helmet
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BOR 0b00000100) // adds mage flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npchan.itm~ ~override~ // corthala family armor
              ~rods04.itm~ ~override~ // rod of smiting
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BOR 0b00000010) // adds f/t flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~hamm06.itm~ ~override~ // dwarven thrower
              ~npbow.itm~  ~override~ // bow of arvoreen
              ~npchan.itm~ ~override~ // corthala family armor
              ~npsw01.itm~ ~override~ // sword of arvoreen
              ~npsw03.itm~ ~override~ // hallowed redeemer
              ~waninja.itm~ ~override~ // scarlet ninja-to
  READ_BYTE  0x20 "use"
  WRITE_BYTE 0x20 ("%use%" BOR 0b00000001) // adds f/m/t flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~hamm06.itm~  ~override~ // dwarven thrower
              ~hlolth.itm~  ~override~ // handmaiden's mace
              ~misc5x.itm~  ~override~ // harper pin
              ~npbow.itm~   ~override~ // bow of arvoreen
              ~npchan.itm~  ~override~ // corthala family armor
              ~npplat.itm~  ~override~ // Firecam Full-Plate Armor
              ~npsw01.itm~  ~override~ // sword of arvoreen
              ~npsw02.itm~  ~override~ // yoshimo's katana
              ~npsw03.itm~  ~override~ // hallowed redeemer
              ~npsw04.itm~  ~override~ // Corthala Family Blade
              ~npsw05.itm~  ~override~ // chaos
              ~npsw06.itm~  ~override~ // entropy
              ~waninja.itm~ ~override~ // scarlet ninja-to
  READ_BYTE  0x21 "use"
  WRITE_BYTE 0x21 ("%use%" BOR 0b10000000) // adds half-orc flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~sw1h46.itm~ ~override~ // wakizashi
              ~sw1h47.itm~ ~override~ // wakizashi +1
              ~sw1h66.itm~ ~override~ // yamato +4
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x21 "use"
    WRITE_BYTE 0x21 ("%use%" BOR 0b01000000) // adds druid flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac19.itm~ ~override~ // Gauntlets of crushing
              ~dagg16.itm~ ~override~ // poisoned throwing daggers
              ~dagg18.itm~ ~override~ // shadow thief dagger
              ~dagg19.itm~ ~override~ // dagger of <CHARNAME>
              ~plat20.itm~ ~override~ // blue dragon plate
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x21 "use"
    WRITE_BYTE 0x21 ("%use%" BAND 0b10111111) // removes druid flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~amul16.itm~   ~override~ // metaspell influence amulet
              ~amul21.itm~   ~override~ // Amulet of power
              ~brac17.itm~   ~override~ // gloves of pickpocketing
              ~brac21.itm~   ~override~ // guantlets of ex specialization
              ~clck29.itm~   ~override~ // robe of apprenti
              ~dwshld01.itm~ ~override~ // drow shield +3
              ~dwsw1h01.itm~ ~override~ // drow scimitar +3
              ~misc5t.itm~   ~override~ // shaman's staff
              ~misc9o.itm~   ~override~ // staff
              ~misca6.itm~   ~override~ // patrol leader helmet
              ~npplat.itm~   ~override~ // Firecam Full-Plate Armor
              ~potn36.itm~   ~override~ // potion of master thievery
              ~ring22.itm~   ~override~ // ring o' holiness
              ~ring35.itm~   ~override~ // ring of lock picking
              ~ring40.itm~   ~override~ // ring of acuity
              ~rods01.itm~   ~override~ // rod of absorption
              ~rods04.itm~   ~override~ // rod of smiting
              ~rods05.itm~   ~override~ // rod of terror
              ~rods06.itm~   ~override~ // rod of reversal
              ~npsw03.itm~   ~override~ // hallowed redeemer
              ~scrl3g.itm~   ~override~ // vocalize
//              ~scrl56.itm~   ~override~ // cure serious wounds (Monks should be able to use Priest-only scrolls according to Bioware)
//              ~scrl58.itm~   ~override~ // free action
//              ~scrl59.itm~   ~override~ // neutralize poison
//              ~scrl5a.itm~   ~override~ // mental domination
//              ~scrl5b.itm~   ~override~ // defensive harmony
//              ~scrl5c.itm~   ~override~ // protection from lightning
//              ~scrl5d.itm~   ~override~ // protection from evil 10'
//              ~scrl5e.itm~   ~override~ // champion's strength
//              ~scrl5f.itm~   ~override~ // chaotic commands
                ~scrl5g.itm~   ~override~ // remove curse (wizard version)
//              ~scrl61.itm~   ~override~ // cure critical wounds
//              ~scrl62.itm~   ~override~ // flame strike
//              ~scrl63.itm~   ~override~ // raise dead
              ~scrl8b.itm~   ~override~ // summon nishruu
              ~scrl8c.itm~   ~override~ // stone to flesh
//              ~wa2amu.itm~   ~override~ // sensate amulet (Monks should be able to use Priest-only items according to Bioware)
              ~wa2ring.itm~  ~override~ // mercykiller ring
              ~wand02.itm~   ~override~ // wand of fear
              ~wand04.itm~   ~override~ // wand of paralyzation
              ~wand05.itm~   ~override~ // wand of fire
              ~wand06.itm~   ~override~ // wand of frost
              ~wand07.itm~   ~override~ // wand of lightning
              ~wand09.itm~   ~override~ // wand of polymorphing
              ~wand10.itm~   ~override~ // wand of monster summoning
//              ~wand11.itm~   ~override~ // wand of the heavens (Monks should be able to use Priest-only items according to Bioware)
              ~wand13.itm~   ~override~ // wand of cloudkill
              ~wand14.itm~   ~override~ // web sack
              ~wand15.itm~   ~override~ // wand of apprenti
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x21 "use"
    WRITE_BYTE 0x21 ("%use%" BOR 0b00100000) // adds monk flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~boot01.itm~ ~override~ // boots of speed
// (added by DW)              ~leat24.itm~ ~override~ // grandmaster armor
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x21 "use"
    WRITE_BYTE 0x21 ("%use%" BAND  0b11011111) // removes monk flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npplat.itm~ ~override~ // Firecam Full-Plate Armor
              ~npsw03.itm~ ~override~ // hallowed redeemer
  READ_BYTE  0x21 "use"
  WRITE_BYTE 0x21 ("%use%" BOR 0b00010000) // adds gnome flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npsw03.itm~ ~override~ // hallowed redeemer
  READ_BYTE  0x21 "use"
  WRITE_BYTE 0x21 ("%use%" BOR 0b00000100) // adds halfling flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npsw03.itm~ ~override~ // hallowed redeemer
  READ_BYTE  0x21 "use"
  WRITE_BYTE 0x21 ("%use%" BOR 0b00000010) // adds half-elf flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npsw03.itm~ ~override~ // hallowed redeemer
  READ_BYTE  0x21 "use"
  WRITE_BYTE 0x21 ("%use%" BOR 0b00000001) // adds dwarf flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~potn56.itm~ ~override~ // potion of frost giant strength
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BOR  0b10000000) // adds wildmage flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~amul21.itm~   ~override~ // Amulet of power
              ~dwplat01.itm~ ~override~ // drow full plate +5
              ~misc5x.itm~   ~override~ // harper pin
  READ_BYTE  0x29 "use"
  WRITE_BYTE 0x29 ("%use%" BOR  0b01000000) // adds barbarian flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac21.itm~ ~override~ // gauntlet of ex specialization
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BAND  0b10111111) // removes barbarian flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~misc5x.itm~ ~override~ // harper pin
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BOR  0b00100000) // add avenger flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~ ~override~ // Wong Fei's Ioun Stone
              ~scrl5t.itm~ ~override~ // protection from electricity (mage)
              ~scrl9a.itm~ ~override~ // pierce shield
              ~scrl9b.itm~ ~override~ // summon fiend
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BAND  0b11011111) // removes avenger flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~chan20.itm~   ~override~ // white dragon scale
              ~dwplat01.itm~ ~override~ // drow full plate +5
              ~leat19.itm~   ~override~ // shadow dragon scale
              ~misc5x.itm~   ~override~ // harper pin
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BOR   0b00010000) // adds shapeshifter flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~dwshld01.itm~ ~override~ // drow medium shield
              ~helm34.itm~   ~override~ // Wong Fei's Ioun Stone
              ~scrl5t.itm~   ~override~ // protection from electricity (mage)
              ~scrl9a.itm~   ~override~ // pierce shield
              ~scrl9b.itm~   ~override~ // summon fiend
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BAND  0b11101111) // removes shapeshifter flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~misc5x.itm~ ~override~ // harper pin
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BOR  0b00001000) // adds totemic druid flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~   ~override~ // Wong Fei's Ioun Stone
              ~scrl5t.itm~   ~override~ // protection from electricity (mage)
              ~scrl9a.itm~   ~override~ // pierce shield
              ~scrl9b.itm~   ~override~ // summon fiend
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BAND  0b11110111) // removes totemic druid flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~ ~override~ // wong fei ioun stone
              ~misc7t.itm~ ~override~ // moon dog figurine
              ~potn56.itm~ ~override~ // rogue potion of power
              ~scrl1w.itm~ ~override~ // fireshield (blue)
              ~scrl2b.itm~ ~override~ // stoneskin
              ~scrl5t.itm~ ~override~ // protection from electricity
              ~scrl9a.itm~ ~override~ // pierce shield
              ~scrl9b.itm~ ~override~ // summon fiend
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BAND  0b11111011) // removes lathander flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~ ~override~ // wong fei ioun stone
              ~misc7t.itm~ ~override~ // moon dog figurine
              ~potn56.itm~ ~override~ // rogue potion of power
              ~scrl1w.itm~ ~override~ // fireshield (blue)
              ~scrl2b.itm~ ~override~ // stoneskin
              ~scrl5t.itm~ ~override~ // protection from electricity
              ~scrl9a.itm~ ~override~ // pierce shield
              ~scrl9b.itm~ ~override~ // summon fiend
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BAND  0b11111101) // removes helm flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~ ~override~ // wong fei ioun stone
              ~misc7t.itm~ ~override~ // moon dog figurine
              ~potn56.itm~ ~override~ // rogue potion of power
              ~scrl1w.itm~ ~override~ // fireshield (blue)
              ~scrl2b.itm~ ~override~ // stoneskin
              ~scrl5t.itm~ ~override~ // protection from electricity
              ~scrl9a.itm~ ~override~ // pierce shield
              ~scrl9b.itm~ ~override~ // summon fiend
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x29 "use"
    WRITE_BYTE 0x29 ("%use%" BAND  0b11111110) // removes talos flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~ ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~ ~override~ // handmaiden's mace
              ~scrl1w.itm~ ~override~ // fireshield (blue)
              ~scrl2b.itm~ ~override~ // stoneskin
              ~scrl5t.itm~ ~override~ // protection from electricity
              ~scrl8e.itm~ ~override~ // protection from the elements
              ~scrl9a.itm~ ~override~ // pierce shield
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2b "use"
    WRITE_BYTE 0x2b ("%use%" BAND  0b11101111) // remove swashbuckler flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac21.itm~ ~override~ // gauntlet of ex specialization
              ~helm34.itm~ ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~ ~override~ // handmaiden's mace
              ~scrl1w.itm~ ~override~ // fireshield (blue)
              ~scrl2b.itm~ ~override~ // stoneskin
              ~scrl5t.itm~ ~override~ // protection from electricity
              ~scrl9a.itm~ ~override~ // pierce shield
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2b "use"
    WRITE_BYTE 0x2b ("%use%" BAND  0b11110111) // remove bounty hunter flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac21.itm~ ~override~ // gauntlet of ex specialization
              ~helm34.itm~ ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~ ~override~ // handmaiden's mace
              ~scrl1w.itm~ ~override~ // fireshield (blue)
              ~scrl2b.itm~ ~override~ // stoneskin
              ~scrl5t.itm~ ~override~ // protection from electricity
              ~scrl9a.itm~ ~override~ // pierce shield
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2b "use"
    WRITE_BYTE 0x2b ("%use%" BAND  0b11111011) // remove assassin flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~dwblun01.itm~ ~override~ // drow flail +3
              ~dwhalb01.itm~ ~override~ // drow halberd +3
              ~dwsper01.itm~ ~override~ // drow lance +3
              ~dwsw1h02.itm~ ~override~ // drow long sword +3
              ~dwchan01.itm~ ~override~ // drow elven chain +3
              ~dwchan02.itm~ ~override~ // drow adamantine chain +5
              ~dwplat01.itm~ ~override~ // drow full plate +5
              ~dwsw1h01.itm~ ~override~ // Drow Scimitar +3
              ~misc4q.itm~   ~override~ // The Ogre's Sword
              ~misc4u.itm~   ~override~ // Embarl's Dagger
              ~misc9q.itm~   ~override~ // scimitar
              ~npchan.itm~   ~override~ // corthala family armor
              ~sendai.itm~   ~override~ // sendai's flail
              ~sw1h20.itm~   ~override~ // scimitar
              ~sw1h22.itm~   ~override~ // Scimitar +1
              ~sw1h23.itm~   ~override~ // Scimitar +2, Rashad's Talon
              ~sw1h30.itm~   ~override~ // belm +2
              ~sw1h50.itm~   ~override~ // Shazzellim +1
              ~sw1h52.itm~   ~override~ // Scimitar +3
              ~sw1h56.itm~   ~override~ // Scimitar
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2b "use"
    WRITE_BYTE 0x2b ("%use%" BOR 0b00000010) // adds beastmaster flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~scrl5t.itm~   ~override~ // protection from electricity (mage)
              ~scrl8e.itm~   ~override~ // protection from the elements
              ~scrl9a.itm~   ~override~ // pierce shield
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2b "use"
    WRITE_BYTE 0x2b ("%use%" BAND 0b11111101) // removes beastmaster flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~chan20.itm~   ~override~ // white dragon scale
              ~dwchan01.itm~ ~override~ // drow elven chain +3
              ~dwchan02.itm~ ~override~ // drow adamantine chain +5
              ~dwplat01.itm~ ~override~ // drow full plate +5
              ~plat06.itm~   ~override~ // ankheg plate
              ~plat18.itm~   ~override~ // red dragon scale
              ~plat20.itm~   ~override~ // blue dragon plate
  READ_BYTE  0x2b "use"
  WRITE_BYTE 0x2b ("%use%" BOR 0b00000001) // adds stalker flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~hlolth.itm~   ~override~ // handmaiden's mace
              ~scrl5t.itm~   ~override~ // protection from electricity (mage)
              ~scrl9a.itm~   ~override~ // pierce shield
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2b "use"
    WRITE_BYTE 0x2b ("%use%" BAND 0b11111110) // removes stalker flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~dwchan01.itm~ ~override~ // drow elven chain +3
              ~dwchan02.itm~ ~override~ // drow adamantine chain +5
              ~dwplat01.itm~ ~override~ // drow full plate +5
              ~npchan.itm~   ~override~ // corthala family armor
  READ_BYTE  0x2d "use"
  WRITE_BYTE 0x2d ("%use%" BOR 0b10000000) // adds archer flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~hlolth.itm~   ~override~ // handmaiden's mace
              ~scrl5t.itm~   ~override~ // protection from electricity (mage)
              ~scrl9a.itm~   ~override~ // pierce shield
              ~plat06.itm~   ~override~ // ankheg plate
              ~plat18.itm~   ~override~ // red dragon scale
              ~plat20.itm~   ~override~ // blue dragon plate
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2d "use"
    WRITE_BYTE 0x2d ("%use%" BAND 0b01111111) // removes archer flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~scrl3h.itm~ ~override~ // protection from evil
  READ_BYTE  0x2d "use"
  WRITE_BYTE 0x2d ("%use%" BOR 0b00100000) // adds transmuter flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~   ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~   ~override~ // handmaiden's mace
              ~potn56.itm~   ~override~ // rogue potion of power
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2d "use"
    WRITE_BYTE 0x2d ("%use%" BAND 0b11011111) // removes transmuter flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~   ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~   ~override~ // handmaiden's mace
              ~potn56.itm~   ~override~ // rogue potion of power
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2d "use"
    WRITE_BYTE 0x2d ("%use%" BAND 0b11101111) // removes necromancer flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~   ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~   ~override~ // handmaiden's mace
              ~potn56.itm~   ~override~ // rogue potion of power
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2d "use"
    WRITE_BYTE 0x2d ("%use%" BAND 0b11110111) // removes invoker flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~   ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~   ~override~ // handmaiden's mace
              ~potn56.itm~   ~override~ // rogue potion of power
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2d "use"
    WRITE_BYTE 0x2d ("%use%" BAND 0b11111011) // removes illusionist flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~dwchan01.itm~ ~override~ // drow chain
              ~dwchan02.itm~ ~override~ // drow chain
              ~dwplat01.itm~ ~override~ // drow plate
              ~helm34.itm~   ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~   ~override~ // handmaiden's mace
              ~potn56.itm~   ~override~ // rogue potion of power
              ~shld25.itm~   ~override~ // shield of harmony
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2d "use"
    WRITE_BYTE 0x2d ("%use%" BAND 0b11111101) // removes enchanter flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~   ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~   ~override~ // handmaiden's mace
              ~potn56.itm~   ~override~ // rogue potion of power
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2d "use"
    WRITE_BYTE 0x2d ("%use%" BAND 0b11111110) // removes diviner flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~   ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~   ~override~ // handmaiden's mace
              ~potn56.itm~   ~override~ // rogue potion of power
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2f "use"
    WRITE_BYTE 0x2f ("%use%" BAND 0b01111111) // removes conjurer flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~scrla1.itm~   ~override~ // wizard eye
  READ_BYTE  0x2f "use"
  WRITE_BYTE 0x2f ("%use%" BOR   0b01000000) // adds abjurer flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~   ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~   ~override~ // handmaiden's mace
              ~potn56.itm~   ~override~ // rogue potion of power
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2f "use"
    WRITE_BYTE 0x2f ("%use%" BAND 0b10111111) // removes abjurer flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npsw04.itm~ ~override~ // Corthala Family Blade
              ~scrl5t.itm~ ~override~ // protection from electricity (mage)
              ~scrl9a.itm~ ~override~ // pierce shield
  READ_BYTE  0x2f "use"
  WRITE_BYTE 0x2f ("%use%" BAND 0b11011111) // removes undead hunter flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npsw04.itm~ ~override~ // Corthala Family Blade
              ~scrl5t.itm~ ~override~ // protection from electricity (mage)
              ~scrl9a.itm~ ~override~ // pierce shield
              ~ttpot.itm~  ~override~ // potion of extra healing
  READ_BYTE  0x2f "use"
  WRITE_BYTE 0x2f ("%use%" BAND 0b11101111) // removes inquisitor flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~dwxbow01.itm~ ~override~ // Drow Crossbow of Speed
              ~wasling.itm~  ~override~ // Sling of Everard +5
  READ_BYTE  0x2f "use"
  WRITE_BYTE 0x2f ("%use%" BOR   0b00001000) // adds cavalier flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~npsw04.itm~ ~override~ // Corthala Family Blade
              ~scrl5t.itm~ ~override~ // protection from electricity (mage)
              ~scrl9a.itm~ ~override~ // pierce shield
  READ_BYTE  0x2f "use"
  WRITE_BYTE 0x2f ("%use%" BAND 0b11110111) // removes cavalier flag
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac19.itm~   ~override~ // Gauntlets of Crushing
              ~dart08.itm~   ~override~ // Crimson Dart +3
              ~dwxbow01.itm~ ~override~ // Drow Crossbow of Speed
              ~misc5x.itm~   ~override~ // harper pin
              ~npbow.itm~    ~override~ // bow of arvoreen
              ~wasling.itm~  ~override~ // Sling of Everard +5
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2f "use"
    WRITE_BYTE 0x2f ("%use%" BOR 0b00000100) // adds kensai flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~ ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~ ~override~ // handmaiden's mace
              ~npchan.itm~  ~override~ // corthala family armor
              ~npsw04.itm~ ~override~ // Corthala Family Blade
              ~potn56.itm~ ~override~ // rogue potion of power
              ~scrl1w.itm~ ~override~ // fireshield (blue)
              ~scrl2b.itm~ ~override~ // stoneskin
              ~scrl5t.itm~ ~override~ // protection from electricity
              ~scrl9a.itm~ ~override~ // pierce shield
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2f "use"
    WRITE_BYTE 0x2f ("%use%" BAND 0b11111011) // removes kensai flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~brac19.itm~   ~override~ // Gauntlets of Crushing
              ~dwclck01.itm~ ~override~ // Drow Piwafwi Cloak
              ~misc5x.itm~   ~override~ // harper pin
              ~misc9w.itm~   ~override~ // Drow Piwafwi Cloak
              ~regisamu.itm~ ~override~ // Ruby Pendant of Beguiling
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2f "use"
    WRITE_BYTE 0x2f ("%use%" BOR 0b00000010) // add wizslayer flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~clck09.itm~  ~override~ // mage robe of cold resistance
              ~clck10.itm~  ~override~ // mage robe of fire resistance
              ~clck11.itm~  ~override~ // mage robe of electric resistance
              ~clck12.itm~  ~override~ // knave's robe
              ~clck13.itm~  ~override~ // traveller's robe
              ~clck14.itm~  ~override~ // adventurer's robe
              ~clck15.itm~  ~override~ // robe of the good archmagi
              ~clck16.itm~  ~override~ // robe of the neutral archmagi
              ~clck17.itm~  ~override~ // robe of the evil archmagi
              ~clck18.itm~  ~override~ // knave's robe
              ~clck19.itm~  ~override~ // robe of the good archmagi
              ~clck29.itm~  ~override~ // robe of the apprenti
              ~hgwra02.itm~ ~override~ // robe of the good archmagi
              ~hlolth.itm~  ~override~ // handmaiden's mace
              ~ipotn08.itm~ ~override~ // healing potion
              ~npsw04.itm~  ~override~ // Corthala Family Blade
              ~potn08.itm~  ~override~ // healing potion
              ~potn17.itm~  ~override~ // elixir of health
              ~potn20.itm~  ~override~ // antidote
              ~potn25.itm~  ~override~ // healing potion (cursed)
              ~potn32.itm~  ~override~ // antidote (cursed)
              ~potn52.itm~  ~override~ // extra healing potion
              ~potn55.itm~  ~override~ // superior healing potion
              ~scrl1w.itm~  ~override~ // fireshield (blue)
              ~scrl2b.itm~  ~override~ // stoneskin
              ~scrl5t.itm~  ~override~ // protection from electricity
              ~scrl9a.itm~  ~override~ // pierce shield
              ~ttpot.itm~   ~override~ // extra healing potion
              ~wa2robe.itm~ ~override~ // robe of vecna
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2f "use"
    WRITE_BYTE 0x2f ("%use%" BAND  0b11111101) // removes wizardslayer flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~misc5x.itm~   ~override~ // harper pin
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2f "use"
    WRITE_BYTE 0x2f ("%use%" BOR 0b00000001) // adds berserker flag
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~helm34.itm~ ~override~ // Wong Fei's Ioun Stone
              ~hlolth.itm~ ~override~ // handmaiden's mace
              ~npsw04.itm~ ~override~ // Corthala Family Blade
              ~potn56.itm~ ~override~ // rogue potion of power
              ~scrl1w.itm~ ~override~ // fireshield (blue)
              ~scrl2b.itm~ ~override~ // stoneskin
              ~scrl5t.itm~ ~override~ // protection from electricity
              ~scrl7u.itm~ ~override~ // contingency
              ~scrl9a.itm~ ~override~ // pierce shield
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE  0x2f "use"
    WRITE_BYTE 0x2f ("%use%" BAND 0b11111110) // removes berserker flag
  END
  BUT_ONLY_IF_IT_CHANGES

// items not working due to mis-targeted effects
COPY_EXISTING ~DRAGRING.ITM~ ~OVERRIDE~
              ~JONHP1.ITM~   ~OVERRIDE~
              ~LICH.ITM~     ~OVERRIDE~
  READ_LONG 0x6a ~effectsOffset~ ELSE 0x72
  FOR (READ_SHORT 0x70 numberOfEffects ELSE 0x00; numberOfEffects > 0x00; numberOfEffects = numberOfEffects - 0x01) BEGIN
    WRITE_BYTE ~%effectsOffset%~ + 0x02 0x01
    SET ~effectsOffset~ = ~%effectsOffset%~ + 0x30
  END
  BUT_ONLY_IF_IT_CHANGES

// many items have effects not being applied due to bad timing modes
COPY_EXISTING ~AEGIS.ITM~    ~override~ // color
              ~AEGIS2.ITM~   ~override~ // color
              ~AX1H04.ITM~   ~override~ // color
              ~AX1H05.ITM~   ~override~ // color
              ~AX1H06.ITM~   ~override~ // color
              ~AX1H08.ITM~   ~override~ // color
              ~BAZPATRG.ITM~ ~override~ // immunity to teleport field
              ~BLUN01.ITM~   ~override~ // color
              ~BLUN04.ITM~   ~override~ // color
              ~BLUN06.ITM~   ~override~ // color
              ~BLUN10.ITM~   ~override~ // color
              ~BLUN23.ITM~   ~override~ // color
              ~BLUN24.ITM~   ~override~ // color
              ~BLUN31.ITM~   ~override~ // color
              ~BODHI.ITM~    ~override~ // protection from spell: nature's beauty
              ~BOW02.ITM~    ~override~ // color
              ~BOW05.ITM~    ~override~ // color
              ~BOW08.ITM~    ~override~ // color
              ~BOW09.ITM~    ~override~ // color
              ~BOW10.ITM~    ~override~ // color
              ~BOW11.ITM~    ~override~ // color
              ~BOW14.ITM~    ~override~ // color
              ~BOW15.ITM~    ~override~ // color
              ~BOW16.ITM~    ~override~ // color
              ~BOW18.ITM~    ~override~ // color
              ~BOW19.ITM~    ~override~ // color
              ~BOW20.ITM~    ~override~ // color
              ~BOW21.ITM~    ~override~ // color
              ~BOW24.ITM~    ~override~ // color
              ~BOW26.ITM~    ~override~ // color
              ~BOW99.ITM~    ~override~ // color
              ~BOWNON.ITM~   ~override~ // color
              ~CATTAC1.ITM~  ~override~ // color
              ~CATTIBOW.ITM~ ~override~ // color
              ~CHALSLAY.ITM~ ~override~ // protection from spell: lower resist
              ~CHWRAITH.ITM~ ~override~ // immunities to charm, sleep, hold creature, hold creature type
              ~CLOWN.ITM~    ~override~ // colorglow pulse
              ~DAGG04.ITM~   ~override~ // color
              ~DAGG05.ITM~   ~override~ // color
              ~DAGG16.ITM~   ~override~ // color
              ~DAGG18.ITM~   ~override~ // color
              ~DAGGSHIT.ITM~ ~override~ // color
              ~DEMOGORG.ITM~ ~override~ // protection from spell: lower resist
              ~DEMSUC01.ITM~ ~override~ // protection from spell: nature's beauty
              ~DWHALB01.ITM~ ~override~ // color
              ~ENMACE.ITM~   ~override~ // color
              ~ENMORN.ITM~   ~override~ // color
              ~ENSW2H.ITM~   ~override~ // color
              ~FROSTY.ITM~   ~override~ // cold resist bonus
              ~FSSPIR.ITM~   ~override~ // character color, immunity to teleport field
              ~GHOST.ITM~    ~override~ // slow
              ~GHOST2.ITM~   ~override~ // slow
              ~GIAFIR.ITM~   ~override~ // color
              ~GIAFIR2.ITM~  ~override~ // color
              ~GIAFIR3.ITM~  ~override~ // color
              ~GIANTS01.ITM~ ~override~ // color
              ~GORCHR.ITM~   ~override~ // immunity to teleport field, slay, kill target
              ~GORFIRG.ITM~  ~override~ // protection from nature's beauty, immunity to animations spmindat & spflayer
              ~GORJELFU.ITM~ ~override~ // protection from nature's beauty, immunity to animations spmindat & spflayer
              ~GORJELGR.ITM~ ~override~ // protection from nature's beauty, immunity to animations spmindat & spflayer
              ~GORMISTI.ITM~ ~override~ // protection from nature's beauty, immunity to animations spmindat & spflayer
              ~GORWOM1.ITM~  ~override~ // protection from nature's beauty
              ~HALB01.ITM~   ~override~ // color
              ~HALBRD01.ITM~ ~override~ // color
              ~HAMM01.ITM~   ~override~ // color
              ~HELM14.ITM~   ~override~ // remove fear, remove fear 2 effects
              ~HGBER01.ITM~  ~override~ // color
              ~HGNYMPH.ITM~  ~override~ // protection from nature's beauty
              ~HGWRA01.ITM~  ~override~ // protection from nature's beauty
              ~HOLDRING.ITM~ ~override~ // immunity to teleport field
              ~HSLAYWPN.ITM~ ~override~ // regen
              ~HSPECTRE.ITM~ ~override~ // protection from deathsong, invis detection by script
              ~IAX1H01.ITM~  ~override~ // color
              ~IBLUN04.ITM~  ~override~ // color
              ~IBOW03.ITM~   ~override~ // color
              ~IHAMM01.ITM~  ~override~ // color
              ~INNOC2.ITM~   ~override~ // protection from nature's beauty
              ~INVULNER.ITM~ ~override~ // immunity to teleport field
              ~IRONGOL.ITM~  ~override~ // immunity to sleep, poison
              ~KUOBOW.ITM~   ~override~ // color
              ~LICH.ITM~     ~override~ // resistance to cold & electricity, immunity to non-magic weapons and spell lev < 6
              ~MDOG1.ITM~    ~override~ // immunity to charm
              ~NPBOW.ITM~    ~override~ // color
              ~OBJRING.ITM~  ~override~ // protection from nature's beauty, immunity to break morale
              ~PLYMSTAR.ITM~ ~override~ // color
              ~REAVER.ITM~   ~override~ // color
              ~RING94.ITM~   ~override~ // protection from nature's beauty
              ~RING95.ITM~   ~override~ // protection from nature's beauty, immunity to animations spmindat & spflayer
              ~RING99.ITM~   ~override~ // immunity to animations spmindat & spflayer
              ~RINGWOLF.ITM~ ~override~ // regen
              ~SELTEST.ITM~  ~override~ // use eff
              ~SHALT01.ITM~  ~override~ // protection from nature's beauty, immunity to break morale
              ~SKELCLUB.ITM~ ~override~ // color
              ~SKELWASU.ITM~ ~override~ // color
              ~SLAYERWP.ITM~ ~override~ // current hp bonus
              ~SLAYSH01.ITM~ ~override~ // protection from nature's beauty
              ~SPECTR.ITM~   ~override~ // protection from nature's beauty
              ~STALKER.ITM~  ~override~ // protection from nature's beauty
              ~STONRING.ITM~ ~override~ // set item color
              ~STONSKIN.ITM~ ~override~ // stoneskin effect
              ~SUREHP1.ITM~  ~override~ // immunity to teleport field
              ~SW1H08.ITM~   ~override~ // color
              ~SW1H14.ITM~   ~override~ // color
              ~SW1H57.ITM~   ~override~ // color
              ~SW1H99.ITM~   ~override~ // color
              ~SW2H01.ITM~   ~override~ // color
              ~SW2H01B.ITM~  ~override~ // color
              ~SW2H02.ITM~   ~override~ // color
              ~SW2H05.ITM~   ~override~ // color
              ~SW2H14.ITM~   ~override~ // imunity to spconfus animation
              ~TELSLAV.ITM~  ~override~ // protection from nature's beauty
              ~TELSLAV2.ITM~ ~override~ // immunity to charm, sleep
              ~TTSWORD2.ITM~ ~override~ // color
              ~VAMP.ITM~     ~override~ // protection from nature's beauty
              ~VAMP1.ITM~    ~override~ // protection from nature's beauty
              ~VAMP2.ITM~    ~override~ // protection from nature's beauty
              ~VAMP3.ITM~    ~override~ // protection from nature's beauty
              ~WIGHT.ITM~    ~override~ // protection from nature's beauty
              ~WRAITH1.ITM~  ~override~ // protection from nature's beauty
              ~XBOW01.ITM~   ~override~ // color
              ~XBOW02.ITM~   ~override~ // modify attacks per round
              ~XBOW03.ITM~   ~override~ // color
              ~XBOW07.ITM~   ~override~ // modify attacks per round
              ~XBOW08.ITM~   ~override~ // modify attacks per round
              ~XBOW17.ITM~   ~override~ // modify attacks per round
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x6a "fx_off"
    READ_SHORT 0x70 "fx_num"
    FOR (index = 0; index < "%fx_num%"; index = index + 1) BEGIN // searches through global effects
      WRITE_BYTE ("%fx_off%" + 0x0c + ("%index%" * 0x30)) 2 // instant/while equipped
      WRITE_LONG ("%fx_off%" + 0x0e + ("%index%" * 0x30)) 0 // duration
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// attack items used by summons should have actual strings instead of -1 or 'skull'
COPY_EXISTING ~basilg1.itm~  ~override~ // -1
              ~basilg2.itm~  ~override~ // -1
              ~basilg3.itm~  ~override~ // -1
              ~basill1.itm~  ~override~ // -1
              ~basill2.itm~  ~override~ // -1
              ~b1-6.itm~     ~override~ // 8777
              ~b1-8.itm~     ~override~ // 8777
              ~b1-8m1.itm~   ~override~ // 8777
              ~b1-10m2.itm~  ~override~ // 8777
              ~b1-12.itm~    ~override~ // 8777
              ~b1-12m3.itm~  ~override~ // 8777
              ~b1-20m3.itm~  ~override~ // -1
              ~b1-20m4.itm~  ~override~ // -1
              ~b2-16.itm~    ~override~ // 8777
              ~b3-24.itm~    ~override~ // -1
              ~b4-32.itm~    ~override~ // 8777
              ~b4-32m3.itm~  ~override~ // -1
              ~b4-32m4.itm~  ~override~ // -1
              ~catjag.itm~   ~override~ // 8777
              ~catlio.itm~   ~override~ // 8777
              ~carrio1.itm~  ~override~ // -1
              ~dogwawp.itm~  ~override~ // 8777
              ~elairl.itm~   ~override~ // 8777
              ~etterc1.itm~  ~override~ // -1
              ~etterc2.itm~  ~override~ // -1
              ~figspid.itm~  ~override~ // -1
              ~fireelel.itm~ ~override~ // 8777
              ~fireelem.itm~ ~override~ // 8777
              ~genscim.itm~  ~override~ // 8777
              ~ghast1.itm~   ~override~ // -1
              ~golfle.itm~   ~override~ // 8777
              ~golcla.itm~   ~override~ // -1
              ~golsto.itm~   ~override~ // -1
              ~jellmu1.itm~  ~override~ // 14182
              ~lacedo.itm~   ~override~ // -1
              ~mistpo.itm~   ~override~ // 8777
              ~nishruu.itm~  ~override~ // -1
              ~ogre1.itm~    ~override~ // -1
              ~p1-4.itm~     ~override~ // 8777
              ~p1-8.itm~     ~override~ // 8777
              ~p1-8m1.itm~   ~override~ // 8777
              ~p3-12m4.itm~  ~override~ // -1
              ~s1-8.itm~     ~override~ // 8777
              ~s1-10m4.itm~  ~override~ // 8777
              ~spidgi1.itm~  ~override~ // -1
              ~spidph1.itm~  ~override~ // -1
              ~spidsw1.itm~  ~override~ // -1
              ~stalkesu.itm~ ~override~ // 2898
              ~wolfwi1.itm~  ~override~ // -1
              ~wolfwi2.itm~  ~override~ // -1
              ~wraith1.itm~  ~override~ // -1
              ~wyvern1.itm~  ~override~ // -1
              ~wyvern2.itm~  ~override~ // -1
  SAY NAME1 #10966
  SAY NAME2 #10966
  BUT_ONLY_IF_IT_CHANGES

// elven sleep/charm immunity
COPY_EXISTING ~clck07.itm~   ~override~ // cloak of the nymph
              ~dagg13.itm~   ~override~ // pixie prick +3
              ~dwbolt01.itm~ ~override~ // drow bolt o' sleep
              ~gorwom1.itm~  ~override~ // undroppable nalmissra weapon - charm effect
              ~hgnymph.itm~  ~override~ // undroppable nymph weapon - charm effect
              ~misc2p.itm~   ~override~ // harp; appears unused
              ~misc9x.itm~   ~override~ // illithid control circlet
              ~psdclaw.itm~  ~override~ // ToB pseudodragon melee weapon
              ~regisamu.itm~ ~override~ // Ruby Pendant of Beguiling on Regis
              ~ring03.itm~   ~override~ // Ring of Animal Friendship
              ~ring30.itm~   ~override~ // Ring of Human Influence
              ~staf09.itm~   ~override~ // staff of command
              ~staf14.itm~   ~override~ // staff of the woodlands
              ~staf15.itm~   ~override~ // staff of air
              ~wand08.itm~   ~override~ // wand of sleep
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF (("%opcode%" = 39) OR ("%opcode%" = 5)) BEGIN // if there's a sleep or charm opcode
        READ_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "target"
        READ_BYTE  ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "prob1"
        READ_BYTE  ("%fx_off%" + 0x13 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "prob2"
        PATCH_IF ("%opcode%" = 5) BEGIN // if charm
          SET "new_fx" = 14
        END ELSE BEGIN
          SET "new_fx" = 10
        END
        SET "fx_delta" = "%fx_delta%" + "%new_fx%"
        FOR (index4 = 2 ; index4 < 4 ; index4 = index4 + 1) BEGIN
          FOR (index3 = 0 ; index3 < (("%new_fx%" / 2)) ; index3 = index3 + 1) BEGIN
            INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // insert new effect
              WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 177           // use eff file
              WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) "%target%"    // preserve target
              WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) "%index4%"    // elf or half elff
              WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 4             // race.ids
              WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) ("%prob2%" + ((21 - ("%index4%" * 6)) * ("%prob1%" - "%prob2%") / 10)) // 90%
              WRITE_BYTE  ("%fx_off%" + 0x13 + (0x30 * "%abil_fx_idx%")) "%prob2%"     // base prob
              WRITE_EVALUATED_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~cdelfcm%index3%~    // eff file
            PATCH_IF ("%opcode%" = 39) BEGIN
              WRITE_ASCII ("%fx_off%" + 0x19 + (0x30 * "%abil_fx_idx%")) ~sl~ #2 // eff file
            END
          END
        END
        SET "index2" = "%index2%" + "%new_fx%"
        SET "abil_fx_num" = "%abil_fx_num%" + "%new_fx%"
      END
    END
    WRITE_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// adds magical flag to a mess of undroppable items to prevent black dragon from taking them
COPY_EXISTING ~aeriebab.itm~ ~override~
              ~bearspir.itm~ ~override~
              ~bootdriz.itm~ ~override~
              ~clck18.itm~   ~override~
              ~dax1h01.itm~  ~override~
              ~famcat.itm~   ~override~
              ~famcat25.itm~ ~override~
              ~famdus25.itm~ ~override~
              ~famdust.itm~  ~override~
              ~famfai25.itm~ ~override~
              ~famfair.itm~  ~override~
              ~famfer.itm~   ~override~
              ~famfer25.itm~ ~override~
              ~famimp.itm~   ~override~
              ~famimp25.itm~ ~override~
              ~fampsd.itm~   ~override~
              ~fampsd25.itm~ ~override~
              ~famqua25.itm~ ~override~
              ~famquas.itm~  ~override~
              ~famrab.itm~   ~override~
              ~famrab25.itm~ ~override~
              ~helmskwa.itm~ ~override~
              ~kuobow.itm~   ~override~
              ~kuosper.itm~  ~override~
              ~lionspir.itm~ ~override~
              ~misc4g.itm~   ~override~
              ~misc84.itm~   ~override~
              ~plat98.itm~   ~override~
              ~plybass.itm~  ~override~
              ~plyfist.itm~  ~override~
              ~plymstar.itm~ ~override~
              ~plysala.itm~  ~override~
              ~plyspid.itm~  ~override~
              ~plywyvrn.itm~ ~override~
              ~snakspir.itm~  ~override~
              ~wolfspir.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_BYTE 0x18 "flags"
    PATCH_IF (("%flags%" BAND "0b00000100") = "0b00000000") BEGIN
      WRITE_BYTE "0x18" ("%flags%" BOR "0b01000000")
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// missile weapons using wrong projectiles and being blocked by protection from normal missiles
COPY_EXISTING ~aegis.itm~    ~override~ // aegis fang
              ~arow02.itm~   ~override~ // arrows +1
              ~ax1h05.itm~   ~override~ // throwing axe +2
              ~ax1h06.itm~   ~override~ // throwing axe +2
              ~ax1h08.itm~   ~override~ // hangard's axe +2
              ~ax1h09.itm~   ~override~ // rifthome axe +3
              ~ax1h16.itm~   ~override~ // k'logarath +4
              ~hamm06.itm~   ~override~ // dwarven thrower
              ~wasling.itm~  ~override~ // sling of everard +5
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_BYTE  ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 2) BEGIN
      READ_SHORT ("%abil_off%" + 0x2a + ("%index%" * 0x38)) "proj"
      PATCH_IF ("%proj%" = 5) BEGIN // normal arrow projectile
        WRITE_SHORT ("%abil_off%" + 0x2a + ("%index%" * 0x38)) 2 // magic arrow
      END ELSE
      PATCH_IF ("%proj%" = 10) BEGIN // normal axe projectile
        WRITE_SHORT ("%abil_off%" + 0x2a + ("%index%" * 0x38)) 7 // magic axe
      END ELSE
      PATCH_IF ("%proj%" = 20) BEGIN // normal axe projectile
        WRITE_SHORT ("%abil_off%" + 0x2a + ("%index%" * 0x38)) 17 // magic bullet
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// consistent +x/+y weapons, from G3 tweaks
COPY_EXISTING ~SW1H31.itm~ ~override~ // Daystar, strref #39453
  WRITE_LONG 0x60 4
  BUT_ONLY_IF_IT_CHANGES

// consistent +x/+y weapons, from G3 tweaks
COPY_EXISTING ~sw1h03.itm~ ~override~ // bastard sword +1/+3 vs shapeshifters, strref #7345
  WRITE_LONG 0x60 3
  BUT_ONLY_IF_IT_CHANGES

// null-weight magically created items, from G3 Tweaks
COPY_EXISTING ~BOLT07.itm~   ~override~ // Jan's Flashers
              ~BRDFLUTE.itm~ ~override~ // bard flute
              ~ENMACE.itm~   ~override~ // Enchanted Weapon: Mace
              ~ENMORN.itm~   ~override~ // Enchanted Weapon: Morningstar
              ~ENSTAFF.itm~  ~override~ // Enchanted Weapon: Staff
              ~ENSW1H01.itm~ ~override~ // Enchanted Weapon: Long Sword
              ~ENSW1H02.itm~ ~override~ // Enchanted Weapon: Short Sword
              ~ENSW2H.itm~   ~override~ // Enchanted Weapon: Battle Axe
              ~MELFMET.itm~  ~override~ // Melf's Minute Meteors
              ~PLYMSTAR.itm~ ~override~ // Ogre's Morningstar from Polymorph Self
              ~PLYSALA.itm~  ~override~ // Salamander's Spear from Polymorph Self
              ~SHILLE.itm~   ~override~ // Shillegagh
              ~SORB.itm~     ~override~ // Sol's Searing Orb
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_LONG 0x4c 0
  END
  BUT_ONLY_IF_IT_CHANGES

// boots of speed, grandmaster armor haste > movement rate bonus fix
COPY_EXISTING ~boot01.itm~ ~override~
              ~leat24.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG   0x6a "fx_off"
    READ_SHORT  0x70 "fx_num"
    WHILE ("%fx_num%" > 0) BEGIN
      SET "fx_num" = ("%fx_num%" - 1)
      READ_SHORT ("%fx_off%" + ("%fx_num%" * 0x30)) "type"
      PATCH_IF( "%type%" = 16 ) BEGIN  // if haste effect
        WRITE_SHORT ("%fx_off%" +        ("%fx_num%" * 0x30)) 126 // change to movementrate bonus
        WRITE_LONG  ("%fx_off%" + 0x04 + ("%fx_num%" * 0x30)) 200 // of 200%
        WRITE_LONG  ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) 2   // via set%
        WRITE_BYTE  ("%fx_off%" + 0x0d + ("%fx_num%" * 0x30)) 0
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// amulet of shield not protecting against MM
COPY_EXISTING ~amul15.itm~   ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "icon"
      PATCH_IF (("%opcode%" = 142) OR ("%opcode%" = 15)) BEGIN // display shield icon
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // clone fx
        // insert protection from mage version of MM
        INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30         // insert new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%"    // clones portrait icon
          WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 206          // protection from spell
          WRITE_LONG            ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 0xffffffff   // strref
          WRITE_ASCII           ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spwi112~ #8 // mage spell
        // insert display string
        INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30      // insert new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%" // clones portrait icon
          WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 139       // display string
          WRITE_LONG            ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 14771     // 'shielded'
          WRITE_BYTE            ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1         // instant/perm
          WRITE_LONG            ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%")) 0         // duration
        SET "fx_delta" = "%fx_delta%" + 2
        SET "abil_fx_num" = "%abil_fx_num%" + 2
        WRITE_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
        SET "index2" = "%abil_fx_num%" // kills loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// amul23 and amul24 have different BAMs than amul22
COPY_EXISTING ~amul23.itm~ ~override~
              ~amul24.itm~ ~override~
  WRITE_EVALUATED_ASCII 0x3a ~i%SOURCE_RES%~ #8
  WRITE_EVALUATED_ASCII 0x58 ~c%SOURCE_RES%~ #8
  BUT_ONLY_IF_IT_CHANGES

// aegis fang shouldn't display name while unidentified, wrong prof
COPY_EXISTING ~aegis.itm~  ~override~
              ~aegis2.itm~ ~override~
  WRITE_BYTE 0x31 97 // warhammer
  SAY 0x08 #6345
  BUT_ONLY_IF_IT_CHANGES

// adds +1 enchantment to acid arrows and Flasher Master Bruiser Mates (BD)
COPY_EXISTING ~arow04.itm~ ~override~
              ~bolt07.itm~ ~override~
              ~dart05.itm~ ~override~
  WRITE_LONG 0x60 1
  BUT_ONLY_IF_IT_CHANGES

// fix power levels
COPY_EXISTING ~arow06.itm~   ~override~ // arrows of detonation - explosion has power 3
              ~arow08.itm~   ~override~ // arrows of fire - fire damage has power 6
              ~arow09.itm~   ~override~ // arrows of ice - cold damage has power 6
              ~aurstaf.itm~  ~override~ // aurumach rilmani's undroppable staff - slow effects have power 6
              ~ax1h07.itm~   ~override~ // bala's axe - miscast magic effects have power 3
              ~blun20.itm~   ~override~ // ardulia's flail - slow effects have power 3
              ~bolt03.itm~   ~override~ // bolt of lightning - electrical damage has power 6
              ~bolt05.itm~   ~override~ // bolt of polymorphing - polymorph effects are power 6
              ~bonedag.itm~  ~override~ // bone dagger attack item - slow effects have power 2, all other effects 0
              ~chalcy2.itm~  ~override~ // undroppable weapon of cyric's chosen - blindness effect has power 1
              ~dart03.itm~   ~override~ // dart of stunning - stun effects have power 8
              ~dart04.itm~   ~override~ // dart of wounding - poison damage has power 0, poison portrait icon has power 8
              ~dart05.itm~   ~override~ // asp's nest - poison damage has power 0, poison portrait icon has power 8
              ~dartmel.itm~  ~override~ // melissan's bone daggers - slow and disease effects have power 8
              ~globblu1.itm~ ~override~ // blue globe - cold damage at power 5
              ~globred1.itm~ ~override~ // red globe - fire damage at power 4
              ~gorcamb.itm~  ~override~ // aesgearth's undroppable weapon - stun at power 6, str/con drain at power 8
              ~hamm03.itm~   ~override~ // ashideena - electrical damage has power 8
              ~hamm05.itm~   ~override~ // borok's fist - electrical damage has power 8
              ~hgber01.itm~  ~override~ // berren's undroppable weapon - slow and dex penalties at power 4
              ~hgnya01.itm~  ~override~ // nyalee's undroppable weapon - slow, entangle effects at power 4
              ~icetrl.itm~   ~override~ // blizzard trolls' undroppable weapon - stun, dex penalty at power 6
              ~killsw01.itm~ ~override~ // arkanis gath's insta-kill sword for crossing shadow thieves - all elemental damages at power 8
              ~kuobolt3.itm~ ~override~ // high level kuo-toa bolts - web/entangle effects at power 2
              ~misc5c.itm~   ~override~ // rift device - fire damage has power 100, all other effects are at 0
              ~mistcd.itm~   ~override~ // attack of crimson deaths - visual effect has power 1
              ~mistho.itm~   ~override~ // attack of mist horrors, swamp horrors - horror effects are at power 4
              ~mistice.itm~  ~override~ // attack of ice mists - horror effects are at power 4
              ~mistva.itm~   ~override~ // attack of vampiric mists - level drain at power 1
              ~mistva2.itm~  ~override~ // attack of vampiric wraiths - level drain at power 1
              ~mistwa.itm~   ~override~ // attack of wandering horrors - stun at power 4
              ~mound.itm~    ~override~ // attack of shambling mounds - slow, ac penalty, extra damage, entangle at power 1, play sound at power 2
              ~nebdag.itm~   ~override~ // neb's dagger - slow effect at power 2, poison at 0
              ~potn26.itm~   ~override~ // potion of explosions
              ~potn27.itm~   ~override~ // potion of firebreath
              ~quasclaw.itm~ ~override~ // attack of quasit familiars - dex drain has power 4
              ~ravag01.itm~  ~override~ // attack of ravager - one effect (visual) has power 3, all others 0
              ~ravag02.itm~  ~override~ // attack of ravager - stun has power 6, all others 0
              ~revent1.itm~  ~override~ // attack of revenants - paralyzation effects at power 1
              ~ring20.itm~   ~override~ // ring of energy
              ~rods03.itm~   ~override~ // rod of resurrection
              ~scrl03.itm~   ~override~ // protection from acid
              ~scrl04.itm~   ~override~ // protection from cold
              ~scrl05.itm~   ~override~ // protection from electricity
              ~scrl06.itm~   ~override~ // protection from fire
              ~scrl08.itm~   ~override~ // protection from poison
              ~scrl09.itm~   ~override~ // protection from undead
              ~scrl15.itm~   ~override~ // protection from petrification
              ~secret02.itm~ ~override~ // pulse ammo - magical damage for easter egg item at power 8
              ~sendai.itm~   ~override~ // sendai's flail - slow has power 6, other effects such as str drain and poison use 0
              ~shille.itm~   ~override~ // shillelagh - visual effect has power 1
              ~spermel.itm~  ~override~ // mellisan's spear.itm~   ~override~ // slow and stun at power 8, save penalties at power 6
              ~staf14.itm~   ~override~ // staff of the woodlands
              ~sw1h06.itm~   ~override~ // varscona - cold damage at power 8
              ~sw1h58.itm~   ~override~ // short sword of mask - some entangle effects at power 1, 2
              ~sw1h59.itm~   ~override~ // short sword of mask - some entangle effects at power 1, 2
              ~telslav.itm~  ~override~ // attack of slave wraiths - slay and finger of death animation at power 7
              ~trolltor.itm~ ~override~ // attack of tor'gal - slow and str drain at power 3
              ~wand12.itm~   ~override~ // wand of wonder - all effects at power 0 except visuals at 8
              ~wolfwi1.itm~  ~override~ // attack of winter wolves - cold damage at power 1
              ~wolfwi2.itm~  ~override~ // attack of winter wolves - cold damage at power 1
              ~xbow15.itm~   ~override~ // firetooth - fire damage at power 6
              ~xbow16.itm~   ~override~ // firetooth - fire damage at power 6
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // cycle thru abilities
    READ_SHORT  (0x1e + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  (0x20 + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // should bypass spell protections
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fire arrows have a spurious +2 thac0 bonus
COPY_EXISTING ~arow08.itm~   ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_BYTE ("%abil_off%" + (0x38 * "%index%")) "type"
    PATCH_IF ("%type%" = 2) BEGIN // ranged
      WRITE_SHORT ("%abil_off%" + 0x14 + (0x38 * "%index%")) 0 // thac0 bonus
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// miscast effects not accompanied by miscast icon
COPY_EXISTING ~ax1h07.itm~   ~override~ // 80% on hit, no icon
  SET "abil_length" = 0x38
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  READ_SHORT 0x70 "fx_num"   ELSE 0
  SET "fx_type" = 0
  SET "new_fx_1" = 0
  SET "new_fx_2" = 0
  SET "delta" = 0
  FOR (index3 = 0 ; index3 < fx_num ; index3 = index3 + 1) BEGIN
    READ_SHORT ("%fx_off%" + ("%fx_type%" * 0x08) +        (0x30 * "%index3%")) "opcode"
    READ_LONG  ("%fx_off%" + ("%fx_type%" * 0x10) + 0x08 + (0x30 * "%index3%")) "icon"
    PATCH_IF ("%opcode%" = 60) BEGIN // miscast effect
      READ_ASCII ("%fx_off%" + ("%fx_type%" * 0x08) +        (0x30 * "%index3%")) "clone" (48 + (216 * "%fx_type%"))
      SET "new_fx_1" = 1
    END ELSE
    PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 105)) BEGIN // display miscast icon
      SET "new_fx_2" = 1
    END ELSE
    PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 83)) BEGIN // display spell failure icon
      WRITE_BYTE ("%fx_off%" + ("%fx_type%" * 0x08) + 0x12 + (0x30 * "%index3%")) 0 // 0% probability
    END
  END
  PATCH_IF (("%new_fx_1%" = 1) AND ("%new_fx_2%" = 0)) BEGIN // if miscast effect but no icon
    INSERT_BYTES            ("%fx_off%") (0x30 + ("%fx_type%" * 0xa8))         // new effect
      WRITE_EVALUATED_ASCII ("%fx_off%") "%clone%" // clones miscast effect
      WRITE_SHORT           ("%fx_off%" + ("%fx_type%" * 0x08)       ) 142       // display portrait icon:
      WRITE_LONG            ("%fx_off%" + ("%fx_type%" * 0x10) + 0x08) 105       // miscast magic
    SET "delta" = "%delta%" + 1
    SET "fx_num" = "%fx_num%" + 1
  END
  WRITE_SHORT 0x70 "%fx_num%"
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN
    SET "new_fx_1" = 0 // reset for each loop through abilities
    SET "new_fx_2" = 0 // reset for each loop through abilities
    READ_SHORT ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%delta%" + "%abil_fx_idx%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "icon"
      PATCH_IF ("%opcode%" = 60) BEGIN // miscast magic
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48)
        SET "new_fx_1" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 105)) BEGIN // display miscast icon
        SET "new_fx_2" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 83)) BEGIN // display spell failure icon
        WRITE_BYTE ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // 0% probability
      END
    END
    PATCH_IF (("%new_fx_1%" = 1) AND ("%new_fx_2%" = 0)) BEGIN // if miscast effect but no icon
      INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30          // new effect
        WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%" #48 // clones miscast effect
        WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 142           // display portrait icon:
        WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 105           // miscast magic
      SET "delta" = "%delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    WRITE_SHORT ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES
  
// Amkethran duplicate gem bag fix, part one of four (see amsmug01.sto amsmug02.sto, cdbag02i.sto, cdbag02j.sto)
ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB-only stuff check
  COPY_EXISTING ~bag02i.itm~ ~override/cdbag02i.itm~
  COPY_EXISTING ~bag02i.itm~ ~override/cdbag02j.itm~
END

// black blade o' disaster using wrong power level for level drain
// black blade o' disaster is supposed to disintegrate, not slay
COPY_EXISTING ~blakblad.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks for magical ability header
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_BYTE ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 216) BEGIN  // level drain
        WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 9 // power 9
      END
      PATCH_IF ("%opcode%" = 55) BEGIN // slay
        WRITE_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) 238 // disintegrate
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// %$#*$&^ damage vs type opcode. remove global 'use eff' opcode; move to melee header (revised by Wisp)
// see macedisr.eff for second half of this fix
COPY_EXISTING ~blun12.itm~ ~override~
              deva.itm     override
              hamm10.itm   override
              hamm11.itm   override
  PATCH_IF SOURCE_SIZE > 0x71 BEGIN
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    READ_LONG   0x6a "fx_off"
    READ_SHORT  0x70 "fx_num"
    SET "fx_delta" = 0
    FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
      READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "type"
      READ_ASCII ("%fx_off%" + 0x14 + ("%index%" * 0x30)) "eff_file"
      PATCH_IF (("%type%" = 177) AND ("macedisr" STRING_COMPARE_CASE "%eff_file%" = 0)) BEGIN
        DELETE_BYTES ("%fx_off%" +        ("%index%" * 0x30)) 0x30 // delete effect
        SET "fx_num" = ("%fx_num%" - 1)
        SET "fx_delta" = ("%fx_delta%" - 1)
        SET "index" = ("%index%" - 1)
      END
    END
    WRITE_SHORT 0x70 "%fx_num%"
    FOR (index2 = 0 ; index2 < abil_num ; index2 = index2 + 1) BEGIN
      READ_BYTE   ("%abil_off%" +        ("%index2%" * 0x38)) "type"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index2%" * 0x38)) "abil_fx_idx"
      SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
      WRITE_SHORT ("%abil_off%" + 0x20 + ("%index2%" * 0x38)) "%abil_fx_idx%"
      PATCH_IF ("%type%" = 1) BEGIN // melee ability check
        READ_SHORT  ("%abil_off%" + 0x1e + ("%index2%" * 0x38)) "abil_fx_num"
        WRITE_SHORT ("%abil_off%" + 0x1e + ("%index2%" * 0x38)) ("%abil_fx_num%" + 1)
        INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30))       0x30 // new effect
          WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30))        177 // use eff
          WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30))          2 // target: preset target
          WRITE_LONG  ("%fx_off%" + 0x04 + ("%abil_fx_idx%" * 0x30))          4 // UNDEAD from...
          WRITE_LONG  ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30))          3 // general.ids
          WRITE_BYTE  ("%fx_off%" + 0x0c + ("%abil_fx_idx%" * 0x30))          1 // instant/permanent
          WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30))        100 // probability
          WRITE_ASCII ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~cddisr~   // resref
        SET "fx_delta" = ("%fx_delta%" + 1)
      END
    END
  END
BUT_ONLY

COPY_EXISTING ~ax1h10.itm~ ~override~
// first uncorrupt the item by fixing the misplaced indexes
  READ_LONG  0x64 abil_off
  READ_SHORT 0x68 abil_num
  READ_LONG  0x6a fx_off
  READ_SHORT 0x70 fx_num
  t_fx_num = fx_num
  CLEAR_ARRAY ab_array
  GET_OFFSET_ARRAY ab_array 0x64 4 0x68 2 0 0 0x38
  PHP_EACH ab_array AS int => goa_abil_off BEGIN
    CLEAR_ARRAY fx_array
    GET_OFFSET_ARRAY2 fx_array goa_abil_off 0x6a 4 0x1e 2 0x20 2 0x30
    PHP_EACH fx_array AS int => goa_fx_off BEGIN
      t_fx_num += 1
    END
  END
  PATCH_IF 0x72 + abil_num*0x38 + 0x30*t_fx_num < BUFFER_LENGTH BEGIN
    DELETE_BYTES 0x72 + abil_num*0x38 + 0x30*t_fx_num BUFFER_LENGTH - (0x72 + abil_num*0x38 + 0x30*t_fx_num)
  END
  LAUNCH_PATCH_FUNCTION ~DELETE_ITEM_EQEFFECT~ INT_VAR "opcode_to_delete" = "177" END              // delete the old, incorrect bonus damage effect
  LAUNCH_PATCH_FUNCTION ~DELETE_ITEM_EFFECT~ INT_VAR "opcode_to_delete" = "177" header = "-1" END  // delete the Baldurdash undead slaying effect
  LAUNCH_PATCH_FUNCTION ~DELETE_ITEM_EFFECT~ INT_VAR opcode_to_delete = "55" header = "-1" END     // delete the old, incorrect undead slaying effect
  // note: the extra damage and the "Undead Destroyed" string need to go before the death effect, otherwise they won't display in the combat log
  PATCH_FOR_EACH resref IN mesdie ax1h10a die BEGIN
    LPF ADD_ITEM_EFFECT
      INT_VAR
        type = 99      //all types
        opcode = 177   //use eff  
        target = 2
        parameter1 = 4 //undead
        parameter2 = 3 //general.ids
        timing = 1
      STR_VAR
        resource = EVAL "%resref%"
    END
  END
  FOR (i =  0; i < abil_num; ++i) BEGIN
    READ_BYTE abil_off + i * 0x38 abil_type
    PATCH_IF abil_type = 2 BEGIN                //ranged
      WRITE_SHORT abil_off + (i * 0x38) + 0x18 1             //number of dice of damage (1d6)
      WRITE_BYTE  abil_off + (i * 0x38) + 0x26 THIS BOR BIT0 //allow strength bonus
      READ_SHORT  abil_off + (i * 0x38) + 0x1e "abil_fx_num"
      READ_SHORT  abil_off + (i * 0x38) + 0x20 "abil_fx_idx"
      WRITE_ASCII (((0x30 * (abil_fx_num + abil_fx_idx)) + fx_off) - 0x4c) ax1h10b
    END
  END
BUT_ONLY

// name fix for FoA +2
COPY_EXISTING ~blun14d.itm~ ~override~
              ~blun14e.itm~ ~override~
              ~blun14f.itm~ ~override~
  SAY NAME2 @125
  BUT_ONLY_IF_IT_CHANGES

// fixes wrong BAMs for cold-acid flail of ages
COPY_EXISTING ~blun14e.itm~ ~override~
  WRITE_ASCII 0x3a ~IBLUN14E~
  WRITE_ASCII 0x58 ~CBLUN14E~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE ("%abil_off%" + (0x38 * "%abil_num%")) "melee"
    PATCH_IF ("%melee%" = 1) BEGIN
      WRITE_ASCII ("%abil_off%" + 0x04 + (0x38 * "%abil_num%")) ~IBLUN14E~
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// damage/thac0 bonuses mistargeted, may not be applying
COPY_EXISTING ~blun18.itm~ ~override~ // skullcrusher
              ~hamm04.itm~ ~override~ // hammer +1/+4 v giantkin
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  FOR (index2 = 0 ; index2 < fx_num ; index2 = index2 + 1) BEGIN
    READ_SHORT ("%fx_off%" +        (0x30 * "%index2%")) "opcode"
    PATCH_IF ("%opcode%" = 177) BEGIN
      WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * "%index2%")) 0 // any
      WRITE_LONG ("%fx_off%" + 0x08 + (0x30 * "%index2%")) 2 // ea.ids
    END
  END
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    FOR (index3 = 0 ; index3 < abil_fx_num ; index3 = index3 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index3%" + "%abil_fx_idx%"))) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN
        WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%index3%" + "%abil_fx_idx%"))) 0 // any
        WRITE_LONG ("%fx_off%" + 0x08 + (0x30 * ("%index3%" + "%abil_fx_idx%"))) 2 // ea.ids
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Club +3, Blackblood had Mace Animation. change it to club
COPY_EXISTING ~blun22.itm~ ~override~
  WRITE_ASCII 0x22 ~CL~
  BUT_ONLY_IF_IT_CHANGES

// level drain now handled by batch fixes
// changes the icon from generic mace to MoD's one. Also see macedisu.eff.
// new for v4; fix ^&%&# damage v opcode no-die bug
COPY_EXISTING ~blun25.itm~ ~override~
  WRITE_ASCII 0x3a ~iblun12~ #8 // use MoD BAM
  WRITE_ASCII 0x44 ~gblun06~ #8 // use MoD BAM
  WRITE_ASCII 0x58 ~cblun12~ #8 // use MoD BAM
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "type"
    READ_ASCII ("%fx_off%" + 0x14 + ("%index%" * 0x30)) "eff_file"
    PATCH_IF (("%type%" = 177) AND ("macedisr" STRING_COMPARE_CASE "%eff_file%" = 0)) BEGIN // change use macedisr eff to colorglow pulse
      WRITE_SHORT ("%fx_off%"        + ("%index%" * 0x30)) 9    // colorglow pulse
      WRITE_BYTE  ("%fx_off%" + 0x02 + ("%index%" * 0x30)) 1    // target self
      WRITE_BYTE  ("%fx_off%" + 0x06 + ("%index%" * 0x30)) 202  // green
      WRITE_BYTE  ("%fx_off%" + 0x07 + ("%index%" * 0x30)) 255  // blue
      WRITE_SHORT ("%fx_off%" + 0x08 + ("%index%" * 0x30)) 21   // weapon head/blade minor
      WRITE_SHORT ("%fx_off%" + 0x0a + ("%index%" * 0x30)) 0x6e // cycle speed
      WRITE_BYTE  ("%fx_off%" + 0x0c + ("%index%" * 0x30)) 2    // instant/while equipped
      WRITE_LONG  ("%fx_off%" + 0x0e + ("%index%" * 0x30)) 0    // duration
      WRITE_BYTE  ("%fx_off%" + 0x12 + ("%index%" * 0x30)) 100  // probability 1
      WRITE_LONG  ("%fx_off%" + 0x24 + ("%index%" * 0x30)) 0    // blank save, just in case
    END
  END
  FOR (index2 = 0 ; index2 < abil_num ; index2 = index2 + 1) BEGIN
    READ_BYTE   ("%abil_off%" +        ("%index2%" * 0x38)) "type"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index2%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index2%" * 0x38)) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%index2%" * 0x38)) ("%abil_fx_idx%")
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      SET "eff_count" = 0
      WRITE_ASCII (0x04 + "%abil_off%" + ("%index2%" * 0x38)) ~iblun12~ #8 // use MoD BAM
      FOR (index3 = 0 ; index3 < abil_fx_num ; index3 = index3 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index3%") * 0x30)) "opcode"
        READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index3%") * 0x30)) "resref"
        // first fix misordered effects bug
        PATCH_IF (("%opcode%" = 177) AND (("mesdie" STRING_COMPARE_CASE "%resref%" = 0) OR ("die" STRING_COMPARE_CASE "%resref%" = 0))) BEGIN
          PATCH_IF ("%eff_count%" = 0) BEGIN
            WRITE_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index3%") * 0x30)) "mesdie" #8
            SET "eff_count" = 1
          END ELSE BEGIN
            WRITE_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index3%") * 0x30)) "die" #8
          END
          WRITE_LONG    ("%fx_off%" + 0x24 + (("%abil_fx_idx%" + "%index3%") * 0x30)) 0 // save handled by EFF
          WRITE_LONG    ("%fx_off%" + 0x28 + (("%abil_fx_idx%" + "%index3%") * 0x30)) 0 // save handled by EFF
        END
      END
      // then add new effect for undead damage
      WRITE_SHORT ("%abil_off%" + 0x1e + ("%index2%" * 0x38)) ("%abil_fx_num%" + 1)
      INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30))       0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30))        177 // use eff
        WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30))          2 // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x04 + ("%abil_fx_idx%" * 0x30))          4 // UNDEAD from...
        WRITE_LONG  ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30))          3 // general.ids
        WRITE_BYTE  ("%fx_off%" + 0x0c + ("%abil_fx_idx%" * 0x30))          1 // instant/permanent
        WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30))        100 // probability
        WRITE_ASCII ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~macedisu~ // resref
      SET "fx_delta" = ("%fx_delta%" + 1)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// club of detonation's 3 fire damage only occurring 20% of the time, instead of always
COPY_EXISTING ~blun26.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    READ_LONG   0x6a "fx_off"
    WHILE ("%abil_num%" > 0) BEGIN // looks for magical ability header
      SET "abil_num" = ("%abil_num%" - 1)
      READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
      PATCH_IF ("%type%" = 1) BEGIN // melee ability check
        READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
        WHILE ("%abil_fx_num%" > 0) BEGIN // searches through fx for THAC0 bonus
          SET "abil_fx_num" = ("%abil_fx_num%" - 1)
          READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "opcode"
          READ_LONG  ("%fx_off%" + 0x04 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "damage"
          PATCH_IF (("%opcode%" = 12) AND ("%damage%" = 3)) BEGIN // changes it from regular to missile THAC0 bonus
            WRITE_BYTE ("%fx_off%" + 0x12 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 100 // probability
          END
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// changes upgraded club o detonation to use club paperdoll and not be a flail
COPY_EXISTING ~blun27.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_SHORT 0x1c 17  // mace
    WRITE_ASCII 0x22 ~CL~  // club
  END
  BUT_ONLY_IF_IT_CHANGES

// some books were quick-slottable
COPY_EXISTING ~book05.itm~ ~override~
              ~book07.itm~ ~override~
              ~book08.itm~ ~override~
  WRITE_SHORT 0x1c 0
  BUT_ONLY_IF_IT_CHANGES
  
// fixes price for 2 books to make them sellable
COPY_EXISTING ~book27.itm~ ~override~
              ~book39.itm~ ~override~
  WRITE_LONG 0x34 2
  BUT_ONLY_IF_IT_CHANGES

// some books were not quick-slottable
COPY_EXISTING ~book32.itm~ ~override~
              ~book94.itm~ ~override~
              ~book95.itm~ ~override~
              ~book96.itm~ ~override~
  WRITE_SHORT 0x1c 37
  BUT_ONLY_IF_IT_CHANGES

// fixes enchantment, weight, icons, and prof of short bow +1
COPY_EXISTING ~bow06.itm~ ~override~
  WRITE_BYTE  0x31 105
  WRITE_ASCII 0x3a ~ibow06~ #8
  WRITE_LONG  0x4c 2
  WRITE_ASCII 0x58 ~cbow06~ #8
  WRITE_LONG  0x60 1
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  WHILE ("%abil_num%" > 0) BEGIN // if abilities are present, need to adjust their effects index
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT  ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 4) BEGIN // launcher
      WRITE_ASCII (0x04 + "%abil_off%" + ("%abil_num%" * 0x38)) ~ibow06~ #8 // use shortbow BAM
      WRITE_SHORT (0x0e + "%abil_off%" + ("%abil_num%" * 0x38)) 75          // fixes range
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes swapped icons
COPY_EXISTING ~bow01.itm~ ~override~
              ~bow03.itm~ ~override~
  WRITE_EVALUATED_ASCII 0x3a ~i%SOURCE_RES%~ #8
  BUT_ONLY_IF_IT_CHANGES

// fixes incorrect BAMs for several bows
COPY_EXISTING ~bow01.itm~    ~override~
              ~bow03.itm~    ~override~
              ~bow06.itm~    ~override~
              ~bow09.itm~    ~override~
              ~bow11.itm~    ~override~
              ~bow12.itm~    ~override~
              ~bow14.itm~    ~override~
              ~bow15.itm~    ~override~
              ~bow16.itm~    ~override~
              ~bow17.itm~    ~override~
              ~bow18.itm~    ~override~
              ~bow22.itm~    ~override~
              ~bow23.itm~    ~override~
              ~gorwom2.itm~  ~override~
              ~npbow.itm~    ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_ASCII 0x3a "bam"
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    WHILE ("%abil_num%" > 0) BEGIN
      SET "abil_num" = ("%abil_num%" - 1)
      READ_BYTE ("%abil_off%" + (0x38 * "%abil_num%")) "abil_type"
      PATCH_IF (("%abil_type%" = 2) OR ("%abil_type%" = 4)) BEGIN
        WRITE_EVALUATED_ASCII ("%abil_off%" + 0x04 + (0x38 * "%abil_num%")) ~%bam%~ #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// changes to long bow prof
COPY_EXISTING ~bow07.itm~ ~override~
  WRITE_BYTE 0x31 104
  BUT_ONLY_IF_IT_CHANGES

// Heartseeker gives regular THAC0 instead of missile THAC0
COPY_EXISTING ~bow10.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN // looks for magical ability header
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // magical ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN // searches through fx for THAC0 bonus
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "type1"
        PATCH_IF ("%type1%" = 54) BEGIN // changes it from regular to missile THAC0 bonus
          WRITE_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 167
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fix power levels
COPY_EXISTING ~brac20.itm~ ~override~ // gloves of curing
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // cycle thru abilities
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // if magical
      READ_SHORT  (0x1e + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  (0x20 + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 1 // power level
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// changes to axe proficiency; enchantment level incorrect
COPY_EXISTING ~bruenaxe.itm~ ~override~
  WRITE_BYTE 0x31 92
  WRITE_LONG 0x60 3
  BUT_ONLY_IF_IT_CHANGES
  
// totemic druid summons weapons; enchantment level incorrect
COPY_EXISTING ~bearspir.itm~ ~override~
              ~lionspir.itm~ ~override~
              ~snakspir.itm~ ~override~
              ~wolfspir.itm~ ~override~
  WRITE_LONG 0x60 3
  BUT_ONLY_IF_IT_CHANGES

// disallows str bonus for magic bullets
COPY_EXISTING ~bull02.itm~   ~override~
              ~bull03.itm~   ~override~
              ~bull04.itm~   ~override~
              ~bull05.itm~   ~override~
              ~bull06.itm~   ~override~
              ~quiver05.itm~ ~override~
              ~quiver06.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    WHILE ("%abil_num%" > 0) BEGIN // looks for ranged ability header
      SET "abil_num" = ("%abil_num%" - 1)
      READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
      PATCH_IF ("%type%" = 2) BEGIN // ranged ability check
        WRITE_BYTE  ("%abil_off%" + 0x26 + ("%abil_num%" * 0x38)) 0 // disallow strength bonus
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~bull06.itm~ ~override~ // bullet +4
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_SHORT 0x42 35
  END
  BUT_ONLY_IF_IT_CHANGES

// blindness not adding portait icon or message
COPY_EXISTING ~chalcy2.itm~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 74) BEGIN // display shield icon
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // clone blindness fx
        INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30      // insert new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%" // blindness icon fx
          WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 139       // display string
          WRITE_LONG            ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 14674     // 'blinded'
          WRITE_BYTE            ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1         // instant/perm
          WRITE_LONG            ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%")) 0         // duration
        INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30      // insert new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%" // blindness icon fx
          WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 142       // display portrait icon
          WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 8         // blindness icon
        SET "fx_delta" = "%fx_delta%" + 2
        SET "abil_fx_num" = "%abil_fx_num%" + 2
        WRITE_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
        SET "index2" = "%abil_fx_num%" // kills loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fixes chan02 description
COPY_EXISTING ~chan02.itm~ ~override~
  SAY IDENTIFIED_DESC #16272
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~chan03.itm~ ~override~ // mail of the dead
  WRITE_SHORT 0x42 65
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~chan21.itm~ ~override~ // chain mail +3
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_SHORT 0x42 75
  END  
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~clck08.itm~ ~override~
  WRITE_ASCII 0x3a ~iclck08~ #8 // inventory icon
  BUT_ONLY_IF_IT_CHANGES

// mage robe of fire resistance uses a resist fire/cold icon insead of protection from fire
COPY_EXISTING ~clck10.itm~  ~override~ // mage robe of fire resistance
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  FOR (index = 0; index < fx_num; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "opcode"
    READ_SHORT ("%fx_off%" + 0x08 + ("%index%" * 0x30)) "icon"
    PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 26)) BEGIN
      WRITE_SHORT ("%fx_off%" + 0x08 + ("%index%" * 0x30)) 16
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// add protection to all lightning projectiles for cloak of reflection
COPY_EXISTING ~clck24.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "new_fx" = 0
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" + ("%index%" * 0x30)) "type"
    PATCH_IF ("%type%" = 197) BEGIN // looks for physical mirror
      READ_ASCII ("%fx_off%" + ("%index%" * 0x30)) "clone" (0x30) // clones effect
      SET "index" = "%fx_num%" // kills loop
      SET "new_fx" = 11 // enables next loop
    END
  END
  PATCH_IF ("%new_fx%" > 0) BEGIN
    WRITE_SHORT  0x70 ("%fx_num%" + "%new_fx%")
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN // adding new effects
      INSERT_BYTES            ("%fx_off%") 0x30
        WRITE_EVALUATED_ASCII ("%fx_off%") "%clone%" #48
    END
    // first new effect is transformed into protection from electricity icon
    WRITE_SHORT ("%fx_off%"       ) 142 // opcode: display portrait icon
    WRITE_SHORT ("%fx_off%" + 0x08) 27  // icon: protection from electricity
    // all other effects remain phsical mirror; adding projectile references below
    WRITE_LONG ("%fx_off%" + 0x08 + ( 1 * 0x30))  80
    WRITE_LONG ("%fx_off%" + 0x08 + ( 2 * 0x30))  81
    WRITE_LONG ("%fx_off%" + 0x08 + ( 3 * 0x30))  82
    WRITE_LONG ("%fx_off%" + 0x08 + ( 4 * 0x30))  83
    WRITE_LONG ("%fx_off%" + 0x08 + ( 5 * 0x30))  84
    WRITE_LONG ("%fx_off%" + 0x08 + ( 6 * 0x30)) 205
    WRITE_LONG ("%fx_off%" + 0x08 + ( 7 * 0x30)) 206
    WRITE_LONG ("%fx_off%" + 0x08 + ( 8 * 0x30)) 212
    WRITE_LONG ("%fx_off%" + 0x08 + ( 9 * 0x30)) 219
    WRITE_LONG ("%fx_off%" + 0x08 + (10 * 0x30)) ("%cdbehbla%" - 1)
    FOR (index3 = 0 ; index3 < abil_num ; index3 = index3 + 1) BEGIN
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index3%" * 0x28)) "abil_fx_idx"
      WRITE_SHORT ("%abil_off%" + 0x20 + ("%index3%" * 0x28)) ("%abil_fx_idx%" + "%new_fx%")
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Cloak of Mirroring also missing many spell immunity effects
COPY_EXISTING ~clck26.itm~   ~override~
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    READ_LONG  0x64 "ho" ELSE 0x72
    READ_SHORT 0x68 "hc" ELSE 0x00
    READ_LONG  0x6a "eo" ELSE 0x72
    READ_SHORT 0x6e "gi" ELSE 0x00
    READ_SHORT 0x70 "gc" ELSE 0x00
    SET "no" = ("eo" + (0x30 * ("gi" + "gc")))
    SET "ad" = 0x10
    INSERT_BYTES    "no"   (0x30 * "ad")
      WRITE_ASCIIT ("no" + (0x30 * 0x00) + 0x14) ~sppr302~  // Call Lightning
      WRITE_ASCIIT ("no" + (0x30 * 0x01) + 0x14) ~sppr304~  // Glyph of Warding
      WRITE_ASCIIT ("no" + (0x30 * 0x02) + 0x14) ~sppr313~  // Holy Smite
      WRITE_ASCIIT ("no" + (0x30 * 0x03) + 0x14) ~sppr314~  // Unholy Blight
      WRITE_ASCIIT ("no" + (0x30 * 0x04) + 0x14) ~spwi313~  // Skull Trap
      WRITE_ASCIIT ("no" + (0x30 * 0x05) + 0x14) ~spwi502~  // Cloud Kill
      WRITE_ASCII  ("no" + (0x30 * 0x06) + 0x14) ~sppr603d~ // Blade Barrier
      WRITE_ASCIIT ("no" + (0x30 * 0x07) + 0x14) ~spwi614~  // Death Fog
      WRITE_ASCIIT ("no" + (0x30 * 0x08) + 0x14) ~sppr705~  // Fire Storm
      WRITE_ASCII  ("no" + (0x30 * 0x09) + 0x14) ~sppr725d~ // Globe of Blades
      WRITE_ASCIIT ("no" + (0x30 * 0x0a) + 0x14) ~spwi712~  // Delayed Blast Fireball
      WRITE_ASCIIT ("no" + (0x30 * 0x0b) + 0x14) ~spwi810~  // Incendiary Cloud
      WRITE_ASCIIT ("no" + (0x30 * 0x0c) + 0x14) ~spwi911~  // Meteor Swarm
      WRITE_ASCII  ("no" + (0x30 * 0x0d) + 0x14) ~spwish25~ // Wish Meteor Swarm
      WRITE_ASCII  ("no" + (0x30 * 0x0e) + 0x14) ~spwish32~ // Wish Horrid Wilting
    FOR ("i" = 0; "i" < "ad"; "i" += 1) BEGIN
      WRITE_SHORT  ("no" + (0x30 * "i") + 0x00) 0xce       // immunity to spell
      WRITE_SHORT  ("no" + (0x30 * "i") + 0x02) 0x01       // target: self
      WRITE_LONG   ("no" + (0x30 * "i") + 0x04) ` 0x00     // strref displayed
      WRITE_LONG   ("no" + (0x30 * "i") + 0x08) 0x00       // useless
      WRITE_BYTE   ("no" + (0x30 * "i") + 0x0c) 0x02       // mode: while equipped
      WRITE_BYTE   ("no" + (0x30 * "i") + 0x12) 0x64       // minimum prob 100%
    END
    WRITE_SHORT  ("no" + (0x30 * 0x0f)       ) 142 // display portrait icon
    WRITE_LONG   ("no" + (0x30 * 0x0f) + 0x04)   0 // unused
    WRITE_LONG   ("no" + (0x30 * 0x0f) + 0x08)  28 // protection from magic
    WRITE_SHORT 0x70 ("gc" + "ad")
    PATCH_IF ("hc" > 0) THEN BEGIN
      FOR ("j" = 0; "j" < "hc"; "j" += 1) BEGIN
        READ_SHORT  ("ho" + (0x38 * "j") + 0x20) "ei"
        WRITE_SHORT ("ho" + (0x38 * "j") + 0x20) (("ei" = 0) ? 0x00 : ("ei" + "ad"))
      END
    END
  END
BUT_ONLY_IF_IT_CHANGES

// changes soultaker dagger to a dagger type
COPY_EXISTING ~dagg10.itm~ ~override~
  WRITE_SHORT 0x1c 16
  BUT_ONLY_IF_IT_CHANGES

// shadow thief dagger has ranged APR effect though a melee weapon
COPY_EXISTING ~dagg18.itm~ ~override~
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +        (0x30 * "%index%")) "opcode"
    PATCH_IF ("%opcode%" = 1) BEGIN // set attacks per round
      WRITE_BYTE ("%fx_off%" + 0x12 + (0x30 * "%index%")) 0 // probability = 0
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// marks dagger of <CHARNAME> as magical
COPY_EXISTING ~dagg19.itm~ ~override~
  READ_BYTE  0x18 "flags"
  WRITE_BYTE 0x18 ("%flags%" BOR 0b01000000) // add magical flag
  WRITE_LONG 0x60 1 // enchantment
  BUT_ONLY_IF_IT_CHANGES

// adds proper number of attacks for dart01, disallows str bonus
COPY_EXISTING ~dart01.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "new_fx" = 1
  WHILE ("%fx_num%" > 0) BEGIN // searches through global effects
    SET "fx_num" = ("%fx_num%" - 1)
    READ_SHORT ("%fx_off%" + ("%fx_num%" * 0x30)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // looks for modify attacks per round
      SET "new_fx" = 0
    END
  END
  WHILE ("%abil_num%" > 0) BEGIN // looks for ranged ability header
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT  (0x20 + "%abil_off%" + ("%abil_num%" * 0x38)) "abil_fx_idx"
    WRITE_SHORT (0x20 + "%abil_off%" + ("%abil_num%" * 0x38)) ("%abil_fx_idx%" + "%new_fx%")
    READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 2) BEGIN // ranged ability check
      WRITE_SHORT ("%abil_off%" + 0x1c + ("%abil_num%" * 0x38)) 4 // missile damage type
      WRITE_BYTE  ("%abil_off%" + 0x26 + ("%abil_num%" * 0x38)) 0 // disallow strength bonus
    END
  END
  PATCH_IF ("%new_fx%" = 1) BEGIN // no effect found, add one
    WRITE_SHORT 0x70 ("%fx_num%" + "%new_fx%")
    INSERT_BYTES  ("%fx_off%" +        ("%fx_num%" * 0x30)) 0x30
      WRITE_SHORT ("%fx_off%" +        ("%fx_num%" * 0x30)) 1   // modify attacks per round
      WRITE_BYTE  ("%fx_off%" + 0x02 + ("%fx_num%" * 0x30)) 1   // target self
      WRITE_LONG  ("%fx_off%" + 0x04 + ("%fx_num%" * 0x30)) 3   // 3 attacks
      WRITE_BYTE  ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) 1   // set
      WRITE_BYTE  ("%fx_off%" + 0x0c + ("%fx_num%" * 0x30)) 2   // instant/while equipped
      WRITE_BYTE  ("%fx_off%" + 0x12 + ("%fx_num%" * 0x30)) 100 // probability 1
  END
  BUT_ONLY_IF_IT_CHANGES

// some effects on dispel magic subject to MR, though all other effects are not; see also sppr303 et al patch
COPY_EXISTING ~deva.itm~     ~override~ // deva weapon
              ~devaevil.itm~ ~override~ // deva weapon
              ~elemchan.itm~ ~override~ // chan weapon
              ~elemcryo.itm~ ~override~ // cryomix weapon
              ~elemhydr.itm~ ~override~ // cryomix weapon
              ~elemimix.itm~ ~override~ // imix weapon
              ~elemogre.itm~ ~override~ // ogremoch weapon
              ~elemsunn.itm~ ~override~ // sunnis weapon
              ~elemyanc.itm~ ~override~ // yan-c-bin weapon
              ~elemzaam.itm~ ~override~ // zaaman rul weapon
              ~planetar.itm~ ~override~ // planetar weapon
              ~ravag01.itm~  ~override~ // ravager weapon
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // loop through abilities
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF (("%opcode%" = 58) OR ("%opcode%" = 77) OR      // dispel fx, cure fm,
                  ("%opcode%" = 215) OR ("%opcode%" = 240)) BEGIN // play 3d effect, remove icon opcodes
          WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // no dispel/bypass MR
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~dwchan01.itm~ ~override~ // drow adamantie chain +5
              ~dwchan02.itm~ ~override~ // drow adamantie chain +5
              ~dwplat01.itm~ ~override~ // drow full plate +5
  WRITE_SHORT 0x42 75
  BUT_ONLY_IF_IT_CHANGES

// removal of extraneous vocalize effect
COPY_EXISTING ~dwsw1h01.itm~ ~override~
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  WHILE ("%fx_num%" > 0) BEGIN // searches through global effects
    SET "fx_num" = ("%fx_num%" - 1)
    READ_SHORT ("%fx_off%" + ("%fx_num%" * 0x30)) "type"
    PATCH_IF ("%type%" = 48) BEGIN // sets extraneous vocalize effect to 0% probability
      WRITE_BYTE ("%fx_off%" + 0x12 + ("%fx_num%" * 0x30)) 0 // 0% chance
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// drow whips not actually using animations
COPY_EXISTING ~dwwhip.itm~   ~override~
              ~dwwhip01.itm~ ~override~
  WRITE_ASCII 0x22 "FL" #2
  BUT_ONLY_IF_IT_CHANGES
  
// energy blades using wrong power level for electrical damage
COPY_EXISTING ~eneblade.itm~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks for magical ability header
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 9 // power 9
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// string fixes
COPY_EXISTING ~ENMACE.ITM~ ~override~
  SAY 0x8 @116
  SAY 0xc @116

// string fixes
COPY_EXISTING ~ENMORN.ITM~ ~override~
  SAY 0x8 @117
  SAY 0xc @117

// string fixes
COPY_EXISTING ~ENSW1H01.ITM~ ~override~
  SAY 0x8 @118
  SAY 0xc @118

// string fixes
COPY_EXISTING ~ENSW1H02.ITM~ ~override~
  SAY 0x8 @119
  SAY 0xc @119

// string fixes
COPY_EXISTING ~ENSW2H.ITM~ ~override~
  SAY 0x8 #6694
  SAY 0xc #6694

// familiar icon restorations
COPY_EXISTING ~FAMPSD.ITM~   ~override~
              ~FAMPSD25.ITM~ ~override~
              ~FAMFAIR.ITM~  ~override~
              ~FAMFAI25.ITM~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_ASCII 0x3a ~FAMPSD~ #8
  END
  BUT_ONLY_IF_IT_CHANGES
  
// per descript flame blade is non-magical, does 1d4 slashing damage plus 1d2 + 4 fire damage
// actual item is magical, does 1d2 + 4 slashing damage plus 1d4 fire, and has a spurious thac0 bonus
COPY_EXISTING ~fblade.itm~ ~override~
  READ_BYTE  0x18 "flags"
  WRITE_BYTE 0x18 ("%flags%" BAND 0b10111111) // removes magical flag
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks for melee ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      WRITE_SHORT ("%abil_off%" + 0x14 + ("%index%" * 0x38)) 0 // thac0 bonus
      WRITE_SHORT ("%abil_off%" + 0x16 + ("%index%" * 0x38)) 4 // dice size, melee damage
      WRITE_SHORT ("%abil_off%" + 0x1a + ("%index%" * 0x38)) 0 // fixed melee damage
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for fire damage
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
        READ_SHORT ("%fx_off%" + 0x0a + (("%abil_fx_idx%" + "%index2%") * 0x30)) "damage_type"
        PATCH_IF (("%opcode%" = 12) AND ("%damage_type%" = 8)) BEGIN // fire damage
          WRITE_LONG ("%fx_off%" + 0x04 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 4 // fixed fire damage
          WRITE_LONG ("%fx_off%" + 0x20 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 2 // dice size, fire damage
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// hammer does slashing damage
COPY_EXISTING ~giafir.itm~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_BYTE  ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee
      WRITE_SHORT ("%abil_off%" + 0x1c + ("%index%" * 0x38)) 2 // crushing
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// giants don't have s2 animation
COPY_EXISTING ~giants01.itm~ ~override~
  WRITE_ASCII 0x22 ~AX~ #2 
  BUT_ONLY_IF_IT_CHANGES

// fix power levels
COPY_EXISTING ~globred2.itm~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // cycle thru abilities
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // if magical
      READ_SHORT  (0x1e + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  (0x20 + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 5 // power level
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// golem immunities: hold, charm, fear, poison, backstab, sleep
COPY_EXISTING ~golbra.itm~   ~override~
              ~golcla.itm~   ~override~
              ~golfle.itm~   ~override~
              ~golmag01.itm~ ~override~
              ~golstone.itm~ ~override~
              ~irongol.itm~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG   0x64 "abil_off" ELSE 0
    READ_SHORT  0x68 "abil_num" ELSE 0
    READ_LONG   0x6a "fx_off"   ELSE 0
    READ_SHORT  0x70 "fx_num"   ELSE 0
    SET "fx_delta" = 0
    SET "hold" = 0
    SET "charm" = 0
    SET "fear" = 0
    SET "poison" = 0
    SET "sleep" = 0
    SET "backstab" = 0
    FOR (index2 = 0 ; index2 < fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        ("%index2%" * 0x30)) "opcode"
      READ_SHORT ("%fx_off%" + 0x04 + ("%index2%" * 0x30)) "param1"
      READ_SHORT ("%fx_off%" + 0x08 + ("%index2%" * 0x30)) "param2"
      PATCH_IF ("%opcode%" = 101) BEGIN // immunity to opcode...
        PATCH_IF (("%param2%" = 109) OR ("%param2%" = 175) OR ("%param2%" = 185)) BEGIN // hold
          SET "hold" = 1
        END ELSE
        PATCH_IF ("%param2%" = 5) BEGIN // charm
          SET "charm" = 1
        END ELSE
        PATCH_IF (("%param2%" = 23) OR ("%param2%" = 24) OR ("%param2%" = 106)) BEGIN // fear
          SET "hold" = 1
        END ELSE
        PATCH_IF ("%param2%" = 25) BEGIN // poison
          SET "poison" = 1
        END ELSE
        PATCH_IF (("%param2%" = 39) OR ("%param2%" = 217)) BEGIN // sleep
          SET "sleep" = 1
        END
      END
      PATCH_IF ("%opcode%" = 292) BEGIN // immunity to backstab...
        SET "backstab" = 1
      END
    END
    // just add absic immunity, let immunity effects batches handle the rest
    PATCH_IF ("%hold%" = 0) BEGIN // insert hold immunity
      INSERT_BYTES  ("%fx_off%"       ) 0x30
        WRITE_SHORT ("%fx_off%"       ) 101 // opcode: immunity to effect
        WRITE_LONG  ("%fx_off%" + 0x08) 109 // hold
      SET "fx_delta" = "%fx_delta%" + 1
    END
    PATCH_IF ("%charm%" = 0) BEGIN // insert charm immunity
      INSERT_BYTES  ("%fx_off%"       ) 0x30
        WRITE_SHORT ("%fx_off%"       ) 101 // opcode: immunity to effect
        WRITE_LONG  ("%fx_off%" + 0x08)   5 // charm
      SET "fx_delta" = "%fx_delta%" + 1
    END
    PATCH_IF ("%fear%" = 0) BEGIN // insert fear immunity
      INSERT_BYTES  ("%fx_off%"       ) 0x30
        WRITE_SHORT ("%fx_off%"       ) 101 // opcode: immunity to effect
        WRITE_LONG  ("%fx_off%" + 0x08) 106 // morale failure
      SET "fx_delta" = "%fx_delta%" + 1
    END
    PATCH_IF ("%poison%" = 0) BEGIN // insert poison immunity
      INSERT_BYTES  ("%fx_off%"       ) 0x30
        WRITE_SHORT ("%fx_off%"       ) 101 // opcode: immunity to effect
        WRITE_LONG  ("%fx_off%" + 0x08)  25 // poison
      SET "fx_delta" = "%fx_delta%" + 1
    END
    PATCH_IF ("%sleep%" = 0) BEGIN // insert sleep immunity
      INSERT_BYTES  ("%fx_off%"       ) 0x30
        WRITE_SHORT ("%fx_off%"       ) 101 // opcode: immunity to effect
        WRITE_LONG  ("%fx_off%" + 0x08)  39 // sleep
      SET "fx_delta" = "%fx_delta%" + 1
    END
    PATCH_IF ("%backstab%" = 0) BEGIN // insert backstab immunity
      INSERT_BYTES  ("%fx_off%"       ) 0x30
        WRITE_SHORT ("%fx_off%"       ) 292 // opcode: immunity to backstab
        WRITE_LONG  ("%fx_off%" + 0x08)   1 // must be 1
      SET "fx_delta" = "%fx_delta%" + 1
    END
    FOR (index3 = 0 ; index3 < fx_delta ; index3 = index3 + 1) BEGIN // set extra parameters for new effects
      WRITE_BYTE  ("%fx_off%" + 0x02 + ("%index3%" * 0x30))   1 // target: self
      WRITE_BYTE  ("%fx_off%" + 0x0c + ("%index3%" * 0x30))   2 // timing: instant/while equipped
      WRITE_LONG  ("%fx_off%" + 0x12 + ("%index3%" * 0x30)) 100 // probability
    END
    // adjust indexes on abilities
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      WRITE_SHORT ("%abil_off%" + 0x20 + ("%index%" * 0x38)) ("%abil_fx_idx%" + "%fx_delta%")
    END
    WRITE_SHORT 0x70 ("%fx_num%" + "%fx_delta%")
  END
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~halb03.itm~ ~override~ // halberd +2
  WRITE_SHORT 0x42 60
  BUT_ONLY_IF_IT_CHANGES
  
// blackmist casting blindness at wrong power level with wrong projectile
COPY_EXISTING ~halb06.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks for magical ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // if magical
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      WRITE_SHORT ("%abil_off%" + 0x2a + ("%index%" * 0x38)) 263 // fixes projectile
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_BYTE ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
        PATCH_IF ("%opcode%" != 141) BEGIN  // everything except lighting fx
          WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 8 // power 8 (pw:blind)
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// wave should kill salamanders; salas are flagged incorrectly (fixed in creature racial patches) and wear ring95 which
// prevents slay opcode. Change wave to use an eff with Kill Target opcode instead.
COPY_EXISTING ~halb09.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_BYTE ("%abil_off%" + (0x38 * "%index%")) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x38 * "%index%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x38 * "%index%")) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 55) BEGIN // slay effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 177        // use eff opcode
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~death~ #8 // death.eff
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// borok's fist should use its own, unique icon
COPY_EXISTING ~hamm05.itm~ ~override~
  WRITE_ASCII 0x3a ~ihamm05~ #8
  WRITE_ASCII 0x58 ~chamm05~ #8
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // get ability icons, too
    WRITE_ASCII ("%abil_off%" + 0x04 + ("%index%" * 0x38)) ~ihamm05~ #8
  END
  BUT_ONLY_IF_IT_CHANGES

// dwarven thrower: changes thrown icon, and fixes melee damage
COPY_EXISTING ~hamm06.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  WHILE ("%abil_num%" > 0) BEGIN // looks for magical ability header
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE   ("%abil_off%" + ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee
      WRITE_SHORT  ("%abil_off%" + 0x1a + ("%abil_num%" * 0x38)) 3 // plus damage
    END ELSE
    PATCH_IF ("%type%" = 2) BEGIN // ranged
      WRITE_ASCII  ("%abil_off%" + 0x04 + ("%abil_num%" * 0x38)) ~ihamm05~ #8 // thrown icon
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// add ability to kill ettins to Crom
COPY_EXISTING ~hamm09.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "delta" = 0
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // looks for melee ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "%abil_fx_idx%"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      WRITE_SHORT ("%abil_off%" + 0x1e + ("%index%" * 0x38)) ("%abil_fx_num%" +  1)
      INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 55   // slay
        WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30)) 2    // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x04 + ("%abil_fx_idx%" * 0x30)) 199  // ettin from
        WRITE_LONG  ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 4    // race.ids
        WRITE_BYTE  ("%fx_off%" + 0x0c + ("%abil_fx_idx%" * 0x30)) 1    // instant/perm
        WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30)) 100  // probability
      SET "delta" = ("%delta%" + 1)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// hastring didn't actually, umm, work and stuff.
COPY_EXISTING ~hastring.itm~ ~override~
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  WHILE ("%fx_num%" > 0) BEGIN
    SET "fx_num" = ("%fx_num%" - 1)
    READ_BYTE ("%fx_off%" + ("%fx_num%" * 0x30)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // modify attacks per round
      WRITE_SHORT  ("%fx_off%" + 0x04 + ("%fx_num%" * 0x30)) 1 // + one attack
      WRITE_SHORT  ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) 0 // increase/decrease
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Helm of Brilliance Sunray fix, icons
COPY_EXISTING ~helm16.itm~ ~override~
  WRITE_ASCII 0x3a ~ihelm16~ #8 // inventory icon
  WRITE_ASCII 0x58 ~chelm16~ #8 // description image
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN // looks for magical ability header
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // magical ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN // searches through fx for cast spell effect
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "type1"
        READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "spell"
        PATCH_IF (("%spell%" STRING_COMPARE_CASE "sppr707" = 0) AND ("%type1%" = 146)) BEGIN // cast spell, sppr707
          WRITE_BYTE ("%fx_off%" + 0x02 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 1   // target self
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// to avoid double immune messages, cast spell opcodes should all use power 0
COPY_EXISTING ~helm16.itm~  ~override~
              ~helm17.itm~  ~override~
              ~staf11.itm~  ~override~
              ~staf13.itm~  ~override~
              ~sw1h31.itm~  ~override~
              ~sw1h51.itm~  ~override~
              ~wa2helm.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks for magical ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // if magical
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_BYTE ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
        PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN  // cast spell
          WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // remove double interaction with spell protections
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// wong-fei using wrong regen icon
COPY_EXISTING ~helm34.itm~  ~override~
  READ_LONG  0x6a "fx_off" ELSE 0
  READ_SHORT 0x70 "fx_num" ELSE 0
  FOR (index = 0 ; index < fx_num; index = index + 1) BEGIN // searches through global effects
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "opcode"
    READ_LONG  ("%fx_off%" + 0x08 + ("%index%" * 0x30)) "icon"
    PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 56)) BEGIN // display regeneration icon
      WRITE_LONG  ("%fx_off%" + 0x08 + ("%index%" * 0x30)) 87 // change to regenerating
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// familiar attacks lack icons
COPY_EXISTING ~imp.itm~      ~override~ // imp soa
              ~impclaw.itm~  ~override~ // imp tob
              ~impqua.itm~   ~override~ // quasit soa
              ~quasclaw.itm~ ~override~ // quasit tob
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN
    WRITE_ASCII 0x3a ~iwolf~ #8
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      WRITE_ASCII ("%abil_off%" + 0x04 + ("%index%" * 0x38)) ~iwolf~ #8
    END
  END
  BUT_ONLY_IF_IT_CHANGES

//removes poison ability from imp and quasit attacks
COPY_EXISTING ~imp.itm~     ~override~
              ~impqua.itm~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    WHILE ("%abil_num%" > 0) BEGIN
      SET "abil_num" = ("%abil_num%" - 1)
      READ_SHORT ("%abil_off%" + ("%abil_num%" * 0x38)) "type"
      PATCH_IF ("%type%" = 1) BEGIN // if melee ability
        WRITE_SHORT ("%abil_off%" + 0x16 + ("%abil_num%" * 0x38)) 6 // sets dice size to 6
        READ_SHORT ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "fx_num"
        READ_SHORT ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "fx_idx"
        WHILE ("%fx_num%" > 0) BEGIN // sets prob = 0 to any effects that go with it
          SET "fx_num" = ("%fx_num%" - 1)
          WRITE_BYTE ("%fx_off%" + 0x12 + (("%fx_idx%" + "%fx_num%") * 0x30)) 0
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// overrides zero-byte files in the biffs, if not overridden already
ACTION_IF NOT FILE_EXISTS ~override/iplot01k.itm~ THEN BEGIN
  COPY_EXISTING ~SW1H01.itm~ ~override/iplot01k.itm~
END
ACTION_IF NOT FILE_EXISTS ~override/iplot04g.itm~ THEN BEGIN
  COPY_EXISTING ~SW1H01.itm~ ~override/iplot04g.itm~
END
ACTION_IF NOT FILE_EXISTS ~override/iplot04h.itm~ THEN BEGIN
  COPY_EXISTING ~SW1H01.itm~ ~override/iplot04h.itm~
END
ACTION_IF NOT FILE_EXISTS ~override/iplot04i.itm~ THEN BEGIN
  COPY_EXISTING ~SW1H01.itm~ ~override/iplot04i.itm~
END

// changes to ipsion, which provides psionic protections for Mordy swords and ToB boneblades
COPY_EXISTING ~ipsion.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  SET "stun_dupe" = 0
  SET "hold_dupe" = 0
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "type"
    PATCH_IF ("%type%" = 101) BEGIN // immunity to stun or hold
      READ_LONG  ("%fx_off%" + 0x08 + ("%index%" * 0x30)) "param"
      PATCH_IF ("%param%" = 45) BEGIN
        PATCH_IF ("%stun_dupe%" = 0) BEGIN // if first effect
          SET "stun_dupe" = 1
        END ELSE BEGIN // if dupe effect
          WRITE_LONG  ("%fx_off%" + 0x08 + ("%index%" * 0x30)) 5 // change to charm
        END
      END ELSE
      PATCH_IF ("%param%" = 175) BEGIN
        PATCH_IF ("%hold_dupe%" = 0) BEGIN // if first effect
          SET "hold_dupe" = 1
        END ELSE BEGIN // if dupe effect
          WRITE_LONG  ("%fx_off%" + 0x08 + ("%hold_dupe%" * 0x30)) 19 // change to inteligence modification
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// enchantment correction for kuo-toan bolts
COPY_EXISTING ~KuoBolt2.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_LONG 0x60 2
  END
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~leat03.itm~ ~override~ // protector of the second
  WRITE_SHORT 0x42 60
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~leat06.itm~ ~override~ // studded leather of missile attraction
  WRITE_SHORT 0x42 100
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~melfmet.itm~  ~override~
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    READ_LONG     0x64  "ho"
    READ_SHORT    0x68  "hc"
    READ_LONG     0x6a  "eo"
    READ_SHORT    0x70  "gc"
    FOR ("i" = 0x00; "i" < ("hc" * 0x38); "i" += 0x38) BEGIN
      READ_SHORT  ("ho" + "i" + 0x20) "ei"
      WRITE_SHORT ("ho" + "i" + 0x20) ("ei" + 0x02)
    END
    INSERT_BYTES  ("eo" + ("gc" * 0x30) + 0x00) (0x30 * 0x02)
      FOR ("j" = ("gc" * 0x30); "j" < (("gc" + 0x02) * 0x30); "j" += 0x30) BEGIN
        WRITE_SHORT ("eo" + "j" + 0x00) 0xce // opcode: protection from spell
        WRITE_BYTE  ("eo" + "j" + 0x02) 0x01 // target: self
        WRITE_LONG  ("eo" + "j" + 0x04) `0x0 // string displayed
        WRITE_BYTE  ("eo" + "j" + 0x0c) 0x02 // timing mode: while equipped
        WRITE_BYTE  ("eo" + "j" + 0x12) 0x64 // minimum probability 100%
      END
      WRITE_ASCII ("eo" + ("gc" * 0x30) + 0x14) ~spcl521d~ // resource reference
      WRITE_ASCII ("eo" + ("gc" * 0x30) + 0x44) ~spcl741d~ // resource reference
    WRITE_SHORT   0x70  ("gc" + 0x02)
  END
BUT_ONLY_IF_IT_CHANGES
  
// monk fists are inconsistent w/ descript
COPY_EXISTING ~mfist3.itm~ ~override~
              ~mfist6.itm~ ~override~
  READ_LONG   0x60 "enchantment" ELSE 0
  READ_LONG   0x64 "abil_off"    ELSE 0
  READ_SHORT  0x68 "abil_num"    ELSE 0
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // looks for melee ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      WRITE_SHORT ("%abil_off%" + 0x14 + ("%index%" * 0x38)) "%enchantment%" // sets thac0 bonus
      WRITE_SHORT ("%abil_off%" + 0x1a + ("%index%" * 0x38)) "%enchantment%" // sets damage bonus
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// string fixes
COPY_EXISTING ~MFIST4.ITM~ ~override~
  SAY 0x8 @120
  SAY 0xc @120

// string fixes
COPY_EXISTING ~MFIST5.ITM~ ~override~
  SAY 0x8 @121
  SAY 0xc @121

// string fixes
COPY_EXISTING ~MFIST6.ITM~ ~override~
              ~MFIST7.ITM~ ~override~
  SAY 0x8 @122
  SAY 0xc @122

// string fixes
ACTION_IF FILE_EXISTS_IN_GAME ~mfist8.itm~ THEN BEGIN
  COPY_EXISTING ~MFIST8.ITM~ ~override~
    SAY 0x8 @123
    SAY 0xc @123
END

// int drain string from mind flayers showing up 300 seconds after occurring
COPY_EXISTING ~mindflay.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN // looks for melee ability header
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN // searches through fx for THAC0 bonus
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "opcode"
        PATCH_IF ("%opcode%" = 139) BEGIN // look for display string
          WRITE_BYTE ("%fx_off%" + 0x0c + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 1 // instant/permanent
          WRITE_LONG ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 0 // no duration
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// minhp1 is not protecting from all types of possible death
COPY_EXISTING ~minhp1.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "new_fx" = 27
  WRITE_SHORT 0x70 ("%fx_num%" + "%new_fx%")
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%index%" * 0x38)) ("%abil_fx_idx%" + "%new_fx%")
  END 
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 14021 // String Ref - ~Intelligence Modification~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 14024 // String Ref - ~Dexterity Modification~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 14029 // String Ref - ~Constitution Modification~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 14034 // String Ref - ~Charisma Modification~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 14042 // String Ref - ~Strength Modification~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 14782 // String Ref - ~Confused~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 14791 // String Ref - ~Rigid Thinking~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 14047 // String Ref - ~Wisdom Modification~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 32089 // String Ref - ~Devour Brain~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 40968 // String Ref - ~Two Levels Drained~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 40969 // String Ref - ~Three Levels Drained~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 40979 // String Ref - ~Four Levels Drained~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 41495 // String Ref - ~One Level Drained~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 267   // disable display string
    WRITE_LONG  ("%fx_off%" + 0x04) 41616 // String Ref - ~Five Levels Drained~
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 6     // charisma modification
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 10    // constitution modification
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 15    // dexterity modification
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 19    // intelligence modification
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 23    // morale modification
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 39    // unconciousness
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 44    // strength modification
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 49    // wisdom modification
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 76    // feeblemind
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 165   // pause target
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 210   // stun 90hp
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 241   // control creature
  INSERT_BYTES "%fx_off%" 0x30
    WRITE_SHORT ("%fx_off%"       ) 101   // immunity to effect
    WRITE_LONG  ("%fx_off%" + 0x08) 246   // berserk
  FOR (index = 0 ; index < new_fx ; index = index + 1) BEGIN
    WRITE_BYTE ("%fx_off%" + 0x02 + ("%index%" * 0x30)) 1   // target: self
    WRITE_BYTE ("%fx_off%" + 0x0c + ("%index%" * 0x30)) 2   // instant/while equipped
    WRITE_BYTE ("%fx_off%" + 0x12 + ("%index%" * 0x30)) 100 // probability
  END

// figurines were using some screwy system of reappearing that broke; should be using charges
COPY_EXISTING ~misc3d.itm~ ~override~ // golden lion
              ~misc3e.itm~ ~override~ // black spider
              ~misc3f.itm~ ~override~ // jade hound
              ~misc7t.itm~ ~override~ // moon dog
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT ("%abil_off%" + ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // if magical ability
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN // searches for certain opcodes and sets prob = 0
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "opcode"
        PATCH_IF (("%opcode%" = 122) OR ("%opcode%" = 123) OR ("%opcode%" = 139)) BEGIN
          WRITE_BYTE ("%fx_off%" + 0x12 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 0 // probability
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// methlid's harp bugs
COPY_EXISTING ~misc3o.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "delta" = 0
  FOR (index = 0; index < abil_num; index = index +1) BEGIN // looks for magical ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "%abil_fx_idx%"
    PATCH_IF ("%type%" = 3) BEGIN // melee ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      WRITE_SHORT ("%abil_off%" + 0x1e + ("%index%" * 0x38)) ("%abil_fx_num%" +  3)
      INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 240  // remove icon
        WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30)) 2    // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 55   // stun
        WRITE_BYTE  ("%fx_off%" + 0x0c + ("%abil_fx_idx%" * 0x30)) 1    // instant/perm
        WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30)) 100  // probability
      INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 163  // free action
        WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30)) 2    // target: preset target
        WRITE_BYTE  ("%fx_off%" + 0x0c + ("%abil_fx_idx%" * 0x30)) 1    // instant/perm
        WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30)) 100  // probability
      INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 46   // unstun
        WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30)) 2    // target: preset target
        WRITE_BYTE  ("%fx_off%" + 0x0c + ("%abil_fx_idx%" * 0x30)) 1    // instant/perm
        WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30)) 100  // probability
      SET "delta" = ("%delta%" + 3)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// portal key should be droppable
COPY_EXISTING ~misc4g.itm~ ~override~
  READ_BYTE 0x18 "flags"
  WRITE_BYTE "0x18" ("%flags%" BOR "0b00000100")
  BUT_ONLY_IF_IT_CHANGES

// changes to bastard sword proficiency
COPY_EXISTING ~misc4q.itm~ ~override~
  WRITE_BYTE  0x31 90
  BUT_ONLY_IF_IT_CHANGES

// changes to dagger proficiency
COPY_EXISTING ~misc4u.itm~ ~override~
              ~misc75.itm~ ~override~
  WRITE_BYTE  0x31 96
  BUT_ONLY_IF_IT_CHANGES

// adds staff prof for kobold staff
COPY_EXISTING ~misc5t.itm~ ~override~
  WRITE_BYTE 0x31 102
  BUT_ONLY_IF_IT_CHANGES

// harper pin supposed to be usable only by Jaheira
COPY_EXISTING ~misc5x.itm~ ~override~
  WRITE_BYTE 0x26 15 // min str
  WRITE_BYTE 0x2a 10 // min int
  WRITE_BYTE 0x2c 17 // min dex
  WRITE_BYTE 0x2e 14 // min wis
  WRITE_BYTE 0x30 17 // min con
  WRITE_BYTE 0x32 15 // min chr
  BUT_ONLY_IF_IT_CHANGES

// claw of kazgaroth equipping effects are disspellable
COPY_EXISTING ~misc72.itm~ ~override~
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  FOR (index = 0; index < "%fx_num%"; index = index + 1) BEGIN // searches through global effects
    WRITE_BYTE ("%fx_off%" + 0x0d + ("%index%" * 0x30)) 2 // not dispel/not bypass
  END
  BUT_ONLY_IF_IT_CHANGES

// make horn of kazgaroth a quickslot item
COPY_EXISTING ~misc73.itm~ ~override~
  WRITE_SHORT 0x1c 0
  BUT_ONLY_IF_IT_CHANGES

// Boo gets a quickslot icon
COPY_EXISTING ~misc84.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  WRITE_SHORT 0x68 ("%abil_num%" + 1)
  READ_LONG   0x6a "fx_off"
  WRITE_LONG  0x6a ("%fx_off%" + 0x38)
  READ_SHORT  0x70 "fx_num"
  INSERT_BYTES "%abil_off%" 0x38 // new ability
    WRITE_BYTE  ("%abil_off%"       ) 3          // magical ability
    WRITE_BYTE  ("%abil_off%" + 0x02) 3          // item slots
    WRITE_ASCII ("%abil_off%" + 0x04) ~imisc84~  // boo icon
    WRITE_SHORT ("%abil_off%" + 0x20) "%fx_num%" // fx index
  BUT_ONLY_IF_IT_CHANGES

// duration for illithid control circlet charm effect
COPY_EXISTING ~misc9x.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN // looks for magical ability header
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // magical ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN // searches through fx for charm creature
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "type1"
        PATCH_IF ("%type1%" = 5) BEGIN // charm
          WRITE_LONG ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 1800
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// blackrazor missing many effects
COPY_EXISTING ~miscbc.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  WRITE_SHORT 0x70 ("%fx_num%" + 2)
  WHILE ("%abil_num%" > 0) BEGIN // looks for magical ability header
    SET "patched" = 0
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE ("%abil_off%" + ("%abil_num%" * 0x38)) "type"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      WRITE_SHORT ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) ("%abil_fx_num%" +  4)
      WHILE ("%abil_fx_num%" > 0) BEGIN // searches through fx for str bonus
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "type1"
        PATCH_IF ("%type1%" = 44) BEGIN // str bonus
          WRITE_BYTE ("%fx_off%" + 0x12 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 15 // probability
        END
      END
      INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 142  // display icon
        WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30)) 1    // target: self
        WRITE_LONG  ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 21   // strength
        WRITE_BYTE  ("%fx_off%" + 0x0d + ("%abil_fx_idx%" * 0x30)) 2    // no dispel/not bypass
        WRITE_LONG  ("%fx_off%" + 0x0e + ("%abil_fx_idx%" * 0x30)) 20   // duration
        WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30)) 15   // probability
      INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 139  // display string
        WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30)) 1    // target: self
        WRITE_LONG  ("%fx_off%" + 0x04 + ("%abil_fx_idx%" * 0x30)) 14022 // strref "healed"
        WRITE_BYTE  ("%fx_off%" + 0x0c + ("%abil_fx_idx%" * 0x30)) 1    // instant/perm
        WRITE_BYTE  ("%fx_off%" + 0x0d + ("%abil_fx_idx%" * 0x30)) 2    // no dispel/not bypass
        WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30)) 15   // probability
      INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 142  // display icon
        WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30)) 1    // target: self
        WRITE_LONG  ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 38   // haste
        WRITE_BYTE  ("%fx_off%" + 0x0d + ("%abil_fx_idx%" * 0x30)) 2    // no dispel/not bypass
        WRITE_LONG  ("%fx_off%" + 0x0e + ("%abil_fx_idx%" * 0x30)) 20   // duration
        WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30)) 15   // probability
      INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 139  // display string
        WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30)) 2    // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x04 + ("%abil_fx_idx%" * 0x30)) 40979 // strref "4 levels drained"
        WRITE_BYTE  ("%fx_off%" + 0x0c + ("%abil_fx_idx%" * 0x30)) 1    // instant/perm
        WRITE_BYTE  ("%fx_off%" + 0x0d + ("%abil_fx_idx%" * 0x30)) 2    // no dispel/not bypass
        WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30)) 15   // probability
      SET "patched" = 1
    END
    PATCH_IF ("%patched%" = 1) BEGIN
      WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) ("%abil_fx_idx%" + 2)
    END ELSE BEGIN
      WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) ("%abil_fx_idx%" + 6)
    END
  END
  WHILE ("%fx_num%" > 0) BEGIN
    SET "fx_num" = ("%fx_num%" - 1)
    READ_SHORT ("%fx_off%" +        ("%fx_num%" * 0x30)) "type"
    PATCH_IF ("%type%" = 7) BEGIN  // set item color
      WRITE_BYTE  ("%fx_off%" + 0x0d + ("%fx_num%" * 0x30)) 0 // no dispel/bypass
    END
  END
  INSERT_BYTES  ("%fx_off%"       ) 0x30 // new effect
    WRITE_LONG  ("%fx_off%" + 0x08) 87   // regeneration
  INSERT_BYTES  ("%fx_off%"       ) 0x30 // new effect
    WRITE_LONG  ("%fx_off%" + 0x08) 52   // mind shield
  SET "loops" = 2
  WHILE ("%loops%" > 0) BEGIN
    SET "loops" = ("%loops%" - 1)
    WRITE_SHORT ("%fx_off%"        + ("%loops%" * 0x30)) 142  // display icon
    WRITE_BYTE  ("%fx_off%" + 0x02 + ("%loops%" * 0x30)) 1    // target: self
    WRITE_BYTE  ("%fx_off%" + 0x0c + ("%loops%" * 0x30)) 2    // instant/while equipped
    WRITE_BYTE  ("%fx_off%" + 0x12 + ("%loops%" * 0x30)) 100  // probability
  END

// cloning Neb's dagger to make a version with no charges
COPY_EXISTING ~nebdag.itm~ ~override/cdnebdag.itm~
  SAY DESC @106
  WRITE_SHORT 0x42 0 // sets lore to zero for instant ID
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN // looks for melee ability header
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WRITE_SHORT ("%abil_off%" + 0x22 + ("%abil_num%" * 0x38)) 0 // charges
      WRITE_BYTE  ("%abil_off%" + 0x24 + ("%abil_num%" * 0x38)) 1 // vanishes
      WRITE_BYTE  ("%abil_off%" + 0x25 + ("%abil_num%" * 0x38)) 0 // unknown (0)
      WHILE ("%abil_fx_num%" > 0) BEGIN // disables all melee effects
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        WRITE_BYTE ("%fx_off%" + 0x12 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 0 // probability: 0
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// altering Neb's dagger to change to cdnebdag when charges run out
COPY_EXISTING ~nebdag.itm~ ~override~
  WRITE_ASCII 0x10 ~cdnebdag~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN // looks for melee ability header
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WRITE_BYTE  ("%abil_off%" + 0x24 + ("%abil_num%" * 0x38)) 2 // replace with used up when drained
      WRITE_BYTE  ("%abil_off%" + 0x27 + ("%abil_num%" * 0x38)) 1 // item does not recharge
      WHILE ("%abil_fx_num%" > 0) BEGIN // searches through fx for slow effect
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "fx_type"
        PATCH_IF ("%fx_type%" = 40) BEGIN // slow effect
          WRITE_BYTE ("%fx_off%" + 0x12 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 0 // probability: 0
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// disables arcane spellcasting; charm now handled in effects batch below
COPY_EXISTING ~npchan.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  WRITE_SHORT 0x70 ("%fx_num%" + 1)
  INSERT_BYTES  ("%fx_off%" +        ("%fx_num%" * 0x30)) 0x30
    WRITE_SHORT ("%fx_off%" +        ("%fx_num%" * 0x30)) 145 // disable spellcasting
    WRITE_BYTE  ("%fx_off%" + 0x02 + ("%fx_num%" * 0x30)) 1   // target:self
    WRITE_BYTE  ("%fx_off%" + 0x0c + ("%fx_num%" * 0x30)) 2   // instant/while equipped
    WRITE_BYTE  ("%fx_off%" + 0x12 + ("%fx_num%" * 0x30)) 100 // probability 1
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%index%" * 0x38)) ("%abil_fx_idx%" + 1)
  END
  BUT_ONLY_IF_IT_CHANGES

// adds min stat requirements to Keldorn's armor
COPY_EXISTING ~npplat.itm~ ~override~
  WRITE_BYTE 0x2a 2  // min int
  WRITE_BYTE 0x2e 16 // min wis
  BUT_ONLY_IF_IT_CHANGES

// string fixes
COPY_EXISTING ~NPSW02.ITM~ ~override~
  SAY 0x8 @124
  SAY 0xc @124
  BUT_ONLY_IF_IT_CHANGES

// Valygar's katana
COPY_EXISTING ~npsw04.itm~ ~override~
  WRITE_BYTE 0x2e 14 // min wis
  BUT_ONLY_IF_IT_CHANGES

// by Bioware naming convention, this item should be 4 enchantment
COPY_EXISTING ~p3-12m4.itm~ ~override~
  WRITE_LONG 0x60 4
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~plat02.itm~ ~override~ // plate mail +1
  WRITE_SHORT 0x42 40
  BUT_ONLY_IF_IT_CHANGES

// both full plate +1 don't disable thieving button, one has bad min str
COPY_EXISTING ~plat05.itm~ ~override~
              ~plat14.itm~ ~override~
  READ_LONG  0x6a "fx_off" ELSE 0
  READ_SHORT 0x70 "fx_num" ELSE 0
  WRITE_BYTE 0x26 15 // correct min str
  SET "count" = 0
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "opcode"
    READ_LONG  ("%fx_off%" + 0x08 + ("%index%" * 0x30)) "param"
    PATCH_IF (("%opcode%" = 144) AND ("%param%" = 0)) BEGIN // disable stealth button
      PATCH_IF ("%count%" = 0) BEGIN // if first time, leave alone
        SET "count" = 1
      END ELSE BEGIN // if second, change to disable thieving button
        WRITE_LONG ("%fx_off%" + 0x08 + ("%index%" * 0x30)) 1 // thieving button
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// three sets of full plate have extraneous movement rate and THAC0 penalties
COPY_EXISTING ~plat19.itm~ ~override~
              ~plat22.itm~ ~override~
              ~plat23.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x6a "fx_off"
    READ_SHORT 0x70 "fx_num"
    WHILE ("%fx_num%" > 0) BEGIN
      SET "fx_num" = ("%fx_num%" - 1)
      READ_BYTE ("%fx_off%" +        ("%fx_num%" * 0x30)) "type"
      READ_LONG ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) "icon"
      PATCH_IF (("%type%" = 54) OR ("%type%" = 126)) BEGIN // movement rate or THAC0
        WRITE_BYTE ("%fx_off%" + 0x12 + ("%fx_num%" * 0x30)) 0 // probability: 0
      END ELSE
      PATCH_IF (("%type%" = 142) AND ("%icon%" = 26)) BEGIN // display portrait icon; a patch for plat22
        WRITE_LONG ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) 16 // change resist fire/cold to protection from fire
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~plat23.itm~ ~override~ // full plate +2
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_SHORT 0x42 75
  END
  BUT_ONLY_IF_IT_CHANGES

// Potion of Storm Giant Strength mis-targeted
COPY_EXISTING ~potn07.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN // looks for magical ability header
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // magical ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN // searches through effects
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "fx_type"
        PATCH_IF ("%fx_type%" = 44) BEGIN // str bonus
          WRITE_BYTE ("%fx_off%" + 0x02 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 1 // target: self
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// thrown oil of fiery burning shouldn't say 'gulp!', fix power levels
// oil of fiery burning damage incorrect
COPY_EXISTING ~potn13.itm~ ~override~
  LAUNCH_PATCH_FUNCTION ~DELETE_ITEM_EFFECT~ INT_VAR
    opcode_to_delete = "139" // kills 'gulp' effect
    END
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // cycle thru abilities
    READ_SHORT  (0x1e + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  (0x20 + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // should bypass spell protections
      PATCH_IF ("%opcode%" = 12) BEGIN // as long as we're here, fix damage
        READ_LONG  ("%fx_off%" + 0x24 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "save"
        WRITE_BYTE ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // instant/perm effects should have 0 duration
        PATCH_IF ("%save%" = 0) BEGIN // if not subject to save
          WRITE_LONG  ("%fx_off%" + 0x1c + (("%abil_fx_idx%" + "%index2%") * 0x30)) 2 // two rolls...
          WRITE_LONG  ("%fx_off%" + 0x20 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 6 // of 6-sided die
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// potion of magic blocking should only block up to level 5 spells, per description
COPY_EXISTING ~potn33.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks for magical ability header
    READ_BYTE  ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN //magical ability
      READ_SHORT ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for immunity to spell level
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "level"
        PATCH_IF (("%opcode%" = 102) AND ("%level%" > 5)) BEGIN // immunity to spell level > 5
          WRITE_BYTE ("%fx_off%" + 0x12 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // probability
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fix errors; full free action batch effects handled below
COPY_EXISTING ~potn45.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" +        (0x28 * "%index%")) "type"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    PATCH_IF ("%type%" = 3) BEGIN // magical ability only
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "fx_type"
        READ_LONG  ("%fx_off%" + 0x08 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "immunity"
        PATCH_IF (("%fx_type%" = 101) AND ("%immunity%" = 5)) BEGIN // change charm immunity to haste immunity
          WRITE_LONG ("%fx_off%" + 0x08 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 16
        END ELSE
        PATCH_IF (("%fx_type%" = 101) AND ("%immunity%" = 45)) BEGIN // change stun immunity to hold immunity
          WRITE_LONG ("%fx_off%" + 0x08 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 175
        END ELSE
        PATCH_IF (("%fx_type%" = 142) OR ("%fx_type%" = 163)) BEGIN // display portrait icon for free action
          WRITE_LONG ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%index2%") * 0x30)) 600 // duration
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fire/air/earth control ring has screwy charm effects; changed to use eff targeting on class fire/air/earth elemental
COPY_EXISTING ~ring27.itm~ ~override~
              ~ring28.itm~ ~override~
              ~ring29.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN // looks for melee ability header
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE  ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    READ_ASCII ("%abil_off%" + 0x04 + ("%abil_num%" * 0x38)) "icon"
    PATCH_IF (("%type%" = 3) AND 
             (("%icon%" STRING_COMPARE_CASE "spwi104b" = 0) OR      // fire control charm
              ("%icon%" STRING_COMPARE_CASE "sppr204b" = 0))) BEGIN // air control charm
      WRITE_SHORT ("%abil_off%" + 0x0e + ("%abil_num%" * 0x38)) 2 // range
      WRITE_BYTE  ("%abil_off%" + 0x27 + ("%abil_num%" * 0x38)) 8 // recharges after rest
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN // searches through fx for slow effect
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "fx_type"
        PATCH_IF ("%fx_type%" = 5) BEGIN // charm > use eff
          WRITE_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 177 // use eff
          PATCH_IF ("ring27" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) BEGIN // fire control ring
            WRITE_LONG  ("%fx_off%" + 0x04 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 187 // fire elemental
          END ELSE
          PATCH_IF ("ring28" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) BEGIN // air control
            WRITE_LONG  ("%fx_off%" + 0x04 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 186 // air elemental
          END ELSE
          PATCH_IF ("ring29" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0) BEGIN // earth control
            WRITE_LONG  ("%fx_off%" + 0x04 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 188 // earth elemental
          END
          WRITE_SHORT ("%fx_off%" + 0x08 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 5   // class
          WRITE_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) ~cdcmelem~ // new eff
          WRITE_LONG  ("%fx_off%" + 0x24 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 1   // save v spells
          WRITE_LONG  ("%fx_off%" + 0x28 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 2   // save bonus
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// air control ring, adding new effects
COPY_EXISTING ~ring28.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  SET "loops" = 0
  SET "fx_new" = 0
  WHILE ("%abil_num%" > "%loops%") BEGIN // finds insert point and adjusts indices
    READ_SHORT  ("%abil_off%" + 0x20 + ("%loops%" * 0x38)) "abil_fx_idx"
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%loops%" * 0x38)) ("%abil_fx_idx%" + "%fx_new%")
    READ_ASCII  ("%abil_off%" + 0x04 + ("%loops%" * 0x38)) "icon"
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "spwi405b" = 0) BEGIN // invisibiity ability
      SET "fx_new" = 5
      SET "fx_insert" = ("%fx_off%" + ("%abil_fx_idx%" * 0x30))
      READ_SHORT  ("%abil_off%" + 0x1e + ("%loops%" * 0x38)) "abil_fx_num"
      WRITE_SHORT ("%abil_off%" + 0x1e + ("%loops%" * 0x38)) ("%abil_fx_num%" + "%fx_new%")
    END
    SET "loops" = ("%loops%" + 1)
  END
  WHILE ("%fx_new%" > 0) BEGIN
    SET "fx_new" = ("%fx_new%" - 1)
    INSERT_BYTES  ("%fx_insert%"       ) 0x30       // new effect
      WRITE_SHORT ("%fx_insert%"       ) ("%fx_new%" + 33) // save bonuses
      WRITE_BYTE  ("%fx_insert%" + 0x02) 1     // target:self
      WRITE_BYTE  ("%fx_insert%" + 0x03) 0     // power
      WRITE_LONG  ("%fx_insert%" + 0x04) 4     // value
      WRITE_BYTE  ("%fx_insert%" + 0x0d) 2     // dispel/not bypass
      WRITE_LONG  ("%fx_insert%" + 0x0e) 60    // duration
      WRITE_BYTE  ("%fx_insert%" + 0x12) 100   // probability
  END
  BUT_ONLY_IF_IT_CHANGES

// disables erroneous save effects from earth control ring
COPY_EXISTING ~ring29.itm~ ~override~
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  WHILE ("%fx_num%" > 0) BEGIN
    SET "fx_num" = ("%fx_num%" - 1)
    READ_BYTE ("%fx_off%" +        ("%fx_num%" * 0x30)) "type"
    PATCH_IF (("%type%" > 32) AND ("%type%" < 38)) BEGIN // save bonuses
      WRITE_BYTE ("%fx_off%" + 0x12 + ("%fx_num%" * 0x30)) 0 // probability: 0
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// ring of gaxx displays wrong icon
COPY_EXISTING ~ring39.itm~ ~override~
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  WHILE ("%fx_num%" > 0) BEGIN // need to change existing icon display
    SET "fx_num" = ("%fx_num%" - 1)
    READ_SHORT ("%fx_off%" +        ("%fx_num%" * 0x30)) "type"
    READ_LONG  ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) "icon"
    PATCH_IF (("%type%" = 142) AND ("%icon%" = 28)) BEGIN // display protection from magic icon
      WRITE_LONG  ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) 63 // change to magic resistance
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// rods02 requires lore; however it would make it un-id'd every time you switched back to the rod.
// So, clone it with 0 lore and have other items create the clone instead of the original
COPY_EXISTING ~rods02.itm~ ~override/rods02a.itm~ // zero-lore copy
  WRITE_SHORT 0x42 0
  
COPY_EXISTING ~rods02.itm~ ~override~ // assign lore to original
  WRITE_SHORT 0x42 70
  BUT_ONLY_IF_IT_CHANGES

// rod of smiting golem damage not set properly, should be in melee ability not global fx
COPY_EXISTING ~rods04.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "delta" = 0
  FOR (index2 = 0 ; index2 < fx_num ; index2 = index2 + 1) BEGIN
    READ_SHORT ("%fx_off%" +        (0x30 * "%index2%")) "opcode"
    READ_ASCII ("%fx_off%" + 0x14 + (0x30 * "%index2%")) "eff_file"
    PATCH_IF (("%opcode%" = 177) AND ("%eff_file%" STRING_COMPARE_CASE "smitgol1" = 0)) BEGIN
      READ_ASCII   ("%fx_off%" + (0x30 * "%index2%")) "clone_fx" (0x30) // reads effect
      DELETE_BYTES ("%fx_off%" + (0x30 * "%index2%")) 0x30 // deletes it
      SET "fx_num" = "%fx_num%" - 1
      WRITE_SHORT 0x70 "%fx_num%" // adjusts global fx number
      SET "index" = "%fx_num%" // kills loop
      SET "delta" = "%delta%" - 1
    END
  END
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // looks for melee ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "%abil_fx_idx%"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      WRITE_SHORT ("%abil_off%" + 0x1e + ("%index%" * 0x38)) ("%abil_fx_num%" +  1)
      INSERT_BYTES            ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30 // new effect
        WRITE_EVALUATED_ASCII ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) "%clone_fx%" // writes in cloned effect
        WRITE_BYTE            ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30)) 2    // target: preset target
        WRITE_BYTE            ("%fx_off%" + 0x0d + ("%abil_fx_idx%" * 0x30)) 0    // no dispel/bypass
      SET "delta" = ("%delta%" + 1)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// change rod-created items to reference clone instead of original
COPY_EXISTING ~rodmace.itm~  ~override~
              ~rodspear.itm~ ~override~
              ~rodsword.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks through headers
    READ_SHORT ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for create item effect
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "item"
      PATCH_IF (("%opcode%" = 122) AND ("%item%" STRING_COMPARE_CASE "rods02" = 0)) BEGIN // create rods02
        WRITE_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) ~rods02a~
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// string fix  
COPY_EXISTING ~rodspear.itm~ ~override~
  SAY 0x8 #7807
  SAY 0xc #7807

// string fix, color change
COPY_EXISTING ~rodsword.itm~ ~override~
  SAY 0x8 @115
  SAY 0xc @115
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  WHILE ("%fx_num%" > 0) BEGIN // searches through global effects
    SET "fx_num" = ("%fx_num%" - 1)
    READ_SHORT ("%fx_off%" + ("%fx_num%" * 0x30)) "type"
    PATCH_IF ("%type%" = 7) BEGIN // looks for set item color effect
      WRITE_LONG ("%fx_off%" + 0x04 + ("%fx_num%" * 0x30)) 115 // turns sword flaming
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// string fix
COPY_EXISTING ~rodmace.itm~ ~override~
  SAY 0x8 #7413
  SAY 0xc #7413

// item requires lore
COPY_EXISTING ~rods06.itm~ ~override~ // rod of reversal
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_SHORT 0x42 85
  END
  BUT_ONLY_IF_IT_CHANGES

// add miscast icons
COPY_EXISTING ~scrl11.itm~ ~override~ // cursed scroll of clumsiness
  LAUNCH_PATCH_FUNCTION ~ADD_ITEM_EFFECT~ INT_VAR
    opcode        = 142 // display portrait icon
    target        = 1   // target self
    resist_dispel = 1   // dispel/bypass MR
    duration      = 600 // duration
    parameter2    = 105 // miscast magic
    power         = 4   // power
    END
  BUT_ONLY

/////                                                  \\\\\
///// big batch o' scroll fixes (thanks devSin)        \\\\\
/////                                                  \\\\\

// scroll fixes: casting opcode
COPY_EXISTING ~scrl1o.itm~ ~override~ // slow
              ~scrl1u.itm~ ~override~ // confusion
              ~scrl2f.itm~ ~override~ // cone of cold
              ~scrl5i.itm~ ~override~ // greater malison
              ~scrl70.itm~ ~override~ // color spray
              ~scrl7i.itm~ ~override~ // death spell
              ~scrl8p.itm~ ~override~ // prismatic spray
              ~scrl94.itm~ ~override~ // resist fear
              ~scrla1.itm~ ~override~ // wizard eye
              ~scrla3.itm~ ~override~ // glitterdust
              ~scrla7.itm~ ~override~ // remove magic
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 146) BEGIN // cast spell
        WRITE_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) 148 // opcode: cast spell (scroll)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: casting opcode
COPY_EXISTING ~scrl5b.itm~ ~override~ // defensive harmony
              ~scrl5d.itm~ ~override~ // protection from evil 10' radius
              ~scrlb4.itm~ ~override~ // wish
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell (scroll)
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 148) BEGIN // cast spell (scroll)
        WRITE_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) 146 // opcode: cast spell
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: power
COPY_EXISTING ~scrl1o.itm~ ~override~ // slow
              ~scrl1u.itm~ ~override~ // confusion
              ~scrl2f.itm~ ~override~ // cone of cold
              ~scrl56.itm~ ~override~ // cure serious wounds
              ~scrl58.itm~ ~override~ // free action
              ~scrl59.itm~ ~override~ // neutralize poison
              ~scrl5i.itm~ ~override~ // greater malison
              ~scrl61.itm~ ~override~ // cure critical wounds
              ~scrl62.itm~ ~override~ // flame strike
              ~scrl63.itm~ ~override~ // raise dead
              ~scrl70.itm~ ~override~ // color spray
              ~scrl7i.itm~ ~override~ // death spell
              ~scrl8p.itm~ ~override~ // prismatic spray
              ~scrl94.itm~ ~override~ // resist fear
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_BYTE  ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0   // power
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: effects target
COPY_EXISTING ~scrl1o.itm~ ~override~ // slow
              ~scrl1u.itm~ ~override~ // confusion
              ~scrl2f.itm~ ~override~ // cone of cold
              ~scrl5i.itm~ ~override~ // greater malison
              ~scrl70.itm~ ~override~ // color spray
              ~scrl7i.itm~ ~override~ // death spell
              ~scrl8p.itm~ ~override~ // prismatic spray
              ~scrl94.itm~ ~override~ // resist fear
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_BYTE  ("%fx_off%" + 0x02 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 1   // target: self
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: ability targeting
COPY_EXISTING ~scrl8y.itm~ ~override~ // protection from energy
              ~scrla8.itm~ ~override~ // contagion
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_BYTE  ("%abil_off%" + 0x0c + ("%index%" * 0x38)) 1 // target: caster (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: ability targeting
COPY_EXISTING ~scrl1o.itm~ ~override~ // slow
              ~scrl1u.itm~ ~override~ // confusion
              ~scrl2f.itm~ ~override~ // cone of cold
              ~scrl5i.itm~ ~override~ // greater malison
              ~scrl70.itm~ ~override~ // color spray
              ~scrl7i.itm~ ~override~ // death spell
              ~scrl8p.itm~ ~override~ // prismatic spray
              ~scrl94.itm~ ~override~ // resist fear
              ~scrla1.itm~ ~override~ // wizard eye
              ~scrla3.itm~ ~override~ // glitterdust
              ~scrla7.itm~ ~override~ // remove magic
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_BYTE  ("%abil_off%" + 0x0c + ("%index%" * 0x38)) 4 // target: any point in range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: ability targeting
COPY_EXISTING ~scrl7m.itm~ ~override~ // true sight
              ~scrl80.itm~ ~override~ // shocking grasp
              ~scrlaj.itm~ ~override~ // farsight
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_BYTE  ("%abil_off%" + 0x0c + ("%index%" * 0x38)) 5 // target: caster (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: range
COPY_EXISTING ~scrl5c.itm~ ~override~ // protection from lightning
              ~scrl5k.itm~ ~override~ // spirit armor
              ~scrl9h.itm~ ~override~ // maze
              ~scrla8.itm~ ~override~ // contagion
              ~scrlak.itm~ ~override~ // remove curse
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 1 // range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: range
COPY_EXISTING ~scrl2f.itm~ ~override~ // cone of cold
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 12 // range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: range
COPY_EXISTING // ~scrl70.itm~ ~override~ // color spray
              ~scrl8p.itm~ ~override~ // prismatic spray
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 15 // range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: range
COPY_EXISTING ~scrl8h.itm~ ~override~ // warding whip
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 20 // range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: range
COPY_EXISTING ~scrl6j.itm~ ~override~ // spell thrust
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 25 // range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: range
COPY_EXISTING ~scrl63.itm~ ~override~ // raise dead
              ~scrl76.itm~ ~override~ // infravision
              ~scrla1.itm~ ~override~ // wizard eye
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 30 // range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: range
COPY_EXISTING ~scrl5f.itm~ ~override~ // chaotic commands
              ~scrl62.itm~ ~override~ // flame strike
              ~scrl6v.itm~ ~override~ // lower resistance
              ~scrla7.itm~ ~override~ // remove magic
              ~scrlAI.itm~ ~override~ // ray of enfeeblement
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 40 // range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: range
COPY_EXISTING ~scrl5i.itm~ ~override~ // greater malison
              ~scrl7i.itm~ ~override~ // death spell
              ~scrl8c.itm~ ~override~ // stone to flesh
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 50 // range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: range
COPY_EXISTING ~scrla6.itm~ ~override~ // spook
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 60 // range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// protection from x scrolls not bypassing MR
COPY_EXISTING ~scrl03.itm~ ~override~
              ~scrl04.itm~ ~override~
              ~scrl05.itm~ ~override~
              ~scrl06.itm~ ~override~
              ~scrl08.itm~ ~override~
              ~scrl09.itm~ ~override~
              ~scrl15.itm~ ~override~
  SAY        0x08 #18094 // protection scroll
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  PATCH_IF ("%abil_num%" > 0) BEGIN // if abilities present, grabs last effect from last ability
    READ_SHORT ("%abil_off%" + 0x1e + (("%abil_num%" - 1) * 0x38)) "last_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (("%abil_num%" - 1) * 0x38)) "last_fx_idx"
    SET "fx_num" = ("%last_fx_num%" + "%last_fx_idx%")
  END
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    WRITE_BYTE ("%fx_off%" + 0x0d + ("%index%" * 0x30)) 3 // dispel/bypass resistance
  END
  BUT_ONLY_IF_IT_CHANGES

// dispel magic scroll uses priest description of spell
COPY_EXISTING ~scrl1e.itm~ ~override~
  SAY IDENTIFIED_DESC #45821 // mage dispel magic descript
  BUT_ONLY_IF_IT_CHANGES

// corrects BAM assignment for Conjure Lesser Fire Elemental scroll
COPY_EXISTING ~scrl6x.itm~ ~override~
  WRITE_ASCII 0x3a ~SPWI516A~  // inventory
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_ASCII ("%abil_off%" + 0x04 + ("%index%" * 0x38)) ~SPWI516A~
  END
  BUT_ONLY_IF_IT_CHANGES

// melf's minute meteors' name
COPY_EXISTING ~scrla5.itm~ ~override~
  SAY NAME2 #38588
  BUT_ONLY_IF_IT_CHANGES

// misc spellhold scrolls should be category books, only allow 1 in stack
COPY_EXISTING ~scrla9.itm~  ~override~ // waneev's note
              ~scrlaa.itm~  ~override~ // waneev's note
              ~scrlab.itm~  ~override~ // monkey balls
              ~scrlac.itm~  ~override~ // amnish dragoon soup
              ~scrlad.itm~  ~override~ // baldur's delight
              ~scrlaf.itm~  ~override~ // ruby racks
              ~scrlag.itm~  ~override~ // crom faeyr scroll
              ~scrlhp.itm~  ~override~ // harper note
              ~scrlick.itm~ ~override~ // illithid correspndence
              ~scrlmz.itm~  ~override~ // note from Mazzy Fentan
  WRITE_SHORT 0x1c 37 // book
  WRITE_SHORT 0x38  1 // 1 max stack
  BUT_ONLY_IF_IT_CHANGES

// more crom faeyr changes: unique icon, make magical
COPY_EXISTING ~scrlAG.itm~ ~override~
  READ_BYTE  0x18 "flags"
  WRITE_BYTE 0x18 ("%flags%" BOR 0b01000000)
  WRITE_ASCII 0x3a ~IMISC6F~ #8
  WRITE_ASCII 0x58 ~CMISC6F~ #8

// ray of enfeeblement lacks casting icon due to typo
COPY_EXISTING ~scrlai.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 147) BEGIN // learn spell
        WRITE_ASCII ("%abil_off%" + 0x04 + ("%index%" * 0x38)) ~spwi221a~ // icon (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// item requires lore
COPY_EXISTING ~shld17.itm~ ~override~ // buckler +1
  WRITE_SHORT 0x42 10
  BUT_ONLY_IF_IT_CHANGES

// small shields granting ac bonus v missiles and should not
COPY_EXISTING ~shld25.itm~  ~override~ // shield o' harmony
              ~shld28.itm~  ~override~ // small shield +2
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  FOR (index = 0; index < fx_num; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "opcode"
    READ_BYTE  ("%fx_off%" + 0x08 + ("%index%" * 0x30)) "flag"
    PATCH_IF (("%opcode%" = 0) AND (("%flag%" BAND 0b00000010) = 0b00000010)) BEGIN
      WRITE_LONG  ("%fx_off%" + 0x04 + ("%index%" * 0x30)) 0xfffffffd // -3
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// shield of harmony stuff could be dispelled
COPY_EXISTING ~shld25.itm~ ~override~
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  WHILE ("%fx_num%" > 0) BEGIN
    SET "fx_num" = ("%fx_num%" - 1)
    WRITE_BYTE ("%fx_off%" + 0x0d + ("%fx_num%" * 0x30)) 0 // no dispel/bypass resistance
  END
  BUT_ONLY_IF_IT_CHANGES
  
// slay living using wrong power level for cosmetic visuals
COPY_EXISTING ~slaylive.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks for magical ability header
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_BYTE  ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 141) BEGIN  // lighting effects
        WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // power level
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~slng03.itm~ ~override~ // sling +3
  WRITE_SHORT 0x42 45
  BUT_ONLY_IF_IT_CHANGES

// spellhaunts have extraneous protection from spell effects
COPY_EXISTING ~spellh01.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    READ_LONG   0x6a "fx_off"
    READ_SHORT  0x70 "fx_num"
    SET "delta" = 0
    FOR (index2 = 0 ; index2 < fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * "%index2%")) "opcode"
      PATCH_IF ("%opcode%" = 206) BEGIN
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * "%index2%")) "spell"
        PATCH_IF (("%spell%" STRING_COMPARE_CASE "sppr316" = 0) OR
                  ("%spell%" STRING_COMPARE_CASE "spwi315" = 0) OR
                  ("%spell%" STRING_COMPARE_CASE "spwi323" = 0)) BEGIN
          DELETE_BYTES ("%fx_off%" + (0x30 * "%index2%")) 0x30 // deletes it
          SET "fx_num" = "%fx_num%" - 1
          SET "delta" = "%delta%" - 1
          SET "index2" = "%index2%" - 1
        END
      END
    END
    WRITE_SHORT 0x70 "%fx_num%" // adjusts global fx number
    FOR (index = 0; index < abil_num; index = index + 1) BEGIN // adjusts fx indices on abilities
      READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
      WRITE_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "%abil_fx_idx%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// spear ranges
COPY_EXISTING ~sper02.itm~   ~override~ // spear +1
              ~sper03.itm~   ~override~ // spear +3 backbiter
              ~sper05.itm~   ~override~ // spear +2
              ~sper06.itm~   ~override~ // spear +3
              ~sper07.itm~   ~override~ // spear of the unicorn +2
              ~sper08.itm~   ~override~ // spear +3 impaler
              ~sper09.itm~   ~override~ // spear +1 halcyon
              ~sper10.itm~   ~override~ // spear of withering +4
              ~sper11.itm~   ~override~ // ixil's nail +4
              ~sper12.itm~   ~override~ // ixil's spike +6
              ~spermel.itm~  ~override~ // melissan's spear
              ~tasloiil.itm~ ~override~ // spear
              ~waspear.itm~  ~override~ // spear of kuldahar +3
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_BYTE  ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee
      WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 2 // range
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~staf06.itm~ ~override~ // staff-mace
  WRITE_SHORT 0x42 25
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~staf07.itm~ ~override~ // staff-spear +2
  WRITE_SHORT 0x42 65
  BUT_ONLY_IF_IT_CHANGES

// disables erroneous save effects. healing bypass MR, and fixes enchanment
// fix power levels
COPY_EXISTING ~staf10.itm~ ~override~
  WRITE_LONG 0x60 1 // enchantment level
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE ("%abil_off%" + ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // magical
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN // all healing effects should bypass MR
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 2 // power level
        WRITE_BYTE ("%fx_off%" + 0x0d + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 3 // dispel/bypass resistance
      END
    END
  END
  WHILE ("%fx_num%" > 0) BEGIN
    SET "fx_num" = ("%fx_num%" - 1)
    READ_BYTE ("%fx_off%" +        ("%fx_num%" * 0x30)) "type"
    PATCH_IF (("%type%" > 32) AND ("%type%" < 38)) BEGIN // save bonuses
      WRITE_BYTE ("%fx_off%" + 0x12 + ("%fx_num%" * 0x30)) 0 // probability: 0
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// SotM needs a lot of rebuilding--dispel effects don't work in melee, several effects are
// mistargeted or dispellable, etc.
COPY_EXISTING ~staf11.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  SET "loops" = "%fx_num%"
  WHILE ("%loops%" > 0) BEGIN
    SET "loops" = ("%loops%" - 1)
    READ_SHORT ("%fx_off%" +        ("%loops%" * 0x30)) "type"
    READ_LONG  ("%fx_off%" + 0x08 + ("%loops%" * 0x30)) "icon"
    PATCH_IF ("%type%" != 20) BEGIN // everything except invisibility
      WRITE_BYTE ("%fx_off%" + 0x0d + ("%loops%" * 0x30)) 0 // no dispel/bypass resistance
    END
    PATCH_IF (("%type%" = 139) OR ("%type%" = 141)) BEGIN // lighting effects, display string
      WRITE_BYTE ("%fx_off%" + 0x02 + ("%loops%" * 0x30)) 1 // target: self
    END ELSE
    PATCH_IF (("%type%" = 142) AND ("%icon%" = 28)) BEGIN // display protection from magic icon
      WRITE_LONG ("%fx_off%" + 0x08 + ("%loops%" * 0x30)) 52 // mind shield
    END
  END
  INSERT_BYTES  ("%fx_off%"       ) 0x30
    WRITE_SHORT ("%fx_off%"       ) 100 // protection from creatue type
    WRITE_BYTE  ("%fx_off%" + 0x02) 1   // target: self
    WRITE_LONG  ("%fx_off%" + 0x04) 9   // summoned demon
    WRITE_LONG  ("%fx_off%" + 0x08) 7   // gender
    WRITE_BYTE  ("%fx_off%" + 0x0c) 2   // instant/while equipped
    WRITE_BYTE  ("%fx_off%" + 0x12) 100 // probability
  INSERT_BYTES  ("%fx_off%"       ) 0x30
    WRITE_SHORT ("%fx_off%"       ) 219 // protection from creatue type
    WRITE_BYTE  ("%fx_off%" + 0x02) 1   // target: self
    WRITE_LONG  ("%fx_off%" + 0x04) 3   // mask_evil
    WRITE_LONG  ("%fx_off%" + 0x08) 8   // from align.ids
    WRITE_BYTE  ("%fx_off%" + 0x0c) 2   // instant/while equipped
    WRITE_BYTE  ("%fx_off%" + 0x12) 100 // probability
  SET "delta" = 2
  WRITE_SHORT 0x70 ("%fx_num%" + "%delta%") // updates global fx total
  SET "loops" = 0
  WHILE ("%loops%" < "%abil_num%") BEGIN
    SET "delta1" = 0
    READ_BYTE  ("%abil_off%" +        ("%loops%" * 0x38)) "type"
    READ_ASCII ("%abil_off%" + 0x04 + ("%loops%" * 0x38)) "icon"
    READ_SHORT ("%abil_off%" + 0x1e + ("%loops%" * 0x38)) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + ("%loops%" * 0x38)) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT  ("%abil_off%" + 0x20 + ("%loops%" * 0x38)) "%abil_fx_idx%"
    PATCH_IF ("%type%" = 1) BEGIN // melee
      DELETE_BYTES ("%fx_off%" + (0x30 * "%abil_fx_idx%")) (0x30 * "%abil_fx_num%") // removes all old effects
      SET "delta1" = (7 - "%abil_fx_num%")
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30   // new effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 139    // display string
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2      // target: preset target
        SAY         ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) #14056 // ~Dispel Effects~
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2      // not dispel/not bypass resistance
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%")) 1      // duration
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100    // probability
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 240  // remove icon 2
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2    // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 48   // feeblemind
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1    // instant/permanent until death
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2    // not dispel/not bypass resistance
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100  // probability
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 77   // cure feeblemindedness
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2    // target: preset target
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1    // instant/permanent until death
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2    // not dispel/not bypass resistance
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100  // probability
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30       // new effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 215        // play 3d effect
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2          // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 1          // play over target
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 3          // dispel/bypass resistance
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%")) 1          // duration
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100        // probability
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spdispma~ // vvc file
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30       // new effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 177        // use eff file
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2          // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 7          // illusionary
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 7          // gender
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1          // instant/permanent until death
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2          // not dispel/not bypass resistance
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100        // probability
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~destself~ // eff file
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 58   // dispel effects
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2    // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 30   // level
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 2    // use specific level
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1    // instant/permanent until death
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2    // not dispel/not bypass resistance
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100  // probability
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 141  // lighting effects
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2    // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 30   // level
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 4    // alteration: air
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1    // instant/permanent until death
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2    // not dispel/not bypass resistance
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100  // probability
    END
    PATCH_IF (("%type%" = 3) AND ("%icon%" STRING_COMPARE_CASE "spwi902b" = 0)) BEGIN // magical, spell trap
      DELETE_BYTES ("%fx_off%" + (0x30 * "%abil_fx_idx%")) (0x30 * "%abil_fx_num%") // removes all old effects
      SET "delta1" = (1 - "%abil_fx_num%")
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30     // new effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 146      // cast spell
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 1        // target: self
        WRITE_BYTE  ("%fx_off%" + 0x03 + (0x30 * "%abil_fx_idx%")) 9        // level
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 10       // cast at level
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 1        // cast instantly
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2        // not dispel/not bypass resistance
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%")) 2400     // duration
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100      // probability
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~staf11~ // spell
    END
    SET "abil_fx_num" = ("%abil_fx_num%" + "%delta1%")
    WRITE_SHORT  ("%abil_off%" + 0x1e + ("%loops%" * 0x38)) "%abil_fx_num%"
    SET "delta" = ("%delta%" + "%delta1%")
    SET "loops" = ("%loops%" + 1)
  END

// Staff of Power should actually cast Globe of Invulnerability,
// not some shabby facsimile. Two icons also incorrect.
COPY_EXISTING ~staf12.itm~   ~override~
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    WRITE_ASCIIT 0x3a ~istaf12~  // correcting inventory icon
    READ_LONG    0x64 "ho"
    READ_SHORT   0x68 "hc"
    READ_LONG    0x6a "eo"
    WRITE_ASCIIT ("ho" + (0x38 * 0x00) + 0x04) ~istaf12~ // melee icon
    WRITE_BYTE   ("ho" + (0x38 * 0x00) + 0x24) 0x00 // melee charges do not deplete
    FOR ("i" = 0; "i" < "hc"; "i" += 1) BEGIN
      READ_SHORT ("ho" + (0x38 * "i") + 0x1e) "ec"
      READ_SHORT ("ho" + (0x38 * "i") + 0x20) "ei"
      FOR ("j" = 0; "j" < "ec"; "j" += 1) BEGIN
        READ_SHORT ("eo" + (0x30 * ("j" + "ei")) + 0x00) "opcode"
        PATCH_IF (("opcode" = 0x66) AND ("ec" > 1)) THEN BEGIN
          SET "deleted" = ("ec" - 1)
          SET "ec" = 1
          WRITE_ASCII  ("ho" + (0x38 * "i" ) + 0x04)  ~spwi602b~ // Icon for Globe of Invulneribility
          WRITE_SHORT  ("ho" + (0x38 * "i" ) + 0x1e)  0x01 // one ability on this header
          DELETE_BYTES ("eo" + (0x30 * "ei") + 0x00)  (0x30 * "deleted")
          WRITE_SHORT  ("eo" + (0x30 * "ei") + 0x00)  0x92 // cast spell
          WRITE_LONG   ("eo" + (0x30 * "ei") + 0x04)  0x00 // use caster level
          WRITE_LONG   ("eo" + (0x30 * "ei") + 0x08)  0x00 // normal casting
          WRITE_BYTE   ("eo" + (0x30 * "ei") + 0x0c)  0x01 // timing: instant/permanent
          WRITE_BYTE   ("eo" + (0x30 * "ei") + 0x0d)  0x03 // dispel/bypass
          WRITE_LONG   ("eo" + (0x30 * "ei") + 0x0e)  0x00 // irrelevant duration
          WRITE_ASCIIT ("eo" + (0x30 * "ei") + 0x14)  ~spwi602~ // Globe of Invulneribility
          SET "k" = ("i" + 1)
          WHILE ("k" < "hc") BEGIN
            READ_SHORT  ("ho" + (0x38 * "k") + 0x20) "ci"
            WRITE_SHORT ("ho" + (0x38 * "k") + 0x20) ("ci" - "deleted")
            SET "k" += 1
          END // WHILE i3, repairing extended header indices
        END // PATCH_IF immunity to spell level located
      END // FOR index2, searching each header's abilities
    END // FOR index, searching extended headers
  END // PATCH_IF filesize sanity check
BUT_ONLY_IF_IT_CHANGES // no bad joke for the end of this patch

// stun on lightning-stun bypassing magical protections
COPY_EXISTING ~staf12.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks for magical ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // if magical
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_BYTE ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
        PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN  // cast spell
          WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // remove double interaction with spell protections
        END ELSE BEGIN
          WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 3 // power (lightning)
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// staff of the woodlands
COPY_EXISTING ~staf14.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  SET "new_fx" = 4
  WRITE_SHORT 0x70 ("%fx_num%" + "%new_fx%")
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE   ("%abil_off%" +        ("%abil_num%" * 0x38)) "type"
    READ_ASCII  ("%abil_off%" + 0x04 + ("%abil_num%" * 0x38)) "icon"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) ("%abil_fx_idx%" + "%new_fx%") // adding 4 global effects
    PATCH_IF (("%type%" = 3) AND ("%icon%" STRING_COMPARE_CASE "sppr204b" = 0)) BEGIN // magical, barkskin
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "opcode"
        PATCH_IF ("%opcode%" = 142) BEGIN // display portrait icon
          WRITE_BYTE ("%fx_off%" + 0x0d + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 1 // dispel/not bypass
        END
      END
    END
  END
  WHILE ("%fx_num%" > 0) BEGIN
    SET "fx_num" = ("%fx_num%" - 1)
    READ_SHORT ("%fx_off%" + ("%fx_num%" * 0x30)) "type"
    PATCH_IF ("%type%" = 0) BEGIN
      WRITE_LONG ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) 16 // set base AC to 3
    END
  END
  WHILE ("%new_fx%" > 0) BEGIN
    SET "new_fx" = ("%new_fx%" - 1)
    INSERT_BYTES  ("%fx_off%"       ) 0x30       // new effect
      WRITE_SHORT ("%fx_off%"       ) ("%new_fx%" + 33) // save bonuses
      WRITE_BYTE  ("%fx_off%" + 0x02) 1     // target:self
      WRITE_LONG  ("%fx_off%" + 0x04) 1     // value
      WRITE_BYTE  ("%fx_off%" + 0x0c) 2     // instant/while equipped
      WRITE_BYTE  ("%fx_off%" + 0x0d) 2     // not dispel/not bypass
      WRITE_BYTE  ("%fx_off%" + 0x12) 100   // probability
  END

// staff of the ram +6 missing listed 1d4 pierce damage
COPY_EXISTING ~staf22.itm~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  SET "delta" = 0
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // looks for melee ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "%abil_fx_idx%"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      WRITE_SHORT ("%abil_off%" + 0x1e + ("%index%" * 0x38)) ("%abil_fx_num%" +  1)
      INSERT_BYTES            ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30 // new effect
        WRITE_SHORT           ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 12   // opcode: damage
        WRITE_BYTE            ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30)) 2    // target: preset target
        WRITE_SHORT           ("%fx_off%" + 0x0a + ("%abil_fx_idx%" * 0x30)) 16   // piercing damage
        WRITE_BYTE            ("%fx_off%" + 0x0c + ("%abil_fx_idx%" * 0x30)) 1    // instant/perm
        WRITE_BYTE            ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30)) 100  // probability
        WRITE_LONG            ("%fx_off%" + 0x1c + ("%abil_fx_idx%" * 0x30)) 1    // num dice
        WRITE_LONG            ("%fx_off%" + 0x20 + ("%abil_fx_idx%" * 0x30)) 4    // dice size
      SET "delta" = ("%delta%" + 1)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// item requires lore
COPY_EXISTING ~sw1h06.itm~ ~override~ // long sword +2 varscona
  WRITE_SHORT 0x42 60
  BUT_ONLY_IF_IT_CHANGES

// arbane's sword has extraneous effects and prevents the wrong string
COPY_EXISTING ~sw1h27.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  SET "orig_fx" = "%fx_num%"
  SET "delta" = 0
  WHILE ("%fx_num%" > 0) BEGIN
    SET "fx_num" = ("%fx_num%" - 1)
    READ_SHORT ("%fx_off%" +        ("%fx_num%" * 0x30)) "type"
    READ_LONG  ("%fx_off%" + 0x04 + ("%fx_num%" * 0x30)) "string"
    READ_LONG  ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) "parameter"
    PATCH_IF (
               ("%type%" = 296) OR // immunity to specific animation
               (
                 ("%type%" = 101) AND // immunity to stun, entangle, grease, web
                 (
                   ("%parameter%" =  45) OR
                   ("%parameter%" = 154) OR
                   ("%parameter%" = 157) OR
                   ("%parameter%" = 158)
                 )
               ) OR (
                ("%type%" = 169) AND // prevent stun, web portrait icons
                (
                  ("%parameter%" =  55) OR
                  ("%parameter%" = 129)
                )
               ) OR (
                ("%type%" = 267) AND ("%string%" = 1280) // disable display string: stunned
               )
             ) BEGIN
      DELETE_BYTES ("%fx_off%" + ("%fx_num%" * 0x30)) 0x30 // delete effect
      SET "delta" = ("%delta%" - 1)
    END
  END
  WRITE_SHORT 0x70 ("%orig_fx%" + "%delta%")
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) ("%abil_fx_idx%" + "%delta%")
  END
  BUT_ONLY_IF_IT_CHANGES
  
// dragonslayer missing regeneration portrait icon
COPY_EXISTING ~sw1h32.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  SET "new_fx" = 1
  WRITE_SHORT 0x70 ("%fx_num%" + "%new_fx%")
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) ("%abil_fx_idx%" + "%new_fx%") // adding new global effects
  END
  INSERT_BYTES  ("%fx_off%"       ) 0x30 // new effect
    WRITE_SHORT ("%fx_off%"       ) 142  // display icon
    WRITE_BYTE  ("%fx_off%" + 0x02) 1    // target:self
    WRITE_LONG  ("%fx_off%" + 0x08) 87   // regeneration
    WRITE_BYTE  ("%fx_off%" + 0x0c) 2    // instant/while equipped
    WRITE_BYTE  ("%fx_off%" + 0x0d) 2    // not dispel/not bypass
    WRITE_BYTE  ("%fx_off%" + 0x12) 100  // probability

// adjatha's healing does not bypass MR and the sword has an incorrect strength requirement
COPY_EXISTING ~sw1h35.itm~ ~override~
  WRITE_BYTE 0x26 6
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT  ("%abil_off%" + ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        WRITE_BYTE ("%fx_off%" + 0x0d + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 0 // not dispel/bypass
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// flags wakizashi +1 as magical
COPY_EXISTING ~sw1h47.itm~ ~override~
  READ_BYTE "0x0018" "flags"
  WRITE_LONG "0x0018" (%flags% BOR 0b01000000)
  BUT_ONLY_IF_IT_CHANGES
  
// shazzelim's damage does not match description
COPY_EXISTING ~sw1h50.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE ("%abil_off%" + ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee
      WRITE_SHORT  ("%abil_off%" + 0x1a + ("%abil_num%" * 0x38)) 1
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// fix power levels
COPY_EXISTING ~sw1h51.itm~ ~override~ // celestial fury
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // cycle thru abilities
    READ_ASCII  (0x04 + "%abil_off%" + ("%index%" * 0x38)) "icon"
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "spwi106b" = 0) BEGIN // blindness
      READ_SHORT  (0x1e + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  (0x20 + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 1 // power level
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~sw1h55.itm~ ~override~
  WRITE_ASCII 0x3a ~isw1h55~ #8 // inventory icon
  BUT_ONLY_IF_IT_CHANGES

// Habib's mighty scimitar
COPY_EXISTING ~sw1h57.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT  ("%abil_off%" + ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 2) BEGIN // ranged
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "opcode"
        PATCH_IF ("%opcode%" = 111) BEGIN // create magical weapon
          WRITE_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 255 // create item in inventory
          WRITE_LONG  ("%fx_off%" + 0x04 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 1   // items in stack
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// foebane's LMD is bypassing MR
COPY_EXISTING ~sw1h63.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    SET "delta" = 0
    SET "loops" = 0
    WHILE ("%loops%" < "%abil_num%") BEGIN
      SET "delta1" = 0
      READ_BYTE  ("%abil_off%" +        ("%loops%" * 0x38)) "type"
      READ_SHORT ("%abil_off%" + 0x1e + ("%loops%" * 0x38)) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + ("%loops%" * 0x38)) "abil_fx_idx"
      SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
      WRITE_SHORT  ("%abil_off%" + 0x20 + ("%loops%" * 0x38)) "%abil_fx_idx%"
      PATCH_IF ("%type%" = 1) BEGIN // melee
        DELETE_BYTES ("%fx_off%" + (0x30 * "%abil_fx_idx%")) (0x30 * "%abil_fx_num%") // removes all old effects
        SET "delta1" = (1 - "%abil_fx_num%")
        INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30       // new effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 146        // cast spell
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2          // target: self
          WRITE_BYTE  ("%fx_off%" + 0x03 + (0x30 * "%abil_fx_idx%")) 1          // power
          WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 1          // cast at level
          WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 1          // cast instantly
          WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 1          // dispel/not bypass resistance
          WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%")) 1          // duration
          WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100        // probability
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spin104a~ // spell
      END
      SET "abil_fx_num" = ("%abil_fx_num%" + "%delta1%")
      WRITE_SHORT  ("%abil_off%" + 0x1e + ("%loops%" * 0x38)) "%abil_fx_num%"
      SET "delta" = ("%delta%" + "%delta1%")
      SET "loops" = ("%loops%" + 1)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// adds party-friendly harbinger for c6eric and c6eric3
COPY_EXISTING ~sw2h07.itm~ ~override/cdsw2h07.itm~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE ("%abil_off%" + (0x38 * "%abil_num%")) "melee"
    PATCH_IF ("%melee%" = 1) BEGIN
      READ_SHORT ("%abil_off%" + 0x1E + (0x38 * "%abil_num%")) "fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x38 * "%abil_num%")) "fx_idx"
      WHILE ("%fx_num%" > 0) BEGIN
        SET "fx_num" = ("%fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (0x30 * ("%fx_idx%" + "%fx_num%"))) "opcode"
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%fx_idx%" + "%fx_num%"))) "resource"
        PATCH_IF ((("%opcode%" = 146) AND ("spwi304" STRING_COMPARE_CASE "%resource%" = 0)) OR // cast fireball
                  (("%opcode%" = 174) AND ("misc_17b" STRING_COMPARE_CASE "%resource%" = 0))) BEGIN // play sound
          WRITE_BYTE ("%fx_off%" + 0x12 + (0x30 * ("%fx_idx%" + "%fx_num%"))) 0 // sets probability to 0
        END
      END
    END
  END

// Soul Reaver's THAC0 drain should bypass MR
COPY_EXISTING ~sw2h08.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT  ("%abil_off%" + ("%abil_num%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee
      READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_num%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x38)) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) "opcode"
        PATCH_IF ("%opcode%" = 54) BEGIN // THAC0 bonus
          WRITE_SHORT ("%fx_off%" + 0x0d + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 0 // no dispel/bypass MR
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Carsomyr's dispel on hit effect is incorrect
COPY_EXISTING ~sw2h10.itm~ ~override~
              ~sw2h19.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    SET "delta" = 0
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      READ_BYTE  ("%abil_off%" +        ("%index%" * 0x38)) "type"
      READ_SHORT ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
      WRITE_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "%abil_fx_idx%"
      PATCH_IF ("%type%" = 1) BEGIN // melee
        WRITE_BYTE  ("%abil_off%" + 0x01 + ("%index%" * 0x38)) 0  // no ID required for melee abilities
        WRITE_SHORT ("%abil_off%" + 0x16 + ("%index%" * 0x38)) 12 // sets dice size to 12
        DELETE_BYTES ("%fx_off%" + (0x30 * "%abil_fx_idx%")) (0x30 * "%abil_fx_num%") // removes all old effects
        SET "delta" = "%delta%" + 6 - "%abil_fx_num%"
        SET "abil_fx_num" = 6
        INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30   // new effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 139    // display string
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2      // target: preset target
          SAY         ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) #14056 // ~Dispel Effects~
          WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2      // not dispel/not bypass resistance
          WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%")) 1      // duration
          WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100    // probability
        INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 240  // remove icon 2
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2    // target: preset target
          WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 48   // feeblemind
          WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1    // instant/permanent until death
          WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2    // not dispel/not bypass resistance
          WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100  // probability
        INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 77   // cure feeblemindedness
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2    // target: preset target
          WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1    // instant/permanent until death
          WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2    // not dispel/not bypass resistance
          WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100  // probability
        INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30       // new effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 215        // play 3d effect
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2          // target: preset target
          WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 1          // play over target
          WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 3          // dispel/bypass resistance
          WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%")) 1          // duration
          WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100        // probability
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spdispma~ // vvc file
        INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30       // new effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 177        // use eff file
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2          // target: preset target
          WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 7          // illusionary
          WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 7          // gender
          WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1          // instant/permanent until death
          WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2          // not dispel/not bypass resistance
          WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100        // probability
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~destself~ // eff file
        INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 58   // dispel effects
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2    // target: preset target
          WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 30   // level
          WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 2    // use specific level
          WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1    // instant/permanent until death
          WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2    // not dispel/not bypass resistance
          WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100  // probability
      END ELSE
      PATCH_IF ("%type%" = 3) BEGIN // magic
        WRITE_BYTE  ("%abil_off%" + 0x01 + ("%index%" * 0x38)) 1  // ID required for magic abilities
        FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
          READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
          READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "spell"
          PATCH_IF (("%spell%" STRING_COMPARE_CASE "sppr303" = 0) AND ("%opcode%" = 146)) BEGIN // cast dispel magic
            WRITE_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) 148 // opcode: cast spell at point
            WRITE_BYTE  ("%fx_off%" + 0x02 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 1   // target self
            WRITE_BYTE  ("%abil_off%" + 0x0c + ("%index%" * 0x38)) 4 // change target on ability to any point in range
          END
        END
      END
      WRITE_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "%abil_fx_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// poison immunity for 'dead' trolls
COPY_EXISTING ~trolldie.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "new_fx" = 2
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  (0x20 + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_idx"
    WRITE_SHORT (0x20 + "%abil_off%" + ("%index%" * 0x38)) ("%abil_fx_idx%" + "%new_fx%")
  END
  WRITE_SHORT 0x70 ("%fx_num%" + "%new_fx%")
  INSERT_BYTES  ("%fx_off%" +        ("%fx_num%" * 0x30)) 0x30
    WRITE_SHORT ("%fx_off%" +        ("%fx_num%" * 0x30)) 101 // immunity to effect
    WRITE_BYTE  ("%fx_off%" + 0x02 + ("%fx_num%" * 0x30)) 1   // target self
    WRITE_LONG  ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) 25  // poison
    WRITE_BYTE  ("%fx_off%" + 0x0c + ("%fx_num%" * 0x30)) 2   // instant/while equipped
    WRITE_BYTE  ("%fx_off%" + 0x12 + ("%fx_num%" * 0x30)) 100 // probability 1
  INSERT_BYTES  ("%fx_off%" +        ("%fx_num%" * 0x30)) 0x30
    WRITE_SHORT ("%fx_off%" +        ("%fx_num%" * 0x30)) 173 // reduced damage from poison
    WRITE_BYTE  ("%fx_off%" + 0x02 + ("%fx_num%" * 0x30)) 1   // target self
    WRITE_LONG  ("%fx_off%" + 0x04 + ("%fx_num%" * 0x30)) 100 // damage
    WRITE_BYTE  ("%fx_off%" + 0x0c + ("%fx_num%" * 0x30)) 2   // instant/while equipped
    WRITE_BYTE  ("%fx_off%" + 0x12 + ("%fx_num%" * 0x30)) 100 // probability 1
  BUT_ONLY_IF_IT_CHANGES

// Wand of heavens claims 8d6 damage; actually does 12d4; fix flame strike animation while we're here
COPY_EXISTING ~ttwand.itm~ ~override~
              ~wand11.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_BYTE ("%abil_off%" + (0x38 * "%index%")) "type"
    PATCH_IF ("%type%" = 3) BEGIN // magical
      READ_SHORT  ("%abil_off%" + 0x1e + (0x38 * "%index%")) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + (0x38 * "%index%")) "abil_fx_idx"
      SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x38 * "%index%")) ("%abil_fx_idx%")
      WRITE_SHORT ("%abil_off%" + 0x2a + (0x38 * "%index%")) 1 // remove old flame strike projectile while we're here
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 12) BEGIN // damage
          WRITE_LONG ("%fx_off%" + 0x1c + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 4 // number of dice; only half since damage is split for save
          WRITE_LONG ("%fx_off%" + 0x20 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 6 // dice size
        END
        PATCH_IF ("%opcode%" = 215) BEGIN  // visuals should always play
          WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // power
        END ELSE BEGIN
          WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 5 // power (damage)
        END
      END
      PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "ttwand" = 0) BEGIN // wand11 already has play 3d effect opcodes
        SET "new_fx" = 2
        FOR (index3 = 0 ; index3 < new_fx ; index3 = index3 + 1) BEGIN
          INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // insert new effect
            WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 215  // play 3d effect
            WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2    // target: preset target
            WRITE_BYTE  ("%fx_off%" + 0x03 + (0x30 * "%abil_fx_idx%")) 4    // power = level
            WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1    // instant/permanent
            WRITE_LONG  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 1    // dispel/not bypass
            WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100  // probability
          PATCH_IF ("%index3%" = 0) BEGIN
            WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spflast2~    // vvc file
          END ELSE BEGIN
            WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spflsrin~    // vvc file
          END
        END
        SET "fx_delta" = "%fx_delta%" + "%new_fx%"
        SET "abil_fx_num" = "%abil_fx_num%" + "%new_fx%"
      END
      WRITE_SHORT  ("%abil_off%" + 0x1e + (0x38 * "%index%")) "%abil_fx_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// sensate amulet should increase max HP and not current & max HP to close healing loophole
COPY_EXISTING ~wa2amu.itm~   ~override~
              ~waspear.itm~ ~override~
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  WHILE ("%fx_num%" > 0) BEGIN
    SET "fx_num" = ("%fx_num%" - 1)
    READ_SHORT ("%fx_off%" +        ("%fx_num%" * 0x30)) "type"
    PATCH_IF ("%type%" = 18) BEGIN // max hp bonus
      WRITE_LONG ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) 3 // increase max without increasing current
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Vhailor's simulcrum ability could fail on MR check
COPY_EXISTING ~wa2helm.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE ("%abil_off%" + (0x38 * "%abil_num%")) "type"
    PATCH_IF ("%type%" = 3) BEGIN // magical
      READ_SHORT ("%abil_off%" + 0x1E + (0x38 * "%abil_num%")) "fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x38 * "%abil_num%")) "fx_idx"
      WHILE ("%fx_num%" > 0) BEGIN
        SET "fx_num" = ("%fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (0x30 * ("%fx_idx%" + "%fx_num%"))) "opcode"
        PATCH_IF ("%opcode%" = 146) BEGIN // cast spell
          WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%fx_idx%" + "%fx_num%"))) 0 // no dispel/bypass MR
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// since beholder lightning bolt is now a separate projectile, need to add protection in shield of balduran
COPY_EXISTING ~wa2shiel.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" + ("%index%" * 0x30)) "type"
    PATCH_IF ("%type%" = 197) BEGIN // looks for physical mirror
      READ_ASCII ("%fx_off%" + ("%index%" * 0x30)) "clone" (0x30) // clones effect
      SET "index" = "%fx_num%" // kills loop
      WRITE_SHORT  0x70 ("%fx_num%" + 1)
      INSERT_BYTES            ("%fx_off%"       ) 0x30
        WRITE_EVALUATED_ASCII ("%fx_off%"       ) "%clone%" #48
        WRITE_LONG            ("%fx_off%" + 0x08) ("%cdbehbla%" - 1)
      FOR (index3 = 0 ; index3 < abil_num ; index3 = index3 + 1) BEGIN
        READ_SHORT  ("%abil_off%" + 0x20 + ("%index3%" * 0x28)) "abil_fx_idx"
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%index3%" * 0x28)) ("%abil_fx_idx%" + "%new_fx%")
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// jerrod's mace has incorrect eff assignments
COPY_EXISTING ~wamace.itm~ ~override~
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  WHILE ("%fx_num%" > 0) BEGIN // looking through effects
    SET "fx_num" = ("%fx_num%" - 1)
    READ_SHORT   ("%fx_off%" +        ("%fx_num%" * 0x30)) "opcode"
    READ_ASCII   ("%fx_off%" + 0x14 + ("%fx_num%" * 0x30)) "eff"
    PATCH_IF (("%opcode%" = 177) AND ("%eff%" STRING_COMPARE_CASE "wamacea" = 0)) BEGIN // use eff
      WRITE_ASCII   ("%fx_off%" + 0x14 + ("%fx_num%" * 0x30)) ~damacea~ #8
    END ELSE
    PATCH_IF (("%opcode%" = 177) AND ("%eff%" STRING_COMPARE_CASE "wamaceb" = 0)) BEGIN // use eff
      WRITE_ASCII   ("%fx_off%" + 0x14 + ("%fx_num%" * 0x30)) ~damaceb~ #8
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// wand o' heavens has no lore value
COPY_EXISTING ~wand11.itm~ ~override~
  WRITE_SHORT 0x42 50
  BUT_ONLY_IF_IT_CHANGES

// wand of wonder has incorrect max charges; causes it to be sold for 5x its value
COPY_EXISTING ~wand12.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_BYTE ("%abil_off%" +        ("%index%" * 0x38)) "abiltype"
    PATCH_IF ("%abiltype%" = 3) BEGIN // magical
      WRITE_SHORT ("%abil_off%" + 0x22 + ("%index%" * 0x38)) 50
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// wand of cloudkill bypassing MR
COPY_EXISTING ~wand13.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE ("%abil_off%" + (0x38 * "%abil_num%")) "type"
    PATCH_IF ("%type%" = 3) BEGIN // magical
      READ_SHORT ("%abil_off%" + 0x1E + (0x38 * "%abil_num%")) "fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x38 * "%abil_num%")) "fx_idx"
      WHILE ("%fx_num%" > 0) BEGIN
        SET "fx_num" = ("%fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (0x30 * ("%fx_idx%" + "%fx_num%"))) "opcode"
        PATCH_IF ("%opcode%" = 12) BEGIN // damage
          WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%fx_idx%" + "%fx_num%"))) 1 // dispel/not bypass MR
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// sling of everard is allowing strength bonus
COPY_EXISTING ~wasling.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_BYTE ("%abil_off%" + (0x38 * "%abil_num%")) "type"
    PATCH_IF ("%type%" = 2) BEGIN // ranged
//      WRITE_SHORT ("%abil_off%" + 0x26 + (0x1a * "%abil_num%")) 3 // damage bonus
      WRITE_SHORT ("%abil_off%" + 0x26 + (0x38 * "%abil_num%")) 0 // no strength bonus
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// two xbows lacking min str requirements
COPY_EXISTING ~xbow15.itm~ ~override~
              ~xbow16.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x26 8
  END
  BUT_ONLY_IF_IT_CHANGES

//Comprehensive batch of weapon-speed fixes (Wisp)
ACTION_CLEAR_ARRAY fl#speed_item
ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#speed_item BEGIN
  AEGIS    => 1  //Aegis Fang
  AEGIS2   => 1  //Aegis Fang
  AX1H07   => 7  //Bala's Axe
  BOW25    => 4  //Long Bow +3
  DART01   => 2  //Dart
  MISC4U   => 2  //Embarl's Dagger
  MISC9Q   => 5  //Scimitar
  SPER03   => 6  //Spear +3, Backbiter
  SPER12   => 1  //Ixil's Spike +6
  STAF04   => 4  //Quarterstaff
  STAF05   => 1  //Staff of Striking
//  STAF11   => 3  //Staff of the Magi
  STAF13   => 2  //Staff of Thunder and Lightning
  SW1H26   => 2  //Ilbratha +1
  SW1H53   => 4  //Sword of Flame +1
  SW1H69   => 1  //Spectral Brand +5
  SW2H03   => 10 //Cursed Berserking Sword +3
END

ACTION_PHP_EACH fl#speed_item AS item => speed BEGIN
  ACTION_IF FILE_EXISTS_IN_GAME "%item%.itm" BEGIN
    COPY_EXISTING "%item%.itm" override
      READ_LONG 0x64 ao
      FOR (i=0;i<SHORT_AT 0x68;++i) BEGIN
        READ_BYTE ao + 0x38*i type
        PATCH_IF type = 1 OR type = 2 OR type = 4 BEGIN
          WRITE_SHORT ao + 0x38*i + 0x12 speed
        END
      END
    BUT_ONLY
  END
END

//Comprehensive (except for bow06) batch of item-weight fixes (Wisp)
ACTION_CLEAR_ARRAY fl#weight_item
ACTION_DEFINE_ASSOCIATIVE_ARRAY fl#weight_item BEGIN
  BRAC15   => 2  //Bracers of Defense AC 3
  CLCK13   => 4  //Traveller's Robe
  DAGG05   => 1  //Throwing Dagger
  DWCHAN02 => 12 //Drow Adamantine Chain +5
  DWSHLD01 => 7  //Drow Shield +3
  SHLD23   => 3  //Fortress Shield +3
  SPER06   => 3  //Spear +3
  STAF04   => 4  //Quarterstaff
  STAF08   => 4  //Martial Staff +3
  STAF10   => 4  //Staff of Curing
  STAF11   => 4  //Staff of the Magi
  STAF13   => 4  //Staff of Thunder and Lightning
  STAF20   => 3  //Staff of Rynn +4
  SW1H15   => 4  //Scimitar +3, Frostbrand
  SW1H16   => 4  //Scimitar +5, Defender
  SW1H23   => 4  //Scimitar +2, Rashad's Talon
  SW1H32   => 3  //Dragonslayer
  SW2H03   => 15 //Cursed Berserking Sword +3
  SW2H12   => 10 //Flame Of The North
  SW2H15   => 15 //Silver Sword
END

ACTION_PHP_EACH fl#weight_item AS item => weight BEGIN
  ACTION_IF FILE_EXISTS_IN_GAME "%item%.itm" BEGIN
    COPY_EXISTING "%item%.itm" override
      WRITE_LONG 0x4c weight
    BUT_ONLY
  END
END

//Correcting the damage of Bruenor's axe to be in line with the description (Wisp)
COPY_EXISTING bruenaxe.itm override
  READ_LONG 0x64 ao
  FOR (i = 0; i < SHORT_AT 0x68; ++i) BEGIN
    WRITE_BYTE ao + 0x38 * i + 0x18 1 //1dN
  END
BUT_ONLY

// ammo with prof 0 removes non-prof penalty
COPY_EXISTING ~arow01.itm~   ~override~ // arrows - arrows w/o shortbow prof
              ~arow02.itm~   ~override~ // arrows +1 - arrows w/o shortbow prof
              ~arow03.itm~   ~override~ // arrow of slaying - arrows w/o shortbow prof
              ~arow04.itm~   ~override~ // acid arrows - arrows w/o shortbow prof
              ~arow05.itm~   ~override~ // arrow of biting - arrows w/o shortbow prof
              ~arow06.itm~   ~override~ // arrows of detonation  - arrows w/o shortbow prof
              ~arow07.itm~   ~override~ // arrows of dispelling - arrows w/o shortbow prof
              ~arow08.itm~   ~override~ // arrow of fire - arrows w/o shortbow prof
              ~arow09.itm~   ~override~ // arrows of ice - arrows w/o shortbow prof
              ~arow10.itm~   ~override~ // arrows of piercing - arrows w/o shortbow prof
              ~arow11.itm~   ~override~ // arrow +2 - arrows w/o shortbow prof
              ~arow14.itm~   ~override~ // poisoned arrow - arrows w/o shortbow prof
              ~arow15.itm~   ~override~ // arrow +3 - arrows w/o shortbow prof
              ~arow1a.itm~   ~override~ // arrow +2 - arrows w/o shortbow prof
              ~bolt01.itm~   ~override~ // bolt - bolts w/o xbow prof
              ~bolt02.itm~   ~override~ // bolt +1 - bolts w/o xbow prof
              ~bolt03.itm~   ~override~ // bolt of lightning - bolts w/o xbow prof
              ~bolt04.itm~   ~override~ // bolt of biting  - bolts w/o xbow prof
              ~bolt05.itm~   ~override~ // bolt of polymorphing - bolts w/o xbow prof
              ~bolt06.itm~   ~override~ // bolt +2 - bolts w/o xbow prof
              ~bolt07.itm~   ~override~ // flasher master bruiser mate - bolts w/o xbow prof
              ~bolt08.itm~   ~override~ // blessed bolt - bolts w/o xbow prof
              ~bolt09.itm~   ~override~ // bolt +3 - bolts w/o xbow prof
              ~bull01.itm~   ~override~ // bullet - bullet w/o sling prof
              ~bull02.itm~   ~override~ // bullet +1 - bullet w/o sling prof
              ~bull03.itm~   ~override~ // bullet +2 - bullet w/o sling prof
              ~bull04.itm~   ~override~ // sunstone bullet +1 - bullet w/o sling prof
              ~bull05.itm~   ~override~ // bullet +3 - bullet w/o sling prof
              ~bull06.itm~   ~override~ // bullet +4 - bullet w/o sling prof
              ~dwbolt01.itm~ ~override~ // drow bolt of sleep - bolts w/o xbow prof
              ~dwbolt02.itm~ ~override~ // drow bolt of stunning - bolts w/o xbow prof
              ~dwbolt03.itm~ ~override~ // drow bolt +1 - bolts w/o xbow prof
              ~flam01.itm~   ~override~ // flamethrower - bolts w/o xbow prof
              ~frag01.itm~   ~override~ // frag grenade - bolts w/o xbow prof
              ~frosty.itm~   ~override~ // dr. freeze death ray - bolts w/o xbow prof
              ~iarow01.itm~  ~override~ // arrows - arrows w/o shortbow prof
              ~kuobolt.itm~  ~override~ // kuo-toa bolts - bolts w/o xbow prof
              ~kuobolt2.itm~ ~override~ // kuo-toa bolts - bolts w/o xbow prof
              ~kuobolt3.itm~ ~override~ // kuo-toa bolts - bolts w/o xbow prof
              ~laser.itm~    ~override~ // laser - bolts w/o xbow prof
              ~light.itm~    ~override~ // wand of magic missiles - bolts w/o xbow prof
              ~puls01.itm~   ~override~ // wand of magic missiles - bolts w/o xbow prof
              ~puls02.itm~   ~override~ // wand of magic missiles - bolts w/o xbow prof
              ~quiv01.itm~   ~override~ // arrows - arrows w/o shortbow prof
              ~quiver01.itm~ ~override~ // quiver of plenty +1 - arrows w/o shortbow prof
              ~quiver02.itm~ ~override~ // case of plenty +1 - bolts w/o xbow prof
              ~quiver03.itm~ ~override~ // quiver of plenty +2 - arrows w/o shortbow prof
              ~quiver04.itm~ ~override~ // case of plenty +2 - bolts w/o xbow prof
              ~quiver05.itm~ ~override~ // bag of plenty +1 - bullet w/o sling prof
              ~quiver06.itm~ ~override~ // bag of plenty +2 - bullet w/o sling prof
              ~sahbolt.itm~  ~override~ // paralytic bolt - bolts w/o xbow prof
              ~secret02.itm~ ~override~ // pulse ammunition - bolts w/o xbow prof
              ~secret03.itm~ ~override~ // frag grenade - bolts w/o xbow prof
              ~secret04.itm~ ~override~ // scorcher ammunition - bolts w/o xbow prof
  READ_SHORT 0x1c "itm_type" ELSE 0
  PATCH_IF (("%itm_type%" = 14) OR    // bullets
            ("%itm_type%" = 31) OR    // bolts
            ("%itm_type%" = 5)) BEGIN // arrows w/o shortbow prof
    WRITE_BYTE 0x31 2 // non-zero prof; doesn't matter
  END
  BUT_ONLY_IF_IT_CHANGES

// two clubs using thrusting animations; other eight do not
COPY_EXISTING ~blun01.itm~ ~override~
              ~blun31.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      READ_BYTE ("%abil_off%" + ("%index%" * 0x38)) "type"
      PATCH_IF ("%type%" = 1) BEGIN // melee
        WRITE_SHORT ("%abil_off%" + 0x2c + ("%index%" * 0x38)) 50 // Overhead
        WRITE_SHORT ("%abil_off%" + 0x2e + ("%index%" * 0x38)) 50 // Backhand
        WRITE_SHORT ("%abil_off%" + 0x30 + ("%index%" * 0x38))  0 // Thrusting
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// various items stun but use held icon
COPY_EXISTING ~dart03.itm~   ~override~
              ~dartmel.itm~  ~override~
              ~paracarr.itm~ ~override~
              ~paraghas.itm~ ~override~
              ~paraghou.itm~ ~override~
              ~wand04.itm~   ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "icon"
      PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 13)) BEGIN // display 'held' icon
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 55 // stun
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// int drain immunity should also suppress strings, icon (revised by Wisp)
COPY_EXISTING ~ipsion.itm~ ~override~
  LPF ADD_ITEM_EQEFFECT
    INT_VAR
      opcode = 169             //prevent portrait icon
      target = 1
      parameter2 = 86          //icon: int drain
      timing = 2
  END
  PATCH_FOR_EACH parameter1 IN
                 14021         // string: int modification
                 32089         // string: devour brain
  BEGIN
    LPF ADD_ITEM_EQEFFECT
      INT_VAR
        opcode = 267           //protection from display string 
        target = 1
        parameter1
        timing = 2
    END
  END
BUT_ONLY

// book of infinite spells; see all misc3a*.itm
COPY_EXISTING ~misc3a.itm~ ~override/misc3aa.itm~ // zero lore copy
              ~misc3a.itm~ ~override/misc3a.itm~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "%DEST_RES%" = 0) BEGIN // original book
    WRITE_SHORT 0x42 80 // lore
  END
  SET "abil_length" = 0x38
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    WRITE_BYTE  ("%abil_off%" + 0x01 + ("%abil_length%" * "%index%")) 1 // identify to use
    READ_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "icon"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    // page turning
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "iscrl02" = 0) BEGIN
      WRITE_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "imisc3a" #8
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "resref"
        PATCH_IF (("%opcode%" = 122) AND ("%resref%" STRING_COMPARE_CASE "misc3a" = 0)) BEGIN // change to original book
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~misc3aa~ #8 // new item
        END ELSE
        PATCH_IF ("%opcode%" = 123) BEGIN // remove item
          WRITE_ASCIIE ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~%DEST_RES%~ // self
        END ELSE
        PATCH_IF ("%opcode%" = 174) BEGIN // play sound
          WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // sound should bypass MR
        END
      END
    END
    // spell casting
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "imisc3a" = 0) BEGIN
      WRITE_BYTE  ("%abil_off%" + 0x0c + ("%abil_length%" * "%index%"))  4 // target: any point within range
      WRITE_SHORT ("%abil_off%" + 0x0e + ("%abil_length%" * "%index%")) 30 // range
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 146) BEGIN // cast spell
          WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 148
          WRITE_SHORT ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 1 // target: self
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// book of infinite spells; see all misc3a*.itm
COPY_EXISTING ~misc3a1.itm~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    WRITE_BYTE  ("%abil_off%" + 0x01 + ("%abil_length%" * "%index%")) 1 // identify to use
    READ_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "icon"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    // page turning
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "iscrl02" = 0) BEGIN
      WRITE_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "imisc3a" #8
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "resref"
        PATCH_IF (("%opcode%" = 122) AND ("%resref%" STRING_COMPARE_CASE "misc3a" = 0)) BEGIN // change to original book
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~misc3aa~ #8 // new item
        END
      END
    END
    // spell casting
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "imisc3a" = 0) BEGIN
      WRITE_SHORT ("%abil_off%" + 0x0e + ("%abil_length%" * "%index%"))  1 // range
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 146) BEGIN // cast spell
          WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // sound should bypass MR
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// book of infinite spells; see all misc3a*.itm
COPY_EXISTING ~misc3a2.itm~ ~override~
              ~misc3a4.itm~ ~override~
              ~misc3a5.itm~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    WRITE_BYTE  ("%abil_off%" + 0x01 + ("%abil_length%" * "%index%")) 1 // identify to use
    READ_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "icon"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    // page turning
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "iscrl02" = 0) BEGIN
      WRITE_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "imisc3a" #8
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "resref"
        PATCH_IF (("%opcode%" = 122) AND ("%resref%" STRING_COMPARE_CASE "misc3a" = 0)) BEGIN // change to original book
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~misc3aa~ #8 // new item
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// book of infinite spells; see all misc3a*.itm
COPY_EXISTING ~misc3a3.itm~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    WRITE_BYTE  ("%abil_off%" + 0x01 + ("%abil_length%" * "%index%")) 1 // identify to use
    READ_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "icon"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    // page turning
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "iscrl02" = 0) BEGIN
      WRITE_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "imisc3a" #8
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "resref"
        PATCH_IF (("%opcode%" = 122) AND ("%resref%" STRING_COMPARE_CASE "misc3a" = 0)) BEGIN // change to original book
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~misc3aa~ #8 // new item
        END
      END
    END
    // spell casting
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "imisc3a" = 0) BEGIN
      WRITE_BYTE  ("%abil_off%" + 0x0c + ("%abil_length%" * "%index%"))  5 // target: caster
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 146) BEGIN // cast spell
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 1 // target: self
//          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~spwi609~ #8 // priest to mage version ?
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// book of infinite spells; see all misc3a*.itm
COPY_EXISTING ~misc3a6.itm~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    WRITE_BYTE  ("%abil_off%" + 0x01 + ("%abil_length%" * "%index%")) 1 // identify to use
    READ_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "icon"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    // page turning
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "iscrl02" = 0) BEGIN
      WRITE_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "imisc3a" #8
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "resref"
        PATCH_IF (("%opcode%" = 122) AND ("%resref%" STRING_COMPARE_CASE "misc3a" = 0)) BEGIN // change to original book
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~misc3aa~ #8 // new item
        END
      END
    END
    // spell casting
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "imisc3a" = 0) BEGIN
      WRITE_BYTE  ("%abil_off%" + 0x0c + ("%abil_length%" * "%index%"))  4 // target: any point within range
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 146) BEGIN // cast spell
          WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 148
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// book of infinite spells; see all misc3a*.itm
COPY_EXISTING ~misc3a7.itm~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    WRITE_BYTE  ("%abil_off%" + 0x01 + ("%abil_length%" * "%index%")) 1 // identify to use
    READ_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "icon"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    // page turning
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "iscrl02" = 0) BEGIN
      WRITE_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "imisc3a" #8
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "resref"
        PATCH_IF (("%opcode%" = 122) AND ("%resref%" STRING_COMPARE_CASE "misc3a" = 0)) BEGIN // change to original book
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~misc3aa~ #8 // new item
        END
      END
    END
    // spell casting
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "imisc3a" = 0) BEGIN
      WRITE_BYTE  ("%abil_off%" + 0x0c + ("%abil_length%" * "%index%"))  4 // target: any point within range
      WRITE_SHORT ("%abil_off%" + 0x0e + ("%abil_length%" * "%index%")) 30 // range
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 146) BEGIN // cast spell
          WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 148
          WRITE_SHORT ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 1 // target: self
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// book of infinite spells; see all misc3a*.itm
COPY_EXISTING ~misc3a8.itm~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    WRITE_BYTE  ("%abil_off%" + 0x01 + ("%abil_length%" * "%index%")) 1 // identify to use
    READ_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "icon"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    // page turning
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "iscrl02" = 0) BEGIN
      WRITE_ASCII  ("%abil_off%" + 0x04 + ("%abil_length%" * "%index%")) "imisc3a" #8
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "resref"
        PATCH_IF (("%opcode%" = 122) AND ("%resref%" STRING_COMPARE_CASE "misc3a" = 0)) BEGIN // change to original book
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~misc3aa~ #8 // new item
        END
      END
    END
    // spell casting
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "imisc3a" = 0) BEGIN
      WRITE_SHORT ("%abil_off%" + 0x0e + ("%abil_length%" * "%index%")) 30 // range
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// rod o' lordly might sub-items created with no charges
COPY_EXISTING ~rodmace.itm~  ~override~
              ~rodspear.itm~ ~override~
              ~rodsword.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks for melee ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // magical ability check
      WRITE_BYTE   ("%abil_off%" + 0x24 + ("%index%" * 0x38)) 1 // vanishes
      WRITE_BYTE   ("%abil_off%" + 0x27 + ("%index%" * 0x38)) 0 // recharge: unknown
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// protection from x scrolls should be visible range
COPY_EXISTING ~scrl03.itm~ ~override~
              ~scrl04.itm~ ~override~
              ~scrl05.itm~ ~override~
              ~scrl06.itm~ ~override~
              ~scrl07.itm~ ~override~
              ~scrl08.itm~ ~override~
              ~scrl09.itm~ ~override~
              ~scrl15.itm~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 30 // range correction
  END
  BUT_ONLY_IF_IT_CHANGES

// daystar fix: does 2d8 + 6 vs. evil undead; should be 2d8 + 8
// harder than usual because of all overlapping effs; see also daystar1.eff, daystar2.eff
// move daystar1 to melee header, apply only v undead
COPY_EXISTING ~sw1h31.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "type"
    READ_ASCII ("%fx_off%" + 0x14 + ("%index%" * 0x30)) "eff_file"
    PATCH_IF (("%type%" = 177) AND ("daystar1" STRING_COMPARE_CASE "%eff_file%" = 0)) BEGIN
      DELETE_BYTES ("%fx_off%" +        ("%index%" * 0x30)) 0x30 // delete effect
      SET "fx_num" = ("%fx_num%" - 1)
      SET "fx_delta" = ("%fx_delta%" - 1)
      SET "index" = ("%index%" - 1)
    END
  END
  WRITE_SHORT 0x70 "%fx_num%"
  FOR (index2 = 0 ; index2 < abil_num ; index2 = index2 + 1) BEGIN
    READ_BYTE   ("%abil_off%" +        ("%index2%" * 0x38)) "type"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index2%" * 0x38)) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%index2%" * 0x38)) "%abil_fx_idx%"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index2%" * 0x38)) "abil_fx_num"
      WRITE_SHORT ("%abil_off%" + 0x1e + ("%index2%" * 0x38)) ("%abil_fx_num%" + 1)
      INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30))       0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30))        177 // use eff
        WRITE_BYTE  ("%fx_off%" + 0x02 + ("%abil_fx_idx%" * 0x30))          2 // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x04 + ("%abil_fx_idx%" * 0x30))          4 // UNDEAD from...
        WRITE_LONG  ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30))          3 // general.ids
        WRITE_BYTE  ("%fx_off%" + 0x0c + ("%abil_fx_idx%" * 0x30))          1 // instant/permanent
        WRITE_BYTE  ("%fx_off%" + 0x12 + ("%abil_fx_idx%" * 0x30))        100 // probability
        WRITE_ASCII ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~daystar1~ // resref
      SET "fx_delta" = ("%fx_delta%" + 1)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// dragonslayer fix: dragon damage gets an extra +2
COPY_EXISTING ~sw1h32.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "type"
    READ_ASCII ("%fx_off%" + 0x14 + ("%index%" * 0x30)) "eff_file"
    PATCH_IF (("%type%" = 177) AND ("sw1h32a" STRING_COMPARE_CASE "%eff_file%" = 0)) BEGIN
      DELETE_BYTES ("%fx_off%" +        ("%index%" * 0x30)) 0x30 // delete effect
      SET "fx_num" = ("%fx_num%" - 1)
      SET "fx_delta" = ("%fx_delta%" - 1)
      SET "index" = ("%index%" - 1)
    END
  END
  WRITE_SHORT 0x70 "%fx_num%"
  FOR (index2 = 0 ; index2 < abil_num ; index2 = index2 + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index2%" * 0x38)) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%index2%" * 0x38)) "%abil_fx_idx%"
  END
  BUT_ONLY_IF_IT_CHANGES

// mage's detect evil scroll using priest spell description
COPY_EXISTING ~scrl86.itm~ ~override~
  SAY 0x54 #12219
  BUT_ONLY_IF_IT_CHANGES

// wand of cursing should cause deafness but is not
COPY_EXISTING ~wand19.itm~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "string"
      PATCH_IF ("%opcode%" = 38) BEGIN // blindness
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // clone fx
        // insert protection from mage version of MM
        INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30         // insert new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%"    // clones portrait icon
          WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 80           // opcode: deafness
        SET "fx_delta" = "%fx_delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
        SET "index2" = "%index2%" + 1
      END
      PATCH_IF (("%opcode%" = 139) AND ("%string%" = 14002)) BEGIN // display 'silence' string
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // clone fx
        // insert protection from mage version of MM
        INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30         // insert new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%"    // clones display string
          WRITE_LONG            ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 54318        // string 'deaf'
        SET "fx_delta" = "%fx_delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
        SET "index2" = "%index2%" + 1
      END
      WRITE_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

/// The Priest of Helm's Sword of Seeking should do 2d4 damage, not 1d8 (by Wisp)
COPY_EXISTING ~sw1hseek.itm~ ~override~
  READ_LONG   0x64 abil_off ELSE 0
  READ_SHORT  0x68 abil_num ELSE 0
  FOR (index = 0; index < abil_num; index += 1) BEGIN
    READ_SHORT (%abil_off% + (0x38 * %index%)) type
    PATCH_IF %type% = 1 BEGIN //Melee ability check
      WRITE_SHORT (%abil_off% + 0x16 + (0x38 * %index%)) 4 //Die size
      WRITE_SHORT (%abil_off% + 0x18 + (0x38 * %index%)) 2 //Number of dice
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// The Shield spell and the Shield Amulet should properly protect the recipient against TRAP_MAGIC_MISSILE (see also spwi114.spl) (Nythrun and aVENGER)
COPY_EXISTING ~amul15.itm~   ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "param2"
      PATCH_IF (("%opcode%" = "142") AND ("%param2%" = "15")) BEGIN // display shield icon
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // clone fx
        INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30         // insert new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%"    // clones effect
          WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "206"        // effect #206: Protection from Spell
          WRITE_LONG            ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) "0"          // param1: 0 (empty strref)
          WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) "0"          // param2: 0
          WRITE_ASCII           ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spwi003~ #8 // resref: SPWI003 (TRAP_MAGIC_MISSILE)
        SET "fx_delta" = "%fx_delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
        WRITE_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
        SET "index2" = "%abil_fx_num%" // kills loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// The Stiletto of Demarchess +2 and the Dart of Stunning should display the appropriate strings upon holding/stunning the target (Wisp)
COPY_EXISTING ~dagg17.itm~ ~override~ // Stiletto of Demarchess +2
              ~dart03.itm~ ~override~ // Dart of Stunning
  READ_LONG  0x64 abil_off ELSE 0
  READ_SHORT 0x68 abil_num ELSE 0
  READ_LONG  0x6a fx_off   ELSE 0
  FOR (index = 0; index < abil_num; index += 1) BEGIN
    READ_SHORT (%abil_off% + 0x1e + (0x38 * %index%)) abil_fx_num
    READ_SHORT (%abil_off% + 0x20 + (0x38 * %index%)) abil_fx_idx
    FOR (index2 = 0; index2 < abil_fx_num; index2 += 1) BEGIN
      READ_SHORT   (%fx_off% + 0x30 * (%abil_fx_idx% + %index2%)) opcode
      PATCH_IF %opcode% = 109 BEGIN //Opcode is Hold
        READ_ASCII (%fx_off% + 0x30 * (%abil_fx_idx% + %index2%)) clone (0x30)
        INSERT_BYTES   (%fx_off%       + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 0x30
          WRITE_ASCIIE (%fx_off%       + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) "%clone%" //Clones effect
          WRITE_SHORT  (%fx_off%       + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 139 //Display string
          WRITE_LONG   (%fx_off% + 0x4 + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 14102 //Held
          WRITE_LONG   (%fx_off% + 0x8 + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 0 // param2: 0
          WRITE_BYTE   (%fx_off% + 0xc + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 1 //Instant/Permanent
          WRITE_LONG   (%fx_off% + 0xe + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 0 // duration: 0
        SET abil_fx_num += 1
        SET index2 = %abil_fx_num%
      END
      PATCH_IF %opcode% = 45  BEGIN //Opcode is Stun
        READ_ASCII (%fx_off% + 0x30 * (%abil_fx_idx% + %index2%)) clone (0x30)
        INSERT_BYTES   (%fx_off%       + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 0x30
          WRITE_ASCIIE (%fx_off%       + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) "%clone%" //Clones effect
          WRITE_SHORT  (%fx_off%       + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 139 //Display string
          WRITE_LONG   (%fx_off% + 0x4 + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 1280 //Stunned
          WRITE_BYTE   (%fx_off% + 0xc + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 1 //Instant/Permanent
          WRITE_LONG   (%fx_off% + 0xe + 0x30 * (%abil_fx_idx% + %abil_fx_num%)) 0 // duration: 0
        SET abil_fx_num += 1
        SET index2 = %abil_fx_num%
      END
      WRITE_SHORT (%abil_off% + 0x1e + (0x38 * %index%)) %abil_fx_num%
    END
  END
  BUT_ONLY

// The Death Spell cast by the Skull of Death should not require a saving throw nor should it allow two magic resistance and power level checks (aVENGER)
COPY_EXISTING ~HELM17.ITM~   ~override~ // Skull of Death
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // looks for magical ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 3) BEGIN // if magical
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
        PATCH_IF ("%opcode%" = 146) BEGIN  // effect #146 - cast spell at target
          WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // power level: 0 (the power level is handled within the spell itself)
          WRITE_BYTE ("%fx_off%" + 0x0d + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // non-magical (MR is handled within the spell itself)
          WRITE_LONG ("%fx_off%" + 0x24 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // saving throw: none
        END
      END
    END
  END
BUT_ONLY_IF_IT_CHANGES

// Runehammer (both versions) should only allow a single saving throw for its undead slaying effect (aVENGER)
ACTION_FOR_EACH ~file~ IN                                                                       // for each of the following files
              ~HAMM10~                                                                          // Runehammer +4
              ~HAMM11~                                                                          // Runehammer +5
BEGIN                                                                                           // execute the following
ACTION_IF FILE_EXISTS_IN_GAME ~%file%.itm~ BEGIN                                                // if the referenced file with an ITM extension exists
COPY_EXISTING ~%file%.itm~ ~override~
PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN                                                      // file size check
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN                                   // cycles through headers
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"                               // header type
    PATCH_IF ("%type%" = 1) BEGIN // if melee header
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "resref"
        PATCH_IF (("%opcode%" = "177") AND ("%resref%" STRING_EQUAL_CASE ~DIE~)) BEGIN          // effect #177 - use EFF file and resref DIE
          WRITE_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "MESDIE" #8 // resref: MESDIE (needs to go first)
          WRITE_LONG ("%fx_off%" + 0x24 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "0"          // saving throw type: 0 (none)
          WRITE_LONG ("%fx_off%" + 0x28 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "0"          // saving throw bonus: 0
        END
        PATCH_IF (("%opcode%" = "177") AND ("%resref%" STRING_EQUAL_CASE ~MESDIE~)) BEGIN       // effect #177 - use EFF file and resref MESDIE
          WRITE_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "DIE" #8    // resref: DIE (needs to go last)
        END
      END
    END
  END
END                                                                                             // ends file size check
BUT_ONLY_IF_IT_CHANGES
END                                                                                             // ends ACTION_IF FILE_EXISTS_IN_GAME block
END                                                                                             // ends ACTION_FOR_EACH block

// Standardize the school and secondary type of items which cast illusionary spells (aVENGER)
COPY_EXISTING ~ring28.itm~ ~override~                                // Ring of Air Control
              ~sw1h26.itm~ ~override~                                // Ilbratha +1
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0; index < "%abil_num%"; index = index + 1) BEGIN     // parse each ability
    READ_BYTE ("%abil_off%" + ("%index%" * 0x38)) "abil_type"        // determine ability type
    PATCH_IF  ("%abil_type%" = 3) BEGIN                              // only patch the magical ability header
      READ_ASCII ("%abil_off%" + 0x04 + ("%index%" * 0x38)) "icon"   // use icon (BAM name)
      PATCH_IF (("%icon%" STRING_EQUAL_CASE ~SPWI212B~) OR ("%icon%" STRING_EQUAL_CASE ~SPWI405B~)) BEGIN // Mirror Image or Improved Invisibility
        WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "5"    // school: Illusionist
        WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "3"    // secondary type: Illusionary Protections
      END
    END
  END
BUT_ONLY_IF_IT_CHANGES

// Standardize the school and secondary type of items which cast abjuration spells (aVENGER)
COPY_EXISTING ~staf11.itm~ ~override~                                // Staff of the Magi
              ~wand18.itm~ ~override~                                // Wand of Spell Striking
PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN                           // file size check
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0; index < "%abil_num%"; index = index + 1) BEGIN     // parse each ability
    READ_BYTE ("%abil_off%" + ("%index%" * 0x38)) "abil_type"        // determine ability type
    PATCH_IF  ("%abil_type%" = 3) BEGIN                              // only patch the magical ability header
      READ_ASCII ("%abil_off%" + 0x04 + ("%index%" * 0x38)) "icon"   // use icon (BAM name)
      PATCH_IF ("%icon%" STRING_EQUAL_CASE ~SPWI902B~) BEGIN         // Spell Trap
        WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "1"    // school: Abjurer
        WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "1"    // secondary type: Spell Protections
      END
      PATCH_IF (("%icon%" STRING_EQUAL_CASE ~SPWI513B~) OR ("%icon%" STRING_EQUAL_CASE ~SPWI608B~)) BEGIN // Breach or Pierce Magic
        WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "1"    // school: Abjurer
        WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "4"    // secondary type: Magic Attack
      END
    END
  END
END                                                                  // ends file size check
BUT_ONLY_IF_IT_CHANGES

// Assign the proper school and secondary type to the special ability of the Shield amulet (aVENGER)
COPY_EXISTING ~amul15.itm~ ~override~                             // Shield Amulet
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0; index < "%abil_num%"; index = index + 1) BEGIN  // parse each ability
    READ_BYTE ("%abil_off%" + ("%index%" * 0x38)) "abil_type"     // determine ability type
    PATCH_IF  ("%abil_type%" = 3) BEGIN                           // only patch the magical ability header
      WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "6"   // school: Invoker
      WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "7"   // secondary type: Combat Protections
    END
  END
BUT_ONLY_IF_IT_CHANGES

// Standardize the school and secondary type of items which cast offensive spells (aVENGER)
COPY_EXISTING ~staf13.itm~ ~override~                                // Staff of Thunder and Lightning
              ~wand03.itm~ ~override~                                // Wand of Magic Missiles
              ~wand05.itm~ ~override~                                // Wand of Fire
              ~wand06.itm~ ~override~                                // Wand of Frost
              ~wand07.itm~ ~override~                                // Wand of Lightning
              ~wand11.itm~ ~override~                                // Wand of the Heavens
              ~wand13.itm~ ~override~                                // Wand of Cloudkill
PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN                           // file size check
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0; index < "%abil_num%"; index = index + 1) BEGIN     // parse each ability
    READ_BYTE ("%abil_off%" + ("%index%" * 0x38)) "abil_type"        // determine ability type
    PATCH_IF  ("%abil_type%" = 3) BEGIN                              // only patch the magical ability header
      READ_ASCII ("%abil_off%" + 0x04 + ("%index%" * 0x38)) "icon"   // use icon (BAM name)
      PATCH_IF NOT (("%icon%" STRING_EQUAL_CASE ~SPWI103B~) OR ("%icon%" STRING_EQUAL_CASE ~SPWI104B~)) BEGIN // not Burning Hands or Charm
        WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "6"    // school: Invoker
        WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "10"   // secondary type: Offensive Damage
      END
      PATCH_IF ("%icon%" STRING_EQUAL_CASE ~SPWI103B~) BEGIN         // Burning Hands
        WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "8"    // school: Transmuter
        WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "10"   // secondary type: Offensive Damage
      END
      PATCH_IF ("%icon%" STRING_EQUAL_CASE ~IWAND13~) BEGIN          // Wand of Cloudkill
        WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "6"    // school: Invoker
        WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "9"    // secondary type: Battleground
      END
    END
  END
END                                                                  // ends file size check
BUT_ONLY_IF_IT_CHANGES

// Standardize the school and secondary type of items which cast alteration spells (aVENGER)
COPY_EXISTING ~brac16.itm~ ~override~                                // Bracers of Blinding Strike
              ~boot12.itm~ ~override~                                // Gargoyle Boots
              ~ring29.itm~ ~override~                                // Ring of Earth Control
              ~ring39.itm~ ~override~                                // Ring of Gaxx
              ~staf16.itm~ ~override~                                // Staff of Earth +2
              ~sw1h27.itm~ ~override~                                // Arbane's Sword +2
              ~sw1h36.itm~ ~override~                                // Namarra +2
PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN                           // file size check
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0; index < "%abil_num%"; index = index + 1) BEGIN     // parse each ability
    READ_BYTE ("%abil_off%" + ("%index%" * 0x38)) "abil_type"        // determine ability type
    PATCH_IF  ("%abil_type%" = 3) BEGIN                              // only patch the magical ability header
      READ_ASCII ("%abil_off%" + 0x04 + ("%index%" * 0x38)) "icon"   // use icon (BAM name)
      PATCH_IF (("%icon%" STRING_EQUAL_CASE ~SPWI305B~) OR ("%icon%" STRING_EQUAL_CASE ~SPWI613B~) OR ("%icon%" STRING_EQUAL_CASE ~SPWI625B~)) BEGIN // Haste, Improved Haste or Stone to Flesh
        WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "8"    // school: Transmuter
        WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "13"   // secondary type: Non-Combat
      END
      PATCH_IF ("%icon%" STRING_EQUAL_CASE ~SPWI408B~) BEGIN         // Stoneskin
        WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "8"    // school: Transmuter
        WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "7"    // secondary type: Combat Protections
      END
      PATCH_IF ("%icon%" STRING_EQUAL_CASE ~SPPR211B~) BEGIN         // Silence 15' Radius
        WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "8"    // school: Transmuter
        WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "11"   // secondary type: Disabling
      END
    END
  END
END                                                                  // ends file size check
BUT_ONLY_IF_IT_CHANGES


// Standardize the school and secondary type of items which cast divination spells (aVENGER)
COPY_EXISTING ~sw1h32.itm~ ~override~                                // Dragonslayer
              ~sw1h34.itm~ ~override~                                // Albruin +1
PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN                           // file size check
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0; index < "%abil_num%"; index = index + 1) BEGIN     // parse each ability
    READ_BYTE ("%abil_off%" + ("%index%" * 0x38)) "abil_type"        // determine ability type
    PATCH_IF  ("%abil_type%" = 3) BEGIN                              // only patch the magical ability header
      READ_ASCII ("%abil_off%" + 0x04 + ("%index%" * 0x38)) "icon"   // use icon (BAM name)
      PATCH_IF ("%icon%" STRING_EQUAL_CASE ~SPWI203B~) BEGIN         // Detect Invisibility
        WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) "3"    // school: Diviner
        WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) "5"    // secondary type: Divination Attack
      END
    END
  END
END                                                                  // ends file size check
BUT_ONLY_IF_IT_CHANGES

ACTION_IF NOT FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // SoA-only fix

  // soa black blade does not grant long sword grandmastery per descript; see also SoA-only spwi915.spl patch for duration, thac0 fixes
  COPY_EXISTING ~blakblad.itm~ ~override~
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    READ_LONG   0x6a "fx_off"
    READ_SHORT  0x70 "fx_num"
    WRITE_SHORT 0x70 ("%fx_num%" + 1)
    INSERT_BYTES  ("%fx_off%" +        ("%fx_num%" * 0x30)) 0x30
      WRITE_SHORT ("%fx_off%" +        ("%fx_num%" * 0x30)) 233 // modify proficiency
      WRITE_BYTE  ("%fx_off%" + 0x02 + ("%fx_num%" * 0x30)) 1   // target:self
      WRITE_LONG  ("%fx_off%" + 0x04 + ("%fx_num%" * 0x30)) 5   // # pips
      WRITE_LONG  ("%fx_off%" + 0x08 + ("%fx_num%" * 0x30)) 90  // in long sword
      WRITE_BYTE  ("%fx_off%" + 0x0c + ("%fx_num%" * 0x30)) 2   // instant/while equipped
      WRITE_BYTE  ("%fx_off%" + 0x0d + ("%fx_num%" * 0x30)) 2   // not dispel/not bypass
      WRITE_BYTE  ("%fx_off%" + 0x12 + ("%fx_num%" * 0x30)) 100 // probability 1
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
      WRITE_SHORT ("%abil_off%" + 0x20 + ("%index%" * 0x38)) ("%abil_fx_idx%" + 1)
    END
    BUT_ONLY_IF_IT_CHANGES

END

/////                                                  \\\\\
///// spell fixes                                      \\\\\
/////                                                  \\\\\

// vamp touch fixes
COPY_EXISTING ~spin106.spl~ ~override/spin106a.spl~ // innate vamp touch
              ~spin106.spl~ ~override/spin106b.spl~ // innate vamp touch
              ~spin997.spl~ ~override/spin997a.spl~ // innate vamp touch
              ~spin997.spl~ ~override/spin997b.spl~ // innate vamp touch
              ~spwi314.spl~ ~override/spwi314a.spl~ // mage vamp touch
              ~spwi314.spl~ ~override/spwi314b.spl~ // mage vamp touch
  WRITE_LONG NAME1 0xffffffff
  WRITE_LONG NAME2 0xffffffff
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  PATCH_IF ("%DEST_RES%" STRING_COMPARE_REGEXP "^.+b$" = 0) BEGIN
    SET "self" = 1
  END ELSE BEGIN
    SET "self" = 0
  END
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_lev"
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = "%abil_fx_idx%" + "%fx_delta%"
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    WRITE_SHORT ("%abil_off%" + 0x26 + (0x28 * "%abil_num%")) 1 // removes projectile
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_BYTE ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "target"
      PATCH_IF ("%target%" = 2) BEGIN // preset target
        PATCH_IF ("%self%" = 0) BEGIN
          READ_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "dispel"
          PATCH_IF ("%dispel%" = 1) BEGIN // if dispel/not bypass
            WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 3 // make dispel/bypass
          END ELSE
          PATCH_IF ("%dispel%" = 2) BEGIN // if not dispel/not bypass
            WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // make not dispel/bypass
          END
        END ELSE BEGIN
          DELETE_BYTES ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30 // delete effect
          SET "index2" = "%index2%" - 1
          SET "abil_fx_num" = "%abil_fx_num%" - 1
          SET "fx_delta" = "%fx_delta%" - 1
        END
      END ELSE
      PATCH_IF ("%target%" = 1) BEGIN // target: self
        PATCH_IF ("%self%" = 0) BEGIN // non-self spell
          DELETE_BYTES ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30 // delete effect
          SET "index2" = "%index2%" - 1
          SET "abil_fx_num" = "%abil_fx_num%" - 1
          SET "fx_delta" = "%fx_delta%" - 1
        END ELSE BEGIN
          READ_BYTE  ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
          PATCH_IF ("%opcode%" = 206) BEGIN
            WRITE_ASCII ("%fx_off%" + 0x1b + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~b~ // changes from spwi314 to spwi314b
          END
        END
      END
    END
    PATCH_IF ("%self%" = 0) BEGIN // if a, insert cast spell b
      INSERT_BYTES   ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 0x30
        WRITE_SHORT  ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 146              // cast spell
        WRITE_BYTE   ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 1                // target self
        WRITE_LONG   ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "%min_lev%"      // cast at level
        WRITE_LONG   ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 1                // cast instantly
        WRITE_BYTE   ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 3                // dispel/bypass resistance
        WRITE_LONG   ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 300              // duration
        WRITE_BYTE   ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 100              // probability
        WRITE_ASCIIE ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) ~%SOURCE_RES%b~ // spell
      SET "abil_fx_num" = "%abil_fx_num%" + 1
      SET "fx_delta" = "%fx_delta%" + 1
    END
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// larloch minor drain fixes
COPY_EXISTING ~spin104.spl~ ~override/spin104a.spl~ // innate LMD
              ~spwi119.spl~ ~override/spwi119a.spl~ // mage LMD
  WRITE_LONG NAME1 0xffffffff
  WRITE_LONG NAME2 0xffffffff
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT ("%abil_off%" + 0x1e + (0x28 * ("%abil_num%" - 1))) "abil_fx_num"
  READ_SHORT ("%abil_off%" + 0x20 + (0x28 * ("%abil_num%" - 1))) "abil_fx_idx"
  SET "total_fx" = ("%abil_fx_idx%" + "%abil_fx_num%")
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    WRITE_SHORT ("%abil_off%" + 0x26 + (0x28 * "%abil_num%")) 1 // removes projectile
  END
  WHILE ("%total_fx%" > 0) BEGIN
    SET "total_fx" = ("%total_fx%" - 1)
    READ_BYTE ("%fx_off%" + 0x0d + (0x30 * "%total_fx%")) "dispel"
    PATCH_IF ("%dispel%" = 1) BEGIN // if dispel/not bypass
      WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * "%total_fx%")) 3 // make dispel/bypass
    END ELSE
    PATCH_IF ("%dispel%" = 2) BEGIN // if not dispel/not bypass
      WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * "%total_fx%")) 0 // make not dispel/bypass
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// innate LMD should do fixed damage of 4, not 1d4
COPY_EXISTING ~spin104a.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "spell"
      PATCH_IF ("%opcode%" = 12) BEGIN // damage opcode
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 4 // fixed damage
        WRITE_LONG  ("%fx_off%" + 0x1c + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // number of dice
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// makes MR-checking "shell" spell that also eliminates self-cast exploit
COPY_EXISTING ~spin104.spl~ ~override~ // innate LMD
              ~spin106.spl~ ~override~ // innate vamp touch
              ~spin997.spl~ ~override~ // innate vamp touch
              ~spwi119.spl~ ~override~ // mage LMD
              ~spwi314.spl~ ~override~ // mage vamp touch
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  PATCH_IF ((~%SOURCE_RES%~ STRING_COMPARE_CASE "spin104" = 0) OR
            (~%SOURCE_RES%~ STRING_COMPARE_CASE "spwi119" = 0)) BEGIN
    SET "power" = 1
  END ELSE BEGIN
    SET "power" = 3
  END
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%abil_num%")) "level"
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) 2
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) ("%abil_num%" * 2)
    DELETE_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) (0x30 * "%abil_fx_num%")  // deletes all effects
    INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30            // cast actual spell
      WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 146             // cast spell
      WRITE_BYTE            ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2               // target: preset target
      WRITE_BYTE            ("%fx_off%" + 0x03 + (0x30 * "%abil_fx_idx%")) "%power%"       // power
      WRITE_LONG            ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) "%level%"       // cast at level
      WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 1               // cast instantly
      WRITE_BYTE            ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1               // instant/permanent
      WRITE_BYTE            ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 1               // dispel/not bypass
      WRITE_BYTE            ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100             // probability
      WRITE_EVALUATED_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~%SOURCE_RES%a~ // spell
    INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30            // prevent self-casting
      WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 206             // spell immunity
      WRITE_BYTE            ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 1               // target: self
      WRITE_BYTE            ("%fx_off%" + 0x03 + (0x30 * "%abil_fx_idx%")) 0               // power
      WRITE_BYTE            ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100             // probability
      WRITE_EVALUATED_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~%SOURCE_RES%~  // spell: self
  END
  PATCH_IF ("%fx_num%" > 0) BEGIN // eliminates global fx
    DELETE_BYTES "%fx_off%" (0x30 * "%fx_num%")
    WRITE_SHORT 0x70 0
  END
  BUT_ONLY_IF_IT_CHANGES

// spells using wrong power level
COPY_EXISTING ~sppr105.spl~ ~override~ // (entangle): one sound effect opcode is power 2.
              ~sppr210.spl~ ~override~ // (resist fire/cold): one display string at level 4 has power 0.
              ~sppr306.spl~ ~override~ // (protection from fire): The character color pulse effect at all levels is at power 1.
              ~sppr315.spl~ ~override~ // (cure medium wounds): remove intoxication is at power 0.
              ~sppr401.spl~ ~override~ // (cure serious wounds): remove intoxication is at power 0.
              ~sppr502.spl~ ~override~ // (cure critical wounds): remove intoxication at power 0, 'healed' string at power 6.
              ~sppr512.spl~ ~override~ // (greater command): visual effect on target at power 1
              ~sppr712.spl~ ~override~ // (resurrection): most of the 'remove spell' opcodes are at power 5.
              ~spwi106.spl~ ~override~ // (blindness): 'blinded' string at power 0
              ~spwi111.spl~ ~override~ // (infravision): 'infravision' string at power 0
              ~spwi113.spl~ ~override~ // (protection from evil): 'protected from evil' string at power 0
              ~spwi210.spl~ ~override~ // (resist fear): visual effect at power 1
              ~spwi223.spl~ ~override~ // (deafness): visual effects at power 1
              ~spwi224.spl~ ~override~ // (glitterdust): visual effect at power 4
              ~spwi410.spl~ ~override~ // (remove curse): save visual effect, all at power 3
              ~spwi414.spl~ ~override~ // (spirit armor): display string at power 3
              ~spwi613.spl~ ~override~ // (improved haste): all effects save one at power 3
              ~spwi711.spl~ ~override~ // (sphere of chaos): play sound at power 4
              ~spwi721.spl~ ~override~ // (mass invisibility): actual invisibility effects at power 4 (this error is propagated when the Fixpack clones this effect for its additional spell protections)
              ~spwi803.spl~ ~override~ // (protection from energy): visual effects at power 7
              ~spwi910.spl~ ~override~ // (imprisonment): visual effects at power 8
              ~spwi922.spl~ ~override~ // (dragon's breath): all effects at power 0
              ~spwi925.spl~ ~override~ // (comet): knockback at power 0, all others power 9
  READ_LONG  0x34 "level"    ELSE 0
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_BYTE ("%fx_off%" + 0x03 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "%level%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// spells using wrong power level
COPY_EXISTING ~sppr303.spl~ ~override~ // (divine dispel magic) : all opcodes are power 0 except its visual effect and removing feeblemind, which are at 3. To work v. magic protections, all of these should be 0.
              ~spwi302.spl~ ~override~ // (remove magic): visual effect at power 3, all others at 0. Should add removal of feeblemind to this spell.
              ~spwi326.spl~ ~override~ // (arcane dispel magic) : all opcodes are power 0 except its visual effect and removing feeblemind, which are at 3. To work v. magic protections, all of these should be 0.
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_BYTE ("%fx_off%" + 0x03 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 0
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// elven sleep/charm immunity
COPY_EXISTING ~beguile.spl~  ~override~ // beguiling gaze (demogorgon)
              ~demochm.spl~  ~override~ // demonic charm (demogorgon)
              ~spcl311.spl~  ~override~ // ranger charm animal
              ~spcl641.spl~  ~override~ // charm person or animal (unused?)
//            ~spcl751a.spl~ ~override~ // bard song (Jester kit)
              ~spin108.spl~  ~override~ // charm animal (elminster version)
              ~spin119.spl~  ~override~ // charm person (elminster version)
              ~spin553.spl~  ~override~ // nalmissra innate charm
              ~spin558.spl~  ~override~ // erinyes charm
//            ~spin775.spl~  ~override~ // psionic mind blast
//            ~spin802.spl~  ~override~ // mind cripple
              ~spin883.spl~  ~override~ // vampire domination
//            ~spin910.spl~  ~override~ // psionic domination
//            ~spin937.spl~  ~override~ // mephit color spray
//            ~spin940.spl~  ~override~ // mephit stinking cloud
              ~spin966.spl~  ~override~ // troll sleep
//            ~spin975.spl~  ~override~ // mind flayer domination
              ~spin980.spl~  ~override~ // beholder charm person
              ~spin985.spl~  ~override~ // beholder domination
              ~sppr102.spl~  ~override~ // command
              ~sppr204.spl~  ~override~ // charm person or mammal
//            ~sppr405.spl~  ~override~ // mental domination
              ~sppr512.spl~  ~override~ // greater command
              ~sppr982.spl~  ~override~ // dire charm (trap)
//            ~spwi004.spl~  ~override~ // stinking cloud (trap)
              ~spwi104.spl~  ~override~ // charm person
//            ~spwi105.spl~  ~override~ // color spray
              ~spwi116.spl~  ~override~ // sleep
//            ~spwi213.spl~  ~override~ // stinking cloud
              ~spwi316.spl~  ~override~ // dire charm
//            ~spwi411.spl~  ~override~ // emotion
              ~spwi506.spl~  ~override~ // domination
//            ~spwi711.spl~  ~override~ // sphere of chaos
              ~spwi929.spl~  ~override~ // succubus charm male
              ~spwi930.spl~  ~override~ // succubus charm female
              ~spwi943.spl~  ~override~ // sirine dire charm
              ~spwm179.spl~  ~override~ // wild surge charm
              ~spwm187.spl~  ~override~ // wild surge sleep
              ~urgekill.spl~ ~override~ // ravager charm
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x28
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF (("%opcode%" = 39) OR ("%opcode%" = 5)) BEGIN // if there's a sleep or charm opcode
        READ_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "target"
        READ_BYTE  ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "prob1"
        READ_BYTE  ("%fx_off%" + 0x13 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "prob2"
        PATCH_IF ("%opcode%" = 5) BEGIN // if charm
          SET "new_fx" = 14
        END ELSE BEGIN
          SET "new_fx" = 10
        END
        SET "fx_delta" = "%fx_delta%" + "%new_fx%"
        FOR (index4 = 2 ; index4 < 4 ; index4 = index4 + 1) BEGIN
          FOR (index3 = 0 ; index3 < (("%new_fx%" / 2)) ; index3 = index3 + 1) BEGIN
            INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // insert new effect
              WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 177           // use eff file
              WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) "%target%"    // preserve target
              WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) "%index4%"    // elf or half elf
              WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 4             // race.ids
              WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) ("%prob2%" + ((21 - ("%index4%" * 6)) * ("%prob1%" - "%prob2%") / 10)) // 90%
              WRITE_BYTE  ("%fx_off%" + 0x13 + (0x30 * "%abil_fx_idx%")) "%prob2%"     // base prob
              WRITE_EVALUATED_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~cdelfcm%index3%~    // eff file
            PATCH_IF ("%opcode%" = 39) BEGIN
              WRITE_ASCII ("%fx_off%" + 0x19 + (0x30 * "%abil_fx_idx%")) ~sl~ #2 // eff file
            END
          END
        END
        SET "index2" = "%index2%" + "%new_fx%"
        SET "abil_fx_num" = "%abil_fx_num%" + "%new_fx%"
      END
    END
    WRITE_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// spells to transform trolls back from dead to alive
COPY_EXISTING ~spin955.spl~ ~override/drshnl21.spl~
              ~spin955.spl~ ~override/eletro01.spl~
              ~spin955.spl~ ~override/kptrol13.spl~
              ~spin955.spl~ ~override/pptroll1.spl~
              ~spin955.spl~ ~override/sutroll.spl~
              ~spin955.spl~ ~override/torgal3.spl~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "eff_file"
      PATCH_IF (("%opcode%" = 151) AND ("%eff_file%" STRING_COMPARE_CASE "troll01" = 0)) BEGIN
        WRITE_EVALUATED_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "%DEST_RES%" #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// abazigal hurts himself when revelaing his dragon form due to bad targeting
COPY_EXISTING ~abzaway.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 12) BEGIN // damage
        WRITE_BYTE ("%fx_off%" + 0x02 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 8 // target: everyone except self
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// resurrection(s) trying to remove incorrect spell resource
COPY_EXISTING ~bhaal4a.spl~  ~override~
              ~spja01.spl~   ~override~
              ~sppr504.spl~  ~override~
              ~sppr712.spl~  ~override~
              ~sppr729.spl~  ~override~
              ~spwish10.spl~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // adjusts fx indices on abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "spell"
      PATCH_IF (("%opcode%" = 172) AND ("%spell%" STRING_COMPARE_CASE "spwi126" = 0)) BEGIN
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "spin126"
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// armor of faith not covering acid, cold, fire, electricity, doubles against missiles
COPY_EXISTING ~dgfaith.spl~ ~override~
              ~sppr111.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x28
  SET "delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
    SET "missile" = 0 // used to track dupe missile protection opcodes
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF (("%opcode%" = 89) AND ("%missile%" = 0)) BEGIN // first missile protection
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // clones effect
        SET "missile" = 1
      END ELSE
      PATCH_IF ((("%opcode%" = 89) AND ("%missile%" = 1)) OR // dupe missile protection
                 ("%opcode%" = 84) OR                        // magic fire (unused)
                 ("%opcode%" = 85)) BEGIN                    // magic cold (unused)
          DELETE_BYTES ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30 // delete effect
          SET "delta" = ("%delta%" - 1)
          SET "index2" = ("%index2%" - 1)
          SET "abil_fx_num" = ("%abil_fx_num%" - 1)
      END
    END
    FOR (index3 = 0 ; index3 < 4 ; index3 = index3 + 1) BEGIN
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // insert new effect
        WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) ~%clone%~         // use cloned missile resist
        WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) (27 + "%index3%") // opcodes 27-30
    END
    SET "delta" = ("%delta%" + 4)
    SET "abil_fx_num" = ("%abil_fx_num%" + 4)
    WRITE_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// dragon breath attacks missing vvc to play over victims
COPY_EXISTING ~drgrbrht.spl~ ~override~
              ~spin691.spl~  ~override~
              ~spin893.spl~  ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // adjusts fx indices on abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "resref"
      PATCH_IF (("%opcode%" = 215) AND 
                (("%resref%" STRING_COMPARE_CASE "spgdraim" = 0) OR
                 ("%resref%" STRING_COMPARE_CASE "spbdimsp" = 0))) BEGIN
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "spsdimpa"
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// hallowed redeemer feedback should not summon CWs
COPY_EXISTING ~keldorn.spl~ ~override~
  WRITE_SHORT 0x1c 2 // priest spell
  READ_BYTE   0x1e "excl"
  WRITE_BYTE  0x1e ("%excl%" BAND 0b11111110) // removes conjurer flag to match regular fireshield
  WRITE_BYTE  0x22 0 // no casting animation
  WRITE_BYTE  0x27 2 // secondary type: specific protections
  BUT_ONLY_IF_IT_CHANGES

// tob spectator's geas missing sound
COPY_EXISTING ~senbehkd.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 174) BEGIN // play sound
        WRITE_BYTE ("%fx_off%" + 0x02 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 1 // target: self
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// fixes expolit of casting restore on a simulcrum
COPY_EXISTING ~simulacr.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "loops" = 0
  SET "delta" = 0
  WHILE ("%loops%" < "%abil_num%") BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%loops%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%loops%")) "abil_fx_idx"
    // first fix dispellability of existing effects
    FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
      WRITE_BYTE ("%fx_off%" + 0x0d + (("%index2%" + "%abil_fx_idx%") * 0x30)) 0   // no dispel/bypass resistance
    END
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%loops%")) "%abil_fx_idx%"
    INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30          // new effect
      WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 206           // spell immunity
      WRITE_ASCII ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~SPWISH46~ #8 // spell resref
    INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30          // new effect
      WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 206           // spell immunity
      WRITE_ASCII ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~SPWISH07~ #8 // spell resref
    INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30          // new effect
      WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 206           // spell immunity
      WRITE_ASCII ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~SPPR713~ #8  // spell resref
    INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30          // new effect
      WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 206           // spell immunity
      WRITE_ASCII ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~SPPR417~ #8  // spell resref
    INSERT_BYTES  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30          // new effect
      WRITE_SHORT ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 101           // immunity to effect
      WRITE_LONG  ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 224           // restoration
    FOR (index = 0x05; index > 0x00; index = index - 0x01) BEGIN
      WRITE_BYTE ("%fx_off%" + 0x02 + (("%index%" + "%abil_fx_idx%" - 1) * 0x30)) 1   // target: self
      WRITE_BYTE ("%fx_off%" + 0x0d + (("%index%" + "%abil_fx_idx%" - 1) * 0x30)) 0   // no dispel/bypass resistance
      WRITE_LONG ("%fx_off%" + 0x0e + (("%index%" + "%abil_fx_idx%" - 1) * 0x30)) 84  // duration
      WRITE_BYTE ("%fx_off%" + 0x12 + (("%index%" + "%abil_fx_idx%" - 1) * 0x30)) 100 // probability
    END
    SET "delta1" = 5
    SET "delta" = ("%delta%" + "%delta1%")
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%loops%")) ("%abil_fx_num%" + "%delta1%")
    SET "loops" = ("%loops%" + 1)
  END
  BUT_ONLY_IF_IT_CHANGES

// many detect evil issues; new cddetevl projectile solves range issue; use a 'shell spell' trick to get proper MR checking
COPY ~bg2fixpack/spl/CDDETEVL.spl~ ~override~
  WRITE_LONG NAME1 0xffffffff
  WRITE_LONG NAME2 0xffffffff

// miscast effects not accompanied by miscast icon
COPY_EXISTING ~spcl132.spl~  ~override~ // 25%, spell failure icon
              ~spin531.spl~  ~override~ // 90%, abazigal's shockwave
              ~sppr310.spl~  ~override~ // 80%, no icon
              ~sppr319.spl~  ~override~ // 50%, no icon
              ~sppr986.spl~  ~override~ // 80%, no icon
              ~spwish30.spl~ ~override~ // 80%, no icon
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    SET "abil_length" = 0x28
    READ_LONG  0x64 "abil_off" ELSE 0
    READ_SHORT 0x68 "abil_num" ELSE 0
    READ_LONG  0x6a "fx_off"   ELSE 0
    READ_SHORT 0x70 "fx_num"   ELSE 0
    SET "fx_type" = 0
    SET "new_fx_1" = 0
    SET "new_fx_2" = 0
    SET "delta" = 0
    FOR (index3 = 0 ; index3 < fx_num ; index3 = index3 + 1) BEGIN
      READ_SHORT ("%fx_off%" + ("%fx_type%" * 0x08) +        (0x30 * "%index3%")) "opcode"
      READ_LONG  ("%fx_off%" + ("%fx_type%" * 0x10) + 0x08 + (0x30 * "%index3%")) "icon"
      PATCH_IF ("%opcode%" = 60) BEGIN // miscast effect
        READ_ASCII ("%fx_off%" + ("%fx_type%" * 0x08) +        (0x30 * "%index3%")) "clone" (48 + (216 * "%fx_type%"))
        SET "new_fx_1" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 105)) BEGIN // display miscast icon
        SET "new_fx_2" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 83)) BEGIN // display spell failure icon
        WRITE_BYTE ("%fx_off%" + ("%fx_type%" * 0x08) + 0x12 + (0x30 * "%index3%")) 0 // 0% probability
      END
    END
    PATCH_IF (("%new_fx_1%" = 1) AND ("%new_fx_2%" = 0)) BEGIN // if miscast effect but no icon
      INSERT_BYTES            ("%fx_off%") (0x30 + ("%fx_type%" * 0xa8))         // new effect
        WRITE_EVALUATED_ASCII ("%fx_off%") "%clone%" // clones miscast effect
        WRITE_SHORT           ("%fx_off%" + ("%fx_type%" * 0x08)       ) 142       // display portrait icon:
        WRITE_LONG            ("%fx_off%" + ("%fx_type%" * 0x10) + 0x08) 105       // miscast magic
      SET "delta" = "%delta%" + 1
      SET "fx_num" = "%fx_num%" + 1
    END
    WRITE_SHORT 0x70 "%fx_num%"
    FOR (index = 0; index < abil_num; index = index + 1) BEGIN
      SET "new_fx_1" = 0 // reset for each loop through abilities
      SET "new_fx_2" = 0 // reset for each loop through abilities
      READ_SHORT ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
      SET "abil_fx_idx" = ("%delta%" + "%abil_fx_idx%")
      WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "%abil_fx_idx%"
      FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "icon"
        PATCH_IF ("%opcode%" = 60) BEGIN // miscast magic
          READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48)
          SET "new_fx_1" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 105)) BEGIN // display miscast icon
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 83)) BEGIN // display spell failure icon
          WRITE_BYTE ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // 0% probability
        END
      END
      PATCH_IF (("%new_fx_1%" = 1) AND ("%new_fx_2%" = 0)) BEGIN // if miscast effect but no icon
        INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30          // new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%" #48 // clones miscast effect
          WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 142           // display portrait icon:
          WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 105           // miscast magic
        SET "delta" = "%delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
      END
      WRITE_SHORT ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~spcl212.spl~ ~override~ // detect evil (paladin innate)
              ~spin120.spl~ ~override~ // detect evil (bhaalspawn innate)
//            ~spin696.spl~ ~override~ // moon dog sight
              ~sppr104.spl~ ~override~ // detect evil (cleric spell)
              ~spwi202.spl~ ~override~ // detect evil (mage spell)
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // loop through abilities
    WRITE_BYTE  ("%abil_off%" + 0x0e + ("%index%" * 0x28)) 5            // target: caster
    WRITE_SHORT ("%abil_off%" + 0x26 + ("%index%" * 0x28)) "%CDDETEVL%" // custom projectile
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN // looks for effects for abilities
      READ_SHORT  ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 115) BEGIN // detect alignment
        WRITE_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) 146        // opcode: cast spell
        WRITE_BYTE  ("%fx_off%" + 0x02 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 2          // target: preset target
        WRITE_BYTE  ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0          // power
        WRITE_LONG  ("%fx_off%" + 0x04 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 1          // cast at level
        WRITE_LONG  ("%fx_off%" + 0x08 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 1          // cast instantly: yes
        WRITE_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) ~cddetevl~ // spell to cast
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// kit innate speed increases should not be prevented by free action
COPY_EXISTING ~spcl151.spl~ ~override~ // barbarian
              ~spcl812.spl~ ~override~ // monk i
              ~spcl813.spl~ ~override~ // monk ii
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 126) BEGIN // movement rate bonus
        WRITE_SHORT ("%fx_off%" + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 176
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// barbarian rage should be granting bonus to save v spell, not penalty
// removing stun icons & effects; see fx batches for the rest
COPY_EXISTING ~spcl152.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "spell"
      PATCH_IF ("%opcode%" = 37) BEGIN // save v magic
        READ_ASCII  ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // clone effect
        WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 2 // should be a +2 bonus not -2 penalty
        SET "index2" = ("%abil_fx_num%" - 1) // kills loop, advances insert point to right before last effect
        FOR (index3 = 0 ; index3 < 2 ; index3 = index3 + 1) BEGIN
          INSERT_BYTES            ("%fx_off%" + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30 // new effect
            WRITE_EVALUATED_ASCII ("%fx_off%" + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "%clone%" #48 // use spell immunity as template
        END
        // write in opcodes and parameters for new effects
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%")))     46  // opcode: unstun
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%index2%")))     1   // timing: instant/permanent
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%" + 1))) 240 // opcode: remove icon
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%" + 1))) 55  // icon: stun
        SET "fx_delta" = ("%fx_delta%" + 2)
        WRITE_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 2)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// cavalier resist fear
COPY_EXISTING ~spcl222.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + (0x28 * "%index%")) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 3 // dispel/bypass MR
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// enrage's effects misordering prevents immunity to level drain strings; missing listed immunity to stun
COPY_EXISTING ~spcl321.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "spell"
      PATCH_IF (("%opcode%" = 206) AND ("%spell%" STRING_COMPARE_CASE "spcl321" = 0)) BEGIN // immunity to itself
        READ_ASCII  ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // clone effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 240          // change to remove icon
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 55           // stun icon
        SET "index2" = "%abil_fx_num%" // kills loop, advances insert point to last effect
        FOR (index3 = 0 ; index3 < 4 ; index3 = index3 + 1) BEGIN
          INSERT_BYTES            ("%fx_off%" + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30 // new effect
            WRITE_EVALUATED_ASCII ("%fx_off%" + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "%clone%" #48 // use spell immunity as template
        END
        // write in opcodes and parameters for new effects
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%" + 0))) 169 // opcode: prevent portrait icon
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%" + 0))) 55  // icon: stun
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%" + 1))) 101 // opcode: immunity to effect
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%" + 1))) 45  // effect: stun
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%" + 2))) 46  // opcode: unstun
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%index2%" + 2))) 1   // timing: instant/permanent
        SET "fx_delta" = ("%fx_delta%" + 4)
        WRITE_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 4)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// enrage cooldown--suppress name from dialogue window and making THAC0 penalty appear in the window
COPY_EXISTING ~spcl321d.spl~ ~override~
  WRITE_LONG NAME1 0xffffffff
  WRITE_LONG NAME2 0xffffffff
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (loops = 0 ; loops < abil_fx_num ; loops = loops + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%loops%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) "eff"
      PATCH_IF (("%opcode%" = 177) AND ("%eff%" STRING_COMPARE_CASE "hitwindd" = 0)) BEGIN // replacing eff call with thac0 bonus
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%loops%"))) 54  // thac0 bonus
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 1   // target self
        WRITE_BYTE  ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // power
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0xfffffffe // value (-2)
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // inc/dec
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // instant/limited
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 2   // not dispel/not bypass
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 30  // duration
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 100 // prob 1
        WRITE_BYTE  ("%fx_off%" + 0x13 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // prob 2
        WRITE_LONG  ("%fx_off%" + 0x1c + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // max level
        WRITE_LONG  ("%fx_off%" + 0x20 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // min level
        WRITE_LONG  ("%fx_off%" + 0x24 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // save type
        WRITE_LONG  ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // save bonus
        SET "loops" = "%abil_fx_num%"
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// all versions of ff should set variable
COPY_EXISTING ~spcl342.spl~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  WRITE_SHORT 0x70 ("%fx_num%" + 1)
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) ("%abil_fx_idx%" + 1)
  END
  INSERT_BYTES  ("%fx_off%"       ) 0x30       // new effect
    WRITE_SHORT ("%fx_off%"       ) 265        // set global
    WRITE_BYTE  ("%fx_off%" + 0x02) 1          // target: self
    WRITE_LONG  ("%fx_off%" + 0x04) 1          // value
    WRITE_BYTE  ("%fx_off%" + 0x0c) 1          // instant/perm
    WRITE_BYTE  ("%fx_off%" + 0x12) 100        // probability
    WRITE_ASCII ("%fx_off%" + 0x14) ~tutfam01~ // variable
  BUT_ONLY_IF_IT_CHANGES

// otilukes--use shell spell so all effects get applied; see also spcl415a.spl, spwi413a.spl
COPY_EXISTING ~spcl415.spl~ ~override~ // otiluke's sphere (special snare)
              ~spwi413.spl~ ~override~ // otiluke's sphere (arcane)
  READ_BYTE  0x19 "flags"
  WRITE_BYTE 0x19 ("%flags%" BAND 0b11111011) // removes break invis flag
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%index%")) "level"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    abil_fx_idx += fx_delta
    WRITE_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) abil_fx_idx
    PATCH_IF ((("%level%" = 16) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "spcl415" = 0)) OR // otilukes from snare
               ("%SOURCE_RES%" STRING_COMPARE_CASE "spwi413" = 0)) BEGIN                   // otilukes from arcana
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      SET "fx_delta" = ("%fx_delta%" - "%abil_fx_num%" + 1)
      WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) 1 // number of effects
      DELETE_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) (0x30 * "%abil_fx_num%")  // deletes all effects
      INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30            // cast actual spell
        WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 146             // cast spell
        WRITE_BYTE            ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2               // target: preset target
        WRITE_BYTE            ("%fx_off%" + 0x03 + (0x30 * "%abil_fx_idx%")) 4               // power
        WRITE_LONG            ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 0               // cast at level
        WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 1               // cast instantly
        WRITE_BYTE            ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1               // instant/permanent
        WRITE_BYTE            ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 1               // dispel/not bypass
        WRITE_BYTE            ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100             // probability
        WRITE_EVALUATED_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~%SOURCE_RES%a~ // spell
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// otiluke spell shell; see also spcl415.spl, spwi413.spl, spwi413a.spl
COPY_EXISTING ~spwi413a.spl~ ~override/spcl415a.spl~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 42
    END
  END

// assassin and skald thac0 bonuses not displaying in character record
COPY_EXISTING ~spcl421.spl~  ~override~
              ~spcl541.spl~  ~override~
  PATCH_IF (%SOURCE_SIZE%>0x71)                             THEN BEGIN
    READ_LONG   0x64 "abil_off"     // extended header offset
    READ_SHORT  0x68 "abil_num"     // extended header count
    READ_LONG   0x6a "fx_off"       // feature table offset
    FOR ("i" = 0 ; "%i%" < "%abil_num%" ; "i" += 1)                      BEGIN
      READ_SHORT  ("%abil_off%" + (0x28 * "%i%") + 0x1e) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + (0x28 * "%i%") + 0x20) "abil_fx_idx"
      FOR ("j" = 0 ; "%j%" < "%abil_fx_num%" ; "j" += 1)                 BEGIN
        READ_SHORT ("%fx_off%" + (0x30 * ("%j%" + "%abil_fx_idx%"))+0x00) "opcode"
        PATCH_IF ("%opcode%"=0xb1)                          THEN BEGIN
          WRITE_SHORT  ("%fx_off%" + (0x30 * ("%j%" + "%abil_fx_idx%")) + 0x00) 0x116  // To-hit bonus
          WRITE_LONG   ("%fx_off%" + (0x30 * ("%j%" + "%abil_fx_idx%")) + 0x04) 0x01   // modifier
          WRITE_LONG   ("%fx_off%" + (0x30 * ("%j%" + "%abil_fx_idx%")) + 0x08) 0x00   // type: cumulative
          WRITE_ASCII  ("%fx_off%" + (0x30 * ("%j%" + "%abil_fx_idx%")) + 0x14) ~~ #8 // nulling resref
        END //PATCH_IF use .eff file opcode located
      END // FOR j, scanning each header's abilities
    END // FOR i, scanning extended headers
  END // PATCH_IF filesize sanity check
  BUT_ONLY_IF_IT_CHANGES // COPY_EXISTING closed

// offensive spin fixes
COPY_EXISTING ~spcl521.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 2)
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) ("%abil_fx_idx%")
    FOR (loops = 0 ; loops < abil_fx_num ; loops = loops + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%loops%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) "eff"
      PATCH_IF (("%opcode%" = 177) AND ("%eff%" STRING_COMPARE_CASE "hitplus2" = 0)) BEGIN // replacing eff call with thac0 bonus
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%loops%"))) 54  // thac0 bonus
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 1   // target self
        WRITE_BYTE  ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // power
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 2   // value
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // inc/dec
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // instant/limited
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 2   // not dispel/not bypass
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 24  // duration
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 100 // prob 1
        WRITE_BYTE  ("%fx_off%" + 0x13 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // prob 2
        WRITE_LONG  ("%fx_off%" + 0x1c + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // max level
        WRITE_LONG  ("%fx_off%" + 0x20 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // min level
        WRITE_LONG  ("%fx_off%" + 0x24 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // save type
        WRITE_LONG  ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // save bonus
      END
      PATCH_IF ("%opcode%" = 16) BEGIN // replacing haste with immunity to haste
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%loops%"))) 101 // immunity to effect
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 1   // target self
        WRITE_BYTE  ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // power
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // value
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 16  // haste
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // instant/limited
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 2   // not dispel/not bypass
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 24  // duration
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 100 // prob 1
        WRITE_BYTE  ("%fx_off%" + 0x13 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // prob 2
        WRITE_LONG  ("%fx_off%" + 0x1c + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // max level
        WRITE_LONG  ("%fx_off%" + 0x20 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // min level
        WRITE_LONG  ("%fx_off%" + 0x24 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // save type
        WRITE_LONG  ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) 0   // save bonus
      END
    END
    INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // insert new effect
      WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 126 // movementrate bonus
      WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 1   // target self
      WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 200 // value
      WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 2   // set to % of
      WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2   // not dispel/not bypass
      WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%")) 24  // duration
      WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100 // prob 1
    INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // insert new effect
      WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 1   // modify attacks per round
      WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 1   // target self
      WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 1   // 1 attack per 1 round
      WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 2   // not dispel/not bypass
      WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%")) 24  // duration
      WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100 // prob 1
    SET "fx_delta" = ("%fx_delta%" + 2)
  END
  BUT_ONLY_IF_IT_CHANGES

// offensive spin/boon of lathander issues with MMM, part i, also see melfmet.itm
COPY_EXISTING ~spcl521.spl~  ~override/spcl521d.spl~
              ~spcl741.spl~  ~override/spcl741d.spl~
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    SAY NAME1 #-1 SAY NAME2 #-1 // erase the name of the secondary spells to prevent feedback duplication
    WRITE_ASCIIT  0x10   ~~  // completion sound
    WRITE_SHORT   0x22  0x00 // casting graphics
    READ_LONG     0x64  "ho"
    READ_SHORT    0x68  "hc"
    READ_LONG     0x6a  "eo"
    READ_SHORT    0x70  "gc"
    FOR ("i" = "hc"; "i" > 0x00; "i" -= 0x01) BEGIN
      WRITE_LONG   ("ho" + (("i" - 0x01) * 0x28) + 0x12) 0x00 // casting time
      READ_SHORT   ("ho" + (("i" - 0x01) * 0x28) + 0x1e) "ec"
      READ_SHORT   ("ho" + (("i" - 0x01) * 0x28) + 0x20) "ei"
      WRITE_SHORT  ("ho" + (("i" - 0x01) * 0x28) + 0x1e) 0x02 //number of effects
      WRITE_SHORT  ("ho" + (("i" - 0x01) * 0x28) + 0x20) ("gc" + (("i" - 0x01) * 0x02))
      DELETE_BYTES ("eo" + ("ei" * 0x30) + 0x00) (("ec" - 0x02) * 0x30)
      WRITE_SHORT  ("eo" + ("ei" * 0x30) + 0x00) 0x01 // opcode: apr mod
      WRITE_BYTE   ("eo" + ("ei" * 0x30) + 0x02) 0x01 // target: self
      WRITE_LONG   ("eo" + ("ei" * 0x30) + 0x04) 0x01 // modifier
      WRITE_LONG   ("eo" + ("ei" * 0x30) + 0x08) 0x00 // type: cumulative
      WRITE_ASCIIT ("eo" + ("ei" * 0x30) + 0x14) ~~   // nulling resref
      WRITE_SHORT  ("eo" + ("ei" * 0x30) + 0x30) 0xce // opcode: protection from spell
      WRITE_BYTE   ("eo" + ("ei" * 0x30) + 0x32) 0x01 // target: self
      WRITE_LONG   ("eo" + ("ei" * 0x30) + 0x34) `0x0 // string displayed
      WRITE_ASCIIT ("eo" + ("ei" * 0x30) + 0x44) ~spwi325~ // melf's meteors
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// offensive spin/boon of lathander issues with MMM, part ii, also see melfmet.itm
COPY_EXISTING ~spcl521.spl~  ~override/spcl521.spl~
              ~spcl741.spl~  ~override/spcl741.spl~
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    READ_LONG     0x64  "ho"
    READ_SHORT    0x68  "hc"
    READ_LONG     0x6a  "eo"
    READ_SHORT    0x70  "gc"
    FOR ("i" = 0x00; "i" < ("hc" * 0x28); "i" += 0x28) BEGIN
      READ_SHORT         ("ho" + "i" + 0x1e) "ec"
      READ_SHORT         ("ho" + "i" + 0x20) "ei"
      FOR  ("j" = ("ei" * 0x30); "j" < (("ei" + "ec") * 0x30); "j" += 0x30) BEGIN
        READ_SHORT       ("eo" + "j" + 0x00) "op"
        PATCH_IF (("op" = 0x10) OR ("op" = 0x01)) THEN BEGIN
          WRITE_SHORT    ("eo" + "j" + 0x00) 0x92 // opcode: cast spell
          WRITE_LONG     ("eo" + "j" + 0x04) 0x00 // cast at level
          WRITE_LONG     ("eo" + "j" + 0x08) 0x00 // cast normally
          WRITE_BYTE     ("eo" + "j" + 0x0c) 0x01 // timing mode: instant/permanent
          WRITE_LONG     ("eo" + "j" + 0x0e) 0x00 // duration
          PATCH_IF          (NOT "%SOURCE_RES%" STRING_COMPARE_CASE "spcl521") THEN BEGIN
            WRITE_ASCII  ("eo" + "j" + 0x14) ~spcl521d~ // resref
          END ELSE PATCH_IF (NOT "%SOURCE_RES%" STRING_COMPARE_CASE "spcl741") THEN BEGIN
            WRITE_ASCII  ("eo" + "j" + 0x14) ~spcl741d~ // resref
          END
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// use shell spells for ApR modification to avoid issues with MMM; see melfmet.itm
COPY_EXISTING ~spcl521.spl~ ~override~ // offensive spin
              ~spcl741.spl~ ~override~ // boon of lathander
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * "%index2%")) "opcode"
      PATCH_IF("%opcode%" = 1) BEGIN
        WRITE_SHORT  ("%fx_off%" +        (0x30 * "%index2%")) 146                // cast spell
        WRITE_LONG   ("%fx_off%" + 0x08 + (0x30 * "%index2%")) 1                  // cast instantly
        WRITE_ASCIIE ("%fx_off%" + 0x14 + (0x30 * "%index2%")) ~%SOURCE_RES%a~ #8 //resref
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// defensive spin fixes
COPY_EXISTING ~spcl522.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) ("%abil_fx_idx%")
    FOR (loops = abil_fx_num ; loops > 0 ; loops = loops - 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + ("%loops%" - 1)))) "opcode"
      PATCH_IF ("%opcode%" = 206) BEGIN // insert right before spell immunities
        WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 1)
        SET "fx_delta" = ("%fx_delta%" + 1)
        INSERT_BYTES  ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + ("%loops%" - 1)))) 0x30 // insert new effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + ("%loops%" - 1)))) 101 // immunity to effect
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + ("%loops%" - 1)))) 1   // target self
          WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + ("%loops%" - 1)))) 126 // movement rate bonue
          WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + ("%loops%" - 1)))) 2   // not dispel/not bypass
          WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + ("%loops%" - 1)))) 24  // duration
          WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + ("%loops%" - 1)))) 100 // prob 1
        SET "loops" = 0
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// greater/deathblow shouldn't be using quivering palm eff (allows spurious save)
COPY_EXISTING ~spcl902.spl~ ~override~ // deathblow
              ~spcl903.spl~ ~override~ // greater deathblow
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (loops = 0 ; loops < abil_fx_num ; loops = loops + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%loops%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) "eff"
      PATCH_IF ((("%opcode%" = 248) OR ("%opcode%" = 249)) AND ("%eff%" STRING_COMPARE_CASE "quivvis" = 0)) BEGIN // replacing eff call with thac0 bonus
        WRITE_EVALUATED_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%loops%"))) "%SOURCE_RES%a"
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// power attack not displaying string on ranged attacks
COPY_EXISTING ~spcl906.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "eff_file"
      PATCH_IF (("%opcode%" = 248) AND ("%eff_file%" STRING_COMPARE_CASE "spcl906b" = 0)) BEGIN // melee display string
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "clone_fx" (0x30)
        SET "index2"= "%abil_fx_num%" // kills loop
        INSERT_BYTES            ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30             // new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) "%clone_fx%"     // cloned effect
          WRITE_SHORT           ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 249              // opcode
        SET "delta" = "%delta%" + 1
        WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 1)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// hardiness missing high level headers
COPY_EXISTING ~spcl907.spl~  ~override~ // hardiness hla
              ~spwish12.spl~ ~override~ // hardiness via wish
  PATCH_IF (SOURCE_SIZE > 0x71) BEGIN
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    READ_SHORT ("%abil_off%" + 0x10 + (("%abil_num%" - 1) * 0x28)) "min_level" // min level of last ability header
    FOR (index = min_level + 2 ; index < 31 ; index = index + 2) BEGIN
      READ_ASCII ("%abil_off%" +        (("%abil_num%" - 1) * 0x28)) "abil_clone" (0x28) // reads last ability as block
      READ_SHORT ("%abil_off%" + 0x1e + (("%abil_num%" - 1) * 0x28)) "abil_fx_num" // reads number of fx from last ability
      READ_SHORT ("%abil_off%" + 0x20 + (("%abil_num%" - 1) * 0x28)) "abil_fx_idx" // reads index of last effects from last ability
      // create effects for next level based off previous level effects
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "clone_fx" (0x30) // reads entire effect
        READ_LONG  ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%index2%") * 0x30)) "duration"        // duration
        INSERT_BYTES ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%") * 0x30)) 0x30
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%") * 0x30)) "%clone_fx%" // clones effect
          PATCH_IF ("%duration%" > 5) BEGIN // if more than one round
            WRITE_LONG  ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%") * 0x30)) ("%duration%" + 6) // duration + round
          END
      END
      // effects created, now add new ability
      INSERT_BYTES            ("%abil_off%" +        ("%abil_num%" * 0x28)) 0x28
        WRITE_EVALUATED_ASCII ("%abil_off%" +        ("%abil_num%" * 0x28)) "%abil_clone%" // clones last ability
        WRITE_SHORT           ("%abil_off%" + 0x10 + ("%abil_num%" * 0x28)) "%index%"      // min level
        WRITE_SHORT           ("%abil_off%" + 0x20 + ("%abil_num%" * 0x28)) ("%abil_fx_num%" + "%abil_fx_idx%") // corrects fx index
      SET "fx_off" = ("%fx_off%" + 0x28)
      SET "abil_num" = "%abil_num%" + 1
    END
    WRITE_SHORT 0x68 "%abil_num%"
    WRITE_LONG  0x6a "%fx_off%"
  END
  BUT_ONLY_IF_IT_CHANGES

// ranger tracking
COPY_EXISTING ~spcl922.spl~  ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 171) BEGIN // give innate
        READ_ASCII              ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48)
        INSERT_BYTES            ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30 // new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "%clone%"
          WRITE_SHORT           ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 172 // remove spell
        SET "index2" = "%index2%" + 1
        SET "delta" = "%delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
      END
    END
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// chromatic orb has a few incorrect targets and MR checks
COPY_EXISTING ~spdr101.spl~ ~override~ // chromatic orb, stalker version
              ~spwi118.spl~ ~override~ // chromatic orb, wiz version
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%abil_num%")) "min_lev"
    WRITE_SHORT ("%abil_off%" + 0x0e + (0x28 * "%abil_num%")) 90 // corrects range
    PATCH_IF (("%min_lev%" = 1) OR ("%min_lev%" = 5) OR ("%min_lev%" = 10) OR ("%min_lev%" = 12)) BEGIN
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
        READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "duration"
        PATCH_IF (("%duration%" > 5) AND ("%min_lev%" = 1)) BEGIN // fix level 1 durations
          WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 6
        END
        PATCH_IF (("%duration%" > 5) AND ("%min_lev%" = 5)) BEGIN // fix level 5 durations, power
          WRITE_LONG  ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%")))  1 // power
          WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 18 // duration
        END
        PATCH_IF ("%opcode%" = 0) BEGIN // armor class penalty
          WRITE_BYTE ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 2 // target: preset target
        END ELSE
        PATCH_IF (("%opcode%" = 139) OR ("%opcode%" = 142)) BEGIN // display portrait icon or display string
          WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 1 // dispel/not bypass
        END ELSE
        PATCH_IF ("%opcode%" = 55) BEGIN // slay
          WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 2 // not dispel/not bypass
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// casting speed fixes
COPY_EXISTING /* ~spin101.spl~ ~override~ // clw, innate */
              ~sppr310.spl~ ~override~ // miscast magic
              ~sppr311.spl~ ~override~ // rigid thinking
              ~sppr403.spl~ ~override~ // free action
              ~sppr717.spl~ ~override~ // creeping doom
              ~spwi504.spl~ ~override~ // mon summoning iii
              ~spwi522.spl~ ~override~ // minor spell turning
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%index%")) 5
  END
  BUT_ONLY_IF_IT_CHANGES

// casting speed fixes
COPY_EXISTING /* ~spin103.spl~ ~override~ // duhm innate */
              /* ~spin105.spl~ ~override~ // innate horror */
              ~sppr104.spl~ ~override~ // detect evil
              ~spwi211.spl~ ~override~ // melf's acid arrow
              ~sppr214.spl~ ~override~ // duhm divine
              ~spwi505.spl~ ~override~ // shadow door
              ~spwi511.spl~ ~override~ // protection from normal weapons
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%index%")) 2
  END
  BUT_ONLY_IF_IT_CHANGES

// casting speed fixes
COPY_EXISTING ~spin104.spl~ ~override~ // innate lmd
              ~spwi402.spl~ ~override~ // dimension door
              ~spwi408.spl~ ~override~ // stoneskin
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%index%")) 1
  END
  BUT_ONLY_IF_IT_CHANGES

// removing horror's undocumented save bonus
COPY_EXISTING ~spin105.spl~  ~override~ // bhaalspawn innate horror
              ~spwi205.spl~  ~override~ // wizard spell horror
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index"=0 ; "%index%" < "%abil_num%" ; "index"= ("%index%" + 1)) BEGIN
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28*"%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28*"%index%")) "abil_fx_idx"
    FOR ("index2"=0 ; "%index2%" < "%abil_fx_num%" ; "index2" = ("%index2%" + 1)) BEGIN
      READ_LONG ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "savebonus"
      PATCH_IF  ("%savebonus%" != 0) BEGIN // saving throw bonus shouldn't be there
        WRITE_LONG ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0
      END // end PATCH_IF for saving throw bonus
    END // end FOR index2 for reading each ability
  END // end FOR index for reading each extended header
  BUT_ONLY_IF_IT_CHANGES

// summon dread wolf referring to non-existant BG reference
COPY_EXISTING ~spin114.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ( index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 67) BEGIN // summon creature
        WRITE_ASCII  ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~wolfdr01~ #8
        SET "index2" = "%abil_fx_num%" // kills fx loop
        SET "index" = "%abil_num%" // kills abil loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// abazigal's shockwave miscast effects
COPY_EXISTING ~spin531.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off" ELSE 0
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
      READ_SHORT   ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 60) BEGIN // if miscast magic
        WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 90
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// hive mother anti-magic ray not affecting divine spellcasting
COPY_EXISTING ~spin550.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off" ELSE 0
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
      READ_SHORT   ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 60) BEGIN // if miscast magic
        WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 100
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// spell failure effects not accompanied by spell failure icon
COPY_EXISTING ~spin550.spl~  ~override~ // 100%, need to fix divine, includes innates
              ~spin646.spl~  ~override~ // 100%, anti-magic zone type
              ~spin689.spl~  ~override~ // 100%, has miscast
              ~spin712.spl~  ~override~ // 100%, sets attacks to 0
              ~spin731.spl~  ~override~ // 100%, party-wide
              ~spin779.spl~  ~override~ // 100%, already has spell failure icon
              ~spin992.spl~  ~override~ // 100%, no icon
              ~sppr517.spl~  ~override~ // 100%, no icon
              ~sppr717.spl~  ~override~ // 100%, no icon
              ~spwm128.spl~  ~override~ // 100%, no icon
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    SET "abil_length" = 0x28
    READ_LONG  0x64 "abil_off" ELSE 0
    READ_SHORT 0x68 "abil_num" ELSE 0
    READ_LONG  0x6a "fx_off"   ELSE 0
    READ_SHORT 0x70 "fx_num"   ELSE 0
    SET "fx_type" = 0
    SET "new_fx_1" = 0
    SET "new_fx_2" = 0
    SET "delta" = 0
    FOR (index3 = 0 ; index3 < fx_num ; index3 = index3 + 1) BEGIN
      READ_SHORT ("%fx_off%" + ("%fx_type%" * 0x08) +        (0x30 * "%index3%")) "opcode"
      READ_LONG  ("%fx_off%" + ("%fx_type%" * 0x10) + 0x08 + (0x30 * "%index3%")) "icon"
      PATCH_IF ("%opcode%" = 60) BEGIN // entangle overlay
        READ_ASCII ("%fx_off%" + ("%fx_type%" * 0x08) +        (0x30 * "%index3%")) "clone" (48 + (216 * "%fx_type%"))
        SET "new_fx_1" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 83)) BEGIN // display spell failure icon
        SET "new_fx_2" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 105)) BEGIN // display miscast icon
        WRITE_BYTE ("%fx_off%" + ("%fx_type%" * 0x08) + 0x12 + (0x30 * "%index3%")) 0 // 0% probability
      END
    END
    PATCH_IF (("%new_fx_1%" = 1) AND ("%new_fx_2%" = 0)) BEGIN // if spell failure effect but no icon
      INSERT_BYTES            ("%fx_off%") (0x30 + ("%fx_type%" * 0xa8))         // new effect
        WRITE_EVALUATED_ASCII ("%fx_off%") "%clone%" // clones miscast effect
        WRITE_SHORT           ("%fx_off%" + ("%fx_type%" * 0x08)       ) 142       // display portrait icon:
        WRITE_LONG            ("%fx_off%" + ("%fx_type%" * 0x10) + 0x08) 83        // spell failure
      SET "delta" = "%delta%" + 1
      SET "fx_num" = "%fx_num%" + 1
    END
    WRITE_SHORT 0x70 "%fx_num%"
    FOR (index = 0; index < abil_num; index = index + 1) BEGIN
      SET "new_fx_1" = 0 // reset for each loop through abilities
      SET "new_fx_2" = 0 // reset for each loop through abilities
      READ_SHORT ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
      SET "abil_fx_idx" = ("%delta%" + "%abil_fx_idx%")
      WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "%abil_fx_idx%"
      FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "icon"
        PATCH_IF ("%opcode%" = 60) BEGIN // miscast effects
          READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48)
          SET "new_fx_1" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 83)) BEGIN // display spell failure icon
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 105)) BEGIN // display miscast icon
          WRITE_BYTE ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // 0% probability
        END
      END
      PATCH_IF (("%new_fx_1%" = 1) AND ("%new_fx_2%" = 0)) BEGIN // if miscast effect but no icon
        INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30          // new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%" #48 // clones miscast effect
          WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 142           // display portrait icon:
          WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 83            // spell failure
        SET "delta" = "%delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
      END
      WRITE_SHORT ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// anti-magic should destroy magically created items
COPY_EXISTING ~spin550.spl~ ~override~ // hive mother anti-magic ray
              ~spin779.spl~ ~override~ // anti-magic zone
              ~spin992.spl~ ~override~ // beholder anti-magic ray
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    SET "loops" = 0
    SET "delta" = 0
    WHILE ("%loops%" < "%abil_num%") BEGIN
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%loops%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%loops%")) "abil_fx_idx"
      SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%loops%")) "%abil_fx_idx%"
      FOR ("index" = "%abil_fx_num%" ; "%index%" > 0; "index" = ("%index%" - 1)) BEGIN // look for remove item opcode
        READ_SHORT ("%fx_off%" + (0x30 * (("%index%" - 1) + "%abil_fx_idx%"))) "opcode"
        PATCH_IF ("%opcode%" = 112) BEGIN
          READ_ASCII ("%fx_off%" + (0x30 * (("%index%" - 1) + "%abil_fx_idx%"))) "effect" (0x30)
          SET "new_fx"  = 17
          SET "index" = 0
        END
      END
      WHILE ("%new_fx%" > 0) BEGIN
        SET "new_fx"  = ("%new_fx%" - 1)
        INSERT_BYTES            ("%fx_off%" + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 0x30
          WRITE_EVALUATED_ASCII ("%fx_off%" + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) "%effect%"
      END
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"     ))) ~BLAKBLAD~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" +  1))) ~ENEBLADE~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" +  2))) ~ENMACE~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" +  3))) ~ENMORN~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" +  4))) ~ENSTAFF~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" +  5))) ~ENSW1H01~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" +  6))) ~ENSW1H02~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" +  7))) ~ENSW2H~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" +  8))) ~GBERRY~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" +  9))) ~GBERRY2~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 10))) ~GBERRY3~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 11))) ~GBERRY4~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 12))) ~GBERRY5~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 13))) ~GBERRY6~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 14))) ~GBERRY7~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 15))) ~PHANBLAD~ #8
      WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 16))) ~SHAKTI1~ #8
      SET "delta" = ("%delta%" + 17)
      WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%loops%")) ("%abil_fx_num%" + 17)
      SET "loops" = ("%loops%" + 1)
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// change old lightning spbehbla.pro spells to new cdbehbla.pro projectile
COPY_EXISTING ~spin579.spl~ ~override~ // power_amp
              ~spin989.spl~ ~override~ // beholder_lightning_bolt
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x26 + (0x28 * "%index%")) "%cdbehbla%"
  END
  BUT_ONLY_IF_IT_CHANGES

// imprisoned summon fix: see gender.ids, cdwi917a.spl, cdwi910.eff, cdwi917a.eff, spwi917.spl
COPY_EXISTING ~spin580.spl~ ~override~
              ~spin626.spl~ ~override~
              ~spin788.spl~ ~override~
              ~spwi910.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 211) BEGIN // imprisonment
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // grab entire fx
        INSERT_BYTES            ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30          // new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "%clone%" #48 // clones imprisonment effect
          WRITE_SHORT           ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 177           // use eff file
          WRITE_LONG            ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%")))   6           // summoned (6)...
          WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%")))   7           // from gender.ids
          WRITE_ASCII           ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~cdwi910~ #8  // eff resref
        SET "delta" = "%delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
        SET "index2" = "%index2%" + 1
      END
    END
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// xp effect not being applied with correct timing
COPY_EXISTING ~spin607.spl~ ~override~
              ~spin640.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 104) BEGIN // xp bonus
        WRITE_BYTE ("%fx_off%" + 0x0c + (("%abil_fx_idx%" + "%index2%") * 0x30)) 1 // timing mode
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// talons icon eff has different timing than other effects
COPY_EXISTING ~spin613.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "eff_file"
      PATCH_IF (("%opcode%" = 283) AND ("%eff_file%" STRING_COMPARE_CASE "deck613a" = 0)) BEGIN // use deck613a.eff as curse
        WRITE_BYTE ("%fx_off%" + 0x0c + (("%abil_fx_idx%" + "%index2%") * 0x30)) 9 // timing mode
        WRITE_LONG ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // duration
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// deck of many things, moon spell
COPY_EXISTING ~spin618.spl~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    WHILE ("%abil_num%" > 0) BEGIN
      SET "abil_num" = ("%abil_num%" - 1)
      READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
      PATCH_IF ("%type%" = 1) BEGIN // if melee
        READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
        READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
        WHILE ("%abil_fx_num%" > 0) BEGIN
          SET "abil_fx_num" = ("%abil_fx_num%" - 1)
          READ_SHORT ("%fx_off%" + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
          PATCH_IF ("%opcode%" = 18) BEGIN // max hp bonus
            WRITE_LONG ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 0 // increase/decrease
          END
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// deck of many things, emperor spell
COPY_EXISTING ~spin632.spl~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    WHILE ("%abil_num%" > 0) BEGIN
      SET "abil_num" = ("%abil_num%" - 1)
      READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
      PATCH_IF ("%type%" = 1) BEGIN // if melee
        READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
        READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
        WHILE ("%abil_fx_num%" > 0) BEGIN
          SET "abil_fx_num" = ("%abil_fx_num%" - 1)
          READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
          PATCH_IF (("%opcode%" = 101) OR ("%opcode%" = 174)) BEGIN // play sound or immunity
            WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 50400 // duration seven days
          END
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// familiars and summons should be pushed back when hell door opens, part 2/2 (see cut85a.bcs)
COPY_EXISTING ~spin658.spl~ ~override~
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  PATCH_IF ("%abil_num%" > 0) BEGIN
    READ_LONG  0x64 "abil_off"
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * ("%abil_num%" - 1))) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * ("%abil_num%" - 1))) "abil_fx_idx"
    SET "fx_num" = ("%abil_fx_idx%" + "%abil_fx_num%")
  END ELSE BEGIN
    READ_SHORT 0x70 "fx_num"
  END
  WHILE ("%fx_num%" > 0) BEGIN
    SET "fx_num" = ("%fx_num%" - 1)
    READ_BYTE ("%fx_off%" + 0x02 + (0x30 * "%fx_num%")) "target"
    PATCH_IF ("%target%" = 2) BEGIN // change target: preset target to
      WRITE_BYTE ("%fx_off%" + 0x02 + (0x30 * "%fx_num%")) 4 // everyone
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// edwina > edwin fixes
COPY_EXISTING ~spin661.spl~ ~override~
              ~spin662.spl~ ~override~
              ~spin916.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
    PATCH_IF ("%type%" = 1) BEGIN // if melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
        PATCH_IF ("%opcode%" = 71) BEGIN // change sex
          WRITE_BYTE ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 1 // instant/permanent
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// Edwin's Nether Scroll bonuses; removes spurious save check on play sound and changes effects to bypass MR
COPY_EXISTING ~spin664.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
    PATCH_IF ("%type%" = 1) BEGIN // if melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 0 // no dispel/bypass
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
        PATCH_IF ("%opcode%" = 174) BEGIN // play sound
          WRITE_LONG ("%fx_off%" + 0x24 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 0 // no save
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Anomen's title change; effects should be permanent and persist through resurrection
COPY_EXISTING ~spin678.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
    PATCH_IF ("%type%" = 1) BEGIN // if melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        WRITE_BYTE ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 1 // instant/permanent
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// entangle effects not setting entangle icon
COPY_EXISTING ~spin688.spl~ ~override~
              ~spwm111.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "delta" = 0
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 154) BEGIN // entangle overlay
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // grab entire fx
        INSERT_BYTES            ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30          // new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "%clone%" #48 // clones entangle effect
          WRITE_SHORT           ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 142           // display portrait icon:
          WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 144           // entangled
        SET "delta" = "%delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
        SET "index2" = "%index2%" + 1
      END
    END
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// fix icon for moon dog's true sight
COPY_EXISTING ~spin696.spl~ ~override~
  WRITE_ASCII 0x3a ~SPWI609C~ #8
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    WRITE_ASCII ("%abil_off%" + 0x04 + (0x28 * "%abil_num%")) ~SPWI609B~ // icon fix
  END
  BUT_ONLY_IF_IT_CHANGES

// hell spell fixes; change alignment deferred to teardoor and ar2900 scripts and wrong timing on bonuses
COPY_EXISTING ~spin747.spl~ ~override~ // selfish, evil
              ~spin749.spl~ ~override~ // wrath, evil
              ~spin750.spl~ ~override~ // wrath, good
              ~spin751.spl~ ~override~ // pride, evil
              ~spin753.spl~ ~override~ // fear, evil
              ~spin755.spl~ ~override~ // greed, evil
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
    PATCH_IF ("%type%" = 1) BEGIN // if melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
        PATCH_IF ("%opcode%" = 57) BEGIN // change alignment
          WRITE_LONG ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 0 // probability: zero
        END
        PATCH_IF (("%opcode%" = 6)  OR ("%opcode%" = 10)  OR ("%opcode%" = 44) // CHR/CON/STR bonus
               OR ("%opcode%" = 49) OR ("%opcode%" = 104) OR ("%opcode%" = 108)) BEGIN // WIS/XP bonus, rep change
          WRITE_BYTE ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 1 // timing: inst/perm
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// hell selfish penalties should be schoolless, bypass MR
COPY_EXISTING ~spin765.spl~ ~override~ // hell_lose xp
              ~spin766.spl~ ~override~ // hell_lose_dex
              ~spin767.spl~ ~override~ // hell_lose_hp
              ~spin768.spl~ ~override~ // hell_dispell [sic]
//              ~spin769.spl~ ~override~ // hell_hold, next
              ~spin770.spl~ ~override~ // hell_explode
              ~spin771.spl~ ~override~ // hell_damage_half
  WRITE_SHORT 0x25 0 // no primary type
  WRITE_SHORT 0x27 0 // no secondary type
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // go through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 0 // no dispel/bypass MR
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// hell selfish penalties should be schoolless, bypass MR-- hold is special; needs to be dispellable by demon
COPY_EXISTING ~spin769.spl~ ~override~ // hell_hold
  WRITE_SHORT 0x25 0 // no primary type
  WRITE_SHORT 0x27 0 // no secondary type
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) ("%abil_fx_idx%")
    FOR (index2 = 0 ; index2 < 2 ; index2 = index2 + 1) BEGIN
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30      // insert new effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 206       // play 3d effect
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2         // target: preset target
        WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1         // instant/permanent
        WRITE_LONG  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 3         // dispel/bypass
        WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100       // probability
    END
    WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%"    ))) ~sppr303~ // priest dispel magic
    WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + 1))) ~spwi326~ // mage dispel magic
    SET "fx_delta" = "%fx_delta%" + 2
    WRITE_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 2)
  END
  BUT_ONLY_IF_IT_CHANGES
  
// fear spell in fear hell trial can generate spurious MR messages and not play sound at end of spell duration
COPY_EXISTING ~spin772.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 174) BEGIN // damage
        WRITE_BYTE ("%fx_off%" + 0x0d + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // no dispel/bypass mr
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// slayer change - investigate further
// typo in resource references
COPY_EXISTING ~spin783.spl~ ~override~
              ~spin852.spl~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // adjusts fx indices on abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "resref"
      PATCH_IF (("%opcode%" = 215) AND ("%resref%" STRING_COMPARE_CASE "sparmor" = 0)) BEGIN
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "spsarmor" #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// use new flame strike animation, not the old one
COPY_EXISTING ~spin799.spl~  ~override~ // dace's flame strike
              ~sppr985.spl~  ~override~ // trap flamestrike
              ~spwi979.spl~  ~override~ // sarevok_strike
              ~spwm186.spl~  ~override~ // wild surge charm--was using flame strike anim
  READ_LONG  0x34 "level"
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) ("%abil_fx_idx%")
    READ_SHORT  ("%abil_off%" + 0x26 + (0x28 * "%index%")) "proj" // check projectile
    PATCH_IF ("%proj%" = 67) BEGIN
      SET "new_fx" = 2
      WRITE_SHORT ("%abil_off%" + 0x26 + (0x28 * "%index%")) 1 // remove old flame strike projectile and use effects instead
      FOR (index3 = 0 ; index3 < new_fx ; index3 = index3 + 1) BEGIN
        INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30      // insert new effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 215       // play 3d effect
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%")) 2         // target: preset target
          WRITE_BYTE  ("%fx_off%" + 0x03 + (0x30 * "%abil_fx_idx%")) "%level%" // power = level
          WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%")) 1         // instant/permanent
          WRITE_LONG  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%")) 1         // dispel/not bypass
          WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%")) 100       // probability
        PATCH_IF ("%index3%" = 0) BEGIN
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spflast2~    // vvc file
        END ELSE BEGIN
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spflsrin~    // vvc file
        END
      END
      SET "abil_fx_num" = "%abil_fx_num%" + "%new_fx%"
      SET "fx_delta" = ("%fx_delta%" + "%new_fx%")
    END
    WRITE_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// City of Caverns party heal before ettin and Illithid/Ularthid heal failed due to poor MR checks
COPY_EXISTING ~spin923.spl~ ~override~ // City of Caverns party heal
              ~spin958.spl~ ~override~ // Illithid/Ularthid heal
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
    PATCH_IF ("%type%" = 1) BEGIN // if melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 0 // no dispel/bypass
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// cutscene petrification visual effect allows save
COPY_EXISTING ~spin950.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 215) BEGIN // play 3d effect
        WRITE_LONG ("%fx_off%" + 0x24 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 0 // no save
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// MF psionic blast only spell to use spflayer.vvc; changing to use spmindat.vvc--calls same BAM to be played plus sound
// changing this reduces having to add protection from animation: spflayer in a lot of other files
COPY_EXISTING ~spin974.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "anim"
      PATCH_IF (("%opcode%" = 215) AND ("%anim%" STRING_COMPARE_CASE "spflayer" = 0)) BEGIN // play 3d animation spflayer.vvc
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~spmindat~
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// slow shouldn't stack
COPY_EXISTING ~spin575.spl~  ~override~ // slow
              ~spin977.spl~  ~override~ // slow (golem)
              ~spin983.spl~  ~override~ // slow (innate)
              ~spwi312.spl~  ~override~ // slow (mage)
              ~spwish25.spl~ ~override~ // slow (wish)
              ~spwm164.spl~  ~override~ // slow (wild surge)
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    SET "delta" = 0
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
        PATCH_IF ("%opcode%" = 40) BEGIN // if slow opcode
          READ_ASCII ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "clone_fx" (0x30) // read entire effect
          SET "index2" = "%abil_fx_num%" // kills loop
        END
      END
      FOR (index3 = 0 ; index3 < 6 ; index3 = index3 + 1) BEGIN
        INSERT_BYTES            ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 0x30         // create new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) ~%clone_fx%~ // clones slow effect
          WRITE_SHORT           ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 206          // spell immunity
          WRITE_LONG            ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 0xffffffff   // string to display
      END
      WRITE_EVALUATED_ASCII     ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 5))) ~%SOURCE_RES%~ #8 // resref
      WRITE_ASCII               ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 4))) ~spin575~ #8  // resref
      WRITE_ASCII               ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 3))) ~spin983~ #8  // resref
      WRITE_ASCII               ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 2))) ~spwi312~ #8  // resref
      WRITE_ASCII               ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 1))) ~spwish25~ #8 // resref
      WRITE_ASCII               ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 0))) ~spin977~ #8  // resref
      PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "spin575" = 0) BEGIN
        WRITE_ASCII               ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 4))) ~spwm164~ #8  // resref
      END ELSE
      PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "spin983" = 0) BEGIN
        WRITE_ASCII               ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 3))) ~spwm164~ #8  // resref
      END ELSE
      PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "spwi312" = 0) BEGIN
        WRITE_ASCII               ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 2))) ~spwm164~ #8  // resref
      END ELSE
      PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "spwish25" = 0) BEGIN
        WRITE_ASCII               ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 1))) ~spwm164~ #8  // resref
      END ELSE
      PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "spin977" = 0) BEGIN
        WRITE_ASCII               ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%" + 0))) ~spwm164~ #8  // resref
      END
      SET "delta" = "%delta%" + 6
      WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 6)
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// beholder death ray should be subject to MR
COPY_EXISTING ~spin991.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
    PATCH_IF ("%type%" = 1) BEGIN // if melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
        PATCH_IF ("%opcode%" = 13) BEGIN // kill target
          WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 1 // dispel/not bypass
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// typo in spl reference
COPY_EXISTING ~spinhum.spl~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off"   ELSE 0
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // adjusts fx indices on abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "resref"
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spinhun" = 0)) BEGIN
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "spinhum" #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Harper's Call not draining stats

/// DW: fix a typo in the CDSPJA files (spotted by Mike1072)

COPY_EXISTING 
  ~cdspja00.eff~ ~override~
  ~cdspja01.eff~ ~override~
  ~cdspja02.eff~ ~override~
  ~cdspja03.eff~ ~override~
  ~cdspja04.eff~ ~override~
  ~cdspja05.eff~ ~override~
    WRITE_LONG 0x20 0
BUT_ONLY_IF_IT_CHANGES
  

COPY_EXISTING ~spja01.spl~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    SET "new_fx" = 6
    FOR (index = 0; index < abil_num; index = index + 1) BEGIN
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + "%new_fx%")
      READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      SET         "abil_fx_idx" = ("%abil_fx_idx%" + ("%new_fx%" * "%index%"))
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
      FOR (index3 = 0 ; index3 < abil_fx_num ; index3 = index3 + 1) BEGIN
        READ_SHORT ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index3%"))) "target"
        PATCH_IF ("%target%" = 2) BEGIN // preset target
          WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index3%"))) 0 // no dispel/bypass mr
        END
      END
      FOR (index2 = 0; index2 < new_fx; index2 = index2 + 1) BEGIN
        INSERT_BYTES   ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 0x30
          WRITE_SHORT  ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 177              // use eff file
          WRITE_BYTE   ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 2                // target: preset target
          WRITE_BYTE   ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 5                // power
          WRITE_LONG   ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 2                // pc...
          WRITE_LONG   ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 2                // from ea.ids
          WRITE_LONG   ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 60               // 60 seconds
          WRITE_BYTE   ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 100              // probability
          WRITE_ASCIIE ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) ~cdspja0%index2%~ // resref
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// entangle doesn't have its listed save bonus for target
COPY_EXISTING ~sppr105.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // look through abilities
    READ_SHORT  ("%abil_off%" + 0x1e) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_LONG ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 3 // save bonus
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// barkskin AC bonus incorrect at higher levels
COPY_EXISTING ~sppr202.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_level"
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 0) BEGIN // ac bonus
        WRITE_LONG ("%fx_off%" + 0x04 + (("%abil_fx_idx%" + "%index2%") * 0x30)) (6 - ("%min_level%" / 4)) // ((6 - (caster level/4), per descript
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// chant doesn't provide the listed save bonuses nor the penalties to opponents. Also shouldn't stack.
COPY_EXISTING ~sppr203.spl~  ~override~
  PATCH_IF (%SOURCE_SIZE%>0x71)                               BEGIN
    READ_LONG    0x64 "ho"                                    // extended header offset
    READ_SHORT   0x68 "hc"                                    // extended header count
    READ_LONG    0x6a "eo"                                    // feature table offset
    FOR ("i1"=0; "%i1%"<"%hc%"; "i1"+=1)                      BEGIN
      WRITE_BYTE    ("%ho%"+(0x28*"%i1%")+0x0c) 0x05          // target self
      WRITE_SHORT   ("%ho%"+(0x28*"%i1%")+0x0e) 0x00          // range
      READ_SHORT    ("%ho%"+(0x28*"%i1%")+0x1e) "ec"          // effects for header i+1
      READ_SHORT    ("%ho%"+(0x28*"%i1%")+0x20) "ei"          // effect index for header i+1
      WRITE_SHORT   ("%ho%"+(0x28*"%i1%")+0x26) 0x01          // projectile: none
      DELETE_BYTES  ("%eo%"+(0x30*"%ei%")+0x00) (0x30*"%ec%") // remove existing effects
      INSERT_BYTES  ("%eo%"+(0x30*"%ei%")+0x00) 0x60          // add two new effects
      WRITE_ASCII   ("%eo%"+(0x30*"%ei%")+0x14) ~sppr203d~ #8 // positive chant
      WRITE_ASCII   ("%eo%"+(0x30*"%ei%")+0x44) ~sppr203e~ #8 // negative chant
      FOR ("i2"=0; "%i2%"<2; "i2"+=1)                         BEGIN
        WRITE_SHORT ("%eo%"+(0x30*("%ei%"+"%i2%"))+0x00) 0x92 // cast spell
        WRITE_BYTE  ("%eo%"+(0x30*("%ei%"+"%i2%"))+0x02) 0x01 // target self
        WRITE_BYTE  ("%eo%"+(0x30*("%ei%"+"%i2%"))+0x03) 0x00 // power
        WRITE_LONG  ("%eo%"+(0x30*("%ei%"+"%i2%"))+0x04) 0x00 // casting level
        WRITE_LONG  ("%eo%"+(0x30*("%ei%"+"%i2%"))+0x08) 0x01 // cast instantly
        WRITE_BYTE  ("%eo%"+(0x30*("%ei%"+"%i2%"))+0x0c) 0x01 // instant/permanent
        WRITE_BYTE  ("%eo%"+(0x30*("%ei%"+"%i2%"))+0x0d) 0x00 // resistability
        WRITE_BYTE  ("%eo%"+(0x30*("%ei%"+"%i2%"))+0x12) 0x64 // min prob 100%
      END                                                     // FOR i2 effect fleshing
      WRITE_SHORT   ("%ho%"+(0x28*"%i1%")+0x1e) 0x02          // effects for header i+1
      FOR ("i3"="%i1%" + 1; "%i3%"<"%hc%"; "i3"+=1)           BEGIN //i1 + 1, because we only want to update the later headers
        READ_SHORT  ("%ho%"+(0x28*"%i3%")+0x20) "ix"          // search later header indices
        WRITE_SHORT ("%ho%"+(0x28*"%i3%")+0x20) (("%ix%"-"%ec%")+0x02)
      END                                                     // FOR i3; rewriting ability effect indices
    END                                                       // FOR i1
  END                                                         // PATCH_IF filesize check
  BUT_ONLY_IF_IT_CHANGES                                        // COPY_EXISTING

// resist fire/cold has incorrect duration at level 20; stacking issue already covered below
COPY_EXISTING ~sppr210.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  PATCH_IF ("%abil_num%" > 0) BEGIN // grabs last ability (lev 20)
    READ_SHORT ("%abil_off%" + 0x1e + (("%abil_num%" - 1) * 0x28)) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (("%abil_num%" - 1) * 0x28)) "abil_fx_idx"
    WHILE ("%abil_fx_num%" > 0) BEGIN
      SET "abil_fx_num" = ("%abil_fx_num%" - 1)
      READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "duration"
      PATCH_IF ("%duration%" = 200) BEGIN // incorrect duration
        WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 120 // corrects duration
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// casting speed fixes
COPY_EXISTING ~sppr301.spl~ ~override~ // animate dead - divine
              ~spwi501.spl~ ~override~ // animate dead - arcane
              ~sppr302.spl~ ~override~ // call lightning
              ~sppr506.spl~ ~override~ // iron skins
              ~sppr608.spl~ ~override~ // harm
              ~sppr720.spl~ ~override~ // earthquake
              ~sppr723.spl~ ~override~ // elemental summoning
              ~sppr724.spl~ ~override~ // greater elemental summoning
              ~spwi208.spl~ ~override~ // know alignment
              ~spwi214.spl~ ~override~ // strength
              ~spwi420.spl~ ~override~ // minor sequencer
              ~spwi617.spl~ ~override~ // contingency
              ~spwi710.spl~ ~override~ // spell sequencer
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%index%")) 9
  END
  BUT_ONLY_IF_IT_CHANGES

// animate dead has several minor errors in effect headers and is missing headrs for levels 6-9
COPY_EXISTING ~sppr301.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "lev6_exist" = 0
  SET "lev7_exist" = 0
  SET "lev8_exist" = 0
  SET "lev9_exist" = 0
  SET "new_abil" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_ASCII ("%abil_off%" + 0x04 + (0x28 * "%index%")) ~sppr301b~ // consistent icon
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_lev"
    PATCH_IF ("%min_lev%" = 1) BEGIN // if first header
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 177) BEGIN // last eff opcode
          READ_BYTE  ("%fx_off%" + 0x13 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "prob_lo"
          PATCH_IF ("%prob_lo%" = 0) BEGIN
            WRITE_BYTE ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 3  // power
            WRITE_BYTE ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 75 // probability
          END ELSE BEGIN
            WRITE_BYTE ("%fx_off%" + 0x13 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 76 // probability
          END
        END
      END
      READ_ASCII ("%abil_off%" + (0x28 * "%index%"))       "abil_clone" (0x28)
      READ_ASCII ("%fx_off%" + (0x30 * ("%abil_fx_idx%"))) "fx_clone" (0x30 * "%abil_fx_num%")
      SET "new_fx" = "%abil_fx_num%"
      SET "start_fx" = ("%abil_fx_idx%" + "%abil_fx_num%")
      SET "insert" = ("%abil_off%" + (0x28 * ("%index%" + 1)))
    END ELSE
    PATCH_IF ("%min_lev%" = 6) BEGIN 
      SET "lev6_exist" = 1
    END ELSE
    PATCH_IF ("%min_lev%" = 7) BEGIN
      SET "lev7_exist" = 1
    END ELSE
    PATCH_IF ("%min_lev%" = 8) BEGIN
      SET "lev8_exist" = 1
    END ELSE
    PATCH_IF ("%min_lev%" = 9) BEGIN
      SET "lev9_exist" = 1
    END ELSE
    PATCH_IF ("%min_lev%" = 11) BEGIN // level 11 header
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 177) BEGIN // last eff opcode
          READ_BYTE  ("%fx_off%" + 0x13 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "prob_lo"
          PATCH_IF ("%prob_lo%" = 0) BEGIN
            WRITE_BYTE ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 45 // probability
          END
        END
      END
    END
  END
  PATCH_IF ("%lev6_exist%" = 0) BEGIN
    SET "level" = 6
    INSERT_BYTES (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // last eff opcode
        READ_BYTE  (("%fx_off%" + (0x28 * "%new_abil%")) + 0x12 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "prob_hi"
        PATCH_IF ("%prob_hi%" != 100) BEGIN
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x12 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) (100 - ("%level%" * 5)) // probability
        END ELSE BEGIN
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x13 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) (101 - ("%level%" * 5)) // probability
        END
      END
    END
    INSERT_BYTES ("%insert%" + (0x28 * "%new_abil%")) 0x28
      WRITE_EVALUATED_ASCII ("%insert%" + (0x28 * "%new_abil%")) "%abil_clone%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x10) "%level%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x1e) "%new_fx%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x20) ("%start_fx%" * ("%new_abil%" + 1))
    SET "new_abil" = "%new_abil%" + 1
  END
  PATCH_IF ("%lev7_exist%" = 0) BEGIN
    SET "level" = 7
    INSERT_BYTES (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // last eff opcode
        READ_BYTE  (("%fx_off%" + (0x28 * "%new_abil%")) + 0x12 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "prob_hi"
        PATCH_IF ("%prob_hi%" != 100) BEGIN
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x12 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) (100 - ("%level%" * 5)) // probability
        END ELSE BEGIN
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x13 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) (101 - ("%level%" * 5)) // probability
        END
      END
    END
    INSERT_BYTES ("%insert%" + (0x28 * "%new_abil%")) 0x28
      WRITE_EVALUATED_ASCII ("%insert%" + (0x28 * "%new_abil%")) "%abil_clone%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x10) "%level%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x1e) "%new_fx%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x20) ("%start_fx%" * ("%new_abil%" + 1))
    SET "new_abil" = "%new_abil%" + 1
  END
  PATCH_IF ("%lev8_exist%" = 0) BEGIN
    SET "level" = 8
    INSERT_BYTES (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // last eff opcode
        READ_BYTE  (("%fx_off%" + (0x28 * "%new_abil%")) + 0x12 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "prob_hi"
        PATCH_IF ("%prob_hi%" != 100) BEGIN
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x12 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) (100 - ("%level%" * 5)) // probability
        END ELSE BEGIN
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x13 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) (101 - ("%level%" * 5)) // probability
        END
      END
    END
    INSERT_BYTES ("%insert%" + (0x28 * "%new_abil%")) 0x28
      WRITE_EVALUATED_ASCII ("%insert%" + (0x28 * "%new_abil%")) "%abil_clone%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x10) "%level%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x1e) "%new_fx%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x20) ("%start_fx%" * ("%new_abil%" + 1))
    SET "new_abil" = "%new_abil%" + 1
  END
  PATCH_IF ("%lev9_exist%" = 0) BEGIN
    SET "level" = 9
    INSERT_BYTES (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // last eff opcode
        READ_BYTE  (("%fx_off%" + (0x28 * "%new_abil%")) + 0x12 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "prob_hi"
        PATCH_IF ("%prob_hi%" != 100) BEGIN
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x12 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) (100 - ("%level%" * 5)) // probability
        END ELSE BEGIN
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x13 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) (101 - ("%level%" * 5)) // probability
        END
      END
    END
    INSERT_BYTES ("%insert%" + (0x28 * "%new_abil%")) 0x28
      WRITE_EVALUATED_ASCII ("%insert%" + (0x28 * "%new_abil%")) "%abil_clone%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x10) "%level%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x1e) "%new_fx%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x20) ("%start_fx%" * ("%new_abil%" + 1))
    SET "new_abil" = "%new_abil%" + 1
  END
  PATCH_IF ("%new_abil%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" + "%new_abil%")
    WRITE_SHORT 0x68 "abil_num"
    WRITE_LONG  0x6a ("%fx_off%" + (0x28 * "%new_abil%"))
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_lev"
      PATCH_IF ("%min_lev%" > 9) BEGIN // if after new inserted effects
        READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
        WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) ("%abil_fx_idx%" + ("%new_abil%" * "%new_fx%"))
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// some effects on dispel magic subject to MR, though all other effects are not; see also deva.itm et al patch
COPY_EXISTING ~spin866.spl~  ~override~ // FORCE_DISPEL_MAGIC
              ~sppr303.spl~  ~override~ // dispel magic (priest)
              ~spwi302.spl~  ~override~ // remove magic (mage)
              ~spwi326.spl~  ~override~ // dispel magic (mage)
              ~sw2h10dm.spl~ ~override~ // dispel magic (unused)
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // loop through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF (("%opcode%" = 58) OR ("%opcode%" = 77) OR ("%opcode%" = 215) OR ("%opcode%" = 240)) BEGIN // dispel fx, cure fm, play 3d effect, remove icon opcodes
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // no dispel/bypass MR
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// hold animal has incorrect casting time and has a spurious save penalty
COPY_EXISTING ~sppr305.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // look through abilities
    WRITE_SHORT ("%abil_off%" + 0x12 + ("%index%" * 0x28)) 5  // casting time
    READ_SHORT  ("%abil_off%" + 0x1e) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_LONG ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // save bonus
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// casting speed fixes
COPY_EXISTING ~sppr309.spl~ ~override~ // invisibility purge
              ~sppr502.spl~ ~override~ // cure crit wounds
              ~spwi609.spl~ ~override~ // true sight
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%index%")) 8
  END
  BUT_ONLY_IF_IT_CHANGES

// holy smite missing level 20 abilities, a few effects mistargeted and/or wrong duration at lev 6, 7
COPY_EXISTING ~sppr313.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "orig_abil" = "%abil_num%"
  SET "delta" = 0
  SET "loops" = 0
  SET "min_lev" = 0
  WHILE ("%abil_num%" > 0) BEGIN // grabs last ability (lev 19) and does patching for lev 6, 7 abilities
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT ("%abil_off%" + 0x10 + (0x28 * "%abil_num%")) "level"
    PATCH_IF ("%min_lev%" = 0) BEGIN
      SET "min_lev" = "%level%" // sets min_lev to use last ability
    END
    PATCH_IF (("%level%" = 6) OR ("%level%" = 7)) BEGIN
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "eff_file"
        PATCH_IF ("%eff_file%" STRING_COMPARE_CASE "hitinvwa" = 0) BEGIN
          WRITE_BYTE ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 1 // instant/permanent
        END ELSE
        PATCH_IF ("%eff_file%" STRING_COMPARE_CASE "blind" = 0) BEGIN
          WRITE_BYTE ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 0 // instant/limited
          WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 6 // duration
        END
      END
    END
  END
  PATCH_IF ("%min_lev%" < 20) BEGIN
    INSERT_BYTES "%fx_off%" 0x28
    SET "delta" = 1
    READ_ASCII ("%fx_off%" - 0x28) "abil_clone" (0x28) // reads entire ability as block
    READ_SHORT (("%fx_off%" - 0x28) + 0x1e) "abil_fx_num"
    READ_SHORT (("%fx_off%" - 0x28) + 0x20) "abil_fx_idx"
  END
  WHILE ("%delta%" > "%loops%") BEGIN // this clones the lev 19 abilities to the lev 20 one
    WRITE_EVALUATED_ASCII  (("%fx_off%" + (0x28 * "%loops%"))       ) "%abil_clone%"
    WRITE_SHORT            (("%fx_off%" + (0x28 * "%loops%")) + 0x10) ("%min_lev%" + 1 + "%loops%")
    WRITE_SHORT            (("%fx_off%" + (0x28 * "%loops%")) + 0x1e) "%abil_fx_num%"
    WRITE_SHORT            (("%fx_off%" + (0x28 * "%loops%")) + 0x20) ("%abil_fx_idx%" + (("%loops%" + 1) * "%abil_fx_num%"))
    SET "loops" = ("%loops%" + 1)
  END
  WRITE_SHORT 0x68 ("%orig_abil%" + "%delta%")
  SET "fx_off" = ("%fx_off%" + (0x28 * "%delta%"))
  WRITE_LONG  0x6a "%fx_off%"
  INSERT_BYTES ("%fx_off%" + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) (0x30 * ("%delta%" * "%abil_fx_num%"))
  WHILE ("%delta%" > 0) BEGIN
    SET "loops" = "%abil_fx_num%"
    WHILE ("%loops%" > 0) BEGIN
      SET "loops" = ("%loops%" - 1)
      READ_ASCII  ("%fx_off%" + 0x00 + (0x30 * ("%loops%" + "%abil_fx_idx%"))) "clone" (0x30)
      WRITE_EVALUATED_ASCII ("%fx_off%" + 0x00 + (0x30 * ("%loops%" + "%abil_fx_idx%")) + ("%delta%" * (0x30 * "%abil_fx_num%"))) "%clone%"
      READ_ASCII  ("%fx_off%" + 0x14 + (0x30 * ("%loops%" + "%abil_fx_idx%"))) "eff_again"
      PATCH_IF ("%eff_again%" STRING_COMPARE_CASE "sp313l19" = 0) BEGIN
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%loops%" + "%abil_fx_idx%")) + ("%delta%" * (0x30 * "%abil_fx_num%"))) ~sp313l20~
      END ELSE BEGIN
        WRITE_EVALUATED_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%loops%" + "%abil_fx_idx%")) + ("%delta%" * (0x30 * "%abil_fx_num%"))) "%eff_again%"
      END
    END
    SET "delta" = ("%delta%" - 1)
  END
  BUT_ONLY_IF_IT_CHANGES

// free action misc errors and missing lev 19, 20 headers
// all supplementary effects handled in effects batches below
COPY_EXISTING ~sppr403.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "basedur" = 96
  FOR (loops = abil_num; loops > 0; loops = loops - 0x01) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * ("%loops%" - 1))) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * ("%loops%" - 1))) "abil_fx_idx"
    WHILE ("%abil_fx_num%" > 0) BEGIN // first fix existing effects
      SET "abil_fx_num" = ("%abil_fx_num%" - 1)
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "immunity"
      PATCH_IF (("%opcode%" = 101) AND ("%immunity%" = 5)) BEGIN // immunity to charm
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 126 // movementrate bonus
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 100 // percentage
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 2   // set to %
      END
      PATCH_IF (("%opcode%" = 101) AND ("%immunity%" = 185)) BEGIN // immunity to hold 2 shouldn't be there, also targeted at self
        WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 169 // prevent portait icon
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 2   // target: preset target
        WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 145 // grease
      END
    END
  END
  // read data from last ability
  READ_SHORT ("%abil_off%" + 0x10 + (0x28 * ("%abil_num%" - 1))) "min_lev"
  READ_SHORT ("%abil_off%" + 0x1e + (0x28 * ("%abil_num%" - 1))) "abil_fx_num"
  READ_SHORT ("%abil_off%" + 0x20 + (0x28 * ("%abil_num%" - 1))) "abil_fx_idx"
  SET "abil_insert" = ("%abil_off%" + (0x28 * "%abil_num%"))
  PATCH_IF ("%min_lev%" < 20) BEGIN // if abilities don't go to lev 20
    READ_ASCII ("%fx_off%" + (0x30 * "%abil_fx_idx%")) "effects" ("%abil_fx_num%" * 0x30) // reads whole block of effects from last ability
    READ_ASCII ("%abil_off%" + (0x28 * ("%abil_num%" - 1))) "ability" (0x28)              // reads last ability
    FOR ("index" = 20; "%index%" > "%min_lev%"; "index" = ("%index%" - 1)) BEGIN          // now extend headers
      INSERT_BYTES          ("%fx_off%" + (0x30 * "%abil_fx_idx%")) ("%abil_fx_num%" * 0x30) // inserts bytes
      WRITE_EVALUATED_ASCII ("%fx_off%" + (0x30 * "%abil_fx_idx%")) "%effects%"              // clones existing effects
      FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN    // loop to adjust effects by min level
        READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%"))) "duration"
        PATCH_IF ("%duration%" > 5) BEGIN // longer than one round
          WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%"))) (60 + (6 * "%index%")) // corrects duration
        END
      END
      INSERT_BYTES          ("%abil_insert%"       ) 0x28        // inserts bytes
      WRITE_EVALUATED_ASCII ("%abil_insert%"       ) "%ability%" // clones existing ability
      WRITE_SHORT           ("%abil_insert%" + 0x10) "%index%"   // minimum level
      WRITE_SHORT           ("%abil_insert%" + 0x1e) "%abil_fx_num%"
      WRITE_SHORT           ("%abil_insert%" + 0x20) ("%abil_fx_idx%" + ("%abil_fx_num%" * ("%index%" - "%min_lev%")))
      SET "fx_off" = ("%fx_off%" + 0x28)
      SET "abil_num" = ("%abil_num%" + 1)
    END
  WRITE_LONG  0x6a "%fx_off%"
  WRITE_SHORT 0x68 "%abil_num%"
  END

// neutralize poison failing to cure disease due to bad target
COPY_EXISTING ~sppr404.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // fix existing effects
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 79) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 2 // target: preset target
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// opcode has wrong target in death ward
COPY_EXISTING ~sppr409.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 282) BEGIN // damage opcode
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 2 // preset target
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// holy power missing level 19, 20 abilities
COPY_EXISTING ~sppr412.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  SET "lev19_exist" = 0
  SET "lev20_exist" = 0
  SET "new_abil" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_lev"
    PATCH_IF ("%index%" = ("%abil_num%" - 1)) BEGIN // last header
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      READ_ASCII  ("%abil_off%" + (0x28 * "%index%"))       "abil_clone" (0x28)
      READ_ASCII  ("%fx_off%" + (0x30 * ("%abil_fx_idx%"))) "fx_clone" (0x30 * "%abil_fx_num%")
      SET "new_fx" = "%abil_fx_num%"
      SET "start_fx" = ("%abil_fx_idx%" + "%abil_fx_num%")
    END ELSE
    PATCH_IF ("%min_lev%" = 19) BEGIN
      SET "lev19_exist" = 1
    END
    PATCH_IF ("%min_lev%" = 20) BEGIN
      SET "lev20_exist" = 1
    END
  END
  PATCH_IF ("%lev19_exist%" = 0) BEGIN
    SET "level" = 19
    INSERT_BYTES ("%fx_off%" + (0x30 * "%start_fx%")) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII ("%fx_off%" + (0x30 * "%start_fx%")) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%start_fx%"))) "opcode"
      PATCH_IF ("%opcode%" = 54) BEGIN // thac0 bonus
        WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%index2%" + "%start_fx%"))) (21 - "%level%")
      END ELSE
      PATCH_IF ("%opcode%" = 18) BEGIN // hp bonus
        WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%index2%" + "%start_fx%"))) "%level%"
      END
      READ_BYTE  ("%fx_off%" + 0x0c + (0x30 * ("%index2%" + "%start_fx%"))) "timing"
      READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%start_fx%"))) "duration"
      PATCH_IF (("%duration%" > 5) AND (("%timing%" = 0) OR ("%timing%" = 3))) BEGIN // for durations longer than a round, limited timing modes
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%start_fx%"))) (6 * "%level%")
      END
    END
    INSERT_BYTES            ("%fx_off%"       ) 0x28
      WRITE_EVALUATED_ASCII ("%fx_off%"       ) "%abil_clone%"
      WRITE_SHORT           ("%fx_off%" + 0x10) "%level%"
    SET "new_abil" = "%new_abil%" + 1
    SET "fx_off" = ("%fx_off%" + 0x28)
    SET "start_fx" = ("%start_fx%" + "%new_fx%")
  END
  PATCH_IF ("%lev20_exist%" = 0) BEGIN
    SET "level" = 20
    INSERT_BYTES ("%fx_off%" + (0x30 * "%start_fx%")) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII ("%fx_off%" + (0x30 * "%start_fx%")) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%start_fx%"))) "opcode"
      PATCH_IF ("%opcode%" = 54) BEGIN // thac0 bonus
        WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%index2%" + "%start_fx%"))) (21 - "%level%")
      END ELSE
      PATCH_IF ("%opcode%" = 18) BEGIN // hp bonus
        WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%index2%" + "%start_fx%"))) "%level%"
      END
      READ_BYTE  ("%fx_off%" + 0x0c + (0x30 * ("%index2%" + "%start_fx%"))) "timing"
      READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%start_fx%"))) "duration"
      PATCH_IF (("%duration%" > 5) AND (("%timing%" = 0) OR ("%timing%" = 3))) BEGIN // for durations longer than a round, limited timing modes
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%start_fx%"))) (6 * "%level%")
      END
    END
    INSERT_BYTES            ("%fx_off%"       ) 0x28
      WRITE_EVALUATED_ASCII ("%fx_off%"       ) "%abil_clone%"
      WRITE_SHORT           ("%fx_off%" + 0x10) "%level%"
    SET "new_abil" = "%new_abil%" + 1
    SET "fx_off" = ("%fx_off%" + 0x28)
    SET "start_fx" = ("%start_fx%" + "%new_fx%")
  END
  PATCH_IF ("%new_abil%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" + "%new_abil%")
    WRITE_SHORT 0x68 "%abil_num%"
    WRITE_LONG  0x6a "%fx_off%"
    // re-index everything
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%fx_num%"
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      SET "fx_num" = "%fx_num%" + "%abil_fx_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// champion's strength missing level 19,20 headers, wrong durations at levels 17,18
COPY_EXISTING ~sppr507.spl~  ~override~ // champion's strength
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT ("%abil_off%" + 0x10 + (("%abil_num%" - 1) * 0x28)) "min_level" // min level of last ability header
  FOR (index = min_level + 1 ; index < 21 ; index = index + 1) BEGIN
    READ_ASCII ("%abil_off%" +        (("%abil_num%" - 1) * 0x28)) "abil_clone" (0x28) // reads last ability as block
    READ_SHORT ("%abil_off%" + 0x1e + (("%abil_num%" - 1) * 0x28)) "abil_fx_num" // reads number of fx from last ability
    READ_SHORT ("%abil_off%" + 0x20 + (("%abil_num%" - 1) * 0x28)) "abil_fx_idx" // reads index of last effects from last ability
    // create effects for next level based off previous level effects
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_ASCII     ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "clone_fx" (0x30) // reads entire effect
      INSERT_BYTES   ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%") * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%") * 0x30)) "%clone_fx%" // clones effect
    END
    // effects created, now add new ability
    INSERT_BYTES            ("%abil_off%" +        ("%abil_num%" * 0x28)) 0x28
      WRITE_EVALUATED_ASCII ("%abil_off%" +        ("%abil_num%" * 0x28)) "%abil_clone%" // clones last ability
      WRITE_SHORT           ("%abil_off%" + 0x10 + ("%abil_num%" * 0x28)) "%index%"      // min level
      WRITE_SHORT           ("%abil_off%" + 0x20 + ("%abil_num%" * 0x28)) ("%abil_fx_num%" + "%abil_fx_idx%") // corrects fx index
    SET "fx_off" = ("%fx_off%" + 0x28)
    SET "abil_num" = "%abil_num%" + 1
  END
  WRITE_SHORT 0x68 "%abil_num%"
  WRITE_LONG  0x6a "%fx_off%"
  // fixes durations for new abilities and levels 17,18
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x10 + ("%index%" * 0x28)) "min_lev"
    READ_SHORT ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    PATCH_IF ("%min_lev%" = 1) BEGIN
      SET "min_lev" = 9
    END
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_LONG  ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%index2%") * 0x30)) "duration"
      PATCH_IF ("%duration%" > 5) BEGIN // if more than one round
        WRITE_LONG  ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%index2%") * 0x30)) ("%min_lev%" * 18) // 3 rounds/level
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// two durations are incorrect for righteous magic; stacking handled below
COPY_EXISTING ~sppr513.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT ("%abil_off%" + 0x10 + (0x28 * "%abil_num%")) "min_lev"
    PATCH_IF ("%min_lev%" = 10) BEGIN // if melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
        PATCH_IF ("%opcode%" = 250) BEGIN // max damage per hit
          WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 60 // dispel/not bypass
        END
      END
    END ELSE
    PATCH_IF ("%min_lev%" = 20) BEGIN // if melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
        PATCH_IF ("%opcode%" = 142) BEGIN // display portrait icon
          WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 120 // dispel/not bypass
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// power issue with false dawn
COPY_EXISTING ~sppr609.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // fix existing effects
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 146) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // power
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// gate should be visual sight range
COPY_EXISTING ~sppr703.spl~ ~override~
              ~spwi905.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x0e + (0x28 * "%index%")) 30
  END
  BUT_ONLY_IF_IT_CHANGES

// casting speed fixes
COPY_EXISTING ~sppr711.spl~ ~override~ // regeneration
              ~spwi723.spl~ ~override~ // improved chaos shield
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%index%")) 7
  END
  BUT_ONLY_IF_IT_CHANGES

ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB
  // energy blades
  COPY_EXISTING ~sppr721.spl~ ~override~
                ~spwi920.spl~ ~override~
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    READ_LONG  0x34 "level"
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "%level%" // power is wrong in effects
      END
    END
    BUT_ONLY_IF_IT_CHANGES
END

// grease fixes
COPY_EXISTING ~spwi101.spl~ ~override~
  WRITE_ASCII 0x3a ~spwi101c~ // fixes icon
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // first fix existing effects
    WRITE_SHORT ("%abil_off%" + index * 0x28 + 0x0e + ("%index%" * 0x28)) 30 // corrects range
    WRITE_SHORT ("%abil_off%" + index * 0x28 + 0x12 + ("%index%" * 0x28)) 1  // casting time
    READ_SHORT  ("%abil_off%" + index * 0x28 + 0x10) "min_lev"
    READ_SHORT  ("%abil_off%" + index * 0x28 + 0x1e) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + index * 0x28 + 0x20) "abil_fx_idx"
    FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN
      READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "duration"
      PATCH_IF ("%duration%" > 5) BEGIN // longer than one round
        WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) (18 + (6 * "%min_lev%")) // corrects duration
      END
    END
  END
  PATCH_IF ("%min_lev%" < 20) BEGIN // if abilities don't go to lev 20
    READ_ASCII ("%fx_off%" + (0x30 * "%abil_fx_idx%")) "effects" ("%abil_fx_num%" * 0x30) // reads whole block of effects from last ability
    READ_ASCII ("%abil_off%" + (0x28 * ("%abil_num%" - 1))) "ability" (0x28)              // reads last ability
    FOR ("index" = 20; "%index%" > "%min_lev%"; "index" = ("%index%" - 1)) BEGIN          // now extend headers
      INSERT_BYTES          ("%fx_off%" + (0x30 * "%abil_fx_idx%")) ("%abil_fx_num%" * 0x30) // inserts bytes
      WRITE_EVALUATED_ASCII ("%fx_off%" + (0x30 * "%abil_fx_idx%")) "%effects%"              // clones existing effects
      FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN    // loop to adjust effects by min level
        READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%"))) "duration"
        PATCH_IF ("%duration%" > 5) BEGIN // longer than one round
          WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%"))) (18 + (6 * "%index%")) // corrects duration
        END
      END
      INSERT_BYTES          ("%abil_off%" + 0x28) 0x28        // inserts bytes
      WRITE_EVALUATED_ASCII ("%abil_off%" + 0x28) "%ability%" // clones existing ability
      WRITE_SHORT           ("%abil_off%" + 0x38) ("%index%") // minimum level
      WRITE_SHORT           ("%abil_off%" + 0x46) "%abil_fx_num%"
      WRITE_SHORT           ("%abil_off%" + 0x48) ("%abil_fx_idx%" + ("%abil_fx_num%" * ("%index%" - 1)))
      SET "fx_off" = ("%fx_off%" + 0x28)
      SET "abil_num" = ("%abil_num%" + 1)
    END
  WRITE_LONG  0x6a "%fx_off%"
  WRITE_SHORT 0x68 "%abil_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// armor fixes
COPY_EXISTING ~spwi102.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    WRITE_SHORT ("%abil_off%" + 0x12 + ("%index%" * 0x28)) 9 // casting time
    READ_SHORT  ("%abil_off%" + 0x10) "min_lev"
    READ_SHORT  ("%abil_off%" + 0x1e) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20) "abil_fx_idx"
    FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "duration"
      PATCH_IF ("%opcode%" = 215) BEGIN // play 3d effect opcode
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 2             // corrects duration
      END
      PATCH_IF ("%duration%" > 5) BEGIN // longer than one round
        WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 2700 // corrects duration
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// burning hands fixes
COPY_EXISTING ~spwi103.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x28)) 5 // corrects range
    READ_SHORT  ("%abil_off%" + 0x10) "min_lev"
    READ_SHORT  ("%abil_off%" + 0x1e) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20) "abil_fx_idx"
    PATCH_IF ("%min_lev%" = 1) BEGIN
      FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 165) BEGIN // play 3d effect opcode
          WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 2             // corrects duration
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// color spray fixes - range is wrong, removes undocumented save penalty
COPY_EXISTING ~spin937.spl~ ~override~ // mephit version
              ~spwi105.spl~ ~override~ // regular mage version
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x28)) 30 // corrects range
    READ_SHORT  ("%abil_off%" + 0x1e) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20) "abil_fx_idx"
    FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN
      WRITE_LONG  ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // set save bonus to 0
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// spell range as "visual range"
COPY_EXISTING ~spwi106.spl~ ~override~ // blindness
              ~spwi111.spl~ ~override~ // infravision
              ~spwi125.spl~ ~override~ // spook
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x28)) 60 // corrects range
  END
  BUT_ONLY_IF_IT_CHANGES

// friends fixes
// partially dropped because of multiple chr stacking. :(
COPY_EXISTING ~spwi107.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT  ("%abil_off%" + 0x48) "second_fx_idx"
  READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * ("%abil_num%" - 1))) "last_fx_num"
  READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * ("%abil_num%" - 1))) "last_fx_idx"
  DELETE_BYTES ("%fx_off%" + (0x30 * "%second_fx_idx%")) (0x30 * (("%last_fx_idx%" + "last_fx_num") - "%second_fx_idx%")) // eliminates all high lev effects
  DELETE_BYTES ("%abil_off%" + 0x28) (0x28 * ("%abil_num%" - 1)) // eliminates all abilities beyond the first
  SET "fx_off" = ("%fx_off%" - (0x28 * ("%abil_num%" - 1)))
  // now to patch effects at lev 1 before cloning
  READ_SHORT  ("%abil_off%" + 0x1e) "abil_fx_num"
  READ_SHORT  ("%abil_off%" + 0x20) "abil_fx_idx"
  READ_ASCII ("%fx_off%" + (0x30 * "%abil_fx_idx%")) "effects" ("%abil_fx_num%" * 0x30) // reads whole block of effects from last ability
  READ_ASCII ("%abil_off%") "ability" (0x28)                                            // reads last ability
  FOR ("index" = 20; "%index%" > 1; "index" = ("%index%" - 1)) BEGIN                    // now extend headers
    INSERT_BYTES            ("%fx_off%" + (0x30 * "%abil_fx_idx%")) ("%abil_fx_num%" * 0x30) // inserts bytes
      WRITE_EVALUATED_ASCII ("%fx_off%" + (0x30 * "%abil_fx_idx%")) "%effects%"              // clones existing effects
    FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN    // loop to adjust effects by min level
      READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%"))) "duration"
      PATCH_IF ("%duration%" > 5) BEGIN // longer than one round
        WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%" + "%index2%"))) ("%duration%" + (6 * ("%index%" - 1))) // corrects duration
      END
    END
    INSERT_BYTES            ("%abil_off%" + 0x28) 0x28        // inserts bytes
      WRITE_EVALUATED_ASCII ("%abil_off%" + 0x28) "%ability%" // clones existing ability
      WRITE_SHORT           ("%abil_off%" + 0x38) ("%index%") // minimum level
      WRITE_SHORT           ("%abil_off%" + 0x46) "%abil_fx_num%"
      WRITE_SHORT           ("%abil_off%" + 0x48) ("%abil_fx_idx%" + ("%abil_fx_num%" * ("%index%" - 1)))
    SET "fx_off" = ("%fx_off%" + 0x28)
    SET "abil_num" = ("%abil_num%" + 1)
  END
  WRITE_LONG  0x6a "%fx_off%"
  WRITE_SHORT 0x68 20
  BUT_ONLY_IF_IT_CHANGES

// magic missile damage fix
COPY_EXISTING ~spin685.spl~ ~override~ // Imoen/promenade cutscene version
              ~spin962.spl~ ~override~ // beholder version
              ~spwi003.spl~ ~override~ // trap wizard version
              ~spwi112.spl~ ~override~ // regular wizard version
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x28)) 60 // corrects range
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 12) BEGIN // damage opcode
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 1 // fixed damage
        WRITE_LONG  ("%fx_off%" + 0x1c + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 1 // num dice
        WRITE_LONG  ("%fx_off%" + 0x20 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 4 // dice size
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// duration for protection from evil wrong at many levels
COPY_EXISTING ~spwi113.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_lev"
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "duration"
      PATCH_IF ("%duration%" > 5) BEGIN // filter out brief and/or instant effects like playing sounds and animations
        WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ("%min_lev%" * 12)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// school fix for shield
COPY_EXISTING ~spwi114.spl~ ~override~ 
  WRITE_BYTE 0x22 15 // evocation
  BUT_ONLY_IF_IT_CHANGES
  
// range fixes
COPY_EXISTING ~spin104.spl~ ~override~ // innate LMD
              ~spwi116.spl~ ~override~ // sleep
              ~spwi119.spl~ ~override~ // mage LMD
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x28)) 90 // corrects range
  END
  BUT_ONLY_IF_IT_CHANGES
  
// find familiar casting time
COPY_EXISTING ~spwi123.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    WRITE_SHORT ("%abil_off%" + 0x12 + ("%index%" * 0x28)) 9 // casting time
  END
  BUT_ONLY_IF_IT_CHANGES

// nahal's reckless dweomer casting time, school
COPY_EXISTING ~spwi124.spl~ ~override~
  WRITE_BYTE  0x22 15 // invocation
  WRITE_SHORT 0x25 6  // invoker
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    WRITE_SHORT ("%abil_off%" + 0x12 + ("%index%" * 0x28)) 5 // casting time
  END
  BUT_ONLY_IF_IT_CHANGES

// casting speed fixes
COPY_EXISTING ~spwi217.spl~ ~override~ // aganazzar's scorcher
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%index%")) 3
  END
  BUT_ONLY_IF_IT_CHANGES

// remove magic not removing feeblemeind like dispel magic
COPY_EXISTING ~spwi302.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle thru abilities
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
      WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%"))  240 // opcode: remove portrait icon
      WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%"))    2 // target: preset target
      WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%"))   48 // icon: feeblemind
      WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%"))    1 // instant/permanent
      WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%"))    2 // dispel/not bypass
      WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%"))  100 // probability
    INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
      WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%"))   77 // opcode: remove feeblemind
      WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%"))    2 // target: preset target
      WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%"))    1 // instant/permanent
      WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * "%abil_fx_idx%"))    2 // dispel/not bypass
      WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%"))  100 // probability
    SET "fx_delta" = ("%fx_delta%" + 2)
    WRITE_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 2)
  END
  BUT_ONLY_IF_IT_CHANGES

// casting speed fixes
COPY_EXISTING ~spwi309.spl~ ~override~ // mon summoning i
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%index%")) 4
  END
  BUT_ONLY_IF_IT_CHANGES

// duration for monster summoning i, ii incorrect when cast at many levels
COPY_EXISTING ~spwi309.spl~ ~override~
              ~spwi407.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "spwi309" = 0) THEN BEGIN
    SET "base_dur" = 12
    SET "open_lvl" = 5
  END ELSE BEGIN
    SET "base_dur" = 18
    SET "open_lvl" = 7
  END
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_lev"
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    PATCH_IF ("%min_lev%" = 1) THEN BEGIN
      SET "min_lev" = "%open_lvl%"
    END
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "duration"
      PATCH_IF ("%duration%" > 5) BEGIN // filter out brief and/or instant effects like playing sounds and animations
        WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ("%base_dur%" + ("%min_lev%" * 6))
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// skull trap has incorrect range
COPY_EXISTING ~spwi313.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    WRITE_SHORT ("%abil_off%" + 0x0e + (0x28 * "%abil_num%")) 30 // range
  END
  BUT_ONLY_IF_IT_CHANGES

// protection from fire and protection from cold missing lev 19, 20 abilities (revised by Wisp)
COPY_EXISTING ~spwi319.spl~ ~override~
              ~spwi320.spl~ ~override~
  READ_LONG  0x64 abil_off
  READ_SHORT 0x68 abil_num
  READ_LONG  0x6a fx_off
  19p = 0
  20p = 0
  FOR (i = 0; i < abil_num; ++i) BEGIN                  //Find the insertion points
    READ_SHORT abil_off + 0x28 * i + 0x10 min_level
    PATCH_IF min_level = 18 BEGIN
      READ_ASCII abil_off + 0x28 * i        abil_clone (0x28)
      READ_SHORT abil_off + 0x28 * i + 0x1e num_fx
      READ_SHORT abil_off + 0x28 * i + 0x20 fx_idx
      READ_ASCII fx_off + 0x30 * fx_idx fx_block_clone (0x30 * num_fx)
      header_point = abil_off + 0x28 * (i + 1)          //+1, to get ahead of the level 18 header 
      fx_point = fx_off + 0x30 * (fx_idx + num_fx)
      FOR (j = abil_num - 1; j > 0; --j) BEGIN          //Verify that levels 19 and 20 are indeed missing; in this context j must always be positive, 
                                                        //since we know we have at least one header for level 18
        READ_SHORT abil_off + 0x28 * j + 0x10 check
        PATCH_IF check = 18 BEGIN                       //No point in going further; it ain't here
          j = 0
        END
        PATCH_IF check = 19 BEGIN
          19p = 1
          READ_SHORT abil_off + 0x28 * j + 0x1e 19num_fx
          READ_SHORT abil_off + 0x28 * j + 0x20 19fx_idx
          header_point = abil_off + 0x28 * (j + 1)      //If we have a level 19 header we need to update these
          fx_point = fx_off + 0x30 * (19num_fx + 19fx_idx)
        END
        PATCH_IF check = 20 BEGIN
          20p = 1
        END
      END
    END
  END
  PATCH_IF VARIABLE_IS_SET header_point BEGIN           //Insert new headers and effects, assuming nothing has gone wrong
    PATCH_FOR_EACH level IN 20 19 BEGIN                 //Reversed to minimise the bookkeeping
      PATCH_IF !EVAL "%level%p" BEGIN
        INSERT_BYTES header_point         0x28
        WRITE_ASCIIE header_point         "%abil_clone%"
        WRITE_SHORT  header_point + 0x10  level
        fx_idx += (num_fx * (level - 18))
        WRITE_SHORT  header_point + 0x20  fx_idx
        fx_off += 0x28
        fx_point += 0x28
        ++abil_num
        INSERT_BYTES fx_point             0x30 * num_fx
        WRITE_ASCIIE fx_point             "%fx_block_clone%"
        FOR (i = 0; i < num_fx; ++i) BEGIN              //Adjust the duration for the new effects, 1 turn/level, but not for the instant or
                                                        //near-instant effects
          WRITE_LONG fx_point + 0x30 * i + 0xe THIS < 5 ? THIS : 60 * level
        END
      END
    END
  END
  WRITE_SHORT 0x68 abil_num
  WRITE_LONG  0x6a fx_off
  READ_SHORT  0x70 fx_idx                               //aka number of global effects
  FOR (i = 0; i < abil_num; ++i) BEGIN                  //Update fx_idx, in case there are headers for levels > 20
    WRITE_SHORT abil_off + 0x28 * i + 0x20 fx_idx
    fx_idx += SHORT_AT (abil_off + 0x28 * i + 0x1e)     //number of effects
  END
BUT_ONLY

// confusion (mage) missing -2 save penalty
COPY_EXISTING ~spwi401.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_LONG  ("%fx_off%" + 0x24 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "saves"
      PATCH_IF ("%saves%" != 0) BEGIN // if save allowed
        WRITE_LONG ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0xfffffffe // should be a -2 penalty
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// poly other shouldn't have save bonuses
COPY_EXISTING ~spwi415.spl~ ~override~
              ~spwm183.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (loops = abil_fx_num ; loops > 0 ; loops = loops - 1) BEGIN
      WRITE_LONG ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + ("%loops%" - 1)))) 0 // save bonus
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// mage farsight has wonky durations
COPY_EXISTING ~spwi424.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x10 + (0x28 * "%index%")) "level"
    PATCH_IF ("%level%" = 1) BEGIN
      SET "level" = 7
    END
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "duration"
      PATCH_IF ("%duration%" > 5) BEGIN // if longer than instant
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) (6 * (3 + "%level%"))
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// cone of cold missing level 10 ability header, wrong range at level 9, inconsistent save v non-save damage split
COPY_EXISTING ~spwi503.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  SET "lev10_exist" = 0
  SET "new_abil" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_lev"
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    PATCH_IF ("%min_lev%" = 1) BEGIN
      SET "min_lev" = 9
    END
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 12) BEGIN // damage
        READ_LONG  ("%fx_off%" + 0x24 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "save"
        PATCH_IF ("%save%" = 0) BEGIN
          WRITE_BYTE ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) (("%min_lev%" + 1) / 2) // damage
          WRITE_BYTE ("%fx_off%" + 0x1c + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ("%min_lev%" / 2) // damage
        END ELSE BEGIN
          WRITE_BYTE ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ("%min_lev%" / 2) // damage
          WRITE_BYTE ("%fx_off%" + 0x1c + (0x30 * ("%abil_fx_idx%" + "%index2%"))) (("%min_lev%" + 1) / 2) // damage
        END
      END
    END
    PATCH_IF ("%min_lev%" = 9) BEGIN // if first header
      WRITE_SHORT ("%abil_off%" + 0x0e + (0x28 * "%index%")) 12 // corrects range
      READ_ASCII  ("%abil_off%" + (0x28 * "%index%"))       "abil_clone" (0x28)
      READ_ASCII  ("%fx_off%" + (0x30 * ("%abil_fx_idx%"))) "fx_clone" (0x30 * "%abil_fx_num%")
      SET "new_fx" = "%abil_fx_num%"
      SET "start_fx" = ("%abil_fx_idx%" + "%abil_fx_num%")
      SET "insert" = ("%abil_off%" + (0x28 * ("%index%" + 1)))
    END ELSE
    PATCH_IF ("%min_lev%" = 10) BEGIN
      SET "lev10_exist" = 1
    END
  END
  PATCH_IF ("%lev10_exist%" = 0) BEGIN
    SET "level" = 10
    INSERT_BYTES (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "opcode"
      PATCH_IF ("%opcode%" = 12) BEGIN // damage
        READ_LONG (("%fx_off%" + (0x28 * "%new_abil%")) + 0x24 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "save"
        PATCH_IF ("%save%" = 0) BEGIN
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x04 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) (("%level%" + 1) / 2) // damage
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x1c + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) ("%level%" / 2) // damage
        END ELSE BEGIN
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x04 + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) ("%level%" / 2) // damage
          WRITE_BYTE (("%fx_off%" + (0x28 * "%new_abil%")) + 0x1c + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) (("%level%" + 1) / 2) // damage
        END
      END
    END
    INSERT_BYTES ("%insert%" + (0x28 * "%new_abil%")) 0x28
      WRITE_EVALUATED_ASCII ("%insert%" + (0x28 * "%new_abil%")) "%abil_clone%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x10) "%level%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x1e) "%new_fx%"
    SET "new_abil" = "%new_abil%" + 1
  END
  PATCH_IF ("%new_abil%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" + "%new_abil%")
    WRITE_SHORT 0x68 "abil_num"
    WRITE_LONG  0x6a ("%fx_off%" + (0x28 * "%new_abil%"))
    // re-index everything
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%fx_num%"
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      SET "fx_num" = "%fx_num%" + "%abil_fx_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// mon sum iii has wrong probabilities at level 1
COPY_EXISTING ~spwi504.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%abil_num%")) "min_lev"
    PATCH_IF ("%min_lev%" = 1) BEGIN // if first header
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      SET "eff" = 3
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
        PATCH_IF (("%opcode%" = 177) AND ("%eff%" = 2)) BEGIN // last eff opcode
          WRITE_BYTE ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 100 // probability
          WRITE_BYTE ("%fx_off%" + 0x13 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 61  // probability
          SET "eff" = 0
        END ELSE
        PATCH_IF (("%opcode%" = 177) AND ("%eff%" = 3)) BEGIN // first or second eff
          SET "eff" = ("%eff%" - 1)
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// protection from acid has incorrect casting time
COPY_EXISTING ~spwi517.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  WHILE ("%abil_num%" > 0) BEGIN // goes through all abilities and adjusts casting time
    SET "abil_num" = ("%abil_num%" - 1)
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%abil_num%")) 6
  END
  BUT_ONLY_IF_IT_CHANGES

 // minor spell turning reflecting spells of level 5-7; should only be 1-4
COPY_EXISTING ~spwi522.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "delta" = 0
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // loop through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR ("index2" = 0; "%index2%" < "%abil_fx_num%"; "index2" = ("%index2%" + 1)) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "max_level"
      PATCH_IF (("%opcode%" = 200) AND ("%max_level%" > 4)) BEGIN // reflect spells of level 5+
        DELETE_BYTES ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30 // delete effect
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        SET "index2" = ("%index2%" - 1)
        SET "delta" = ("%delta%" - 1)
      END
    END
    WRITE_SHORT ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// invisible stalkers only summoned for 8 hours, should be 9
COPY_EXISTING ~spwi601.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // use eff file
        WRITE_LONG ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%index2%") * 0x30)) 2700 // duration = 9 hours, per descript
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// spell shield is hardcoded to display icon #73 which is currently protection from magical energy; need to swap
// see also statdesc.2da, states.bam, states2.bam
COPY_EXISTING ~spwi606.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "icon"
      PATCH_IF (("%opcode%" = 142) AND ("%icon%" = 73)) BEGIN // display old pro-magic energy icon
        WRITE_LONG ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 123 // change to new pro-magic energy icon
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// casting speed fixes
COPY_EXISTING ~spwi608.spl~ ~override~ // pierce magic
              ~spwi802.spl~ ~override~ // spell deflection
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%index%")) 6
  END
  BUT_ONLY_IF_IT_CHANGES

// conjure fire elemental should be restricted from diviners (spell school)
COPY_EXISTING ~spwi620.spl~ ~override~
  READ_BYTE  0x1f "school"
  WRITE_BYTE 0x1f ("%school%" BOR 0b00000001) // adds diviner flag
  BUT_ONLY_IF_IT_CHANGES

// conjure air/earth elemental missing level 12-14 ability headers
COPY_EXISTING ~spwi621.spl~ ~override~
              ~spwi622.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  SET "lev12_exist" = 0
  SET "lev13_exist" = 0
  SET "lev14_exist" = 0
  SET "new_abil" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_lev"
    PATCH_IF ("%min_lev%" = 1) BEGIN // if first header
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      READ_ASCII  ("%abil_off%" + (0x28 * "%index%"))       "abil_clone" (0x28)
      READ_ASCII  ("%fx_off%" + (0x30 * ("%abil_fx_idx%"))) "fx_clone" (0x30 * "%abil_fx_num%")
      SET "new_fx" = "%abil_fx_num%"
      SET "start_fx" = ("%abil_fx_idx%" + "%abil_fx_num%")
      SET "insert" = ("%abil_off%" + (0x28 * ("%index%" + 1)))
    END ELSE
    PATCH_IF ("%min_lev%" = 12) BEGIN
      SET "lev12_exist" = 1
    END
    PATCH_IF ("%min_lev%" = 13) BEGIN
      SET "lev13_exist" = 1
    END
    PATCH_IF ("%min_lev%" = 14) BEGIN
      SET "lev14_exist" = 1
    END
  END
  PATCH_IF ("%lev12_exist%" = 0) BEGIN
    SET "level" = 12
    INSERT_BYTES (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // use eff file
        WRITE_LONG (("%fx_off%" + (0x28 * "%new_abil%")) + 0x0e + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) ("%level%" * 60) // duration
      END
    END
    INSERT_BYTES ("%insert%" + (0x28 * "%new_abil%")) 0x28
      WRITE_EVALUATED_ASCII ("%insert%" + (0x28 * "%new_abil%")) "%abil_clone%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x10) "%level%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x1e) "%new_fx%"
    SET "new_abil" = "%new_abil%" + 1
  END
  PATCH_IF ("%lev13_exist%" = 0) BEGIN
    SET "level" = 13
    INSERT_BYTES (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // use eff file
        WRITE_LONG (("%fx_off%" + (0x28 * "%new_abil%")) + 0x0e + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) ("%level%" * 60) // duration
      END
    END
    INSERT_BYTES ("%insert%" + (0x28 * "%new_abil%")) 0x28
      WRITE_EVALUATED_ASCII ("%insert%" + (0x28 * "%new_abil%")) "%abil_clone%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x10) "%level%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x1e) "%new_fx%"
    SET "new_abil" = "%new_abil%" + 1
  END
  PATCH_IF ("%lev14_exist%" = 0) BEGIN
    SET "level" = 14
    INSERT_BYTES (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // use eff file
        WRITE_LONG (("%fx_off%" + (0x28 * "%new_abil%")) + 0x0e + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) ("%level%" * 60) // duration
      END
    END
    INSERT_BYTES ("%insert%" + (0x28 * "%new_abil%")) 0x28
      WRITE_EVALUATED_ASCII ("%insert%" + (0x28 * "%new_abil%")) "%abil_clone%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x10) "%level%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x1e) "%new_fx%"
    SET "new_abil" = "%new_abil%" + 1
  END
  PATCH_IF ("%new_abil%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" + "%new_abil%")
    WRITE_SHORT 0x68 "%abil_num%"
    WRITE_LONG  0x6a ("%fx_off%" + (0x28 * "%new_abil%"))
    // re-index everything
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%fx_num%"
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      SET "fx_num" = "%fx_num%" + "%abil_fx_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// cacofiends summoned for 120s; should be 90
COPY_EXISTING ~spwi707.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // use eff file
        WRITE_LONG ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%index2%") * 0x30)) 90 // duration = 15 rounds, per descript
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// sphere of chaos sleep duration is off by a second
COPY_EXISTING ~spwi711.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // look through abilities
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 2) BEGIN // ranged ability check
      READ_SHORT  ("%abil_off%" + 0x1e) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
        PATCH_IF ("%opcode%" = 39) BEGIN // sleep
          WRITE_BYTE ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%index2%") * 0x30)) 9 // duration
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// delayed blast fireball should do 15d6 damage, not 14d6 + 15
COPY_EXISTING ~spwi712.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 12) BEGIN // no-save damage
        READ_LONG  ("%fx_off%" + 0x24 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "saves"
        WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // fixed damage
        PATCH_IF ("%saves%" = 0) BEGIN
          WRITE_LONG  ("%fx_off%" + 0x1c + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 8 // number of dice, no save
        END ELSE BEGIN
          WRITE_LONG  ("%fx_off%" + 0x1c + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 7 // number of dice, save
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// mordy sword should break invisibility
COPY_EXISTING ~spwi716.spl~ ~override~
  READ_BYTE  0x19 "flags"
  WRITE_BYTE 0x19 ("%flags%" BOR 0b00000100) // adds break invis flag
  BUT_ONLY_IF_IT_CHANGES

// summon hakeshar missing lev 14, 15 headers
COPY_EXISTING ~spwi719.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  READ_SHORT 0x70 "fx_num"
  SET "lev14_exist" = 0
  SET "lev15_exist" = 0
  SET "new_abil" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_lev"
    PATCH_IF ("%min_lev%" = 1) BEGIN // if first header
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 177) BEGIN // use eff
          WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 126 // duration
        END
      END
      READ_ASCII  ("%abil_off%" + (0x28 * "%index%"))       "abil_clone" (0x28)
      READ_ASCII  ("%fx_off%" + (0x30 * ("%abil_fx_idx%"))) "fx_clone" (0x30 * "%abil_fx_num%")
      SET "new_fx" = "%abil_fx_num%"
      SET "start_fx" = ("%abil_fx_idx%" + "%abil_fx_num%")
      SET "insert" = ("%abil_off%" + (0x28 * ("%index%" + 1)))
    END ELSE
    PATCH_IF ("%min_lev%" = 14) BEGIN
      SET "lev14_exist" = 1
    END
    PATCH_IF ("%min_lev%" = 15) BEGIN
      SET "lev15_exist" = 1
    END
  END
  PATCH_IF ("%lev14_exist%" = 0) BEGIN
    SET "level" = 14
    INSERT_BYTES (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // use eff file
        WRITE_LONG (("%fx_off%" + (0x28 * "%new_abil%")) + 0x0e + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) ((8 + "%level%") * 6) // duration
      END
    END
    INSERT_BYTES ("%insert%" + (0x28 * "%new_abil%")) 0x28
      WRITE_EVALUATED_ASCII ("%insert%" + (0x28 * "%new_abil%")) "%abil_clone%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x10) "%level%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x1e) "%new_fx%"
    SET "new_abil" = "%new_abil%" + 1
  END
  PATCH_IF ("%lev15_exist%" = 0) BEGIN
    SET "level" = 15
    INSERT_BYTES (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) (0x30 * "%new_fx%")
      WRITE_EVALUATED_ASCII (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%start_fx%" * ("%new_abil%" + 1)))) "%fx_clone%"
    FOR (index2 = 0 ; index2 < new_fx ; index2 = index2 + 1) BEGIN
      READ_SHORT (("%fx_off%" + (0x28 * "%new_abil%")) + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // use eff file
        WRITE_LONG (("%fx_off%" + (0x28 * "%new_abil%")) + 0x0e + (0x30 * ("%index2%" + "%start_fx%" + ("%new_abil%" * "%new_fx%")))) ((8 + "%level%") * 6) // duration
      END
    END
    INSERT_BYTES ("%insert%" + (0x28 * "%new_abil%")) 0x28
      WRITE_EVALUATED_ASCII ("%insert%" + (0x28 * "%new_abil%")) "%abil_clone%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x10) "%level%"
      WRITE_SHORT (("%insert%" + (0x28 * "%new_abil%")) + 0x1e) "%new_fx%"
    SET "new_abil" = "%new_abil%" + 1
  END
  PATCH_IF ("%new_abil%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" + "%new_abil%")
    WRITE_SHORT 0x68 "abil_num"
    WRITE_LONG  0x6a ("%fx_off%" + (0x28 * "%new_abil%"))
    // re-index everything
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%fx_num%"
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      SET "fx_num" = "%fx_num%" + "%abil_fx_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// spell school fix
COPY_EXISTING ~spwi721.spl~ ~override~ // mass invisibility
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    WRITE_SHORT 0x25 5 // illusion
  END
  BUT_ONLY_IF_IT_CHANGES

// casting speeds for mage symbol spells and spell trigger are incorrect
COPY_EXISTING ~spwi809.spl~ ~override~ // spell trigger
              ~spwi811.spl~ ~override~ // symbol fear (mage)
              ~spwi816.spl~ ~override~ // symbol stun (mage)
              ~spwi817.spl~ ~override~ // symbol death (mage)
              ~spwi897.spl~ ~override~ // symbol death (enemy mage version)
              ~spwi898.spl~ ~override~ // symbol stun (enemy mage version)
              ~spwi899.spl~ ~override~ // symbol fear (enemy mage version)
              ~spwm123.spl~ ~override~ // symbol fear (wild magic)
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // look through abilities
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x28)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
      WRITE_SHORT ("%abil_off%" + 0x12 + ("%index%" * 0x28)) 9 // casting time
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// lowest level casting of symbol, stun and symbol, fear have inconsistent sound effect; casting times fixed elsewhere
COPY_EXISTING ~spwi811.spl~ ~override~
              ~spwi816.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "sound"
      PATCH_IF (("%opcode%" = 174) AND ("%sound%" STRING_COMPARE_CASE "eff_m03" = 0)) BEGIN // sound to be replaced
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~eff_p04~ #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// power word: blind should last 6 rounds, not 10
COPY_EXISTING ~spwi815.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "duration"
      PATCH_IF ("%duration%" = 60) BEGIN // 10 rounds
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 36 // 6 rounds
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// enemy versions of symbol spells missing casting sounds
COPY_EXISTING ~spwi897.spl~ ~override~
              ~spwi898.spl~ ~override~
              ~spwi899.spl~ ~override~
              ~spwm123.spl~ ~override~
  WRITE_ASCII 0x10 ~cas_m03~ #8
  BUT_ONLY_IF_IT_CHANGES

// typo in wav reference
COPY_EXISTING ~spwi995.spl~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN // adjusts fx indices on abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "resref"
      PATCH_IF (("%opcode%" = 174) AND ("%resref%" STRING_COMPARE_CASE "eff_m09 " = 0)) BEGIN
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "eff_m09" #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// create custom spell trap for SotM
COPY_EXISTING ~spwi902.spl~ ~override/staf11.spl~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  PATCH_IF ("%abil_num%" > 0) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (("%abil_num%" - 1) * 0x28)) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (("%abil_num%" - 1) * 0x28)) "abil_fx_idx"
    SET "last_fx" = ("%abil_fx_num%" + "%abil_fx_idx%")
  END ELSE BEGIN
    READ_SHORT 0x70 "last_fx"
  END
  WHILE ("%last_fx%" > 0) BEGIN
    SET "last_fx" = ("%last_fx%" - 1)
    READ_BYTE ("%fx_off%" + 0x0c + ("%last_fx%" * 0x30)) "timing"
    READ_LONG ("%fx_off%" + 0x0e + ("%last_fx%" * 0x30)) "duration"
    PATCH_IF (("%timing%" = 0) AND ("%duration%" > 5)) BEGIN // if instant/limited for more than one round
      WRITE_LONG ("%fx_off%" + 0x0e + ("%last_fx%" * 0x30)) 2400
    END
  END

// pit fiends around for an extra two seconds
COPY_EXISTING ~spwi905.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 177) BEGIN // use eff file
        WRITE_LONG ("%fx_off%" + 0x0e + (("%abil_fx_idx%" + "%index2%") * 0x30)) 198 // duration = 33 rounds, per descript
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// absolute immunity has wrong duration
COPY_EXISTING ~spwi907.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  WHILE ("%abil_num%" > 0) BEGIN
    SET "abil_num" = ("%abil_num%" - 1)
    READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
    PATCH_IF ("%type%" = 1) BEGIN // if melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
      WHILE ("%abil_fx_num%" > 0) BEGIN
        SET "abil_fx_num" = ("%abil_fx_num%" - 1)
        READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "duration"
        PATCH_IF ("%duration%" = 28) BEGIN // wrong duration
          WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 24 // correct duration
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// energy drain lighting effect is not bypassing MR like all other effects
COPY_EXISTING ~spwi914.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 141) BEGIN // lighting effect
        WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// imprisoned summon fix: see gender.ids, cdwi917a.spl, cdwi910.eff, cdwi917a.eff, spin580.spl, spin626.spl, spin788.spl, spwi910.spl, spwi917.spl
COPY_EXISTING ~spwi917.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 212) BEGIN // imprisonment
        SET "index2" = "%index2%" + 1 // make extra spellcast after freedom effect
        INSERT_BYTES  ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30 // new effect
          WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 146 // cast spell
          WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%")))   1 // target self
          WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%")))   0 // cast at level
          WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%")))   1 // cast instantly
          WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%index2%")))   4 // delay/permanent
          WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%")))   2 // 2 second delay
          WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 100 // probability
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~cdwi917a~ #8 // spell
        SET "delta" = "%delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
      END
    END
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// bigby's crushing hand should be saving against paralyzation; some second round saves are incorrect
COPY_EXISTING ~spwi918.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off" ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_BYTE ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 9 // power is inconsistent in effects
      READ_BYTE ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "timing"
      READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "duration"
      READ_BYTE ("%fx_off%" + 0x24 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "savetype"
      PATCH_IF (("%timing%" = 4) AND ("%duration%" = 12)) BEGIN // round 2 damage
        WRITE_LONG ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0  // no save penalty
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// dragon's breath has spurious save penalty vs. sleep, missing sleep portrait icon
COPY_EXISTING ~spwi922.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 39) BEGIN // sleep
        WRITE_LONG ("%fx_off%" + 0x28 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0  // no save penalty
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // grab entire fx
        INSERT_BYTES            ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30 // new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "%clone%" #48 // clones sleep effect
          WRITE_SHORT           ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 142 // display portrait icon
          WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 14  // sleep icon
        SET "delta" = "%delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
        SET "index2" = "%index2%" + 1
      END
    END
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// time stop/imp alacrity from wish has wrong opcode for IA
COPY_EXISTING ~spwish17.spl~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    WHILE ("%abil_num%" > 0) BEGIN
      SET "abil_num" = ("%abil_num%" - 1)
      READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
      PATCH_IF ("%type%" = 1) BEGIN // if melee
        READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
        READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
        WHILE ("%abil_fx_num%" > 0) BEGIN
          SET "abil_fx_num" = ("%abil_fx_num%" - 1)
          READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "opcode"
          READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) "sound"
          PATCH_IF ("%opcode%" = 189) BEGIN // increase casting speed
            WRITE_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 188 // increase spells/round
            WRITE_SHORT ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 1   // unlimited
          END ELSE
          PATCH_IF ("%opcode%" = 139) BEGIN // increase casting speed
            WRITE_BYTE  ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 0   // probability: 0
          END ELSE
          PATCH_IF (("%opcode%" = 174) AND ("%sound%" STRING_COMPARE_CASE "eff_m29" = 0)) BEGIN // sound
            WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 24   // duration
          END
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// wild surge: destroy gold is supposed to target self, not present target
COPY_EXISTING ~spwm117.spl~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    WHILE ("%abil_num%" > 0) BEGIN
      SET "abil_num" = ("%abil_num%" - 1)
      READ_SHORT ("%abil_off%" + (0x28 * "%abil_num%")) "type"
      PATCH_IF ("%type%" = 1) BEGIN // if melee
        READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%abil_num%")) "abil_fx_num"
        READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%abil_num%")) "abil_fx_idx"
        WHILE ("%abil_fx_num%" > 0) BEGIN
          SET "abil_fx_num" = ("%abil_fx_num%" - 1)
          WRITE_BYTE ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%abil_fx_num%"))) 1   // target: self
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB-only stuff check

  // mage HLAs should be schoolless
  COPY_EXISTING ~spwi920.spl~ ~override~ // energy blades
                ~spwi921.spl~ ~override~ // improved alacrity
                ~spwi922.spl~ ~override~ // dragon's breath
                ~spwi923.spl~ ~override~ // summon planetar
                ~spwi924.spl~ ~override~ // summon dark planetar
                ~spwi925.spl~ ~override~ // comet
    WRITE_SHORT 0x1e 0 // removes exclusion flags
    WRITE_SHORT 0x25 0 // removes primary type
    WRITE_BYTE  0x27 0 // removes secondary type
    BUT_ONLY_IF_IT_CHANGES

END

// improved invisibility and its %$^%&$# saves
// first make shell spells containing just the saves
COPY_EXISTING ~balth10.spl~ ~override/balth10a.spl~ // Shadow Stance!
              ~spdr401.spl~ ~override/spdr401a.spl~ // Invisible Stalker Improved Invisibility
              ~spin544.spl~ ~override/spin544a.spl~ // PSIONIC _SUPERIOR_INVISIBILITY
              ~spin687.spl~ ~override/spin687a.spl~ // Create Shadows
              ~spin698.spl~ ~override/spin698a.spl~ // Cerebus Improved Invisibility
              ~spwi405.spl~ ~override/spwi405a.spl~ // improved invis (mage)
              ~spwi505.spl~ ~override/spwi505a.spl~ // shadow door (mage)
              ~spwi607.spl~ ~override/spwi607a.spl~ // Mislead
              ~spwi721.spl~ ~override/spwi721a.spl~ // mass invisibility
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_LONG  0x08 0xffffffff // blanks spell name
    WRITE_ASCII 0x10 ~~ #8      // blanks casting sound
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    READ_LONG   0x6a "fx_off"
    FOR (index = (abil_num - 1) ; index >= 0 ; index = index - 1) BEGIN
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) 5
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) (5 * "%index%")
      WRITE_SHORT ("%abil_off%" + 0x26 + (0x28 * "%index%")) 1 // remove projectile, if any
      FOR (index2 = (abil_fx_num - 1) ; index2 >= 0 ; index2 = index2 - 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 20) BEGIN
          READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (0x30)
        END
        DELETE_BYTES ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30
      END
      FOR (index3 = 33 ; index3 < 38 ; index3 = index3 + 1) BEGIN
        INSERT_BYTES   ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30
          WRITE_ASCIIE ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%"
          WRITE_SHORT  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%index3%" // save v X
          WRITE_LONG   ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 4 // save bonus
          WRITE_LONG   ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 0 // increase/decrease
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// next make shell spells containing just protection spells
COPY_EXISTING ~balth10.spl~ ~override/balth10b.spl~ // Shadow Stance!
              ~spdr401.spl~ ~override/spdr401b.spl~ // Invisible Stalker Improved Invisibility
              ~spin544.spl~ ~override/spin544b.spl~ // PSIONIC _SUPERIOR_INVISIBILITY
              ~spin687.spl~ ~override/spin687b.spl~ // Create Shadows
              ~spin698.spl~ ~override/spin698b.spl~ // Cerebus Improved Invisibility
              ~spwi405.spl~ ~override/spwi405b.spl~ // improved invis (mage)
              ~spwi505.spl~ ~override/spwi505b.spl~ // shadow door (mage)
              ~spwi607.spl~ ~override/spwi607b.spl~ // Mislead
              ~spwi721.spl~ ~override/spwi721b.spl~ // mass invisibility
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_LONG  0x08 0xffffffff // blanks spell name
    WRITE_ASCII 0x10 ~~ #8      // blanks casting sound
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    READ_LONG   0x6a "fx_off"
    FOR (index = (abil_num - 1) ; index >= 0 ; index = index - 1) BEGIN
      READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) 9
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) (9 * "%index%")
      WRITE_SHORT ("%abil_off%" + 0x26 + (0x28 * "%index%")) 1 // remove projectile, if any
      FOR (index2 = (abil_fx_num - 1) ; index2 >= 0 ; index2 = index2 - 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 20) BEGIN
          READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (0x30)
        END
        DELETE_BYTES ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30
      END
      FOR (index4 = 0 ; index4 < 9 ; index4 = index4 + 1) BEGIN
        INSERT_BYTES   ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30
          WRITE_ASCIIE ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%"
          WRITE_SHORT  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 206       // spell immunity
          WRITE_LONG   ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 0xffffffff // no string (silent fail)
//          SAY   ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) @114 // no string (silent fail)
      END
      // resrefs for immunity spells
      WRITE_ASCII      ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%"    ))) ~balth10a~ #8 // resref
      WRITE_ASCII      ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + 1))) ~spdr401a~ #8 // resref
      WRITE_ASCII      ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + 2))) ~spin544a~ #8 // resref
      WRITE_ASCII      ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + 3))) ~spin687a~ #8 // resref
      WRITE_ASCII      ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + 4))) ~spin698a~ #8 // resref
      WRITE_ASCII      ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + 5))) ~spwi405a~ #8 // resref
      WRITE_ASCII      ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + 6))) ~spwi505a~ #8 // resref
      WRITE_ASCII      ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + 7))) ~spwi607a~ #8 // resref
      WRITE_ASCII      ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + 8))) ~spwi721a~ #8 // resref
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// improved invisibility is missing +4 save bonuses and should not be able to stack with itself
COPY_EXISTING ~balth10.spl~ ~override~ // Shadow Stance!
              ~spdr401.spl~ ~override~ // Invisible Stalker Improved Invisibility
              ~spin544.spl~ ~override~ // PSIONIC _SUPERIOR_INVISIBILITY
              ~spin687.spl~ ~override~ // Create Shadows
              ~spin698.spl~ ~override~ // Cerebus Improved Invisibility
              ~spwi405.spl~ ~override~ // improved invis (mage)
              ~spwi505.spl~ ~override~ // shadow door (mage)
              ~spwi607.spl~ ~override~ // Mislead
              ~spwi721.spl~ ~override~ // mass invisibility
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    SET "delta" = 0
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 20) BEGIN
          READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (0x30)
        END ELSE
        PATCH_IF (("%opcode%" > 32) AND ("%opcode%" < 38)) BEGIN // if save bonuses present, remove them
          DELETE_BYTES ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0x30
          SET "index2" = "%index2%" - 1
          SET "abil_fx_num" = "%abil_fx_num%" - 1
          SET "delta" = "%delta%" - 1
        END
      END
      INSERT_BYTES   ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 0x30
        WRITE_ASCIIE ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) "%clone%"
        WRITE_SHORT  ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 146       // cast spell
        WRITE_LONG   ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 0 // no string (silent fail)
        WRITE_LONG   ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 1 // no string (silent fail)
        WRITE_ASCIIE ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) ~%SOURCE_RES%b~ #8 // resref
      INSERT_BYTES   ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30
        WRITE_ASCIIE ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%"
        WRITE_SHORT  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 146               // cast spell
        WRITE_LONG   ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 0                 // use caster level
        WRITE_LONG   ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 1                 // cast instantly
        WRITE_ASCIIE ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~%SOURCE_RES%a~   // resref
      SET "abil_fx_num" = "%abil_fx_num%" + 2
      SET "delta" = "%delta%" + 2
      WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// many spells stack with themselves and should not
COPY_EXISTING ~dgfaith.spl~ ~override~ // armor of faith (abazigal)
              ~dgright.spl~ ~override~ // righteous magic (abazigal)
              ~spcl423.spl~ ~override~ // assassin poison weapon ability
              ~spcl907.spl~ ~override~ // hardiness hla
              ~spcl913.spl~ ~override~ // evasion hla
              ~spcl914.spl~ ~override~ // greater evasion hla
              ~spcl917.spl~ ~override~ // avoid death hla
              ~spin943.spl~ ~override~ // blur (air mephit)
              ~sppr111.spl~ ~override~ // armor of faith (priest)
              ~sppr113.spl~ ~override~ // doom
              ~sppr210.spl~ ~override~ // resist fire/cold
              ~sppr306.spl~ ~override~ // protection from fire (priest)
              ~sppr406.spl~ ~override~ // defensive harmony
              ~sppr412.spl~ ~override~ // holy power
              ~sppr513.spl~ ~override~ // righteous magic (priest)
              ~spwi107.spl~ ~override~ // friends: special case, handled directly in its own patch // not anymore
              ~spwi201.spl~ ~override~ // blur (wizard)
              ~spwi209.spl~ ~override~ // luck
              ~spwi214.spl~ ~override~ // strength
              ~spwi319.spl~ ~override~ // protection from fire (wizard)
              ~spwi320.spl~ ~override~ // protection from cold
              ~spwi603.spl~ ~override~ // tenser's transformation
              ~spwi702.spl~ ~override~ // protection from the elements
              ~spwi703.spl~ ~override~ // projected image
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    READ_LONG  0x64 "abil_off"
    READ_SHORT 0x68 "abil_num"
    READ_LONG  0x6a "fx_off"
    READ_LONG  0x34 "level"
    SET "delta" = 0
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
      WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_BYTE  ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "timing"
        READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "duration"
        PATCH_IF (("%timing%" = 0) AND ("%duration%" > 5) AND // instant/limited and duration greater than a round
                  (("%opcode%" = 33) OR ("%opcode%" = 86) OR ("%opcode%" = 142))) BEGIN
          READ_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "target"
          READ_BYTE  ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "power"
          READ_BYTE  ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "bypass"
          SET "index2" = "%abil_fx_num%" // kills WHILE loop
        END
      END
      INSERT_BYTES            ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 0x30
        WRITE_SHORT           ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 206            // spell immunity
        WRITE_BYTE            ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) "%target%"     // inherits target
        WRITE_BYTE            ("%fx_off%" + 0x03 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) "%power%"      // power
        SAY                   ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) @114           // ~You cannot cast...~
        WRITE_BYTE            ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 0              // instant/limited
        WRITE_BYTE            ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) "%bypass%"     // inherits dispel/MR
        WRITE_LONG            ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) "%duration%"   // inherits duration
        WRITE_BYTE            ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 100            // probability
        WRITE_EVALUATED_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) ~%SOURCE_RES%~ // spell: self
      SET "delta1" = 1
      SET "delta" = ("%delta%" + "%delta1%")
      WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + "%delta1%")
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scriptable spells
COPY_EXISTING ~SPCL232.spl~ ~override~ // true sight
              ~SPCL412.spl~ ~override~ // set snare
              ~SPCL414.spl~ ~override~ // set special snare
              ~SPCL621.spl~ ~override~ // summon spirit animal
              ~SPCL721.spl~ ~override~ // storm shield
              ~SPCL722.spl~ ~override~ // lightning bolt
              ~SPCL731.spl~ ~override~ // seeking sword
              ~SPCL732.spl~ ~override~ // true sight
              ~SPCL741.spl~ ~override~ // boon of lathander
              ~SPCL742.spl~ ~override~ // hold undead
              ~SPCL910.spl~ ~override~ // set spike trap
              ~SPCL911.spl~ ~override~ // set exploding trap
              ~SPCL912.spl~ ~override~ // set time trap
              ~SPCL923.spl~ ~override~ // summon deva
              ~SPIN683.spl~ ~override~ // figurine_spider_web
              ~SPIN696.spl~ ~override~ // moon_dog_howl
              ~SPIN697.spl~ ~override~ // haste_self
              ~SPIN698.spl~ ~override~ // non_detection_self
              ~SPIN891.spl~ ~override~ // moon_dog_fear
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    WRITE_LONG 0x34 1
  END
  BUT_ONLY_IF_IT_CHANGES

// projected images and simulcra shouldn't have slayer and pocket plane abilities
COPY_EXISTING ~projimag.spl~ ~override~
              ~simulacr.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing effects
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 2)
    FOR (index2 = 0 ; index2 < 2 ; index2 = index2 + 1) BEGIN
      INSERT_BYTES  ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
        WRITE_SHORT ("%fx_off%" +        (0x30 * "%abil_fx_idx%"))  172 // remove spell opcode
        WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * "%abil_fx_idx%"))    1 // target: self
        WRITE_BYTE  ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%"))   84 // duration
        WRITE_LONG  ("%fx_off%" + 0x12 + (0x30 * "%abil_fx_idx%"))  100 // probability
    END
    WRITE_ASCII  ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spin649~
    WRITE_ASCII  ("%fx_off%" + 0x44 + (0x30 * "%abil_fx_idx%")) ~spin822~
    SET "fx_delta" = "%fx_delta%" + 2
  END
  BUT_ONLY_IF_IT_CHANGES

// kensai weapon speed
COPY_EXISTING ~spcl143.spl~ ~override~
  PATCH_IF (SOURCE_SIZE = 0xca) THEN BEGIN
    READ_LONG  0x64 "ho"
    READ_LONG  0x6a "eo"
    READ_ASCII "ho" ~h1~ (0x28)
    READ_ASCII "eo" ~fx~ (0x30)
    FOR (READ_SHORT 0x68 "hc"; "hc" < 10; "hc" += 0x1) BEGIN
      INSERT_BYTES ("ho" + ("hc" * 0x28) + 0x00) 0x28
      WRITE_ASCIIE ("ho" + ("hc" * 0x28) + 0x00) ~%h1%~
      WRITE_SHORT  ("ho" + ("hc" * 0x28) + 0x10) ("hc" * 0x4)
      WRITE_SHORT  ("ho" + ("hc" * 0x28) + 0x20) "hc"
      INSERT_BYTES ("eo" + ("hc" * 0x58) + 0x00) 0x30
      WRITE_ASCIIE ("eo" + ("hc" * 0x58) + 0x00) ~%fx%~
      WRITE_LONG   ("eo" + ("hc" * 0x58) + 0x04) ("hc" + 0x1)
    END
    WRITE_SHORT 0x68 "hc"
    WRITE_LONG  0x6a ("eo" + (0x28 * ("hc" - 0x1)))
  END
BUT_ONLY

// transformation spells themselves need to nuke leftover bits from other transformations
COPY_EXISTING ~spcl611.spl~ ~override~ // druid shapeshift brown bear
              ~spcl612.spl~ ~override~ // druid shapeshift wuff
              ~spcl613.spl~ ~override~ // druid shapeshift black bear
              ~spcl632.spl~ ~override~ // avenger shapeshift spider
              ~spcl633.spl~ ~override~ // avenger shapeshift baby wyvern
              ~spcl634.spl~ ~override~ // avenger shapeshift fire salamander
              ~spcl643.spl~ ~override~ // shapeshifter shapeshift werewolf
              ~spcl644.spl~ ~override~ // shapeshifter shapeshift greater werewolf
              ~spin823.spl~ ~override~ // slayer change
              ~spin852.spl~ ~override~ // slayer change ii
              ~sppr731.spl~ ~override~ // druid hla fire elemental transformation
              ~sppr732.spl~ ~override~ // druid hla earth elemental transformation
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  SET "fx_delta" = 0
  SET "new_fx_6" = 0
  SET "new_fx_7" = 0
  SET "new_fx_8" = 0
  SET "new_fx_9" = 0
  SET "new_fx_10" = 0
  SET "new_fx_11" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      READ_LONG  ("%fx_off%" + 0x08 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "param"
      READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "resref"
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spin160" = 0)) BEGIN // remove spell
        SET "new_fx_6" = ("%new_fx_6%" + 1) // increment; should total 3
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spinhum" = 0)) BEGIN // remove spell
        SET "new_fx_7" = 1
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "template" (48)
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spwi491" = 0)) BEGIN // remove spell
        SET "new_fx_8" = 1
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "template" (48)
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spin122" = 0)) BEGIN // remove spell
        SET "new_fx_9" = 1
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "template" (48)
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spin123" = 0)) BEGIN // remove spell
        SET "new_fx_10" = 1
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "template" (48)
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spin124" = 0)) BEGIN // remove spell
        SET "new_fx_11" = 1
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "template" (48)
      END
    END
    FOR (index3 = new_fx_6 ; index3 < 3 ; index3 = index3 + 1) BEGIN // remove 3x salamander fire breath
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spin160~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_7%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spinhum~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_8%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spwi491~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_9%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spin122~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_10%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spin123~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_11%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spin124~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    WRITE_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) ("%abil_fx_num%")
  END
  BUT_ONLY_IF_IT_CHANGES

// monk weapon speed
COPY_EXISTING ~spcl816.spl~ ~override~
  PATCH_IF (SOURCE_SIZE = 0xca) THEN BEGIN
    READ_LONG  0x64 "ho"
    READ_LONG  0x6a "eo"
    READ_ASCII "ho" ~h1~ (0x28)
    READ_ASCII "eo" ~fx~ (0x30)
    FOR (READ_SHORT 0x68 "hc"; "hc" < 2; "hc" += 0x1) BEGIN
      INSERT_BYTES ("ho" + ("hc" * 0x28) + 0x00) 0x28
      WRITE_ASCIIE ("ho" + ("hc" * 0x28) + 0x00) ~%h1%~
      WRITE_SHORT  ("ho" + ("hc" * 0x28) + 0x10) ("hc" * 12)
      WRITE_SHORT  ("ho" + ("hc" * 0x28) + 0x20) "hc"
      INSERT_BYTES ("eo" + ("hc" * 0x58) + 0x00) 0x30
      WRITE_ASCIIE ("eo" + ("hc" * 0x58) + 0x00) ~%fx%~
      WRITE_LONG   ("eo" + ("hc" * 0x58) + 0x04) ("hc" + 0x1)
    END
    WRITE_SHORT 0x68 "hc"
    WRITE_LONG  0x6a ("eo" + (0x28 * ("hc" - 0x1)))
  END
BUT_ONLY

// wing buffet, hell knockback shouldn't be stopped by spell protections
COPY_EXISTING ~spin658.spl~ ~override~ // wing buffet
              ~spin695.spl~ ~override~ // wing buffet
  WRITE_SHORT 0x25 0 // schoolless
  WRITE_BYTE  0x27 0 // no secondary type
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_BYTE ("%fx_off%" + 0x03 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 0
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// dragon_silence's lowest level header should be level 1, not 20
COPY_EXISTING ~spin692.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  PATCH_IF ("%abil_num%" != 0) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x10) 1 // set to level 1
  END
  BUT_ONLY_IF_IT_CHANGES

// spells to transform trolls back from dead to alive
COPY_EXISTING ~spin955.spl~ ~override/cdtroll1.spl~
              ~spin955.spl~ ~override/obsice01.spl~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "eff_file"
      PATCH_IF (("%opcode%" = 151) AND ("%eff_file%" STRING_COMPARE_CASE "troll01" = 0)) BEGIN
        WRITE_EVALUATED_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "%DEST_RES%" #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// shapeshifting return-to-human spells need to remove all shapeshifted weapons, abilities, etc.
COPY_EXISTING ~spin122.spl~ ~override~
              ~spin123.spl~ ~override~
              ~spin124.spl~ ~override~
              ~spinhum.spl~ ~override~
              ~spwi491.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "fx_delta" = 0
  SET "new_fx_1" = 0
  SET "new_fx_2" = 0
  SET "new_fx_3" = 0
  SET "new_fx_4" = 0
  SET "new_fx_5" = 0
  SET "new_fx_6" = 0
  SET "new_fx_7" = 0
  SET "new_fx_8" = 0
  SET "new_fx_9" = 0
  SET "new_fx_10" = 0
  SET "new_fx_11" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      READ_LONG  ("%fx_off%" + 0x08 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "param"
      READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "resref"
      // first, purge sound-to-be redundant effects
      PATCH_IF ("%opcode%" = 112) BEGIN // remove item, spell
        DELETE_BYTES ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) 0x30 // delete effect
        SET "fx_delta" = "%fx_delta%" - 1
        SET "index2" = "%index2%" - 1
        SET "abil_fx_num" = "%abil_fx_num%" - 1
      END
      PATCH_IF (("%opcode%" = 279) AND ("%param%" = 7)) BEGIN // reenable talk button
        SET "new_fx_1" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 279) AND ("%param%" = 2)) BEGIN // reenable select spell
        SET "new_fx_2" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 279) AND ("%param%" = 3)) BEGIN // reenable quick spell 1
        SET "new_fx_3" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 279) AND ("%param%" = 4)) BEGIN // reenable quick spell 2
        SET "new_fx_4" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 279) AND ("%param%" = 5)) BEGIN // reenable quick spell 3
        SET "new_fx_5" = 1
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spin160" = 0)) BEGIN // remove spell
        SET "new_fx_6" = ("%new_fx_6%" + 1) // increment; should total 3
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spinhum" = 0)) BEGIN // remove spell
        SET "new_fx_7" = 1
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "template" (48)
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spwi491" = 0)) BEGIN // remove spell
        SET "new_fx_8" = 1
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "template" (48)
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spin122" = 0)) BEGIN // remove spell
        SET "new_fx_9" = 1
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "template" (48)
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spin123" = 0)) BEGIN // remove spell
        SET "new_fx_10" = 1
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "template" (48)
      END ELSE
      PATCH_IF (("%opcode%" = 172) AND ("%resref%" STRING_COMPARE_CASE "spin124" = 0)) BEGIN // remove spell
        SET "new_fx_11" = 1
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "template" (48)
      END
    END
    PATCH_IF ("%new_fx_1%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_SHORT  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 279          // reenable button
        WRITE_LONG   ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 7            // talk
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_2%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_SHORT  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 279          // reenable button
        WRITE_LONG   ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 2            // spell select
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_3%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_SHORT  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 279          // reenable button
        WRITE_LONG   ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 3            // quick spell 1
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_4%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_SHORT  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 279          // reenable button
        WRITE_LONG   ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 4            // quick spell 2
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_5%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_SHORT  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 279          // reenable button
        WRITE_LONG   ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 5            // quick spell 3
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    FOR (index3 = new_fx_6 ; index3 < 3 ; index3 = index3 + 1) BEGIN // remove 3x salamander fire breath
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spin160~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_7%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spinhum~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_8%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spwi491~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_9%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spin122~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_10%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spin123~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    PATCH_IF ("%new_fx_11%" = 0) BEGIN
      INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
        WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
        WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~spin124~ #8 // resref
      SET "fx_delta" = "%fx_delta%" + 1
      SET "abil_fx_num" = "%abil_fx_num%" + 1
    END
    // insert an item creation at top
    INSERT_BYTES   ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30
      WRITE_ASCIIE ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) ~%template%~ // clone
      WRITE_SHORT  ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 111          // create item
      WRITE_ASCII  ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) ~wolfm~ #8   // resource
    // at the end, remove the newly created wolfm
    INSERT_BYTES   ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 0x30
      WRITE_ASCIIE ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) ~%template%~ // clone
      WRITE_SHORT  ("%fx_off%" +        (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) 112          // remove item
      WRITE_ASCII  ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%abil_fx_num%") * 0x30)) ~wolfm~ #8   // resource
    SET "fx_delta" = "%fx_delta%" + 2
    WRITE_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 2)
  END
  BUT_ONLY_IF_IT_CHANGES

// remove paralysis not removing icons on target
COPY_EXISTING ~sppr308.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 240) BEGIN // remove icon opcode
        WRITE_BYTE ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 2 // target: preset target
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// chaotic commands not protecting against psionic maze
COPY_EXISTING ~sppr508.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN // fix existing indices
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "resref"
      PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spwi813" = 0)) BEGIN
        READ_ASCII ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "clone" (48)
        INSERT_BYTES   ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30 // new effect
          WRITE_ASCIIE ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%"
          WRITE_ASCII  ("%fx_off%" + 0x14 + (0x30 * "%abil_fx_idx%")) ~spin774~
        SET "fx_delta" = "%fx_delta%" + 1
        WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 1)
        SET "index2" = "%abil_fx_num%" // kills loop
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// (un)holy word not displaying deaf portrait icon for deafened characters; see icondeaf.eff
COPY_EXISTING ~sppr710.spl~ ~override~
              ~sppr715.spl~ ~override~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index2%") * 0x30)) "eff_file"
      PATCH_IF (("%opcode%" = 177) AND ("%eff_file%" STRING_COMPARE_CASE "deafness" = 0)) BEGIN // deaf eff file
        READ_ASCII     ("%fx_off%" +        ((("%abil_fx_idx%" + "%index2%"    ) * 0x30))) "clone_fx" (48)
        INSERT_BYTES   ("%fx_off%" +        ((("%abil_fx_idx%" + "%index2%" + 1) * 0x30))) 0x30             // new effect
          WRITE_ASCIIE ("%fx_off%" +        ((("%abil_fx_idx%" + "%index2%" + 1) * 0x30))) "%clone_fx%"     // cloned effect
          WRITE_ASCII  ("%fx_off%" + 0x14 + ((("%abil_fx_idx%" + "%index2%" + 1) * 0x30))) "icondeaf"       // new eff reference
        SET "delta" = "%delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
        SET "index2" = "%index2%" + 1
      END
    END
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// wrong vvc for regen at lvl 15
COPY_EXISTING ~sppr711.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle thru abilities
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "resref"
      PATCH_IF (("%opcode%" = 215) AND ("%resref%" STRING_COMPARE_CASE "magres" = 0)) BEGIN
        WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "icwrati" #8
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// bad targets for pfnm sound effect targeting
COPY_EXISTING ~spra303.spl~ ~override~ // avenger
              ~spwi311.spl~ ~override~ // generic arcane
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle thru abilities
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      PATCH_IF ("%opcode%" = 174) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x02 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 2 // target: preset target
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect casting animaton
COPY_EXISTING ~spwi114.spl~ ~override~ // shield
              ~spwi818.spl~ ~override~ // bigby's clenched fist
              ~spwi918.spl~ ~override~ // bigby's crushing hand
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    WRITE_BYTE 0x22 15 // evocation animation
  END
  BUT_ONLY_IF_IT_CHANGES

// spook's 'panic' string not properly quashed by MR
// one sound can't be saved against
COPY_EXISTING ~spwi125.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR ("index" = 0; "%index%" < "%abil_num%"; "index" = ("%index%" + 1)) BEGIN
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 1 // change to dispel, no bypass MR
      WRITE_BYTE ("%fx_off%" + 0x24 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) THIS | BIT0
      WRITE_LONG ("%fx_off%" + 0x28 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) (index * "-1")
    END
  END
  BUT_ONLY

// mage detect evil using priest spell description
COPY_EXISTING ~spwi202.spl~ ~override~
  SAY 0x50 #12219
  BUT_ONLY_IF_IT_CHANGES

// horror duration incorrect
COPY_EXISTING ~spwi205.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle thru abilities
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "duration"
      PATCH_IF ("%duration%" = 18) BEGIN
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 60
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// luck not providing saving throw and thieving skill bonuses; duration incorrect
COPY_EXISTING ~spwi209.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle thru abilities
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    // first fix duration while we're here
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "duration"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "resref"
      PATCH_IF ("%duration%" = 20) BEGIN
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 18
      END
      PATCH_IF (("%opcode%" = 174) AND ("%resref%" STRING_EQUAL_CASE "EFF_M05")) BEGIN
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 1 // fix invalid sound effect duration
      END
      PATCH_IF ("%opcode%" = 133) BEGIN
        READ_ASCII ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "clone" (0x30)
        FOR (index3 = 33 ; index3 < 38 ; index3 = index3 + 1) BEGIN
          INSERT_BYTES   ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) 0x30 // new effect
            WRITE_ASCIIE ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "%clone%"
            WRITE_SHORT  ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "%index3%" // opcode: one of them thar saves
        END
                      PATCH_FOR_EACH ~thskill~ IN ~59~ ~90~ ~91~ ~92~ ~275~ ~276~ ~277~ BEGIN                   // all 7 thieving skill opcodes
        INSERT_BYTES            ("%fx_off%" +        ("%index2%" + "%abil_fx_idx%")) 0x30         // new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        ("%index2%" + "%abil_fx_idx%")) "%clone%"    // cloned effect
          WRITE_SHORT           ("%fx_off%" +        ("%index2%" + "%abil_fx_idx%")) "%thskill%"  // opcode
          WRITE_LONG            ("%fx_off%" + 0x04 + ("%index2%" + "%abil_fx_idx%")) 5            // param1: 5 (5% bonus)
          WRITE_LONG            ("%fx_off%" + 0x08 + ("%index2%" + "%abil_fx_idx%")) 0            // param2: 0 (cumulative bonus type)
        END
        SET "fx_delta" = ("%fx_delta%" + 12)
        SET "index2" = ("%index2%" + 12)
        SET "abil_fx_num" = ("%abil_fx_num%" + 12)
      END
    END
    WRITE_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// portrait icon for melf's acid arrow bypasses MR though spell itself does not
COPY_EXISTING ~spwi211.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle thru abilities
    WRITE_SHORT ("%abil_off%" +        (0x28 * "%index%")) 1 // change to melee (lvl 1 header is ranged)
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      PATCH_IF ("%opcode%" = 142) BEGIN
        WRITE_BYTE  ("%fx_off%" + 0x0d + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 1 // dispel/not bypass MR
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect casting animaton
COPY_EXISTING ~spwi222.spl~ ~override~ // chaos shield
              ~spwi723.spl~ ~override~ // improved chaos shield
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    WRITE_BYTE 0x22 12 // abjuration animation
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect duration, targeting for invis 10'
COPY_EXISTING ~spwi307.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle thru abilities
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "duration"
      PATCH_IF ("%duration%" = 300) BEGIN
        WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 7200
      END
      PATCH_IF ("%opcode%" = 174) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x02 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 2 // target: preset target
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect casting animaton
COPY_EXISTING ~spwi409.spl~ ~override~ // contagion
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    WRITE_BYTE 0x22 9 // necromancy animation
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect casting animaton
COPY_EXISTING ~spwi424.spl~ ~override~ // farsight
              ~spwi515.spl~ ~override~ // oracle
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    WRITE_BYTE 0x22 16 // divination animation
  END
  BUT_ONLY_IF_IT_CHANGES

// incorrect casting animaton
COPY_EXISTING ~spwi505.spl~ ~override~ // shadow door
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    WRITE_BYTE 0x22 13 // illusion animation
  END
  BUT_ONLY_IF_IT_CHANGES

// hold monster swirly graphic craps out early; should also set icon and display 'held' string
COPY_EXISTING ~spwi507.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle thru abilities
    READ_SHORT  ("%abil_off%" + 0x10 + (0x28 * "%index%")) "min_lev"
    PATCH_IF ("%min_lev%" = 1) THEN BEGIN
      SET "min_lev" = 9
    END
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 2)
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    SET "fx_delta" = ("%fx_delta%" + 2)
    // fix duration for swirly graphic while we're here, then clone the effect
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      PATCH_IF ("%opcode%" = 215) BEGIN
        WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%index2%" + "%abil_fx_idx%"))) (6 * "%min_lev%")
        READ_ASCII  ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "clone" (48)
      END
    END
    INSERT_BYTES   ("%fx_off%" +        (0x30 * "%abil_fx_idx%"))      0x30 // new effect
      WRITE_ASCIIE ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%" // use 215 effect as base
      WRITE_SHORT  ("%fx_off%" +        (0x30 * "%abil_fx_idx%"))       142 // display portrait icon
      WRITE_LONG   ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%"))        13 // icon: held
    INSERT_BYTES   ("%fx_off%" +        (0x30 * "%abil_fx_idx%"))      0x30 // new effect
      WRITE_ASCIIE ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%" // use 215 effect as base
      WRITE_SHORT  ("%fx_off%" +        (0x30 * "%abil_fx_idx%"))       139 // display string
      WRITE_LONG   ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%"))     14102 // string: held
      WRITE_BYTE   ("%fx_off%" + 0x0c + (0x30 * "%abil_fx_idx%"))         1 // instant/permanent
      WRITE_BYTE   ("%fx_off%" + 0x0e + (0x30 * "%abil_fx_idx%"))         0 // duration
  END
  BUT_ONLY_IF_IT_CHANGES

// wrong string for pfnw's protection from pfmw spell
COPY_EXISTING ~spwi511.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle thru abilities
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "resref"
      PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spwi611" = 0)) BEGIN // replace s&s descript
        WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) 36743
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// spell shield does not have listed durations due to missing ability headers
COPY_EXISTING ~spwi519.spl~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // first fix existing effects
    READ_SHORT  ("%abil_off%" + 0x10 + ("%index%" * 0x28)) "min_lev"
    PATCH_IF ("%min_lev%" = 1) BEGIN
      SET "min_lev" = 11
    END
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "duration"
      PATCH_IF ("%duration%" > 5) BEGIN // longer than one round
        WRITE_LONG ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // no dispel/bypass resistance
        WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) (18 * "%min_lev%") // corrects duration
      END
    END
  END
  FOR (index3 = min_lev + 1 ; index3 < 21 ; index3 = index3 + 1) BEGIN
    READ_ASCII ("%fx_off%" + (0x30 * "%abil_fx_idx%")) "effects" ("%abil_fx_num%" * 0x30) // reads whole block of effects from last ability
    READ_ASCII ("%abil_off%" + (0x28 * ("%abil_num%" - 1))) "ability" (0x28)              // reads last ability
    SET "abil_fx_idx" = "%abil_fx_idx%" + "%abil_fx_num%"
    INSERT_BYTES   ("%fx_off%" + (0x30 * "%abil_fx_idx%")) ("%abil_fx_num%" * 0x30) // inserts bytes
      WRITE_ASCIIE ("%fx_off%" + (0x30 * "%abil_fx_idx%")) "%effects%"              // clones existing effects
      FOR (index4 = 0 ; index4 < abil_fx_num ; index4 = index4 + 1) BEGIN    // loop to adjust effects by min level
        READ_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index4%"))) "duration"
        PATCH_IF ("%duration%" > 5) BEGIN // longer than one round
          WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index4%"))) (18 * "%index3%") // corrects duration
        END
      END
    INSERT_BYTES   ("%abil_off%" +        ("%abil_num%" * 0x28)) 0x28        // inserts bytes
      WRITE_ASCIIE ("%abil_off%" +        ("%abil_num%" * 0x28)) "%ability%" // clones existing ability
      WRITE_SHORT  ("%abil_off%" + 0x10 + ("%abil_num%" * 0x28)) ("%index3%") // minimum level
      WRITE_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x28)) "%abil_fx_idx%"
    SET "fx_off" = ("%fx_off%" + 0x28)
    SET "abil_num" = ("%abil_num%" + 1)
  END
  WRITE_LONG  0x6a "%fx_off%"
  WRITE_SHORT 0x68 "%abil_num%"
  BUT_ONLY_IF_IT_CHANGES

/// Ployer breaks the game if he meets Jaheira when she has fewer than 20 hit points. (see also cut12b.bcs) (proposed and originally coded by Icendoan, 
//// this code by DavidW)
COPY ~bg2fixpack/spl/dw#fpplo.spl~ ~override~ // this spell is a silent healing spell
  WRITE_LONG 0x9e 2 // the number of hit points healed - being done here for fine-tuning purposes

// Evil hell rewards have some effects with non-zero power levels and bad targeting (Wisp)
COPY_EXISTING spin747.spl override //selfish, evil
              spin749.spl override //wrath, evil
              spin751.spl override //pride, evil
              spin753.spl override //fear, evil
              spin755.spl override //greed, evil
  READ_LONG  0x64 ab_off
  READ_SHORT 0x68 num_ab
  READ_LONG  0x6a fx_off
  FOR (i=0; i < num_ab; i +=1) BEGIN
    READ_SHORT ab_off + 0x28 * i + 0x1e num_l_fx
    READ_SHORT ab_off + 0x28 * i + 0x20 fx_idx
    FOR (j=0; j < num_l_fx; j +=1) BEGIN
      WRITE_BYTE fx_off + 0x30 * (fx_idx + j) + 0x2 2 //Target
      WRITE_BYTE fx_off + 0x30 * (fx_idx + j) + 0x3 0 //Power
    END
  END
BUT_ONLY

// The Shield spell and the Shield Amulet should properly protect the recipient against TRAP_MAGIC_MISSILE (see also amul15.itm) (Nythrun and aVENGER)
COPY_EXISTING ~spwi114.spl~ ~override~ // Shield (WIZARD_SHIELD)
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
     READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
     READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "resref"
     READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "resref"
      PATCH_IF (("%opcode%" = "206") AND ("%resref%" STRING_EQUAL_CASE ~SPWI112~)) BEGIN           // effect #206: Protection from Spell
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "clone_fx" (0x30) // clone effect
        SET "index2"= "%abil_fx_num%" // kills loop
        INSERT_BYTES            ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30                // new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) "%clone_fx%"        // cloned effect
          WRITE_ASCII           ("%fx_off%" + 0x14 + ("%abil_fx_idx%" * 0x30)) "spwi003" #8        // resref: SPWI003 (TRAP_MAGIC_MISSILE)
        SET "delta" = "%delta%" + 1
        WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 1)
      END
    END
  END
BUT_ONLY_IF_IT_CHANGES

// Prismatic Spray was erroneously blinding targets up to level five, rather than seven (Nythrun)
COPY_EXISTING spwi714.spl override
  READ_LONG  0x64 ho
  READ_SHORT 0x68 hc
  READ_LONG  0x6a eo
  FOR (i_0 = 0x00; i_0 < hc; i_0 += 0x01) BEGIN
    READ_SHORT  ho + 0x28 * i_0 + 0x1e ec
    READ_SHORT  ho + 0x28 * i_0 + 0x20 ei
    FOR (i_1 = 0x00 opcode = 0xffff; i_1 < ec && opcode != 0x4a; i_1 += 0x01) BEGIN
      READ_SHORT eo + 0x30 * (i_1 + ei) + 0x00 opcode
      PATCH_IF opcode = 0x4a BEGIN
        WRITE_SHORT eo + 0x30 * (i_1 + ei) + 0x1c 0x07
      END
    END
  END
BUT_ONLY

// Pierce Shield now provides feedback when it lowers the target's magic resistance (Nythrun)
COPY_EXISTING spwi805.spl override
  READ_LONG  0x64 ho
  READ_SHORT 0x68 hc
  READ_LONG  0x6a eo
  FOR (i_0 = 0x00; i_0 < hc; i_0 += 0x01) BEGIN
    READ_SHORT  ho + 0x28 * i_0 + 0x10 ml
    READ_SHORT  ho + 0x28 * i_0 + 0x1e ec
    READ_SHORT  ho + 0x28 * i_0 + 0x20 ei
    FOR (i_1 = 0x00 opcode = 0xffff; i_1 < ec && opcode != 0x8b; i_1 += 0x01) BEGIN
      READ_SHORT eo + 0x30 * (i_1 + ei) + 0x00 opcode
      PATCH_IF i_1 = 0x00 BEGIN
        READ_ASCII eo + 0x30 * ei + 0x00 ef_0 (0x30)
        INNER_PATCH_SAVE ef_0 ~%ef_0%~ BEGIN
          WRITE_SHORT  0x00 0x8b // Display String Feedback
          WRITE_LONG   0x04 ml < 17 ? 32869 : ml < 20 ? 32853 + ml : 32875 // String to run
          WRITE_LONG   0x08 0x00 // Unused
          WRITE_ASCII  0x14 ~~ #8
        END
      END
    END
    PATCH_IF opcode != 0x8b BEGIN
      WRITE_SHORT ho + 0x28 * i_0 + 0x1e ec + 0x01
      INSERT_BYTES eo + 0x30 * (ec + ei) 0x30
      WRITE_ASCIIE eo + 0x30 * (ec + ei) ~%ef_0%~
      FOR (i_1 = i_0 + 0x01; i_1 < hc; i_1 += 0x01) BEGIN
        READ_SHORT  ho + 0x28 * i_1 + 0x20 ei
        WRITE_SHORT ho + 0x28 * i_1 + 0x20 ei + 0x01
      END
    END
  END
BUT_ONLY

// Prevent Enhanced Bard Song from reverting back to the default version after bard characters leave and rejoin the party (aVENGER)
COPY_EXISTING ~spcl920.spl~ ~override~     // Enhanced Bard Song
PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN // file size check
PATCH_FOR_EACH ~file~ IN                   // for each of the following files
            ~spcl542~                      // Skald song
            ~spcl751~                      // Jester song
             ~fjbard~                      // Bard song (BG2 fixpack OBC)
            ~fjblade~                      // Blade song (BG2 fixpack OBC)
BEGIN                                      // execute the following
SET opcode = "206"                         // effect: #206 (Protection from Spell)
SET target = "2"                           // target: 2 (pre-target)
SET timing = "9"                           // timing mode: 9 (permanent after death)
SET parameter1 = "0"                       // param1: 0
SET parameter2 = "0"                       // param2: 0
SET power = "0"                            // power: 0
SET resist_dispel = "0"                    // dispel/resistance: 0 (non-magical)
SET duration = "0"                         // duration: 0
SET probability1 = "100"                   // probability1: 100%
SET probability2 = "0"                     // probability2: 0%
SET dicenumber = "0"                       // dicenumber: 0
SET dicesize = "0"                         // dicesize: 0
SET savingthrow = "0"                      // saving throw type: 0 (none)
SET savebonus = "0"                        // save bonus: 0
SPRINT ~resource~ EVALUATE_BUFFER "%file%" // resref: the current file
SET header = "0"                           // add effect to every header
LAUNCH_PATCH_MACRO ~ADD_SPELL_EFFECT~      // add new spell effect
END                                        // ends PATCH_FOR_EACH
END                                        // ends file size check
BUT_ONLY_IF_IT_CHANGES

// Non-magical innate abilities shouldn't be affected by Wild Magic and Dead Magic zones (aVENGER)
ACTION_FOR_EACH ~file~ IN                        // for each of the following files
             ~spcl152~                           // Barbarian Rage
             ~spcl211~                           // Paladin Lay On Hands
            ~spcl321d~                           // Berserker Enrage secondary effect (becoming winded)
             ~spcl611~                           // Druid Shapeshift Brown Bear
             ~spcl612~                           // Druid Shapeshift Wolf
             ~spcl613~                           // Druid Shapeshift Black Bear
             ~spcl632~                           // Avenger Shapeshift Spider
             ~spcl633~                           // Avenger Shapeshift Baby Wyvern
             ~spcl634~                           // Avenger Shapeshift Fire Salamander
             ~spcl643~                           // Shapeshifter Werewolf Transformation
             ~spcl644~                           // Shapeshifter Greater Werewolf Transformation
             ~spcl815~                           // Monk Lay On Hands
             ~sppr731~                           // Druid Fire Elemental Transformation
             ~sppr732~                           // Druid Earth Elemental Transformation
BEGIN                                            // execute the following
ACTION_IF FILE_EXISTS_IN_GAME ~%file%.spl~ BEGIN // if the designated file with a SPL extension exists
COPY_EXISTING ~%file%.spl~ ~override~
PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN       // file size sanity check (filters out 0 byte files i.e. ALLOW_MISSING)
  READ_BYTE  0x19 "flags"
  WRITE_BYTE 0x19 ("%flags%" BOR 0b01000000)     // add the Non-Magical flag
END                                              // ends file size check
BUT_ONLY_IF_IT_CHANGES
END                                              // ends ACTION_IF FILE_EXISTS_IN_GAME block
END                                              // ends ACTION_FOR_EACH block

// Wish: Breach on all enemies in the area should not affect friendly summoned creatures and turn them hostile. Fixed by using a different targeting method and projectile
ACTION_IF GAME_IS tob BEGIN
COPY_EXISTING ~SPWISH38.SPL~  ~override~                                           // Wish: Breach on all enemies in the area
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN                       // cycle through abilities
   READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
   READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
     WRITE_BYTE  ("%fx_off%" + 0x02 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "2" // target: 2 (preset target)
    END
  WRITE_SHORT  ("%abil_off%" + 0x26 + (0x28 * "%index%")) "254"                    // projectile: 254 (BIGNAREA)
  END
BUT_ONLY_IF_IT_CHANGES
END

// Greater Command should use the same projectile at all levels. In term, the spell will no longer affect the caster's allies at lower levels
COPY_EXISTING ~SPPR512.SPL~ ~override~                                             // Greater Command
PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN                                         // file size sanity check
READ_LONG  0x64 ab_off
READ_SHORT 0x68 ab_num
  FOR(i=0; i<ab_num; i+=1) BEGIN                                                   // cycle through all headers
    WRITE_SHORT (ab_off+i*0x28+0x26) 159                                           // use INAREANP.PRO for the projectile
  END
END                                                                                // end file size sanity check
BUT_ONLY_IF_IT_CHANGES

ACTION_IF NOT FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // SoA-only fix

  // SoA black blade missing lev 19, 20 headers; see also blakblad.itm SoA patch for prof fix
  COPY_EXISTING ~spwi915.spl~ ~override~
    READ_LONG   0x64 "abil_off"
    READ_SHORT  0x68 "abil_num"
    READ_LONG   0x6a "fx_off"
    READ_SHORT  0x70 "fx_num"
    FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // first fix existing effects
      READ_SHORT  ("%abil_off%" + 0x10 + ("%index%" * 0x28)) "min_lev"
      PATCH_IF ("%min_lev%" = 1) BEGIN
        SET "min_lev" = 18
      END
      READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x28)) "abil_fx_num"
      READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x28)) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "duration"
        PATCH_IF ("%opcode%" = 54) BEGIN // thac0 bonus
          WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) (21 - "%min_lev%") // adjusted for level
          WRITE_LONG ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 1                  // set to value
        END
        PATCH_IF ("%duration%" > 5) BEGIN // longer than one round
          WRITE_LONG ("%fx_off%" + 0x0d + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // no dispel/bypass resistance
          WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) (6 * "%min_lev%") // corrects duration
        END
      END
    END
    FOR (index3 = min_lev + 1 ; index3 < 21 ; index3 = index3 + 1) BEGIN
      READ_ASCII ("%fx_off%" + (0x30 * "%abil_fx_idx%")) "effects" ("%abil_fx_num%" * 0x30) // reads whole block of effects from last ability
      READ_ASCII ("%abil_off%" + (0x28 * ("%abil_num%" - 1))) "ability" (0x28)              // reads last ability
      SET "abil_fx_idx" = "%abil_fx_idx%" + "%abil_fx_num%"
      INSERT_BYTES   ("%fx_off%" + (0x30 * "%abil_fx_idx%")) ("%abil_fx_num%" * 0x30) // inserts bytes
        WRITE_ASCIIE ("%fx_off%" + (0x30 * "%abil_fx_idx%")) "%effects%"              // clones existing effects
        FOR (index4 = 0 ; index4 < abil_fx_num ; index4 = index4 + 1) BEGIN    // loop to adjust effects by min level
          READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index4%"))) "opcode"
          READ_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index4%"))) "duration"
          PATCH_IF ("%opcode%" = 54) BEGIN // thac0 bonus
            WRITE_LONG ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index4%"))) (21 - "%index3%") // adjusted for level
          END
          PATCH_IF ("%duration%" > 5) BEGIN // longer than one round
            WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index4%"))) (6 * "%index3%") // corrects duration
          END
        END
      INSERT_BYTES   ("%abil_off%" +        ("%abil_num%" * 0x28)) 0x28        // inserts bytes
        WRITE_ASCIIE ("%abil_off%" +        ("%abil_num%" * 0x28)) "%ability%" // clones existing ability
        WRITE_SHORT  ("%abil_off%" + 0x10 + ("%abil_num%" * 0x28)) ("%index3%") // minimum level
        WRITE_SHORT  ("%abil_off%" + 0x20 + ("%abil_num%" * 0x28)) "%abil_fx_idx%"
      SET "fx_off" = ("%fx_off%" + 0x28)
      SET "abil_num" = ("%abil_num%" + 1)
    END
    WRITE_LONG  0x6a "%fx_off%"
    WRITE_SHORT 0x68 "%abil_num%"
    BUT_ONLY_IF_IT_CHANGES

END

/////                                                  \\\\\
///// store fixes                                      \\\\\
/////                                                  \\\\\

// Monster code for disabling infinite items.
COPY_EXISTING ~25spell2.sto~ ~override~
              ~arled.sto~    ~override~
              ~bdbart01.sto~ ~override~
              ~bernard2.sto~ ~override~
              ~ffbart.sto~   ~override~
              ~gorch.sto~    ~override~
              ~hgkar01.sto~  ~override~
              ~lehtinan.sto~ ~override~
              ~ppstor01.sto~ ~override~
              ~ribald.sto~   ~override~
              ~ribald2.sto~  ~override~
              ~ribald3.sto~  ~override~
              ~sartem01.sto~ ~override~
              ~shop03.sto~   ~override~
              ~shop07.sto~   ~override~
              ~thumb.sto~    ~override~
              ~trgeni01.sto~ ~override~
              ~trmer04.sto~  ~override~
              ~trmer04a.sto~ ~override~
              ~type2.sto~    ~override~
              ~uddrow23.sto~ ~override~
  READ_LONG 0x34 "itm_off" ELSE 0
  READ_LONG 0x38 "itm_num" ELSE 0
  WHILE ("%itm_num%" > 0) BEGIN
    SET "itm_num" = ("%itm_num%" - 1)
    READ_ASCII ("%itm_off%" + (0x1c * "%itm_num%")) "item"
    PATCH_IF (("%item%" STRING_COMPARE_CASE "scrl2h" = 0) AND ("25spell2" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0xA  + (0x1c * "%itm_num%")) 1 // Set quantity/charges of item to 1
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x14 + (0x1c * "%itm_num%")) 2 // Set number in stock to 2
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "sw1h44" = 0) AND ("arled" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "sw2h02" = 0) AND ("arled" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "halb02" = 0) AND ("arled" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "book40" = 0) AND ("bdbart01" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "scrl8p" = 0) AND ("bernard2" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "book40" = 0) AND ("ffbart" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "blun21" = 0) AND ("gorch" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "blun31" = 0) AND ("hgkar01" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "book40" = 0) AND ("lehtinan" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "dart02" = 0) AND ("ppstor01" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "ring28" = 0) AND ("ribald" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "ring03" = 0) AND ("ribald" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "potn19" = 0) AND ("ribald2" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "bow10" = 0)  AND ("ribald3" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0xA  + (0x1c * "%itm_num%")) 0 // Set quantity/charges of item to 0
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
//    PATCH_IF (("%item%" STRING_COMPARE_CASE "scrl9z" = 0) AND ("ribald3" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
//      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
//    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "sw2h09" = 0) AND ("ribald3" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "sw2h11" = 0) AND ("ribald3" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "miscau" = 0) AND ("sartem01" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "bull02" = 0) AND ("shop03" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "shld05" = 0) AND ("shop07" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "book40" = 0) AND ("thumb" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "sw1h44" = 0) AND ("trgeni01" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "sw2h02" = 0) AND ("trgeni01" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "halb02" = 0) AND ("trgeni01" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "potn19" = 0) AND ("trmer04" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "sw2h11" = 0) AND ("trmer04a" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "chan05" = 0) AND ("type2" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "sw1h44" = 0) AND ("type2" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "potn19" = 0) AND ("type2" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END ELSE
    PATCH_IF (("%item%" STRING_COMPARE_CASE "sw2h07" = 0) AND ("uddrow23" STRING_COMPARE_CASE ~%SOURCE_RES%~ = 0)) BEGIN
      READ_BYTE  ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) "itm_flags"
      WRITE_BYTE ("%itm_off%" + 0x10 + (0x1c * "%itm_num%")) ("%itm_flags%" BOR 0b00000001) // Set item flags to identified
      WRITE_BYTE ("%itm_off%" + 0x18 + (0x1c * "%itm_num%")) 0 // Set infinite flag to zero
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// sell stacks of 1 throwing axe
COPY_EXISTING ~bshop02.sto~ ~override~
  ADD_STORE_ITEM + ~ax1h04~ #5 #0 #0 ~IDENTIFIED~ #3
  BUT_ONLY_IF_IT_CHANGES

// sell stacks of 1 throwing axe
COPY_EXISTING ~garlena.sto~ ~override~
              ~sahpr1.sto~  ~override~
              ~suelf10.sto~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x9a) BEGIN
    ADD_STORE_ITEM + ~ax1h04~ #5 #0 #0 ~IDENTIFIED~ #2
  END
  BUT_ONLY_IF_IT_CHANGES
  
// stores with dupe large shield +1 entries; should be normal large shields
COPY_EXISTING ~ribald.sto~ ~override~
              ~shop02.sto~ ~override~
  READ_LONG 0x34 "itm_off" ELSE 0
  READ_LONG 0x38 "itm_num" ELSE 0
  FOR (index = 0 ; index < itm_num ; index = index + 1) BEGIN
    READ_ASCII ("%itm_off%" +        (0x1c * "%index%")) "item"
    READ_BYTE  ("%itm_off%" + 0x14 + (0x1c * "%index%")) "quantity"
    PATCH_IF (("%item%" STRING_COMPARE_CASE "shld06" = 0) AND ("%quantity%" = 5)) BEGIN
      WRITE_ASCII ("%itm_off%" +        (0x1c * "%index%")) ~shld05~ #8
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB-only stuff check

  // fix arcana archive name
  COPY_EXISTING ~25SPELL.STO~ ~OVERRIDE~
    SAY 0x0c #70882 // Arcana Archives
    BUT_ONLY_IF_IT_CHANGES

  // fix arcana archive name
  COPY_EXISTING ~25SPELL2.STO~ ~OVERRIDE~
    SAY 0x0c #73982 // Arcana Archives
    BUT_ONLY_IF_IT_CHANGES

  // Amkethran duplicate gem bag fix, part two of four (see cdbag02i.itm, cdbag02j.itm, cdbag02i.sto, cdbag02j.sto)
  COPY_EXISTING ~amsmug01.sto~ ~override~
    READ_LONG 0x34 "4sale_off"
    READ_LONG 0x38 "4sale_num"
    WHILE ("%4sale_num%" > 0) BEGIN
      SET "4sale_num" = ("%4sale_num%" - 1)
      READ_ASCII ("%4sale_off%" + ("%4sale_num%" * 0x1c)) "item"
      PATCH_IF ("%item%" STRING_COMPARE_CASE "bag02d" = 0) BEGIN
        WRITE_ASCII ("%4sale_off%" + ("%4sale_num%" * 0x1c)) "cdbag02i"
      END
    END
    BUT_ONLY_IF_IT_CHANGES

  // Amkethran duplicate gem bag fix, part three of four (see cdbag02i.itm, cdbag02j.itm, cdbag02i.sto, cdbag02j.sto)
  COPY_EXISTING ~amsmug02.sto~ ~override~
    READ_LONG 0x34 "4sale_off"
    READ_LONG 0x38 "4sale_num"
    WHILE ("%4sale_num%" > 0) BEGIN
      SET "4sale_num" = ("%4sale_num%" - 1)
      READ_ASCII ("%4sale_off%" + ("%4sale_num%" * 0x1c)) "item"
      PATCH_IF ("%item%" STRING_COMPARE_CASE "bag02d" = 0) BEGIN
        WRITE_ASCII ("%4sale_off%" + ("%4sale_num%" * 0x1c)) "cdbag02j"
      END
    END
    BUT_ONLY_IF_IT_CHANGES

  // Amkethran duplicate gem bag fix, part four of four (see amsmug01.sto, amsmug02.sto, cdbag02i.itm, cdbag02j.itm)
  COPY_EXISTING ~bag02i.sto~ ~override/cdbag02i.sto~
  COPY_EXISTING ~bag02i.sto~ ~override/cdbag02j.sto~

  // starting ToB bags of holding have uncharged items
  COPY_EXISTING ~bag20.sto~ ~override~
                ~bag22.sto~ ~override~
    ADD_STORE_ITEM + ~MISC3E~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3I~ #1 #0 #0 IDENTIFIED #1
    BUT_ONLY_IF_IT_CHANGES

  COPY_EXISTING ~bag21.sto~ ~override~
    ADD_STORE_ITEM + ~BRAC16~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3E~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3I~ #1 #0 #0 IDENTIFIED #1
    BUT_ONLY_IF_IT_CHANGES

  COPY_EXISTING ~bag23.sto~ ~override~
                ~bag24.sto~ ~override~
                ~bag25.sto~ ~override~
    ADD_STORE_ITEM + ~MISC3E~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3I~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~SW1H27~ #0 #1 #0 IDENTIFIED #1
    BUT_ONLY_IF_IT_CHANGES

  COPY_EXISTING ~bag26.sto~ ~override~
    ADD_STORE_ITEM + ~BULL03~ #40 #0 #0 IDENTIFIED #2
    ADD_STORE_ITEM + ~MISC3E~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3I~ #1 #0 #0 IDENTIFIED #1
    BUT_ONLY_IF_IT_CHANGES

  COPY_EXISTING ~bag27.sto~ ~override~
                ~bag28.sto~ ~override~
    ADD_STORE_ITEM + ~BULL03~ #40 #0 #0 IDENTIFIED #2
    ADD_STORE_ITEM + ~MISC3D~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3E~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3I~ #1 #0 #0 IDENTIFIED #1
    BUT_ONLY_IF_IT_CHANGES

  COPY_EXISTING ~bag29.sto~ ~override~
    ADD_STORE_ITEM + ~DART04~ #40 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3E~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3I~ #1 #0 #0 IDENTIFIED #1
    BUT_ONLY_IF_IT_CHANGES

  COPY_EXISTING ~bag30.sto~ ~override~
    ADD_STORE_ITEM + ~MISC3D~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3E~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3I~ #1 #0 #0 IDENTIFIED #1
    ADD_STORE_ITEM + ~MISC3M~ #1 #0 #0 IDENTIFIED #1
    BUT_ONLY_IF_IT_CHANGES

END

// fixes markup issues at Sahuagin and Suldanesselar stores
COPY_EXISTING ~sahpr1.sto~  ~override~ // Sahuagin store
              ~suelf10.sto~ ~override~ // Suldanesselar markup adjustments
  WRITE_LONG 0x14 120
  WRITE_LONG 0x18 50
  BUT_ONLY_IF_IT_CHANGES

// items being under/over charged
COPY_EXISTING ~amsmug01.sto~ ~override~ // Amkethran Smugglers (Carras)
              ~amsmug02.sto~ ~override~ // Amkethran Smugglers (Carras)
              ~bag20.sto~    ~override~ // Thone of Bhaal Goodwill Bag
              ~bag21.sto~    ~override~ // Thone of Bhaal Goodwill Bag
              ~bag22.sto~    ~override~ // Thone of Bhaal Goodwill Bag
              ~bag23.sto~    ~override~ // Thone of Bhaal Goodwill Bag
              ~bag24.sto~    ~override~ // Thone of Bhaal Goodwill Bag
              ~bag25.sto~    ~override~ // Thone of Bhaal Goodwill Bag
              ~bag26.sto~    ~override~ // Thone of Bhaal Goodwill Bag
              ~bag27.sto~    ~override~ // Thone of Bhaal Goodwill Bag
              ~bag28.sto~    ~override~ // Thone of Bhaal Goodwill Bag
              ~bag29.sto~    ~override~ // Thone of Bhaal Goodwill Bag
              ~bag30.sto~    ~override~ // Thone of Bhaal Goodwill Bag
  // (unused) ~bdbart01.sto~ ~override~ // Five Flagons
              ~bshop01.sto~  ~override~ // Merchant (Cutpurse) (Bridge District)
              ~bshop02.sto~  ~override~ // Merchant (Storekeep) (Bridge District)
              ~garlena.sto~  ~override~ // Temple of Helm (Sister Garlena) (Watcher's Keep)
              ~ribald.sto~   ~override~ // Adventurers' Mart (Ribald)
  // (unused) ~ribald2.sto~  ~override~ // Adventurers' Mart
              ~ribald3.sto~  ~override~ // Adventurers' Mart (Ribald's special stock)
              ~sahpr1.sto~   ~override~ // Temple of Sekolah (Priestess of Sekolah)
              ~suelf10.sto~  ~override~ // Temple of Rillifane (Rierra)
              ~trcar04.sto~  ~override~ // Merchant (Caravan Merchant) (Trademeet Hut)
              ~trmer02.sto~  ~override~ // Merchant (Merchant) (Trademeet)
  // (unused) ~type1.sto~    ~override~ // Merchant
  // (unused) ~type2.sto~    ~override~ // Adventurers' Mart
              ~uddrow23.sto~ ~override~ // Merchant (Drow) (Ust Natha)
              ~uddrow24.sto~ ~override~ // Shop (Drow) (Ust Natha)
  PATCH_IF (%SOURCE_SIZE% > 0xb4) THEN BEGIN
    READ_LONG 0x34 "io"
    READ_LONG 0x38 "ic"
    FOR ("i1" = 0x00; "i1" < ("ic" * 0x1c); "i1" += 0x1c) BEGIN
      READ_ASCII    ("io" + "i1" + 0x00) "it"
      READ_SHORT    ("io" + "i1" + 0x0a) "c1"
      READ_SHORT    ("io" + "i1" + 0x0c) "c2"
      READ_SHORT    ("io" + "i1" + 0x0e) "c3"
      PATCH_IF          ((NOT "%it%" STRING_COMPARE_CASE "arow02" ) AND ("c1"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x28 // Arrows +1
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "ax1h04" ) AND ("c1"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x0a // Throwing Axe
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "boot12" ) AND ("c1"  < 0x02)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x02 // Gargoyle Boots
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "bow10"  ) AND ("c2"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0c) 0x01 // Heartseeker +3
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "brac16" ) AND ("c1"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x01 // Bracers of Blinding Strike
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "bull03" ) AND ("c1"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x28 // Bullet +2
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "dart04" ) AND ("c1"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x28 // Dart of Wounding
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "misc3d" ) AND ("c1"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x01 // Golden Lion Figurine
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "misc3e" ) AND ("c1"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x01 // Black Spider Figurine
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "misc3i" ) AND ("c1"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x01 // Silver Horn of Valhalla
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "misc3m" ) AND ("c1"  < 0x03)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x03 // Harp of Discord
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "potn20" ) AND ("c1"  > 0x05)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x05 // Antidote
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "restore") AND ("c2"  > 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0c) 0x00 // Restoration
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "ring28" ) AND (("c1" = 0x00) OR ("c2" = 0x00))) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x01 // Ring of Air Control
        WRITE_SHORT ("io" + "i1" + 0x0c) 0x01
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "rods04" ) AND ("c1" != 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x00 // Rod of Smiting
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "rods06" ) AND ("c1"  > 0x0a)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0a) 0x0a // Rod of Reversal
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "staf16" ) AND (("c2" < 0x1e) OR ("c3" < 0x1e))) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0c) 0x1e // Staff of Earth +2
        WRITE_SHORT ("io" + "i1" + 0x0e) 0x1e
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "sw1h27" ) AND ("c2"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0c) 0x01 // Arbane's Sword +2
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "sw1h33" ) AND ("c2"  = 0x00)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0c) 0x01 // Ras +2
      END ELSE PATCH_IF ((NOT "%it%" STRING_COMPARE_CASE "wand05" ) AND ("c2"  < 0x32)) THEN BEGIN
        WRITE_SHORT ("io" + "i1" + 0x0c) 0x32 // Wand of Fire
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// The merchant who gets assaulted by a thug at the City Gates no longer shares a store with the
// Brynnlaw storekeeper (see also soa-dlg.d) (Nythrun and devSin)
COPY_EXISTING ppstor01.sto ~override/cdaemerc.sto~
  WRITE_LONG 0x14 145 // reduce sell markup

/////                                                  \\\\\
///// pro fixes                                        \\\\\
/////                                                  \\\\\

// color spray arc fix
COPY_EXISTING ~cspray.pro~ ~override~
  WRITE_SHORT 0x206 426
  BUT_ONLY_IF_IT_CHANGES

// power word blind should also affect party/allies
COPY_EXISTING ~holdsumm.pro~ ~override~
  READ_BYTE  0x200 "flags"
  WRITE_BYTE 0x200 ("%flags%" BAND 0b00001010) // removes ally/self exemptin flags
  BUT_ONLY_IF_IT_CHANGES

// missing shadow
COPY_EXISTING ~ICEGLYP.PRO~ ~OVERRIDE~
  READ_BYTE 0x0100 ~projectileFlags~ ELSE 0x00
  WRITE_BYTE 0x0100 ~%projectileFlags%~ BAND 0x7f
  BUT_ONLY_IF_IT_CHANGES

// meteor swarm should be 4 rounds, per descript
COPY_EXISTING ~metswarm.pro~ ~override~
  WRITE_BYTE 0x216 4 // should last 4 rounds per descript
  BUT_ONLY_IF_IT_CHANGES

// shadow/bam missing
COPY_EXISTING ~SPATTCK2.PRO~ ~OVERRIDE~
  READ_BYTE 0x0100 ~projectileFlags~ ELSE 0x00
  WRITE_ASCII 0x010c ~SPSHADOW~ #8
  WRITE_BYTE 0x0100 ~%projectileFlags%~ BOR 0x20
  WRITE_BYTE 0x0115 0x00
  BUT_ONLY_IF_IT_CHANGES

// another shadow
COPY_EXISTING ~SPGREORB.PRO~ ~OVERRIDE~
  READ_BYTE 0x0100 ~projectileFlags~ ELSE 0x00
  WRITE_ASCII 0x010c ~SPCHRORB~ #8
  WRITE_BYTE 0x0100 ~%projectileFlags%~ BOR 0x20
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// vvc fixes                                        \\\\\
/////                                                  \\\\\

// adds unused sequence
COPY_EXISTING ~SPATTCK1.VVC~ ~OVERRIDE~
  WRITE_LONG 0x68 0x02
  WRITE_LONG 0x6c 0x01
  BUT_ONLY_IF_IT_CHANGES

ACTION_IF FILE_EXISTS_IN_GAME ~spauraff.vvc~ THEN BEGIN

  // wrong sounds for aura o' flamin' death
  COPY_EXISTING ~SPAURAFF.VVC~ ~OVERRIDE~
    WRITE_ASCII 0x78 ~EFF_P114~ #8
    WRITE_ASCII 0x80 ~AFT_P28~ #8
    BUT_ONLY_IF_IT_CHANGES
    
END

// play intro, then normal sequence
COPY_EXISTING ~spbldbtm.VVC~ ~OVERRIDE~
              ~spbldtop.VVC~ ~OVERRIDE~
  WRITE_LONG 0x68 0x02
  WRITE_LONG 0x6c 0x01
  WRITE_LONG 0x90 0x03
  BUT_ONLY_IF_IT_CHANGES

// should have three variations
COPY_EXISTING ~SPCLOUD1.VVC~ ~OVERRIDE~
  WRITE_LONG 0x68 0x03
  WRITE_LONG 0x6c 0x04
  BUT_ONLY_IF_IT_CHANGES

// enables outro in place of middle for smoother animation
COPY_EXISTING ~SPWOOD.VVC~ ~OVERRIDE~
  WRITE_LONG 0x68 0x01
  WRITE_LONG 0x6c 0x03
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// eff fixes                                        \\\\\
/////                                                  \\\\\

// bolt of glory should do same type of damage to all creatures
COPY_EXISTING ~boltund.eff~ ~override~
  WRITE_SHORT 0x22 128 // missile
  BUT_ONLY_IF_IT_CHANGES

// changes Flame o' North's damage bonus to CE from all E
COPY_EXISTING ~flamenor.eff~ ~override~
  WRITE_LONG 0x1c 51
  BUT_ONLY_IF_IT_CHANGES

// change from damage v type (179) to damage (12); see blun12.itm (revised by Wisp)
COPY_EXISTING ~macedisr.eff~ ~override/cddisr.eff~
  WRITE_LONG  0x10 12 // opcode: damage
  WRITE_LONG  0x1c  2 // fixed damage
  WRITE_SHORT 0x20  0 // straight butter, baby
  WRITE_SHORT 0x60  0 // param3 not needed
  BUT_ONLY_IF_IT_CHANGES

// changes bonus damage to undead for IMoD (blun25.itm) to 1d6 + 1 to bring total to 2d6 +4 (revised by Wisp)
COPY_EXISTING ~cddisr.eff~ ~override/macedisu.eff~
  WRITE_LONG 0x1c 1 // fixed damage

// Polymorph other was setting victim's attacks per round to zero; adjusted to one. See spwi415.spl for one other fix.
COPY_EXISTING ~plyrate.eff~ ~override~
  WRITE_LONG 0x1c 1
  BUT_ONLY_IF_IT_CHANGES

// new eff needed for level 20 holy smite
COPY_EXISTING ~SP313L19.EFF~ ~override/SP313L20.EFF~
  WRITE_LONG 0x38 20

// assassin poison should be a save v death, not save v everything
COPY_EXISTING ~SPCL422.EFF~ ~override~
  WRITE_LONG 0x40 0x4 // saving throw vs. death ONLY
  BUT_ONLY_IF_IT_CHANGES

// more assassin poison; damage is incorrect
COPY_EXISTING ~SPCL422A.EFF~ ~override~
  WRITE_LONG 0x1c 0x2 // +2 damage, not 1
  WRITE_LONG 0x20 0x02 // type is incorrect (Nythrun)
  BUT_ONLY_IF_IT_CHANGES

// deathblow has no save and doesn't affect >10 HD creatures
COPY_EXISTING ~QUIVVIS.EFF~ ~override/SPCL902A.EFF~
  WRITE_LONG  0x40 0x0   // no save
  WRITE_SHORT 0x58 0xa  // max HD 10

// greater deathblow has no save and doesn't affect >10 HD creatures
COPY_EXISTING ~QUIVVIS.EFF~ ~override/SPCL903A.EFF~
  WRITE_LONG  0x40 0x0   // no save
  WRITE_SHORT 0x58 0xc  // max HD 12

// display string effs with incorrect timing
COPY_EXISTING ~spcl906b.eff~ ~override~
              ~spin935d.eff~ ~override~
              ~stunstrg.eff~ ~override~
  PATCH_IF (SOURCE_SIZE >= 0x110) BEGIN
    WRITE_LONG 0x24 0x1 // Instant/Permanent
    WRITE_LONG 0x28 0x0 // duration
  END
  BUT_ONLY_IF_IT_CHANGES

// greater earth elem (cleric) is hostile, should match summoner's allegiance
COPY_EXISTING ~SPEART3P.EFF~ ~override~
  WRITE_LONG 0x20 0x0 // set to Match target
  BUT_ONLY_IF_IT_CHANGES

// removing saves from effs; save chances are already handled by the spell file
COPY_EXISTING ~UDEAD66.EFF~  ~override~  // Sol's +6d6 deep-fry
              ~UNDCHSTR.EFF~ ~override~  // "Controlled" str
              ~UNDCHVIS.EFF~ ~override~  // SPNWCHRM for hold spells? L A Z Y
  WRITE_LONG 0x40 0x0
  BUT_ONLY_IF_IT_CHANGES
  
// new eff for holy smite; needs to display blind icon for blinded creatures
COPY_EXISTING ~blind.eff~    ~override/cdblind.eff~
  WRITE_LONG 0x10 142 // display portrait icon
  WRITE_LONG 0x20 8   // icon: blinded

// new eff for holy smite; needs to display blinded string for blinded creatures
COPY_EXISTING ~blind.eff~    ~override/cdblind1.eff~
  WRITE_LONG 0x10 139   // display string
  WRITE_LONG 0x1c 14674 // string: blinded

// daystar damage vs. evil undead fixes, pt. 2 (see sw1h31.itm, daystar2.eff)
COPY_EXISTING ~daystar1.eff~ ~override~
  WRITE_LONG  0x10        177 // use eff file
  WRITE_LONG  0x1c          3 // against mask_evil...
  WRITE_LONG  0x20          8 // ...from align.ids
  WRITE_ASCII 0x30 ~daystar2~ // then actually go to another +2 damage

// new eff for (un)holy word to display deaf icon; see sppr710.spl, sppr715.spl
COPY_EXISTING ~iconslow.eff~ ~override/icondeaf.eff~
  WRITE_LONG 0x20 112 // deafened

/////                                                  \\\\\
///// music fixes                                      \\\\\
/////                                                  \\\\\

// from remix, devsin
COPY_EXISTING ~music/bc1.mus~ ~music~
  REPLACE_TEXTUALLY ~J1 +B1 +@TAG +ZJ~ ~J1  BC1   B1        @TAG ZJ~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bc2.mus~ ~music~
  REPLACE_TEXTUALLY ~K1 +A2 +@TAG +Z~ ~K1  BC2   A2        @TAG Z~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bd1.mus~ ~music~
  REPLACE_TEXTUALLY ~E2 +B1 +@TAG +ZB~ ~E2  BD1   B1        @TAG ZB~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bd2.mus~ ~music~
  REPLACE_TEXTUALLY ~F2 +B1 +@TAG +ZF~ ~F2  BD2   B1        @TAG ZF~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bd2/bd2zg2.acm~ ~music/bd3/bd3zg2.acm~

COPY_EXISTING ~music/bd3.mus~ ~music~
  REPLACE_TEXTUALLY ~G2 +A2 +@TAG +ZG2~ ~G2  BD3   A2        @TAG ZG2~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bf1.mus~ ~music~
  REPLACE_TEXTUALLY ~H2 +B1 +@TAG +Z~ ~H2  BF1   B1        @TAG Z~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bf2.mus~ ~music~
  REPLACE_TEXTUALLY ~J3 +B1 +@TAG +ZJ3~ ~J3  BF2   B1        @TAG ZJ3~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bjr.mus~ ~music~
  REPLACE_TEXTUALLY "H2 +B1" "H2 BJR B1"
  REPLACE_TEXTUALLY ZA Z
  SET_2DA_ENTRY 11 2 3 ZB
BUT_ONLY  

COPY_EXISTING ~music/bm1.mus~ ~music~
  INSERT_2DA_ROW 11 3 "J1 @TAG ZA"
  INSERT_2DA_ROW 12 3 "J2 BM1 B1 @TAG ZB"
  REPLACE_TEXTUALLY ~H1 +B2~ ~H1~
  SET_2DA_ENTRY 1 0 1 13

COPY_EXISTING ~music/bm2.mus~ ~music~
  REPLACE_TEXTUALLY ~N2 +B1 +@TAG +ZA~ ~N2  BM2   B1        @TAG ZA~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bp1.mus~ ~music~
  REPLACE_TEXTUALLY ~H3 +B1 +@TAG +ZA~ ~H3  BP1   B1        @TAG ZA~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bp2.mus~ ~music~
  REPLACE_TEXTUALLY ~K1 +B1 +@TAG +Z~ ~K1  BP2   B1        @TAG Z~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/brd.mus~ ~music~
  REPLACE_TEXTUALLY ~B2 +A1 +@TAG +ZB~ ~B2  BRD   A1        @TAG ZB~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bsd.mus~ ~music~
  REPLACE_TEXTUALLY ~F2A +A2 +@TAG +ZF2~ ~F2A  BSD  A2        @TAG ZF2~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/bst.mus~ ~music~
  REPLACE_TEXTUALLY ~J1 +C1 +@TAG +ZH2~ ~J1  BST   C1        @TAG ZH2~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/harp_v2.mus~ ~music~
  SET_2DA_ENTRY 6 0 1 ~1C~ // the current entry, C (HARP_V2C.ACM), doesn't exist
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/harp_v6.mus~ ~music~
  REPLACE_TEXTUALLY ~^5~ ~6~
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~music/mx0202.mus~ ~music/mxkalah.mus~
  REPLACE_TEXTUALLY ~0202~ ~KALAH~

COPY_EXISTING ~music/mx0202.mus~ ~music/mxkhali.mus~
  REPLACE_TEXTUALLY ~0202~ ~KHALI~

COPY_EXISTING ~music/mx0202.mus~ ~music/mxthief.mus~
  REPLACE_TEXTUALLY ~0202~ ~THIEF~

ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // ToB-only stuff check

  COPY_EXISTING ~music/dream2.mus~ ~music~
    REPLACE_TEXTUALLY ~DREAM~ ~COMBO~

  COPY_EXISTING ~music/mb.mus~ ~music~
    REPLACE_TEXTUALLY ~_F3 +_A2 +@TAG +_G1~ ~_F3  MB  _A2    @TAG _G1~
    BUT_ONLY_IF_IT_CHANGES

  COPY_EXISTING ~music/vb.mus~ ~music~
    REPLACE_TEXTUALLY ~_H2 +_B2 +@TAG +_I1~ ~_H2  VB    _B2        @TAG _I1~
    BUT_ONLY_IF_IT_CHANGES

END

/////                                                  \\\\\
///// immunity effects batch patches                   \\\\\
/////                                                  \\\\\

// basic idea: if you're protected from, say, confusion, confusion icon and 'confused' messages should also be suppressed

// include macros for batch processing
INCLUDE ~bg2fixpack/lib/macro_fx_batch_prep.tph~

// free action... ugh. just set up immunities, let other batches below fill in the other effects
// unlike others, generate this patch list manually--otherwise it'll turn a simple hold immunity into full-blown free aciton
COPY_EXISTING ~blun30.itm~  ~override~ // foa +5
              ~potn45.itm~  ~override~ // potion of freedom
              ~ring09.itm~  ~override~ // ring of free action
              ~sper12.itm~  ~override~ // ixil's spike +6
              ~sppr403.spl~ ~override~ // spell of free action
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_12" = 0
        SET "new_fx_15" = 0
        SET "new_fx_16" = 0
        SET "new_fx_17" = 0
        SET "new_fx_18" = 0
        SET "new_fx_19" = 0
        SET "new_fx_20" = 0
        SET "new_fx_21" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_12" = 1
        SET "new_fx_15" = 1
        SET "new_fx_16" = 1
        SET "new_fx_17" = 1
        SET "new_fx_18" = 1
        SET "new_fx_19" = 1
        SET "new_fx_20" = 1
        SET "new_fx_21" = 1
      END
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      SET "new_fx_3" = 0
      SET "new_fx_4" = 0
      SET "new_fx_5" = 0
      SET "new_fx_6" = 0
      SET "new_fx_7" = 0
      SET "new_fx_8" = 0
      SET "new_fx_9" = 0
      SET "new_fx_10" = 0
      SET "new_fx_11" = 0
      SET "new_fx_13" = 0
      SET "new_fx_14" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"

        // first, effects to delete (mainly stun immunity)
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 45)) BEGIN // stun immunity
          DELETE_BYTES ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%"))))  ((0x30 + (0xd8 * "%fx_type%")))
          SET "new_fx" = ("%new_fx%" - 1)
          SET "counter" = ("%counter%" - 1)
          SET "index2" = ("%index2%" - 1)
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 210)) BEGIN // pw stun immunity
          DELETE_BYTES ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%"))))  ((0x30 + (0xd8 * "%fx_type%")))
          SET "new_fx" = ("%new_fx%" - 1)
          SET "counter" = ("%counter%" - 1)
          SET "index2" = ("%index2%" - 1)
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 185)) BEGIN // hold creature 2 immunity (hc2 is only used for special, non-defensible holds)
          DELETE_BYTES ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%"))))  ((0x30 + (0xd8 * "%fx_type%")))
          SET "new_fx" = ("%new_fx%" - 1)
          SET "counter" = ("%counter%" - 1)
          SET "index2" = ("%index2%" - 1)
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 55)) BEGIN // prevent stun icon
          DELETE_BYTES ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%"))))  ((0x30 + (0xd8 * "%fx_type%")))
          SET "new_fx" = ("%new_fx%" - 1)
          SET "counter" = ("%counter%" - 1)
          SET "index2" = ("%index2%" - 1)
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 1280)) BEGIN // prevent stunned string 
          DELETE_BYTES ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%"))))  ((0x30 + (0xd8 * "%fx_type%")))
          SET "new_fx" = ("%new_fx%" - 1)
          SET "counter" = ("%counter%" - 1)
          SET "index2" = ("%index2%" - 1)
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14043)) BEGIN // prevent stun string
          DELETE_BYTES ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%"))))  ((0x30 + (0xd8 * "%fx_type%")))
          SET "new_fx" = ("%new_fx%" - 1)
          SET "counter" = ("%counter%" - 1)
          SET "index2" = ("%index2%" - 1)
        END ELSE

        // effects immunities
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 16)) BEGIN // haste immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 40)) BEGIN // slow immunity
          SET "new_fx_2" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 109)) BEGIN // paralyzation immunity
          SET "new_fx_3" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 126)) BEGIN // movement rate bonus immunity
          SET "new_fx_4" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 154)) BEGIN // entangle overlay immunity
          SET "new_fx_5" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 157)) BEGIN // web immunity
          SET "new_fx_6" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 158)) BEGIN // grease immunity
          SET "new_fx_7" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 175)) BEGIN // hold immunity
          SET "new_fx_8" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE

        // one-time effects, other misc effects
        PATCH_IF ("%opcode%" = 46) BEGIN // unstun
          SET "new_fx_9" = 1
        END ELSE
        PATCH_IF ("%opcode%" = 162) BEGIN // remove paralysis
          SET "new_fx_10" = 1
        END ELSE
        PATCH_IF ("%opcode%" = 163) BEGIN // free action
          SET "new_fx_11" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 142) AND ("%param2%" = 19)) BEGIN // display free action icon
          SET "new_fx_12" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 126) AND ("%param1%" = 100) AND ("%param2%" = 2)) BEGIN // set movement rate to 100%
          SET "new_fx_13" = 1
        END ELSE
        
        // spell immunities - don't like to explicitly block spells as most effects from these are already nullified
        // however, other effects due to the spells' primary effects would still get through unless whole spell blocked
        // i.e. haste spells can still make you fatigued; slow would still incur THAC0 and AC penalties, etc.
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spcl522" = 0)) BEGIN // protection from spell, defensive spin
          SET "new_fx_14" = 1
        END ELSE

        // remove portrait icons
        PATCH_IF (("%opcode%" = 240) AND ("%param2%" = 13)) BEGIN // remove held icon
          SET "new_fx_15" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 240) AND ("%param2%" = 38)) BEGIN // remove haste icon
          SET "new_fx_16" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 240) AND ("%param2%" = 41)) BEGIN // remove slow icon
          SET "new_fx_17" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 240) AND ("%param2%" = 55)) BEGIN // remove stun icon
          SET "new_fx_18" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 240) AND ("%param2%" = 129)) BEGIN // remove web icon
          SET "new_fx_19" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 240) AND ("%param2%" = 144)) BEGIN // remove entangled icon
          SET "new_fx_20" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 240) AND ("%param2%" = 145)) BEGIN // remove grease icon
          SET "new_fx_21" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" + "%new_fx_2%" + "%new_fx_3%" + "%new_fx_4%" + "%new_fx_5%" + "%new_fx_6%" + "%new_fx_7%" + "%new_fx_8%" > 0) BEGIN
        // special, this one goes at end
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + (("%abil_fx_idx%" + "%counter%") * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + (("%abil_fx_idx%" + "%counter%") * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%counter%") * (0x30 + (0xd8 * "%fx_type%")))) 126          // movement rate change immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 16           // haste immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 40           // slow immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 109          // paralyzation immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 154          // entangle immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 157          // web immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 158          // grease immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_8%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 175          // hold immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_9%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 46           // unstun
            WRITE_BYTE   ("%fx_off%" + 0x0c + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 1            // instant/permanent
            WRITE_LONG   ("%fx_off%" + 0x0e + (0x12 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0            // duration
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_10%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 162          // remove paralysis
            WRITE_BYTE   ("%fx_off%" + 0x0c + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 1            // instant/permanent
            WRITE_LONG   ("%fx_off%" + 0x0e + (0x12 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0            // duration
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_11%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 163          // free action
            WRITE_BYTE   ("%fx_off%" + 0x0c + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 1            // instant/permanent
            WRITE_LONG   ("%fx_off%" + 0x0e + (0x12 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0            // duration
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_12%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 142          // display portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 19           // free action
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_13%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 126          // set movement rate
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 100          // 100%
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 2            // set to
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_14%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spcl522~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_15%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 240          // remove portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 13           // held
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_16%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 240          // remove portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 38           // haste
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_17%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 240          // remove portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 41           // slow
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_18%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 240          // remove portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 55           // stun
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_19%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 240          // remove portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 129          // web
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_20%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 240          // remove portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 144          // entangled
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_21%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 240          // remove portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 145          // grease
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// entangle
COPY_EXISTING ~abazring.itm~ ~override~ // ring
              ~aldeth.itm~   ~override~ // ring of free action
              ~bazpatrg.itm~ ~override~ // ring
              ~beholder.itm~ ~override~ // ring
              ~blun30.itm~   ~override~ // flail of ages +5
              ~chaldt01.cre~ ~override~ // <charname>
              ~chalin01.cre~ ~override~ // <charname>
              ~chalslay.cre~ ~override~ // slayer
              ~dragring.itm~ ~override~ // ring
              ~freering.itm~ ~override~ // ring of free action
              ~fsspir.itm~   ~override~ // ring
              ~gorair01.cre~ ~override~ // lesser air elemental
              ~gorair02.cre~ ~override~ // greater air elemental
              ~gorchr.itm~   ~override~ // ring
              ~gormistp.cre~ ~override~ // poison mist
              ~gorstalk.cre~ ~override~ // guardian of air
              ~holdring.itm~ ~override~ // ring
              ~invulner.itm~ ~override~ // ring
              ~jwsuper.itm~  ~override~ // ring of free action
              ~mage05.itm~   ~override~ // ring of free action
              ~mistpo01.cre~ ~override~ // poison mist
              ~npplat.itm~   ~override~ // firecam full-plate armor
              ~objring.itm~  ~override~ // ring
              ~palring.itm~  ~override~ // ring
              ~potn45.itm~   ~override~ // potion of freedom
              ~ring09.itm~   ~override~ // ring of free action
              ~ring97.itm~   ~override~ // ring
              ~rossring.itm~ ~override~ // ring of free action
              ~shalt01.itm~  ~override~ // ring
              ~spcl415.spl~  ~override~ // <invalid strref -1>
              ~sper12.itm~   ~override~ // ixil's spike +6
              ~spin853.spl~  ~override~ // otiluke's resilient sphere
              ~sppr403.spl~  ~override~ // free action
              ~spwi853.spl~  ~override~ // otiluke's resilient sphere
              ~surehp1.itm~  ~override~ // ring
              ~sw2h06.itm~   ~override~ // spider's bane
              ~sw2h13.itm~   ~override~ // spider's bane
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_2" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_2" = 1
      END
      SET "new_fx_1" = 0
      SET "new_fx_3" = 0
      SET "new_fx_4" = 0
      SET "new_fx_5" = 0
      SET "new_fx_6" = 0
      SET "new_fx_7" = 0
      SET "new_fx_8" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 154)) BEGIN // entangle overlay immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 144)) BEGIN // prevent entangled icon
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spin688" = 0)) BEGIN // protection from spell, plant growth
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "sppr105" = 0)) BEGIN // protection from spell, entangle
          SET "new_fx_4" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spwm111" = 0)) BEGIN // protection from spell, plant growth
          SET "new_fx_5" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "cdhgnya1" = 0)) BEGIN // protection from spell, nyalee
          SET "new_fx_6" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "cdmound" = 0)) BEGIN // protection from spell, shambling mound
          SET "new_fx_7" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "cdsw1h58" = 0)) BEGIN // protection from spell, ss of mask
          SET "new_fx_8" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 144          // entangled
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spin688~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr105~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwm111~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~cdhgnya1~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~cdmound~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_8%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~cdsw1h58~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// grease
COPY_EXISTING ~blun30.itm~   ~override~ // flail of ages +5
              ~jwsuper.itm~  ~override~ // ring of free action
              ~potn45.itm~   ~override~ // potion of freedom
              ~ring09.itm~   ~override~ // ring of free action
              ~rossring.itm~ ~override~ // ring of free action
              ~spcl415.spl~  ~override~ // <invalid strref -1>
              ~sper12.itm~   ~override~ // ixil's spike +6
              ~spin853.spl~  ~override~ // otiluke's resilient sphere
              ~spwi853.spl~  ~override~ // otiluke's resilient sphere
              ~sw2h06.itm~   ~override~ // spider's bane
              ~sw2h13.itm~   ~override~ // spider's bane
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_2" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_2" = 1
      END
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 158)) BEGIN // grease immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 145)) BEGIN // prevent grease icon
          SET "new_fx_2" = 1
        END 
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 145          // grease
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// slow
COPY_EXISTING ~aldeth.itm~   ~override~ // ring of free action
              ~ammgrd01.cre~ ~override~ // monk
              ~ammgrd02.cre~ ~override~ // monk
              ~ammgrd03.cre~ ~override~ // monk
              ~ammgrd04.cre~ ~override~ // guard captain
              ~ammgrd05.cre~ ~override~ // monk
              ~ammlegs.cre~  ~override~ // monk
              ~ammonk01.cre~ ~override~ // monk
              ~ammonk02.cre~ ~override~ // monk
              ~ammonk04.cre~ ~override~ // monk
              ~ammonk05.cre~ ~override~ // monk
              ~ammonk06.cre~ ~override~ // monk
              ~balelite.cre~ ~override~ // monk
              ~balth.cre~    ~override~ // balthazar
              ~bazmonk.cre~  ~override~ // monk
              ~bazpatrg.itm~ ~override~ // ring
              ~beholder.itm~ ~override~ // ring
              ~blun30.itm~   ~override~ // flail of ages +5
              ~cutamgrd.cre~ ~override~ // monk
              ~cutbalth.cre~ ~override~ // balthazar
              ~dragring.itm~ ~override~ // ring
              ~freering.itm~ ~override~ // ring of free action
              ~fsdragon.cre~ ~override~ // dragon
              ~fsspir.itm~   ~override~ // ring
              ~golstone.itm~ ~override~ // ring
              ~gorchr.itm~   ~override~ // ring
              ~holdring.itm~ ~override~ // ring
              ~invulner.itm~ ~override~ // ring
              ~jwsuper.itm~  ~override~ // ring of free action
              ~killmonk.cre~ ~override~ // monk
              ~killsw01.itm~ ~override~ // long sword +2
              ~kuoring.itm~  ~override~ // <invalid strref -1>
              ~mage05.itm~   ~override~ // ring of free action
              ~npplat.itm~   ~override~ // firecam full-plate armor
              ~npsw01.itm~   ~override~ // sword of arvoreen
              ~potn45.itm~   ~override~ // potion of freedom
              ~ring09.itm~   ~override~ // ring of free action
              ~ring97.itm~   ~override~ // ring
              ~rossring.itm~ ~override~ // ring of free action
              ~senmonk.cre~  ~override~ // master bennon
              ~spcl814.spl~  ~override~ // <invalid strref -1>
              ~sper12.itm~   ~override~ // ixil's spike +6
              ~sppr403.spl~  ~override~ // free action
              ~surehp1.itm~  ~override~ // ring
              ~sw2h06.itm~   ~override~ // spider's bane
              ~sw2h13.itm~   ~override~ // spider's bane
              ~tobpar03.cre~ ~override~ // long po
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_2" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_2" = 1
      END
      SET "new_fx_1" = 0
      SET "new_fx_3" = 0
      SET "new_fx_4" = 0
      SET "new_fx_5" = 0
      SET "new_fx_6" = 0
      SET "new_fx_7" = 0
      SET "new_fx_8" = 0
      SET "new_fx_9" = 0
      SET "new_fx_10" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"

        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 40)) BEGIN // slow immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 41)) BEGIN // prevent slow icon
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spwm164" = 0)) BEGIN // protection from spell, slow
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spin977" = 0)) BEGIN // protection from spell, slow
          SET "new_fx_4" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spin983" = 0)) BEGIN // protection from spell, slow
          SET "new_fx_5" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spwish25" = 0)) BEGIN // protection from spell, slow
          SET "new_fx_6" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spwi312" = 0)) BEGIN // protection from spell, slow
          SET "new_fx_7" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spin575" = 0)) BEGIN // protection from spell, slow
          SET "new_fx_8" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14000)) BEGIN // disable string "slow"
          SET "new_fx_9" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14668)) BEGIN // disable string "slowed"
          SET "new_fx_10" = 1
        END

      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 41           // slow
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwm164~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spin977~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spin983~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwish25~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi312~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_8%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spin575~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_10%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14000        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_10%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14668        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// confusion
COPY_EXISTING ~abazring.itm~ ~override~ // ring
              ~ammonk07.cre~ ~override~ // monk
              ~ammonk08.cre~ ~override~ // monk
              ~amul17.itm~   ~override~ // greenstone amulet
              ~chalcy3.itm~  ~override~ // greenstone amulet
              ~chalslay.itm~ ~override~ // ring
              ~chwraith.itm~ ~override~ // <invalid strref -1>
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~devaevil.cre~ ~override~ // fallen deva
              ~devagood.cre~ ~override~ // deva
              ~devast01.cre~ ~override~ // astral deva
              ~devmon01.cre~ ~override~ // monadic deva
              ~elearb11.cre~ ~override~ // apparition
              ~fangel01.cre~ ~override~ // einhiris
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~finsol01.cre~ ~override~ // solar
              ~finsol04.cre~ ~override~ // fallen solar
              ~firlch01.cre~ ~override~ // fire lich
              ~gorfirg.itm~  ~override~ // ring
              ~gorjelfu.itm~ ~override~ // ring
              ~gorjelgr.itm~ ~override~ // ring
              ~gormisti.itm~ ~override~ // ring
              ~helljon.cre~  ~override~ // jon irenicus
              ~helljon2.cre~ ~override~ // jon irenicus
              ~hllich.cre~   ~override~ // elemental lich
              ~hlshade.cre~  ~override~ // shade lich
              ~innoc.itm~    ~override~ // ring
              ~ipsion.itm~   ~override~ // greenstone amulet
              ~killsw01.itm~ ~override~ // long sword +2
              ~leat20.itm~   ~override~ // aeger's hide +3
              ~lichel01.cre~ ~override~ // elemental lich
              ~mage20.cre~   ~override~ // mage
              ~mage20b.cre~  ~override~ // mage
              ~mage20c.cre~  ~override~ // mage
              ~maharper.itm~ ~override~ // master harper item
              ~mane01.itm~   ~override~ // ring
              ~mdk2gun.itm~  ~override~ // big gun
              ~mdk2ring.itm~ ~override~ // big gun
              ~objring.itm~  ~override~ // ring
              ~palring.itm~  ~override~ // ring
              ~planet01.cre~ ~override~ // planetar
              ~planevil.cre~ ~override~ // fallen planetar
              ~plangood.cre~ ~override~ // planetar
              ~planwish.cre~ ~override~ // fallen planetar
              ~potn21.itm~   ~override~ // potion of clarity
              ~ppguy01.cre~  ~override~ // <invalid strref -1>
              ~ppireni2.cre~ ~override~ // jon irenicus
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~ring94.itm~   ~override~ // ring
              ~ring95.itm~   ~override~ // ring
              ~ring98.itm~   ~override~ // ring
              ~ring99.itm~   ~override~ // ring
              ~ringdemn.itm~ ~override~ // <invalid strref -1>
              ~ringkora.itm~ ~override~ // ring
              ~sendai7.cre~  ~override~ // sendai
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~sewyag04.cre~ ~override~ // yaga-shura mage
              ~shalt01.itm~  ~override~ // ring
              ~shararm.itm~  ~override~ // darkmail +3
              ~shld25.itm~   ~override~ // shield of harmony +2
              ~solar.cre~    ~override~ // solar
              ~solar01.cre~  ~override~ // solar
              ~spcl152.spl~  ~override~ // barbarian rage
              ~spcl321.spl~  ~override~ // enrage
              ~spcl542a.spl~ ~override~ // <invalid strref -1>
              ~spcl920a.spl~ ~override~ // <invalid strref -1>
              ~spin117.spl~  ~override~ // berserk
              ~spin632.spl~  ~override~ // emperor
              ~spin783.spl~  ~override~ // slayer change
              ~spin823.spl~  ~override~ // slayer change
              ~spin852.spl~  ~override~ // slayer change
              ~spin872.spl~  ~override~ // <invalid strref -1>
              ~spin906.spl~  ~override~ // <invalid strref -1>
              ~sppr508.spl~  ~override~ // chaotic commands
              ~stalker.itm~  ~override~ // ring
              ~sujon.cre~    ~override~ // jon irenicus
              ~sujon2.cre~   ~override~ // jon irenicus
              ~suraam.cre~   ~override~ // raamilat
              ~susuneer.cre~ ~override~ // suneer
              ~sw1h54.itm~   ~override~ // the equalizer
              ~sw2h14.itm~   ~override~ // lilarcor
              ~sw2h21.itm~   ~override~ // psion's blade +5
              ~sword01.cre~  ~override~ // magical sword
              ~telslav2.itm~ ~override~ // <invalid strref -1>
              ~trollimm.itm~ ~override~ // ring
              ~tstatue.itm~  ~override~ // <invalid strref -1>
              ~uddrow50.cre~ ~override~ // drow wizard
              ~udsola01.cre~ ~override~ // solaufein
              ~umber01.itm~  ~override~ // attack
              ~umber02.itm~  ~override~ // attack
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_2" = 0
        SET "new_fx_3" = 0
        SET "new_fx_4" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_2" = 1
        SET "new_fx_3" = 1
        SET "new_fx_4" = 1
      END
      SET "new_fx_1" = 0
      SET "new_fx_5" = 0
      SET "new_fx_6" = 0
      SET "new_fx_7" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 128)) BEGIN // confusion immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 2)) BEGIN // prevent rigid thinking icon
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 3)) BEGIN // prevent confused icon
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 47)) BEGIN // prevent chaos icon
          SET "new_fx_4" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14782)) BEGIN // disable string "confused"
          SET "new_fx_5" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14791)) BEGIN // disable string "Rigid Thinking"
          SET "new_fx_6" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 296) AND ("%resref%" STRING_COMPARE_CASE "spconfus" = 0)) BEGIN // confusion visuals
          SET "new_fx_7" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 2            // rigid thinking
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 3            // confused
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 47           // chaos
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14782        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14791        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 296          // prevent specific animation
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spconfus~   // confusion animation
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// level drain
COPY_EXISTING ~abazring.itm~ ~override~ // ring
              ~balth02.spl~  ~override~ // lunar stance!
              ~bazpatrg.itm~ ~override~ // ring
              ~bhaal3a.spl~  ~override~ // <invalid strref -1>
              ~bhaalhp1.itm~ ~override~ // <invalid strref -1>
              ~bhaalimm.itm~ ~override~ // <invalid strref -1>
              ~blun25.itm~   ~override~ // mace of disruption +2
              ~chalslay.itm~ ~override~ // ring
              ~chwraith.itm~ ~override~ // <invalid strref -1>
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~deva.itm~     ~override~ // mace of disruption +2
              ~devaevil.cre~ ~override~ // fallen deva
              ~devagood.cre~ ~override~ // deva
              ~devast01.cre~ ~override~ // astral deva
              ~devmon01.cre~ ~override~ // monadic deva
              ~famcat25.cre~ ~override~ // cat
              ~famdus25.cre~ ~override~ // dust mephit
              ~famfai25.cre~ ~override~ // fairy dragon
              ~famfer25.cre~ ~override~ // ferret
              ~famimp25.cre~ ~override~ // imp
              ~fampsd25.cre~ ~override~ // pseudo dragon
              ~famqua25.cre~ ~override~ // quasit
              ~famrab25.cre~ ~override~ // rabbit
              ~fangel01.cre~ ~override~ // einhiris
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~finsol01.cre~ ~override~ // solar
              ~finsol04.cre~ ~override~ // fallen solar
              ~fsspir.itm~   ~override~ // ring
              ~gorchr.itm~   ~override~ // ring
              ~gorfirg.itm~  ~override~ // ring
              ~gorjelfu.itm~ ~override~ // ring
              ~gorjelgr.itm~ ~override~ // ring
              ~gormisti.itm~ ~override~ // ring
              ~hamm10.itm~   ~override~ // runehammer +4
              ~hamm11.itm~   ~override~ // runehammer +5
              ~holdring.itm~ ~override~ // ring
              ~immcloud.itm~ ~override~ // <invalid strref -1>
              ~imoenhp1.itm~ ~override~ // imoen's belt
              ~innoc.itm~    ~override~ // ring
              ~invulner.itm~ ~override~ // ring
              ~jonhp1.itm~   ~override~ // <invalid strref -1>
              ~jwsuper.itm~  ~override~ // ring of free action
              ~killsw01.itm~ ~override~ // long sword +2
              ~mel01.itm~    ~override~ // imoen's belt
              ~objring.itm~  ~override~ // ring
              ~palring.itm~  ~override~ // ring
              ~planet01.cre~ ~override~ // planetar
              ~planevil.cre~ ~override~ // fallen planetar
              ~plangood.cre~ ~override~ // planetar
              ~planwish.cre~ ~override~ // fallen planetar
              ~ppguy01.cre~  ~override~ // <invalid strref -1>
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~ring94.itm~   ~override~ // ring
              ~ring95.itm~   ~override~ // ring
              ~ring97.itm~   ~override~ // ring
              ~ring98.itm~   ~override~ // ring
              ~ring99.itm~   ~override~ // ring
              ~rossring.itm~ ~override~ // ring of free action
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~shalt01.itm~  ~override~ // ring
              ~solar.cre~    ~override~ // solar
              ~solar01.cre~  ~override~ // solar
              ~spcl152.spl~  ~override~ // barbarian rage
              ~spcl242.spl~  ~override~ // <invalid strref -1>
              ~spcl321.spl~  ~override~ // enrage
              ~spcl415.spl~  ~override~ // <invalid strref -1>
              ~spcl741.spl~  ~override~ // boon of lathander
              ~spcl917.spl~  ~override~ // avoid death
              ~spin117.spl~  ~override~ // berserk
              ~spin783.spl~  ~override~ // slayer change
              ~spin852.spl~  ~override~ // slayer change
              ~spin853.spl~  ~override~ // otiluke's resilient sphere
              ~sppr413.spl~  ~override~ // negative plane protection
              ~spwi853.spl~  ~override~ // otiluke's resilient sphere
              ~stalker.itm~  ~override~ // ring
              ~surehp1.itm~  ~override~ // ring
              ~sw1h61.itm~   ~override~ // angurvadal +5
              ~sw1h69.itm~   ~override~ // spectral brand +5
              ~telslav2.itm~ ~override~ // <invalid strref -1>
              ~tstatue.itm~  ~override~ // <invalid strref -1>
              ~vampreg1.itm~ ~override~ // ring
              ~vampreg2.itm~ ~override~ // ring
              ~vvarkan.cre~  ~override~ // arkanis gath
              ~vvcat.cre~    ~override~ // shadow thief
              ~vvryokoi.cre~ ~override~ // ryokoi
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_2" = 0
        SET "new_fx_3" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_2" = 1
        PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "imoenhp1" = 0) BEGIN
          SET "new_fx_3" = 0
        END ELSE BEGIN
          SET "new_fx_3" = 1
        END
      END
      SET "new_fx_1" = 0
      SET "new_fx_4" = 0
      SET "new_fx_5" = 0
      SET "new_fx_6" = 0
      SET "new_fx_7" = 0
      SET "new_fx_8" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 216)) BEGIN // level drain immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 142) AND ("%param2%" = 90)) BEGIN // display npp icon
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 59)) BEGIN // prevent level drain icon
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 41495)) BEGIN // disable string "one level drained"
          SET "new_fx_4" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 40968)) BEGIN // disable string "two levels drained"
          SET "new_fx_5" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 40969)) BEGIN // disable string "three levels drained"
          SET "new_fx_6" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 40979)) BEGIN // disable string "four levels drained"
          SET "new_fx_7" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 41616)) BEGIN // disable string "five levels drained"
          SET "new_fx_8" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 142          // display portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 90           // npp
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 59           // level drain
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 41495        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 40968        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 40969        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 40979        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_8%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 41616        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// hold
COPY_EXISTING ~aldeth.itm~   ~override~ // ring of free action
              ~amul17.itm~   ~override~ // greenstone amulet
              ~antiweb.itm~  ~override~ // <invalid strref -1>
              ~beholder.itm~ ~override~ // ring
              ~bhaalhp1.itm~ ~override~ // <invalid strref -1>
              ~bhaalimm.itm~ ~override~ // <invalid strref -1>
              ~blun30.itm~   ~override~ // flail of ages +5
              ~chalcy3.itm~  ~override~ // greenstone amulet
              ~chalslay.itm~ ~override~ // ring
              ~chwraith.itm~ ~override~ // <invalid strref -1>
              ~demglab.cre~  ~override~ // glabrezu
              ~demglab2.cre~ ~override~ // glabrezu
              ~demglasu.cre~ ~override~ // glabrezu
              ~demilich.itm~ ~override~ // ring
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~dragring.itm~ ~override~ // ring
              ~elemhydr.cre~ ~override~ // olhydra
              ~elemimix.cre~ ~override~ // imix
              ~elemogre.cre~ ~override~ // ogremoch
              ~elemsunn.cre~ ~override~ // sunnis
              ~elemzaam.cre~ ~override~ // zaaman rul
              ~enddem01.cre~ ~override~ // glabrezu
              ~enddem02.cre~ ~override~ // glabrezu
              ~enddem03.cre~ ~override~ // balor
              ~enddem04.cre~ ~override~ // nabassu
              ~enddem05.cre~ ~override~ // nabassu
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~finsol04.cre~ ~override~ // fallen solar
              ~freering.itm~ ~override~ // ring of free action
              ~golbra.itm~   ~override~ // brain golem item
              ~golcla.itm~   ~override~ // clay golem item
              ~golfle.itm~   ~override~ // flesh golem item
              ~golmag01.itm~ ~override~ // magic golem item
              ~golstone.itm~ ~override~ // stone golem item
              ~gorfirg.itm~  ~override~ // ring
              ~gorjelfu.itm~ ~override~ // ring
              ~gorjelgr.itm~ ~override~ // ring
              ~gormisti.itm~ ~override~ // ring
              ~icbone01.cre~ ~override~ // bone golem
              ~immchs.itm~   ~override~ // <invalid strref -1>
              ~imoenhp1.itm~ ~override~ // imoen's belt
              ~innoc.itm~    ~override~ // ring
              ~ipsion.itm~   ~override~ // greenstone amulet
              ~irongol.itm~  ~override~ // iron golem item
              ~jondem01.cre~ ~override~ // glabrezu
              ~jondem02.cre~ ~override~ // balor
              ~jondem03.cre~ ~override~ // glabrezu
              ~jondem04.cre~ ~override~ // balor
              ~jondem05.cre~ ~override~ // glabrezu
              ~jwsuper.itm~  ~override~ // ring of free action
              ~killsw01.itm~ ~override~ // long sword +2
              ~kuoring.itm~  ~override~ // <invalid strref -1>
              ~lich.itm~     ~override~ // ring
              ~mage05.itm~   ~override~ // ring of free action
              ~magiweb.itm~  ~override~ // <invalid strref -1>
              ~mel01.itm~    ~override~ // imoen's belt
              ~mindva01.cre~ ~override~ // vampiric illithid
              ~mindvam.cre~  ~override~ // vampiric illithid
              ~minhp1.itm~   ~override~ // <invalid strref -1>
              ~npplat.itm~   ~override~ // firecam full-plate armor
              ~objring.itm~  ~override~ // ring
              ~palring.itm~  ~override~ // ring
              ~plytroll.itm~ ~override~ // attack
              ~potn45.itm~  ~override~ // potion of freedom
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~ring09.itm~   ~override~ // ring of free action
              ~ring94.itm~   ~override~ // ring
              ~ring95.itm~   ~override~ // ring
              ~ring97.itm~   ~override~ // ring
              ~ring98.itm~   ~override~ // ring
              ~ring99.itm~   ~override~ // ring
              ~ringkora.itm~ ~override~ // ring
              ~rossring.itm~ ~override~ // ring of free action
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~shalt01.itm~  ~override~ // ring
              ~shld25.itm~   ~override~ // shield of harmony +2
              ~spcl152.spl~  ~override~ // barbarian rage
              ~spcl233b.spl~ ~override~ // <invalid strref -1>
              ~spcl242.spl~  ~override~ // <invalid strref -1>
              ~spcl321.spl~  ~override~ // enrage
              ~sper07.itm~   ~override~ // spear of the unicorn +2
              ~sper12.itm~   ~override~ // ixil's spike +6
              ~spin117.spl~  ~override~ // berserk
              ~spin872.spl~  ~override~ // <invalid strref -1>
              ~spin906.spl~  ~override~ // <invalid strref -1>
              ~sppr403.spl~  ~override~ // free action
              ~sppr508.spl~  ~override~ // chaotic commands
              ~stalker.itm~  ~override~ // ring
              ~surehp1.itm~  ~override~ // ring
              ~sw1h27.itm~   ~override~ // arbane's sword +2
              ~sw2h06.itm~   ~override~ // spider's bane
              ~sw2h13.itm~   ~override~ // spider's bane
              ~sword01.cre~  ~override~ // magical sword
              ~telslav2.itm~ ~override~ // <invalid strref -1>
              ~torgal.cre~   ~override~ // torgal
              ~torgal2.cre~  ~override~ // torgal
              ~torgal3.cre~  ~override~ // torgal
              ~trollall.itm~ ~override~ // attack
              ~trollimm.itm~ ~override~ // ring
              ~udvamp.cre~   ~override~ // vampiric illithid
              ~vampreg.itm~  ~override~ // ring
              ~vampreg1.itm~ ~override~ // ring
              ~vampreg2.itm~ ~override~ // ring
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF (("%cosmetic%" = 1) OR ("%SOURCE_RES%" STRING_COMPARE_CASE "imoenhp1" = 0)) BEGIN // if cosmetic effects needed
        SET "new_fx_4" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_4" = 1
      END
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      SET "new_fx_3" = 0
      SET "new_fx_5" = 0
      SET "new_fx_6" = 0
      SET "new_fx_7" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 109)) BEGIN // hold immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE

        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 175)) BEGIN // hold creature type immunity
          SET "new_fx_2" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE

        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 185)) BEGIN // hold creature 2 immunity
          SET "new_fx_3" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 13)) BEGIN // prevent hold icon
          SET "new_fx_4" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14102)) BEGIN // disable string "held"
          SET "new_fx_5" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 296) AND ("%resref%" STRING_COMPARE_CASE "spmindat" = 0)) BEGIN // disable held animation
          SET "new_fx_6" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 296) AND ("%resref%" STRING_COMPARE_CASE "spflayer" = 0)) BEGIN // disable held animation
          SET "new_fx_7" = 1
        END
      END
      PATCH_IF (("%new_fx_1%" = 1) OR ("%new_fx_2%" = 1) OR ("%new_fx_3%" = 1)) BEGIN
        PATCH_IF ("%new_fx_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 109          // hold immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 175          // hold creature type immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 13           // hold icon
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14102        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 296          // prevent specific animation
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spmindat~   // confusion animation
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 296          // prevent specific animation
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spflayer~   // confusion animation
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES
// fear (also add immunity to new cdhorror.vvc)
ACTION_FOR_EACH file IN abazring.itm ammonk07.cre ammonk08.cre amsmith.cre amul17.itm
  balth.cre bazdra02.cre bazpatrg.itm bhaalhp1.itm bhaalimm.itm brdflute.itm chalcy3.itm
  chalslay.itm chwraith.itm clck30.itm ddguard1.cre ddguard2.cre ddguard3.cre ddguard4.cre
  ddguard5.cre ddguard6.cre ddguard7.cre demogorg.itm elemhydr.cre finmel01.itm 
  firlch01.cre fsspir.itm golbra.itm golbra01.cre golcla.itm golfle.itm golmag01.itm
  golstone.itm gorair01.cre gorair02.cre gorcamb6.cre gorcamb7.cre gorchr.itm gorfirg.itm
  gorjelfu.itm gorjelgr.itm gormisti.itm gormistp.cre gorstalk.cre hamm11.itm helljon.cre
  helljon2.cre helm14.itm hgber01.itm hgfel01.cre hllich.cre hlshade.cre holdring.itm
  igolem01.cre imoenhp1.itm innoc.itm invulner.itm ipsion.itm irongol.itm jonhp1.itm
  kaypal02.cre kaypal03.cre kaysmg01.cre kaysmg02.cre kaysmg03.cre killsw01.itm
  lichel01.cre mage20.cre mage20b.cre mage20c.cre maharper.itm mane01.itm mdk2gun.itm
  mdk2ring.itm mdog1.itm mel01.itm minhp1.itm miscbc.itm mistpo01.cre nofear.itm
  objring.itm palring.itm potn21.itm ppireni2.cre ravag03.itm ring94.itm ring95.itm
  ring98.itm ring99.itm ringdemn.itm ringkora.itm sarvie01.cre sendai7.cre sengua04.itm
  sewyag04.cre shalt01.itm shararm.itm spcl152.spl spcl221.spl spcl222.spl spcl321.spl
  spcl542a.spl spcl920a.spl spcl921a.spl spec01.itm spec02.itm spin117.spl spin676.spl
  spin823.spl spin872.spl spin891.spl spin906.spl sppr108.spl spwi210.spl spwi411.spl
  stalker.itm sujon.cre sujon2.cre suraam.cre surehp1.itm susuneer.cre sw1h32.itm
  sword01.cre telslav2.itm torgal.cre torgal2.cre torgal3.cre trollimm.itm tstatue.itm
  uddrow50.cre udgolem.cre udlesa.cre vampreg.itm vampreg1.itm vampreg2.itm BEGIN

  ACTION_IF FILE_EXISTS_IN_GAME ~%file%~ BEGIN

    COPY_EXISTING ~%file%~ ~override~
      LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
      PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
        SET "new_fx" = 0
        FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
          PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
            SET "new_fx_9" = 0
            SET "new_fx_10" = 0
            SET "new_fx_11" = 0
          END ELSE BEGIN // if no cosmetic effects should be added
            SET "new_fx_11" = 1
            PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "imoenhp1" = 0) BEGIN
              SET "new_fx_9" = 0
              SET "new_fx_10" = 0
            END ELSE BEGIN
              SET "new_fx_9" = 1
              SET "new_fx_10" = 1
            END
          END
          SET "new_fx_1" = 0
          SET "new_fx_2" = 0
          SET "new_fx_3" = 0
          SET "new_fx_4" = 0
          SET "new_fx_5" = 0
          SET "new_fx_6" = 0
          SET "new_fx_7" = 0
          SET "new_fx_8" = 0
          SET "new_fx_12" = 0
          PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
            SET "abil_fx_idx" = 0
          END ELSE BEGIN // otherwise normal ability
            SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
            READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
            SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
            WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
          END
          READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
          FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
            READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
            READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
            READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
            READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
            PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 23)) BEGIN // morale modifer immunity
              SET "new_fx_1" = 1
              READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
            END ELSE
            PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 24)) BEGIN // horror immunity
              SET "new_fx_2" = 1
              READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
            END ELSE
            PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 106)) BEGIN // morale break modifier immunity
              SET "new_fx_3" = 1
              READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
            END ELSE
            PATCH_IF ("%opcode%" = 23) BEGIN // morale
              SET "new_fx_4" = 1
            END ELSE
            PATCH_IF ("%opcode%" = 161) BEGIN // cure horror
              SET "new_fx_5" = 1
            END ELSE
            PATCH_IF (("%opcode%" = 106) AND ("%param2%" = 1)) BEGIN // morale break modifier
              SET "new_fx_6" = 1
            END ELSE
            PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14007)) BEGIN // disable string "panic"
              SET "new_fx_7" = 1
            END ELSE
            PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 17427)) BEGIN // disable string "panic"
              SET "new_fx_8" = 1
            END ELSE
            PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 36)) BEGIN // prevent panic icon
              SET "new_fx_9" = 1
            END ELSE
            PATCH_IF (("%opcode%" = 240) AND ("%param2%" = 36)) BEGIN // remove panic icon
              SET "new_fx_10" = 1
            END ELSE
            PATCH_IF (("%opcode%" = 142) AND ("%param2%" = 37)) BEGIN // display resist fear icon
              SET "new_fx_11" = 1
            END
            PATCH_IF (("%opcode%" = 296) AND ("%resref%" STRING_COMPARE_CASE "cdhorror" = 0)) BEGIN // horror visuals
              SET "new_fx_12" = 1
            END
          END
          PATCH_IF (("%new_fx_1%" = 1) OR ("%new_fx_2%" = 1) OR ("%new_fx_3%" = 1)) BEGIN
            // put three immunities at end of effects, others first so immunities don't prevent other new/ existing effects
            PATCH_IF ("%new_fx_1%" = 0) BEGIN
              INSERT_BYTES   ("%fx_off%"                               + (("%counter%" + "%abil_fx_idx%") * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
                WRITE_ASCIIE ("%fx_off%"                               + (("%counter%" + "%abil_fx_idx%") * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
                WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%counter%" + "%abil_fx_idx%") * (0x30 + (0xd8 * "%fx_type%")))) 23           // modify morale imunity
              SET "new_fx" = ("%new_fx%" + 1)
              SET "counter" = ("%counter%" + 1)
            END
            PATCH_IF ("%new_fx_2%" = 0) BEGIN
              INSERT_BYTES   ("%fx_off%"                               + (("%counter%" + "%abil_fx_idx%") * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
                WRITE_ASCIIE ("%fx_off%"                               + (("%counter%" + "%abil_fx_idx%") * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
                WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%counter%" + "%abil_fx_idx%") * (0x30 + (0xd8 * "%fx_type%")))) 24           // panic imunity
              SET "new_fx" = ("%new_fx%" + 1)
              SET "counter" = ("%counter%" + 1)
            END
            PATCH_IF ("%new_fx_3%" = 0) BEGIN
              INSERT_BYTES   ("%fx_off%"                               + (("%counter%" + "%abil_fx_idx%") * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
                WRITE_ASCIIE ("%fx_off%"                               + (("%counter%" + "%abil_fx_idx%") * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
                WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%counter%" + "%abil_fx_idx%") * (0x30 + (0xd8 * "%fx_type%")))) 106          // morale break modifier immunity
              SET "new_fx" = ("%new_fx%" + 1)
              SET "counter" = ("%counter%" + 1)
            END
            PATCH_IF ("%new_fx_4%" = 0) BEGIN
              INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
                WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
                WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 23           // modify morale
                WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0            // param1
                WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0            // param2
              SET "new_fx" = ("%new_fx%" + 1)
              SET "counter" = ("%counter%" + 1)
            END
            PATCH_IF ("%new_fx_5%" = 0) BEGIN
              INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
                WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
                WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 161          // cure horror
                WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0            // param1
                WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0            // param2
              SET "new_fx" = ("%new_fx%" + 1)
              SET "counter" = ("%counter%" + 1)
            END
            PATCH_IF ("%new_fx_6%" = 0) BEGIN
              INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
                WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
                WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 106          // morale break
                WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 1            // param1
                WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 1            // param2
              SET "new_fx" = ("%new_fx%" + 1)
              SET "counter" = ("%counter%" + 1)
            END
            PATCH_IF ("%new_fx_7%" = 0) BEGIN
              INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
                WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
                WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
                WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14007        // strref
              SET "new_fx" = ("%new_fx%" + 1)
              SET "counter" = ("%counter%" + 1)
            END
            PATCH_IF ("%new_fx_8%" = 0) BEGIN
              INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
                WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
                WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
                WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 17427        // strref
              SET "new_fx" = ("%new_fx%" + 1)
              SET "counter" = ("%counter%" + 1)
            END
            PATCH_IF ("%new_fx_9%" = 0) BEGIN
              INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
                WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
                WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
                WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 36           // panic icon
              SET "new_fx" = ("%new_fx%" + 1)
              SET "counter" = ("%counter%" + 1)
            END
            PATCH_IF ("%new_fx_10%" = 0) BEGIN
              INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
                WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
                WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 240          // remove portrait icon
                WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 36           // panic icon
              SET "new_fx" = ("%new_fx%" + 1)
              SET "counter" = ("%counter%" + 1)
            END
            PATCH_IF ("%new_fx_11%" = 0) BEGIN
              INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
                WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
                WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 142          // display portrait icon
                WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 37           // resist fear icon
              SET "new_fx" = ("%new_fx%" + 1)
              SET "counter" = ("%counter%" + 1)
            END
            PATCH_IF ("%new_fx_12%" = 0) BEGIN
              INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
                WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
                WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 296          // prevent specific animation
                WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~cdhorror~   // confusion animation
              SET "new_fx" = ("%new_fx%" + 1)
              SET "counter" = ("%counter%" + 1)
            END
          END
          WRITE_SHORT "%counter_offset%" "%counter%"
        END
        LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
      END
      BUT_ONLY_IF_IT_CHANGES
      
  END

END

// charm
COPY_EXISTING ~ammgrd01.cre~ ~override~ // monk
              ~ammgrd02.cre~ ~override~ // monk
              ~ammgrd03.cre~ ~override~ // monk
              ~ammgrd04.cre~ ~override~ // guard captain
              ~ammgrd05.cre~ ~override~ // monk
              ~ammlegs.cre~  ~override~ // monk
              ~ammonk01.cre~ ~override~ // monk
              ~ammonk02.cre~ ~override~ // monk
              ~ammonk04.cre~ ~override~ // monk
              ~ammonk05.cre~ ~override~ // monk
              ~ammonk06.cre~ ~override~ // monk
              ~ammonk07.cre~ ~override~ // monk
              ~ammonk08.cre~ ~override~ // monk
              ~amul17.itm~   ~override~ // greenstone amulet
              ~balelite.cre~ ~override~ // monk
              ~balth.cre~    ~override~ // balthazar
              ~bazmonk.cre~  ~override~ // monk
              ~bhaalhp1.itm~ ~override~ // <invalid strref -1>
              ~bhaalimm.itm~ ~override~ // <invalid strref -1>
              ~c6guen.cre~   ~override~ // guenhwyvar
              ~chalcy3.itm~  ~override~ // greenstone amulet
              ~chalslay.itm~ ~override~ // ring
              ~chevil02.cre~ ~override~ // doppleganger
              ~chevil06.cre~ ~override~ // drow warrior
              ~chevil07.cre~ ~override~ // drow priestess
              ~chgood04.cre~ ~override~ // elven warrior
              ~chgood05.cre~ ~override~ // elven warrior
              ~chgood09.cre~ ~override~ // ellesime
              ~chwraith.itm~ ~override~ // <invalid strref -1>
              ~cuphaer.cre~  ~override~ // phaere
              ~cutamgrd.cre~ ~override~ // monk
              ~cutbalth.cre~ ~override~ // balthazar
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~devaevil.cre~ ~override~ // fallen deva
              ~devagood.cre~ ~override~ // deva
              ~devast01.cre~ ~override~ // astral deva
              ~devmon01.cre~ ~override~ // monadic deva
              ~dragring.itm~ ~override~ // ring
              ~drow05.cre~   ~override~ // drow
              ~fangel01.cre~ ~override~ // einhiris
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~finsol01.cre~ ~override~ // solar
              ~finsol04.cre~ ~override~ // fallen solar
              ~golbra01.cre~ ~override~ // brain golem
              ~golbra.itm~   ~override~ // brain golem item
              ~golcla.itm~   ~override~ // clay golem item
              ~golfle.itm~   ~override~ // flesh golem item
              ~golmag01.itm~ ~override~ // magic golem item
              ~golstone.itm~ ~override~ // stone golem item
              ~gorair01.cre~ ~override~ // lesser air elemental
              ~gorair02.cre~ ~override~ // greater air elemental
              ~gorcamb6.cre~ ~override~ // fell cat
              ~gorcamb7.cre~ ~override~ // fell cat
              ~gorfirg.itm~  ~override~ // ring
              ~gorjelfu.itm~ ~override~ // ring
              ~gorjelgr.itm~ ~override~ // ring
              ~gormisti.itm~ ~override~ // ring
              ~gormistp.cre~ ~override~ // poison mist
              ~gorstalk.cre~ ~override~ // guardian of air
              ~helm06.itm~   ~override~ // helm of charm protection
              ~hgber01.itm~  ~override~ // two handed sword +1
              ~hgfel01.cre~  ~override~ // fell cat
              ~icbone01.cre~ ~override~ // bone golem
              ~immchs.itm~   ~override~ // <invalid strref -1>
              ~imoenhp1.itm~ ~override~ // imoen's belt
              ~innoc.itm~    ~override~ // ring
              ~ipsion.itm~   ~override~ // greenstone amulet
              ~irongol.itm~  ~override~ // iron golem item
              ~jonhp1.itm~   ~override~ // <invalid strref -1>
              ~killmonk.cre~ ~override~ // monk
              ~killsw01.itm~ ~override~ // long sword +2
              ~maharper.itm~ ~override~ // master harper item
              ~mane01.itm~   ~override~ // ring
              ~mdk2gun.itm~  ~override~ // big gun
              ~mdk2ring.itm~ ~override~ // big gun
              ~mdog1.itm~    ~override~ // <invalid strref -1>
              ~mel01.itm~    ~override~ // imoen's belt
              ~mindva01.cre~ ~override~ // vampiric illithid
              ~mindvam.cre~  ~override~ // vampiric illithid
              ~minhp1.itm~   ~override~ // <invalid strref -1>
              ~miscbc.itm~   ~override~ // blackrazor
              ~mistpo01.cre~ ~override~ // poison mist
              ~npchan.itm~   ~override~ // corthala family armor
              ~objring.itm~  ~override~ // ring
              ~palring.itm~  ~override~ // ring
              ~planet01.cre~ ~override~ // planetar
              ~planevil.cre~ ~override~ // fallen planetar
              ~plangood.cre~ ~override~ // planetar
              ~planwish.cre~ ~override~ // fallen planetar
              ~potn21.itm~   ~override~ // potion of clarity
              ~ppguy01.cre~  ~override~ // <invalid strref -1>
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~reaver.itm~   ~override~ // unholy reaver
              ~ring95.itm~   ~override~ // ring
              ~ring98.itm~   ~override~ // ring
              ~ringdemn.itm~ ~override~ // <invalid strref -1>
              ~sendai.cre~   ~override~ // sendai
              ~sendai2.cre~  ~override~ // sendai
              ~sendai3.cre~  ~override~ // sendai
              ~sendai4.cre~  ~override~ // sendai
              ~sendai5.cre~  ~override~ // sendai
              ~sendai6.cre~  ~override~ // sendai
              ~sendai7.cre~  ~override~ // sendai
              ~sendai8.cre~  ~override~ // sendai
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~senmonk.cre~  ~override~ // master bennon
              ~shalt01.itm~  ~override~ // ring
              ~shld25.itm~   ~override~ // shield of harmony +2
              ~solar.cre~    ~override~ // solar
              ~solar01.cre~  ~override~ // solar
              ~spcl152.spl~  ~override~ // barbarian rage
              ~spcl221.spl~  ~override~ // <invalid strref -1>
              ~spcl233b.spl~ ~override~ // <invalid strref -1>
              ~spcl321.spl~  ~override~ // enrage
              ~spcl817.spl~  ~override~ // <invalid strref -1>
              ~sper07.itm~   ~override~ // spear of the unicorn +2
              ~spin117.spl~  ~override~ // berserk
              ~spin121.spl~  ~override~ // protection from evil
              ~spin632.spl~  ~override~ // emperor
              ~spin783.spl~  ~override~ // slayer change
              ~spin823.spl~  ~override~ // slayer change
              ~spin852.spl~  ~override~ // slayer change
              ~spin872.spl~  ~override~ // <invalid strref -1>
              ~spin906.spl~  ~override~ // <invalid strref -1>
              ~sppr508.spl~  ~override~ // chaotic commands
              ~staf11.itm~   ~override~ // staff of the magi
              ~stalker.itm~  ~override~ // ring
              ~surehp1.itm~  ~override~ // ring
              ~sw1h35.itm~   ~override~ // adjatha the drinker +2
              ~sw1h54.itm~   ~override~ // the equalizer
              ~sw2h14.itm~   ~override~ // lilarcor
              ~sword01.cre~  ~override~ // magical sword
              ~telslav2.itm~ ~override~ // <invalid strref -1>
              ~tobpar03.cre~ ~override~ // long po
              ~torgal.cre~   ~override~ // torgal
              ~torgal2.cre~  ~override~ // torgal
              ~torgal3.cre~  ~override~ // torgal
              ~trollimm.itm~ ~override~ // ring
              ~tstatue.itm~  ~override~ // <invalid strref -1>
              ~udgolem.cre~  ~override~ // brain golem
              ~udphae01.cre~ ~override~ // phaere
              ~udsola01.cre~ ~override~ // solaufein
              ~udvamp.cre~   ~override~ // vampiric illithid
              ~vampreg.itm~  ~override~ // ring
              ~vampreg1.itm~ ~override~ // ring
              ~vampreg2.itm~ ~override~ // ring
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_2" = 0
        SET "new_fx_3" = 0
        SET "new_fx_4" = 0
        SET "new_fx_8" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_8" = 1
        PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "imoenhp1" = 0) BEGIN
          SET "new_fx_2" = 0
          SET "new_fx_3" = 0
          SET "new_fx_4" = 0
        END ELSE BEGIN
          SET "new_fx_2" = 1
          SET "new_fx_3" = 1
          SET "new_fx_4" = 1
        END
      END
      SET "new_fx_1" = 0
      SET "new_fx_5" = 0
      SET "new_fx_6" = 0
      SET "new_fx_7" = 0
      SET "new_fx_9" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 5)) BEGIN // charm immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 0)) BEGIN // prevent charm icon
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 1)) BEGIN // prevent dire charm icon
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 43)) BEGIN // prevent domination icon
          SET "new_fx_4" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14672)) BEGIN // disable string "charmed"
          SET "new_fx_5" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14780)) BEGIN // disable string "dire charmed"
          SET "new_fx_6" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 296) AND ("%resref%" STRING_COMPARE_CASE "spnwchrm" = 0)) BEGIN // disable charmed visuals
          SET "new_fx_7" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 142) AND ("%param2%" = 52)) BEGIN // display mind shield icon
          SET "new_fx_8" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 8364)) BEGIN // disable string "dominated"
          SET "new_fx_9" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0            // charm
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 1            // dire charm
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 43           // domination
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14672        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14780        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 296          // prevent specific animation
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spnwchrm~   // confusion animation
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_8%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 142          // display portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 52           // mind shield
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_9%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 8364         // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// haste
COPY_EXISTING ~ammgrd01.cre~ ~override~ // monk
              ~ammgrd02.cre~ ~override~ // monk
              ~ammgrd03.cre~ ~override~ // monk
              ~ammgrd04.cre~ ~override~ // guard captain
              ~ammgrd05.cre~ ~override~ // monk
              ~ammlegs.cre~  ~override~ // monk
              ~ammonk01.cre~ ~override~ // monk
              ~ammonk02.cre~ ~override~ // monk
              ~ammonk04.cre~ ~override~ // monk
              ~ammonk05.cre~ ~override~ // monk
              ~ammonk06.cre~ ~override~ // monk
              ~balelite.cre~ ~override~ // monk
              ~balth.cre~    ~override~ // balthazar
              ~bazmonk.cre~  ~override~ // monk
              ~blun30.itm~   ~override~ // flail of ages +5
              ~cutamgrd.cre~ ~override~ // monk
              ~cutbalth.cre~ ~override~ // balthazar
              ~finmel01.cre~ ~override~ // melissan
              ~killmonk.cre~ ~override~ // monk
              ~potn45.itm~   ~override~ // potion of freedom
              ~ring09.itm~   ~override~ // ring of free action
              ~senmonk.cre~  ~override~ // master bennon
              ~spcl521.spl~  ~override~ // offensive spin
              ~spcl814.spl~  ~override~ // <invalid strref -1>
              ~sper12.itm~   ~override~ // ixil's spike +6
              ~sppr403.spl~  ~override~ // free action
              ~tobpar03.cre~ ~override~ // long po
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_2" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_2" = 1
      END
      SET "new_fx_1" = 0
      SET "new_fx_3" = 0
      SET "new_fx_4" = 0
      SET "new_fx_5" = 0
      SET "new_fx_6" = 0
      SET "new_fx_7" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 16)) BEGIN // haste immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 38)) BEGIN // prevent haste icon
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14023)) BEGIN // disable string "hasted"
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spin572" = 0)) BEGIN // protection from spell
          SET "new_fx_4" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spin828" = 0)) BEGIN // protection from spell
          SET "new_fx_5" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spra301" = 0)) BEGIN // protection from spell
          SET "new_fx_6" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spwi305" = 0)) BEGIN // protection from spell
          SET "new_fx_7" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 38           // haste
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14023        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spin572~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spin828~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spra301~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi305~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// disease (revised by Wisp; reduced damage from poison is now in its own batch, since it is both immunity to disease as well as poison)
COPY_EXISTING ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~minhp1.itm~   ~override~ // <invalid strref -1>
              ~misc8j.itm~   ~override~ // boots of the west
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~ring39.itm~   ~override~ // ring of gaxx
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~spcl814.spl~  ~override~ // <invalid strref -1>
              ~sword01.cre~  ~override~ // magical sword
              ~tstatue.itm~  ~override~ // <invalid strref -1>
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_2" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_2" = 1
      END
      SET "new_fx_1" = 0
      SET "new_fx_3" = 0
      SET "new_fx_4" = 0
      //SET "new_fx_5" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 78)) BEGIN // disease immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 7)) BEGIN // prevent nauseated icon
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 39752)) BEGIN // disable string "stricken by a foul disease"
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 54337)) BEGIN // disable string "diseased"
          SET "new_fx_4" = 1
        END //ELSE
        //PATCH_IF (("%opcode%" = 173) AND ("%param1%" = 100)) BEGIN // reduced damage from poison - 100%
        //  SET "new_fx_5" = 1
        //END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 7            // nauseated
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 39752        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 54337        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        //PATCH_IF ("%new_fx_5%" = 0) BEGIN
        //  INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
        //    WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
        //    WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 173          // reduced damage from poison
        //    WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 100          // value
        //  SET "new_fx" = ("%new_fx%" + 1)
        //  SET "counter" = ("%counter%" + 1)
        //END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// poison resistance (immunity to both disease damage and poison damage)
COPY_EXISTING demogorg.itm override //<Invalid Strref -1>
              finmel01.itm override //<Invalid Strref -1>
              minhp1.itm   override //<Invalid Strref -1>
              ravag03.itm  override //<Invalid Strref -1>
              ring39.itm   override //Ring of Gaxx
              sengua04.itm override //<Invalid Strref -1>
              tstatue.itm  override //<Invalid Strref -1>
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop); index < abil_num; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      SET "new_fx_3" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0; index2 < counter; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 78)) BEGIN // disease immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 25)) BEGIN // poison immunity
          SET "new_fx_2" = 1
        END
        PATCH_IF (("%opcode%" = 173)) BEGIN // poison resistance
          SET "new_fx_3" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1 AND new_fx_2 = 1 AND new_fx_3 = 0) BEGIN
        INSERT_BYTES   ("%fx_off%"                                 + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
        WRITE_ASCIIE ("%fx_off%"                                   + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
        WRITE_SHORT  ("%fx_off%"            + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 173          // reduced damage from poison
        WRITE_LONG   ("%fx_off%" + 0x04     + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 100          // value
        SET "new_fx" = ("%new_fx%" + 1)
        SET "counter" = ("%counter%" + 1)
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
BUT_ONLY_IF_IT_CHANGES  

// poison
COPY_EXISTING ~amcst02.cre~  ~override~ // mercenary
              ~amcst03.cre~  ~override~ // mercenary
              ~ammgrd01.cre~ ~override~ // monk
              ~ammgrd02.cre~ ~override~ // monk
              ~ammgrd05.cre~ ~override~ // monk
              ~ammlegs.cre~  ~override~ // monk
              ~ammonk01.cre~ ~override~ // monk
              ~ammonk02.cre~ ~override~ // monk
              ~ammonk03.cre~ ~override~ // monk
              ~ammonk07.cre~ ~override~ // monk
              ~ammonk08.cre~ ~override~ // monk
              ~amul22.itm~   ~override~ // periapt of proof against poison
              ~balelite.cre~ ~override~ // monk
              ~balth.cre~    ~override~ // balthazar
              ~barl.cre~     ~override~ // barl
              ~barlfl.itm~   ~override~ // flail
              ~bazdra02.cre~ ~override~ // draconis
              ~bazdra03.cre~ ~override~ // fll'yissetat
              ~bazmonk.cre~  ~override~ // monk
              ~bazpatrg.itm~ ~override~ // ring
              ~bhaalhp1.itm~ ~override~ // <invalid strref -1>
              ~bhaalimm.itm~ ~override~ // <invalid strref -1>
              ~chalslay.itm~ ~override~ // ring
              ~chwraith.itm~ ~override~ // <invalid strref -1>
              ~cutamgrd.cre~ ~override~ // monk
              ~cutbalth.cre~ ~override~ // balthazar
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~demosum1.cre~ ~override~ // marilith
              ~deriny01.cre~ ~override~ // erinyes
              ~devaevil.cre~ ~override~ // fallen deva
              ~devagood.cre~ ~override~ // deva
              ~devast01.cre~ ~override~ // astral deva
              ~devmon01.cre~ ~override~ // monadic deva
              ~dimp01.cre~   ~override~ // imp
              ~elemprin.itm~ ~override~ // <invalid strref -1>
              ~fangel01.cre~ ~override~ // einhiris
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~finsol01.cre~ ~override~ // solar
              ~finsol04.cre~ ~override~ // fallen solar
              ~fsdragon.cre~ ~override~ // dragon
              ~fsspir.itm~   ~override~ // ring
              ~golbra.itm~   ~override~ // brain golem item
              ~golbra01.cre~ ~override~ // brain golem
              ~golcla.itm~   ~override~ // clay golem item
              ~golcla01.cre~ ~override~ // clay golem
              ~golem01.cre~  ~override~ // clay golem
              ~golfle.itm~   ~override~ // flesh golem item
              ~golice01.cre~ ~override~ // ice golem
              ~goljug01.cre~ ~override~ // juggernaut golem
              ~golmag01.itm~ ~override~ // magic golem item
              ~golsan01.cre~ ~override~ // sand golem
              ~golsto01.cre~ ~override~ // stone golem
              ~golstone.itm~ ~override~ // stone golem item
              ~gorbat1.cre~  ~override~ // ka'rashur
              ~gorbat2.cre~  ~override~ // erinyes
              ~gorbat3.cre~  ~override~ // cornugon
              ~gorbat4.cre~  ~override~ // imp
              ~gorcamb6.cre~ ~override~ // fell cat
              ~gorcamb7.cre~ ~override~ // fell cat
              ~gorfirg.itm~  ~override~ // ring
              ~gorgua01.cre~ ~override~ // aurumach rilmani
              ~gorgua02.cre~ ~override~ // ferrumach rilmani
              ~gorjelfu.itm~ ~override~ // ring
              ~gorjelgr.itm~ ~override~ // ring
              ~gormisti.itm~ ~override~ // ring
              ~gormistp.cre~ ~override~ // poison mist
              ~gormistp.itm~ ~override~ // ring
              ~gorwom01.cre~ ~override~ // nalmissra
              ~gorwom03.cre~ ~override~ // y'tossi
              ~gorwom04.cre~ ~override~ // ameralis zauviir
              ~helm30.itm~   ~override~ // thieves' hood
              ~hgber01.itm~  ~override~ // two handed sword +1
              ~hgfel01.cre~  ~override~ // fell cat
              ~holdring.itm~ ~override~ // ring
              ~icbone01.cre~ ~override~ // bone golem
              ~imoenhp1.itm~ ~override~ // imoen's belt
              ~innoc.itm~    ~override~ // ring
              ~invulner.itm~ ~override~ // ring
              ~irongol.itm~  ~override~ // iron golem item
              ~killmonk.cre~ ~override~ // monk
              ~mdog1.itm~    ~override~ // <invalid strref -1>
              ~mel01.itm~    ~override~ // imoen's belt
              ~melsum05.cre~ ~override~ // marilith
              ~mindva01.cre~ ~override~ // vampiric illithid
              ~mindvam.cre~  ~override~ // vampiric illithid
              ~minhp1.itm~   ~override~ // <invalid strref -1>
              ~mistpo01.cre~ ~override~ // poison mist
              ~morsword.itm~ ~override~ // mordenkainen's sword
              ~nishrusu.cre~ ~override~ // nishruu
              ~objring.itm~  ~override~ // ring
              ~planet01.cre~ ~override~ // planetar
              ~planevil.cre~ ~override~ // fallen planetar
              ~plangood.cre~ ~override~ // planetar
              ~planwish.cre~ ~override~ // fallen planetar
              ~ppguy01.cre~  ~override~ // <invalid strref -1>
              ~ppiron.cre~   ~override~ // clay golem
              ~pudden01.cre~ ~override~ // dense pudding
              ~pudden02.cre~ ~override~ // dense pudding
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~ring39.itm~   ~override~ // ring of gaxx
              ~ring46.itm~   ~override~ // ring of anti-venom
              ~ring94.itm~   ~override~ // ring
              ~ring95.itm~   ~override~ // ring
              ~ring98.itm~   ~override~ // ring
              ~ring99.itm~   ~override~ // ring
              ~ringdemn.itm~ ~override~ // <invalid strref -1>
              ~ringkora.itm~ ~override~ // ring
              ~scrl08.itm~   ~override~ // protection from poison
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~senmonk.cre~  ~override~ // master bennon
              ~shalt01.itm~  ~override~ // ring
              ~shararm.itm~  ~override~ // darkmail +3
              ~solar.cre~    ~override~ // solar
              ~solar01.cre~  ~override~ // solar
              ~spcl221.spl~  ~override~ // <invalid strref -1>
              ~spcl415.spl~  ~override~ // <invalid strref -1>
              ~spcl818.spl~  ~override~ // <invalid strref -1>
              ~spcl924.spl~  ~override~ // <invalid strref -1>
              ~spin853.spl~  ~override~ // otiluke's resilient sphere
//              ~spwi413.spl~  ~override~ // otiluke's resilient sphere
              ~spwi853.spl~  ~override~ // otiluke's resilient sphere
              ~stalker.itm~  ~override~ // ring
              ~surehp1.itm~  ~override~ // ring
              ~sw1h34.itm~   ~override~ // albruin +1
              ~telimp1.cre~  ~override~ // imp
              ~telpit1.cre~  ~override~ // pit fiend
              ~telslav2.itm~ ~override~ // <invalid strref -1>
              ~tobpar03.cre~ ~override~ // long po
              ~tomegol2.cre~ ~override~ // clay golem
              ~tomegol3.cre~ ~override~ // stone golem
              ~trolldie.itm~ ~override~ // <invalid strref -1>
              ~tstatue.itm~  ~override~ // <invalid strref -1>
              ~udgolem.cre~  ~override~ // brain golem
              ~udvamp.cre~   ~override~ // vampiric illithid
              ~vampreg.itm~  ~override~ // ring
              ~vampreg1.itm~ ~override~ // ring
              ~vampreg2.itm~ ~override~ // ring
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_3" = 0
        SET "new_fx_4" = 0
        SET "new_fx_5" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_5" = 1
        PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "imoenhp1" = 0) BEGIN
          SET "new_fx_3" = 0
          SET "new_fx_4" = 0
        END ELSE BEGIN
          SET "new_fx_3" = 1
          SET "new_fx_4" = 1
        END
      END
      SET "new_fx_1" = 0
      SET "new_fx_6" = 0
      SET "new_fx_7" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 25)) BEGIN // poison immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 6)) BEGIN // prevent poison icon
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 137)) BEGIN // prevent bleeding icon
          SET "new_fx_4" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 142) AND ("%param2%" = 30)) BEGIN // display protection from poison icon
          SET "new_fx_5" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14662)) BEGIN // disable string "poisoned"
          SET "new_fx_6" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14017)) BEGIN // disable string "poison"
          SET "new_fx_7" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 6            // poison
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 137          // bleeding
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 142          // display portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 30           // protection from poison
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14662        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14017        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// web
COPY_EXISTING ~abazring.itm~ ~override~ // ring
              ~bazpatrg.itm~ ~override~ // ring
              ~chaldt01.cre~ ~override~ // <charname>
              ~chalin01.cre~ ~override~ // <charname>
              ~chalslay.cre~ ~override~ // slayer
              ~fsspir.itm~   ~override~ // ring
              ~gorchr.itm~   ~override~ // ring
              ~gormistp.cre~ ~override~ // poison mist
              ~gortan3.cre~  ~override~ // yochlol
              ~holdring.itm~ ~override~ // ring
              ~invulner.itm~ ~override~ // ring
              ~jwsuper.itm~  ~override~ // ring of free action
              ~killsw01.itm~ ~override~ // long sword +2
              ~mistpo01.cre~ ~override~ // poison mist
              ~npplat.itm~   ~override~ // firecam full-plate armor
              ~potn45.itm~   ~override~ // potion of freedom
              ~rossring.itm~ ~override~ // ring of free action
              ~sw2h06.itm~   ~override~ // spider's bane
              ~sw2h13.itm~   ~override~ // spider's bane
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_3" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_3" = 1
      END
      // special block for WK statues
      PATCH_IF ("%SOURCE_RES%" STRING_COMPARE_CASE "holdring" = 0) BEGIN // should still be vulnerable to opcode 109
        SET "new_fx_2" = 1
      END ELSE BEGIN
        SET "new_fx_2" = 0
      END
      SET "new_fx_1" = 0
      SET "new_fx_4" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 157)) BEGIN // web immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 109)) BEGIN // paralyze
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 129)) BEGIN // prevent webbed icon
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14102)) BEGIN // disable string "held"
          SET "new_fx_4" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 109          // paralyzation immunity
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 129          // webbed
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14102        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// additional spell immunites
COPY_EXISTING ~aurstaf.itm~  ~override~ // staff of the ram +4
              ~balth.cre~    ~override~ // balthazar
              ~bazpatrg.itm~ ~override~ // ring
              ~demilich.itm~ ~override~ // ring
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~fsspir.itm~   ~override~ // ring
              ~golmag01.cre~ ~override~ // magic golem
              ~holdring.itm~ ~override~ // ring
              ~icbone01.cre~ ~override~ // bone golem
              ~invulner.itm~ ~override~ // ring
              ~jwglobe.spl~  ~override~ // globe of invulnerability
              ~lich.itm~     ~override~ // ring
              ~mageamul.itm~ ~override~ // necklace
              ~misc73.itm~   ~override~ // the horn of kazgaroth
              ~potn33.itm~   ~override~ // potion of magic blocking
              ~rakring.itm~  ~override~ // <invalid strref -1>
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~scrl07.itm~   ~override~ // protection from magic
              ~spcl415a.spl~ ~override~ // otiluke's resilient sphere
              ~spellh01.itm~ ~override~ // skull
              ~spwi406.spl~  ~override~ // minor globe of invulneribility
              ~spwi413a.spl~ ~override~ // otiluke's resilient sphere
              ~spwi602.spl~  ~override~ // globe of invulnerability
//              ~spwi954.spl~  ~override~ // selune's blessing
              ~spwm126.spl~  ~override~ // minor globe of invulneribility
              ~ucounter.cre~ ~override~ // <invalid strref -1>
              ~uhostile.cre~ ~override~ // <invalid strref -1>
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
//  SET "debug" = 1
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1_0" = 0
      SET "new_fx_1_1" = 0
      SET "new_fx_2_0" = 0
      SET "new_fx_2_1" = 0
      SET "new_fx_2_2" = 0
      SET "new_fx_2_3" = 0
      SET "new_fx_3_0" = 0
      SET "new_fx_3_1" = 0
      SET "new_fx_3_2" = 0
      SET "new_fx_3_3" = 0
      SET "new_fx_3_4" = 0
      SET "new_fx_3_5" = 0
      SET "new_fx_4_0" = 0
      SET "new_fx_5_0" = 0
      SET "new_fx_5_1" = 0
      SET "new_fx_6_0" = 0
      SET "new_fx_6_1" = 0
      SET "new_fx_6_2" = 0
      SET "new_fx_7_0" = 0
      SET "new_fx_7_1" = 0
      SET "new_fx_7_2" = 0
      SET "new_fx_7_3" = 0
      SET "new_fx_7_4" = 0
      SET "new_fx_7_5" = 0
      SET "new_fx_7_6" = 0
      SET "new_fx_8_0" = 0
      SET "new_fx_8_1" = 0
      SET "new_fx_8_2" = 0
      SET "new_fx_8_3" = 0
      SET "new_fx_8_4" = 0
      SET "new_fx_9_0" = 0
      SET "new_fx_9_1" = 0
      SET "new_fx_9_2" = 0
      SET "new_fx_9_3" = 0
      SET "new_fx_9_4" = 0
      SET "new_fx_9_5" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"

        PATCH_IF ("%opcode%" = 102) BEGIN // immunity to spell level
          PATCH_IF ("%param1%" = 1) BEGIN
            SET "new_fx_1_0" = 1
            READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template1" ((0x30 + (0xd8 * "%fx_type%")))
          END ELSE
          PATCH_IF ("%param1%" = 2) BEGIN
            SET "new_fx_2_0" = 1
            READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template2" ((0x30 + (0xd8 * "%fx_type%")))
          END ELSE
          PATCH_IF ("%param1%" = 3) BEGIN
            SET "new_fx_3_0" = 1
            READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template3" ((0x30 + (0xd8 * "%fx_type%")))
          END ELSE
          PATCH_IF ("%param1%" = 4) BEGIN
            SET "new_fx_4_0" = 1
            READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template4" ((0x30 + (0xd8 * "%fx_type%")))
          END ELSE
          PATCH_IF ("%param1%" = 5) BEGIN
            SET "new_fx_5_0" = 1
            READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template5" ((0x30 + (0xd8 * "%fx_type%")))
          END ELSE
          PATCH_IF ("%param1%" = 6) BEGIN
            SET "new_fx_6_0" = 1
            READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template6" ((0x30 + (0xd8 * "%fx_type%")))
          END ELSE
          PATCH_IF ("%param1%" = 7) BEGIN
            SET "new_fx_7_0" = 1
            READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template7" ((0x30 + (0xd8 * "%fx_type%")))
          END ELSE
          PATCH_IF ("%param1%" = 8) BEGIN
            SET "new_fx_8_0" = 1
            READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template8" ((0x30 + (0xd8 * "%fx_type%")))
          END ELSE
          PATCH_IF ("%param1%" = 9) BEGIN
            SET "new_fx_9_0" = 1
            READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template9" ((0x30 + (0xd8 * "%fx_type%")))
          END
        END ELSE
        PATCH_IF ("%opcode%" = 206) BEGIN // immunity to spell
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr105" = 0) BEGIN
            SET "new_fx_1_1" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi215" = 0) BEGIN
            SET "new_fx_2_1" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi213" = 0) BEGIN
            SET "new_fx_2_2" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr211" = 0) BEGIN
            SET "new_fx_2_3" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi313" = 0) BEGIN
            SET "new_fx_3_1" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr314" = 0) BEGIN
            SET "new_fx_3_2" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr313" = 0) BEGIN
            SET "new_fx_3_3" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr304" = 0) BEGIN
            SET "new_fx_3_4" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr302" = 0) BEGIN
            SET "new_fx_3_5" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi502" = 0) BEGIN
            SET "new_fx_5_1" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi614" = 0) BEGIN
            SET "new_fx_6_1" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr603d" = 0) BEGIN
            SET "new_fx_6_2" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi712" = 0) BEGIN
            SET "new_fx_7_1" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr725d" = 0) BEGIN
            SET "new_fx_7_2" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr719" = 0) BEGIN
            SET "new_fx_7_3" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr718" = 0) BEGIN
            SET "new_fx_7_4" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr706" = 0) BEGIN
            SET "new_fx_7_5" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "sppr705" = 0) BEGIN
            SET "new_fx_7_6" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi817" = 0) BEGIN
            SET "new_fx_8_1" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi816" = 0) BEGIN
            SET "new_fx_8_2" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi811" = 0) BEGIN
            SET "new_fx_8_3" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi810" = 0) BEGIN
            SET "new_fx_8_4" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwish35" = 0) BEGIN
            SET "new_fx_9_1" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwish32" = 0) BEGIN
            SET "new_fx_9_2" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwish27" = 0) BEGIN
            SET "new_fx_9_3" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwish25" = 0) BEGIN
            SET "new_fx_9_4" = 1
          END ELSE
          PATCH_IF ("%resref%" STRING_COMPARE_CASE "spwi911" = 0) BEGIN
            SET "new_fx_9_5" = 1
          END
        END
      END
      PATCH_IF ("%new_fx_1_0%" = 1) BEGIN
        PATCH_IF ("%new_fx_1_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template1%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr105~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      PATCH_IF ("%new_fx_2_0%" = 1) BEGIN
        PATCH_IF ("%new_fx_2_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template2%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi215~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_2_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template2%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi213~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_2_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template2%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr211~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      PATCH_IF ("%new_fx_3_0%" = 1) BEGIN
        PATCH_IF ("%new_fx_3_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template3%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi313~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template3%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr314~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template3%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr313~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template3%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr304~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template3%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr302~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      PATCH_IF ("%new_fx_5_0%" = 1) BEGIN
        PATCH_IF ("%new_fx_5_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template5%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi502~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      PATCH_IF ("%new_fx_6_0%" = 1) BEGIN
        PATCH_IF ("%new_fx_6_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template6%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi614~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template6%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr603d~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      PATCH_IF ("%new_fx_7_0%" = 1) BEGIN
        PATCH_IF ("%new_fx_7_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template7%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206           // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff    // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi712~ #8  // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template7%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206           // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff    // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr725d~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template7%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr719~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template7%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr718~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template7%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr706~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_7_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template7%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~sppr705~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      PATCH_IF ("%new_fx_8_0%" = 1) BEGIN
        PATCH_IF ("%new_fx_8_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template8%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi817~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_8_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template8%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi816~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_8_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template8%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi811~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_8_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template8%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi810~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      PATCH_IF ("%new_fx_9_0%" = 1) BEGIN
        PATCH_IF ("%new_fx_9_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template9%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwish35~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_9_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template9%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwish32~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_9_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template9%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwish27~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_9_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template9%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwish25~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_9_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template9%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi911~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES
  
// make sure blindness effects always have a blind icon and string
COPY_EXISTING ~gorwom4.itm~ ~override~ // drow flail +3
              ~sorb.itm~    ~override~ // searing orb
              ~sw1h51.itm~  ~override~ // celestial fury +3
              ~wand19.itm~  ~override~ // wand of cursing
              ~spdr101.spl~ ~override~ // chromatic orb
              ~spin595.spl~ ~override~ // yellow dragon scorching sand
              ~spin878.spl~ ~override~ // level drain
              ~spin893.spl~ ~override~ // shadow dragon breath
              ~spin929.spl~ ~override~ // mist ball
              ~spin931.spl~ ~override~ // sooty ball
              ~sppr313.spl~ ~override~ // holy smite
              ~sppr707.spl~ ~override~ // sunray
              ~spwi118.spl~ ~override~ // chromatic orb
              ~spwi224.spl~ ~override~ // glitterdust
              ~spwi714.spl~ ~override~ // prismatic spray
              ~spwi815.spl~ ~override~ // power word blind
              ~spwi958.spl~ ~override~ // power word, blind
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      SET "new_fx_3" = 0
      SET "new_fx_4" = 0
      SET "new_fx_5" = 0
      SET "new_fx_6" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF ("%opcode%" = 74) BEGIN // blindness
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 142) AND ("%param2%" = 8)) BEGIN // display blinded portrait icon
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 139) AND (("%param1%" = 1474) OR ("%param1%" = 14674))) BEGIN // display 'blinded' string
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 177) AND ("%resref%" STRING_COMPARE_CASE "blind" = 0)) BEGIN // blindness via eff
          SET "new_fx_4" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 177) AND ("%resref%" STRING_COMPARE_CASE "cdblind" = 0)) BEGIN // blindness icon via eff
          SET "new_fx_5" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 177) AND ("%resref%" STRING_COMPARE_CASE "cdblind1" = 0)) BEGIN // blindness string via eff
          SET "new_fx_6" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 142          // display portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 8            // blinded
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 139          // display string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14674        // blinded
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      PATCH_IF ("%new_fx_4%" = 1) BEGIN
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 177          // display portrait icon
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~cdblind~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_6%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%"  // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 177           // display portrait icon
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~cdblind1~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// petrification
COPY_EXISTING ~balth02.spl~  ~override~ // lunar stance!
              ~bazdra02.cre~ ~override~ // draconis
              ~chaldt01.cre~ ~override~ // <charname>
              ~chalin01.cre~ ~override~ // <charname>
              ~chalslay.cre~ ~override~ // slayer
              ~chalslay.itm~ ~override~ // ring
              ~chwraith.itm~ ~override~ // <invalid strref -1>
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~demosum4.cre~ ~override~ // cambion
              ~devaevil.cre~ ~override~ // fallen deva
              ~devagood.cre~ ~override~ // deva
              ~devast01.cre~ ~override~ // astral deva
              ~devmon01.cre~ ~override~ // monadic deva
              ~elemhydr.cre~ ~override~ // olhydra
              ~elemimix.cre~ ~override~ // imix
              ~elemogre.cre~ ~override~ // ogremoch
              ~elemsunn.cre~ ~override~ // sunnis
              ~elemzaam.cre~ ~override~ // zaaman rul
              ~fangel01.cre~ ~override~ // einhiris
              ~finsol01.cre~ ~override~ // solar
              ~finsol04.cre~ ~override~ // fallen solar
              ~golstone.itm~ ~override~ // ring
              ~gorair01.cre~ ~override~ // lesser air elemental
              ~gorair02.cre~ ~override~ // greater air elemental
              ~gorbat1.cre~  ~override~ // ka'rashur
              ~gorcamb.cre~  ~override~ // aesgareth
              ~gorstalk.cre~ ~override~ // guardian of air
              ~hgber01.itm~  ~override~ // two handed sword +1
              ~immcloud.itm~ ~override~ // <invalid strref -1>
              ~innoc.itm~    ~override~ // ring
              ~jonhp1.itm~   ~override~ // <invalid strref -1>
              ~mdk2gun.itm~  ~override~ // big gun
              ~mdk2ring.itm~ ~override~ // big gun
              ~minhp20.itm~  ~override~ // <invalid strref -1>
              ~objring.itm~  ~override~ // ring
              ~planet01.cre~ ~override~ // planetar
              ~planevil.cre~ ~override~ // fallen planetar
              ~plangood.cre~ ~override~ // planetar
              ~planwish.cre~ ~override~ // fallen planetar
              ~potn38.itm~   ~override~ // potion of mirrored eyes
              ~ppguy01.cre~  ~override~ // <invalid strref -1>
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~ring94.itm~   ~override~ // ring
              ~ring98.itm~   ~override~ // ring
              ~ringkora.itm~ ~override~ // ring
              ~scrl15.itm~   ~override~ // protection from petrification
              ~shalt01.itm~  ~override~ // ring
              ~solar.cre~    ~override~ // solar
              ~solar01.cre~  ~override~ // solar
              ~spcl415.spl~  ~override~ // <invalid strref -1>
              ~spcl917.spl~  ~override~ // avoid death
              ~spin853.spl~  ~override~ // otiluke's resilient sphere
              ~spwi108.spl~  ~override~ // protection from petrification
              ~spwi853.spl~  ~override~ // otiluke's resilient sphere
              ~stalker.itm~  ~override~ // ring
              ~surehp1.itm~  ~override~ // ring
              ~sw1h71.itm~   ~override~ // hindo's doom +4
              ~sword01.cre~  ~override~ // magical sword
              ~telpit1.cre~  ~override~ // pit fiend
              ~telslav2.itm~ ~override~ // <invalid strref -1>
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 134)) BEGIN // petrification immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14665)) BEGIN // disable string "petrified"
          SET "new_fx_2" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14665        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// kill target
COPY_EXISTING ~ammonk07.cre~ ~override~ // monk
              ~ammonk08.cre~ ~override~ // monk
              ~bazdra01.cre~ ~override~ // draconis
              ~bazdra02.cre~ ~override~ // draconis
              ~bhaalhp1.itm~ ~override~ // <invalid strref -1>
              ~bhaalimm.itm~ ~override~ // <invalid strref -1>
              ~chalrv01.cre~ ~override~ // the ravager
              ~chalslay.cre~ ~override~ // slayer
              ~demilich.cre~ ~override~ // demi-lich
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~golice01.cre~ ~override~ // ice golem
              ~gorchr.itm~   ~override~ // ring
              ~gorsal.cre~   ~override~ // saladrex
              ~hgmnd2.cre~   ~override~ // shambling mound
              ~hgmound.cre~  ~override~ // shambling mound
              ~holdring.itm~ ~override~ // ring
              ~imoenhp1.itm~ ~override~ // imoen's belt
              ~invulner.itm~ ~override~ // ring
              ~jonhp1.itm~   ~override~ // <invalid strref -1>
              ~mel01.itm~    ~override~ // imoen's belt
              ~minhp1.itm~   ~override~ // <invalid strref -1>
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~shararm.itm~  ~override~ // darkmail +3
              ~spcl917.spl~  ~override~ // avoid death
              ~sw1h71.itm~   ~override~ // hindo's doom +4
              ~tstatue.itm~  ~override~ // <invalid strref -1>
              ~yaga01.cre~   ~override~ // yaga-shura
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      SET "new_fx_3" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 13)) BEGIN // kill target immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 64285)) BEGIN // disable string "vorpal hit"
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14026)) BEGIN // disable string "death"
          SET "new_fx_3" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 64285        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14026        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// invisibility
COPY_EXISTING ~bazpatrg.itm~ ~override~ // ring
              ~fsspir.itm~   ~override~ // ring
              ~gorchr.itm~   ~override~ // ring
              ~holdring.itm~ ~override~ // ring
              ~invulner.itm~ ~override~ // ring
              ~surehp1.itm~  ~override~ // ring
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 20)) BEGIN // immunity to invisibility
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14773)) BEGIN // disable string "invisible"
          SET "new_fx_2" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14773        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// silence
COPY_EXISTING ~ammonk07.cre~ ~override~ // monk
              ~ammonk08.cre~ ~override~ // monk
              ~amul21.itm~   ~override~ // amulet of power
              ~amul28.itm~   ~override~ // amulet of the master harper
              ~dragring.itm~ ~override~ // ring
              ~firlch01.cre~ ~override~ // fire lich
              ~gorair01.cre~ ~override~ // lesser air elemental
              ~gorair02.cre~ ~override~ // greater air elemental
              ~gorstalk.cre~ ~override~ // guardian of air
              ~helljon.cre~  ~override~ // jon irenicus
              ~helljon2.cre~ ~override~ // jon irenicus
              ~hgber01.itm~  ~override~ // two handed sword +1
              ~hllich.cre~   ~override~ // elemental lich
              ~hlshade.cre~  ~override~ // shade lich
              ~lichel01.cre~ ~override~ // elemental lich
              ~mage20.cre~   ~override~ // mage
              ~mage20b.cre~  ~override~ // mage
              ~mage20c.cre~  ~override~ // mage
              ~minhp1.itm~   ~override~ // <invalid strref -1>
              ~ppireni2.cre~ ~override~ // jon irenicus
              ~sendai7.cre~  ~override~ // sendai
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~sewyag04.cre~ ~override~ // yaga-shura mage
              ~spwi219.spl~  ~override~ // vocalize
              ~sujon.cre~    ~override~ // jon irenicus
              ~sujon2.cre~   ~override~ // jon irenicus
              ~suraam.cre~   ~override~ // raamilat
              ~susuneer.cre~ ~override~ // suneer
              ~sw1h50.itm~   ~override~ // shazzellim +1
              ~telqua1.cre~  ~override~ // quasit
              ~telqua2.cre~  ~override~ // quasit
              ~tstatue.itm~  ~override~ // <invalid strref -1>
              ~uddrow50.cre~ ~override~ // drow wizard
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      SET "new_fx_3" = 0
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_4" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_4" = 1
      END
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 38)) BEGIN // silence immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14002)) BEGIN // disable string "silence"
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14676)) BEGIN // disable string "silenced"
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 34)) BEGIN // prevent silenced icon
          SET "new_fx_4" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14002        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14676        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 34           // silenced
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// blindness
COPY_EXISTING ~sword01.cre~ ~override~
              ~npmisc1.itm~ ~override~
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      SET "new_fx_3" = 0
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_4" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_4" = 1
      END
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 74)) BEGIN // immunity to blindness
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 1474)) BEGIN // disable string "blind"
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14674)) BEGIN // disable string "blinded"
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 8)) BEGIN // prevent blind icon
          SET "new_fx_4" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 1474        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14674        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 8            // blind
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// deafness
COPY_EXISTING ~sword01.cre~ ~override~
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_3" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_3" = 1
      END
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 80)) BEGIN // immunity to deafness
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 54318)) BEGIN // disable string "deaf"
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 112)) BEGIN // prevent deaf icon
          SET "new_fx_3" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 54318        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 112          // deaf
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// slay
COPY_EXISTING ~balth02.spl~ ~override~ // lunar stance!
              ~spcl415.spl~ ~override~ // <invalid strref -1>
              ~spcl917.spl~ ~override~ // avoid death
              ~spin853.spl~ ~override~ // otiluke's resilient sphere
              ~sppr409.spl~ ~override~ // death ward
              ~spwi853.spl~ ~override~ // otiluke's resilient sphere
              ~sw1h71.itm~  ~override~ // hindo's doom +4
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_2" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_2" = 1
      END
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 55)) BEGIN // immunity to slay
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 51)) BEGIN // prevent dying icon
          SET "new_fx_2" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 51           // deaf
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// detect invisible
COPY_EXISTING ~swordi.itm~   ~override~ // <invalid strref -1>
              ~ucounter.cre~ ~override~ // <invalid strref -1>
              ~uhostile.cre~ ~override~ // <invalid strref -1>
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 116)) BEGIN // immunity to detect invisible
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14109)) BEGIN // disable string "dispel invisible"
          SET "new_fx_2" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14109        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// polymorph
COPY_EXISTING ~bazdra02.cre~ ~override~ // draconis
              ~bazdra03.cre~ ~override~ // fll'yissetat
              ~bhaalhp1.itm~ ~override~ // <invalid strref -1>
              ~bhaalimm.itm~ ~override~ // <invalid strref -1>
              ~chaldt01.cre~ ~override~ // <charname>
              ~chalin01.cre~ ~override~ // <charname>
              ~chalslay.cre~ ~override~ // slayer
              ~demilich.itm~ ~override~ // ring
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~demsuc01.cre~ ~override~ // succubus
              ~deriny01.cre~ ~override~ // erinyes
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~finsol04.cre~ ~override~ // fallen solar
              ~gorbat1.cre~  ~override~ // ka'rashur
              ~gorbat2.cre~  ~override~ // erinyes
              ~gorcamb.cre~  ~override~ // aesgareth
              ~gormistp.cre~ ~override~ // poison mist
              ~gorsuc01.cre~ ~override~ // succubus
              ~gortan2.cre~  ~override~ // succubus
              ~imoenhp1.itm~ ~override~ // imoen's belt
              ~jonhp1.itm~   ~override~ // <invalid strref -1>
              ~lich.itm~     ~override~ // ring
              ~mel01.itm~    ~override~ // imoen's belt
              ~minhp1.itm~   ~override~ // <invalid strref -1>
              ~mistpo01.cre~ ~override~ // poison mist
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~ringdemn.itm~ ~override~ // <invalid strref -1>
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~spcl415.spl~  ~override~ // <invalid strref -1>
              ~spin853.spl~  ~override~ // otiluke's resilient sphere
              ~spwi853.spl~  ~override~ // otiluke's resilient sphere
              ~sword01.cre~  ~override~ // magical sword
              ~telpit1.cre~  ~override~ // pit fiend
              ~tstatue.itm~  ~override~ // <invalid strref -1>
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      SET "new_fx_3" = 0
      SET "new_fx_4" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 135)) BEGIN // immunity to polymorph
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spwi711" = 0)) BEGIN // protection from spell, sphere of chaos
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spwi415" = 0)) BEGIN // protection from spell, polymorph other
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_COMPARE_CASE "spwm113" = 0)) BEGIN // protection from spell, wild surge polymorph
          SET "new_fx_4" = 1
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi711~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwi415~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 206          // protection from spell
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 0xffffffff   // no string
            WRITE_ASCII  ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) ~spwm113~ #8 // resref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// sleep
COPY_EXISTING ~abazring.itm~ ~override~ // ring
              ~amul17.itm~   ~override~ // greenstone amulet
              ~barl.cre~     ~override~ // barl
              ~bhaalhp1.itm~ ~override~ // <invalid strref -1>
              ~bhaalimm.itm~ ~override~ // <invalid strref -1>
              ~chalcy3.itm~  ~override~ // greenstone amulet
              ~chalslay.itm~ ~override~ // ring
              ~chevil02.cre~ ~override~ // doppleganger
              ~chevil06.cre~ ~override~ // drow warrior
              ~chevil07.cre~ ~override~ // drow priestess
              ~chgood04.cre~ ~override~ // elven warrior
              ~chgood05.cre~ ~override~ // elven warrior
              ~chgood09.cre~ ~override~ // ellesime
              ~chwraith.itm~ ~override~ // <invalid strref -1>
              ~demilich.itm~ ~override~ // ring
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~dragring.itm~ ~override~ // ring
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~finsol04.cre~ ~override~ // fallen solar
              ~golbra.itm~   ~override~ // brain golem item
              ~golcla.itm~   ~override~ // clay golem item
              ~golfle.itm~   ~override~ // flesh golem item
              ~golmag01.itm~ ~override~ // magic golem item
              ~golstone.itm~ ~override~ // stone golem item
              ~gorfirg.itm~  ~override~ // ring
              ~gorjelfu.itm~ ~override~ // ring
              ~gorjelgr.itm~ ~override~ // ring
              ~gormisti.itm~ ~override~ // ring
              ~gormistp.cre~ ~override~ // poison mist
              ~hgber01.itm~  ~override~ // two handed sword +1
              ~icbone01.cre~ ~override~ // bone golem
              ~immchs.itm~   ~override~ // <invalid strref -1>
              ~immcloud.itm~ ~override~ // <invalid strref -1>
              ~imoenhp1.itm~ ~override~ // imoen's belt
              ~innoc.itm~    ~override~ // ring
              ~ipsion.itm~   ~override~ // greenstone amulet
              ~irongol.itm~  ~override~ // iron golem item
              ~jondem05.cre~ ~override~ // glabrezu
              ~jonhp1.itm~   ~override~ // <invalid strref -1>
              ~killsw01.itm~ ~override~ // long sword +2
              ~lich.itm~     ~override~ // ring
              ~mel01.itm~    ~override~ // imoen's belt
              ~mindva01.cre~ ~override~ // vampiric illithid
              ~mindvam.cre~  ~override~ // vampiric illithid
              ~minhp1.itm~   ~override~ // <invalid strref -1>
              ~mistpo01.cre~ ~override~ // poison mist
              ~objring.itm~  ~override~ // ring
              ~palring.itm~  ~override~ // ring
              ~plytroll.itm~ ~override~ // attack
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~ring92.itm~   ~override~ // ring
              ~ring94.itm~   ~override~ // ring
              ~ring95.itm~   ~override~ // ring
              ~ring98.itm~   ~override~ // ring
              ~ring99.itm~   ~override~ // ring
              ~ringkora.itm~ ~override~ // ring
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~shalt01.itm~  ~override~ // ring
              ~spcl152.spl~  ~override~ // barbarian rage
              ~spcl321.spl~  ~override~ // enrage
              ~spin117.spl~  ~override~ // berserk
              ~spin783.spl~  ~override~ // slayer change
              ~spin823.spl~  ~override~ // slayer change
              ~spin852.spl~  ~override~ // slayer change
              ~spin872.spl~  ~override~ // <invalid strref -1>
              ~spin906.spl~  ~override~ // <invalid strref -1>
              ~sppr508.spl~  ~override~ // chaotic commands
              ~stalker.itm~  ~override~ // ring
              ~surehp1.itm~  ~override~ // ring
              ~sword01.cre~  ~override~ // magical sword
              ~telslav2.itm~ ~override~ // <invalid strref -1>
              ~torgal.cre~   ~override~ // torgal
              ~trollall.itm~ ~override~ // attack
              ~trollimm.itm~ ~override~ // ring
              ~tstatue.itm~  ~override~ // <invalid strref -1>
              ~udvamp.cre~   ~override~ // vampiric illithid
              ~vampreg.itm~  ~override~ // ring
              ~vampreg1.itm~ ~override~ // ring
              ~vampreg2.itm~ ~override~ // ring
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_3" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_3" = 1
      END
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      SET "new_fx_4" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 39)) BEGIN // sleep immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 217)) BEGIN // pw sleep immunity
          SET "new_fx_2" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 14)) BEGIN // prevent sleep icon
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14001)) BEGIN // disable string "sleep"
          SET "new_fx_4" = 1
        END
      END
      PATCH_IF (("%new_fx_1%" = 1) OR ("%new_fx_2%" = 1)) BEGIN
        PATCH_IF ("%new_fx_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 39           // sleep
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 217          // pw sleep
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14           // sleep
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14001        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

// stun
COPY_EXISTING ~abazring.itm~ ~override~ // ring
              ~aldeth.itm~   ~override~ // ring of free action
              ~amul17.itm~   ~override~ // greenstone amulet
              ~beholder.itm~ ~override~ // ring
              ~bhaalhp1.itm~ ~override~ // <invalid strref -1>
              ~bhaalimm.itm~ ~override~ // <invalid strref -1>
              ~chalcy3.itm~  ~override~ // greenstone amulet
              ~chaldt01.cre~ ~override~ // <charname>
              ~chalin01.cre~ ~override~ // <charname>
              ~chalslay.cre~ ~override~ // slayer
              ~cuphaer.cre~  ~override~ // phaere
              ~demogorg.itm~ ~override~ // <invalid strref -1>
              ~dragring.itm~ ~override~ // ring
              ~drow05.cre~   ~override~ // drow
              ~elearb11.cre~ ~override~ // apparition
              ~elemhydr.cre~ ~override~ // olhydra
              ~elemimix.cre~ ~override~ // imix
              ~elemogre.cre~ ~override~ // ogremoch
              ~elemsunn.cre~ ~override~ // sunnis
              ~elemzaam.cre~ ~override~ // zaaman rul
              ~finmel01.itm~ ~override~ // <invalid strref -1>
              ~finsol04.cre~ ~override~ // fallen solar
              ~firlch01.cre~ ~override~ // fire lich
              ~freering.itm~ ~override~ // ring of free action
              ~gorfirg.itm~  ~override~ // ring
              ~gorjelfu.itm~ ~override~ // ring
              ~gorjelgr.itm~ ~override~ // ring
              ~gormisti.itm~ ~override~ // ring
              ~gormistp.cre~ ~override~ // poison mist
              ~helljon.cre~  ~override~ // jon irenicus
              ~helljon2.cre~ ~override~ // jon irenicus
              ~hgber01.itm~  ~override~ // two handed sword +1
              ~hllich.cre~   ~override~ // elemental lich
              ~hlshade.cre~  ~override~ // shade lich
              ~hslaywpn.itm~ ~override~ // <invalid strref -1>
              ~imoenhp1.itm~ ~override~ // imoen's belt
              ~invulner.itm~ ~override~ // ring
              ~ipsion.itm~   ~override~ // greenstone amulet
              ~jwsuper.itm~  ~override~ // ring of free action
              ~killsw01.itm~ ~override~ // long sword +2
              ~lichel01.cre~ ~override~ // elemental lich
              ~mage05.itm~   ~override~ // ring of free action
              ~mage20.cre~   ~override~ // mage
              ~mage20b.cre~  ~override~ // mage
              ~mage20c.cre~  ~override~ // mage
              ~mel01.itm~    ~override~ // imoen's belt
              ~minhp1.itm~   ~override~ // <invalid strref -1>
              ~mistpo01.cre~ ~override~ // poison mist
              ~npsw01.itm~   ~override~ // sword of arvoreen
              ~objring.itm~  ~override~ // ring
              ~palring.itm~  ~override~ // ring
              ~plytroll.itm~ ~override~ // attack
              ~ppireni2.cre~ ~override~ // jon irenicus
              ~ravag03.itm~  ~override~ // <invalid strref -1>
              ~ring95.itm~   ~override~ // ring
              ~ring99.itm~   ~override~ // ring
              ~rossring.itm~ ~override~ // ring of free action
              ~sendai7.cre~  ~override~ // sendai
              ~sengua04.itm~ ~override~ // <invalid strref -1>
              ~sewyag04.cre~ ~override~ // yaga-shura mage
              ~shalt01.itm~  ~override~ // ring
              ~shararm.itm~  ~override~ // darkmail +3
              ~slayerwp.itm~ ~override~ // <invalid strref -1>
              ~spcl152.spl~  ~override~ // barbarian rage
              ~spcl321.spl~  ~override~ // enrage
              ~spcl542a.spl~ ~override~ // <invalid strref -1>
              ~spcl920a.spl~ ~override~ // <invalid strref -1>
              ~spin783.spl~  ~override~ // slayer change
              ~spin852.spl~  ~override~ // slayer change
              ~spin872.spl~  ~override~ // <invalid strref -1>
              ~spin906.spl~  ~override~ // <invalid strref -1>
              ~sppr508.spl~  ~override~ // chaotic commands
              ~stalker.itm~  ~override~ // ring
              ~sujon.cre~    ~override~ // jon irenicus
              ~sujon2.cre~   ~override~ // jon irenicus
              ~suraam.cre~   ~override~ // raamilat
              ~surehp1.itm~  ~override~ // ring
              ~susuneer.cre~ ~override~ // suneer
              ~sw2h06.itm~   ~override~ // spider's bane
              ~sword01.cre~  ~override~ // magical sword
              ~torgal.cre~   ~override~ // torgal
              ~trollall.itm~ ~override~ // attack
              ~tstatue.itm~  ~override~ // <invalid strref -1>
              ~uddrow50.cre~ ~override~ // drow wizard
              ~udphae01.cre~ ~override~ // phaere
              ~udsilver.cre~ ~override~ // adalon
              ~udsola01.cre~ ~override~ // solaufein
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      SET "new_fx_2" = 0
      SET "new_fx_3" = 0
      SET "new_fx_5" = 0
      PATCH_IF ("%cosmetic%" = 1) BEGIN // if cosmetic effects needed
        SET "new_fx_4" = 0
      END ELSE BEGIN // if no cosmetic effects should be added
        SET "new_fx_4" = 1
      END
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 45)) BEGIN // immunity to stun
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 1280)) BEGIN // disable string "stunned"
          SET "new_fx_2" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 267) AND ("%param1%" = 14043)) BEGIN // disable string "stun"
          SET "new_fx_3" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 169) AND ("%param2%" = 55)) BEGIN // prevent stunned icon
          SET "new_fx_4" = 1
        END ELSE
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 210)) BEGIN // immunity to pw stun
          SET "new_fx_5" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END
      END
      PATCH_IF (("%new_fx_1%" = 1) OR ("%new_fx_5%" = 1)) BEGIN
        PATCH_IF ("%new_fx_1%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 45           // stun
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_2%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 1280         // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_3%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
            WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14043        // strref
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_4%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 55           // stun
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
        PATCH_IF ("%new_fx_5%" = 0) BEGIN
          INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
            WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
            WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 210          // pw stun
          SET "new_fx" = ("%new_fx%" + 1)
          SET "counter" = ("%counter%" + 1)
        END
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES  

/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////                                                  \\\\\
///// Game text update                                 \\\\\
/////                                                  \\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\

/////                                                  \\\\\
///// Game text update light                           \\\\\
/////                                                  \\\\\

BEGIN @1000 DESIGNATED 1000 // GTU Light (by Wisp)
SUBCOMPONENT @1  // Game text update
REQUIRE_PREDICATE ((FILE_EXISTS ~bg2fixpack/languages/%LANGUAGE%/gtul.tra~) AND
                   (FILE_EXISTS ~bg2fixpack/languages/%LANGUAGE%/gtul.tpa~)) @5

LOAD_TRA ~bg2fixpack/languages/%LANGUAGE%/gtul.tra~
INCLUDE  ~bg2fixpack/languages/%LANGUAGE%/gtul.tpa~

/////                                                  \\\\\
///// Game text update, original Baldurdash            \\\\\
/////                                                  \\\\\

BEGIN @1001 DESIGNATED 1001 // GTU Classic (from Baldurdash, by Kevin Dorner)
SUBCOMPONENT @1  // Game text update
REQUIRE_PREDICATE ((FILE_EXISTS ~bg2fixpack/languages/%LANGUAGE%/gtu.tra~) AND
                   (FILE_EXISTS ~bg2fixpack/languages/%LANGUAGE%/gtu.tpa~)) @5

LOAD_TRA ~bg2fixpack/languages/%LANGUAGE%/gtu.tra~
INCLUDE  ~bg2fixpack/languages/%LANGUAGE%/gtu.tpa~

/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////                                                  \\\\\
///// modder pack                                      \\\\\
/////                                                  \\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\

BEGIN @3 DESIGNATED 2 // modder pack
DEPRECATED @22 //Remove this line if you want the component back

INCLUDE ~bg2fixpack/lib/modder.tpa~

/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////                                                  \\\\\
///// BETA Core Fixes                                  \\\\\
/////                                                  \\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\

BEGIN @20 DESIGNATED 3 // Beta Core Fixes

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0003.g3~

// patch functions
INCLUDE ~bg2fixpack/lib/functions.tpa~

/////                                                  \\\\\
///// string fixes                                     \\\\\
/////                                                  \\\\\

/////                                                  \\\\\
///// ids fixes                                        \\\\\
/////                                                  \\\\\


// Fix the BashDoor() entry in ACTION.IDS (Wounded_Lion)
COPY_EXISTING ~action.ids~ ~override~
 REPLACE_TEXTUALLY ~BashDoor(0:Object)~ ~BashDoor(O:Object)~
BUT_ONLY_IF_IT_CHANGES

// Fix the LeaveAreaLUAPanicEntry() entry in ACTSLEEP.IDS (Lu_ and aVENGER)
COPY_EXISTING ~actsleep.ids~ ~override~
PATCH_IF NOT FILE_CONTAINS_EVALUATED (~%SOURCE_FILE%~ ~LeaveAreaLUAPanicEntry(S\:Area\*\,S\:Entry\*\,P\:Point\*\,I\:Face\*)~) BEGIN
  REPLACE_TEXTUALLY EXACT_MATCH ~351 LeaveAreaLUAPanicEntry(S:Area*,S:Entry*,P:Point*,~ ~351 LeaveAreaLUAPanicEntry(S:Area*,S:Entry*,P:Point*,I:Face*)~
END
BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// misc 2da fixes                                   \\\\\
/////                                                  \\\\\

/////                                                  \\\\\
///// mass compile/copy actions actions                \\\\\
/////                                                  \\\\\

COPY ~bg2fixpack/copy/ar1900n.wed~  ~override~ // fixed nighttime wed; see ar1900.are

//Creeping Doom's panic effect does not work
//see also sppr717.spl
//panic for 1 round, portrait icon, display string; save vs. spell at -2; power 0
COPY "bg2fixpack/copy/flpr717a.spl" override

COMPILE ~bg2fixpack/dlg/beta_soa-dlg.d~

ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN // tob only

  COMPILE ~bg2fixpack/dlg/beta_tob-dlg.d~

END

/////                                                  \\\\\
///// dialogue fixes                                   \\\\\
/////                                                  \\\\\

/////                                                  \\\\\
///// scripting fixes                                  \\\\\
/////                                                  \\\\\

// saemon brynnlaw -> sahuagin city sequence errors (8 changes)
// see ppsaem3.dlg (x2), ppsailor.dlg, ar1600.bcs, cut41q.bcs, cut41zf.bcs, cut41zg.bcs, ppsaem2.bcs
// add extra trigger so this won't fire twice
COPY_EXISTING ~ar1600.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Dead("ppright")~  ~GlobalLT("AsylumPlot","GLOBAL",78) Dead("ppright")~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// saemon brynnlaw -> sahuagin city sequence errors (8 changes)
// see ppsaem3.dlg (x2), ppsailor.dlg, ar1600.bcs, cut41q.bcs, cut41zf.bcs, cut41zg.bcs, ppsaem2.bcs
// many changes--clear actions, make uniterruptable, reorder textscreen, move saemon dialogue call here from ppsaem2.bcs
COPY_EXISTING ~cut41q.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~CutSceneId(Player1)~     ~CutSceneId(Player1) ClearAllActions() SetInterrupt(FALSE)~
    REPLACE_TEXTUALLY ~TextScreen("SCRTXT05")~  ~ActionOverride("ppsaem3",StartDialogueNoSet(Player1))~
    REPLACE_TEXTUALLY ~MultiPlayerSync()~       ~MultiPlayerSync() TextScreen("SCRTXT05")~
    REPLACE_TEXTUALLY ~Explore()~               ~Explore() SetInterrupt(TRUE)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// saemon brynnlaw -> sahuagin city sequence errors (8 changes)
// see ppsaem3.dlg (x2), ppsailor.dlg, ar1600.bcs, cut41q.bcs, cut41zf.bcs, cut41zg.bcs, ppsaem2.bcs
// clear actions, make uninterruptable
COPY_EXISTING ~cut41zf.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~CutSceneId(Player1)~                  ~CutSceneId(Player1) ClearAllActions() SetInterrupt(FALSE)~
    REPLACE_TEXTUALLY ~SetGlobal("AttackedGith","GLOBAL",1)~ ~SetGlobal("AttackedGith","GLOBAL",1) SetInterrupt(TRUE)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// saemon brynnlaw -> sahuagin city sequence errors (8 changes)
// see ppsaem3.dlg (x2), ppsailor.dlg, ar1600.bcs, cut41q.bcs, cut41zf.bcs, cut41zg.bcs, ppsaem2.bcs
// add a bit more time for sahuagin attack
COPY_EXISTING ~cut41zg.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~SetGlobalTimer("GithTimer1","GLOBAL",5)~ ~SetGlobalTimer("GithTimer1","GLOBAL",10)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// saemon brynnlaw -> sahuagin city sequence errors (8 changes)
// see ppsaem3.dlg (x2), ppsailor.dlg, ar1600.bcs, cut41q.bcs, cut41zf.bcs, cut41zg.bcs, ppsaem2.bcs
// false block for saemon initiating dialogue (moved to cut41q.bcs); add block to make saemon hostile if attacked
COPY_EXISTING ~ppsaem2.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Global("SaemInit1607","GLOBAL",0)~ ~False()~
    APPEND_FILE ~bg2fixpack/baf/ppsaem2.baf~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// Hendak should not randomly end up in some other part of the Copper Coronet if he performs a jump to arrive at Lehtinan's spot (Wisp)
COPY_EXISTING hendak.bcs override
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY EXACT_MATCH "SetHomeLocation([32.120])" "SetHomeLocation([526.1193])"
    REPLACE_TEXTUALLY EXACT_MATCH "JumpToPoint([526.1193])" "SetHomeLocation([526.1193]) JumpToPoint([526.1193])"
  COMPILE_BAF_TO_BCS
BUT_ONLY
UNLESS // True unless there already is a SetHomeLocation before JumpToPoint.
~AC
261OB
0 0 0 0 0 0 0 0 0 0 0 0 ""OB
OB
0 0 0 0 0 0 0 0 0 0 0 0 ""OB
OB
0 0 0 0 0 0 0 0 0 0 0 0 ""OB
0 526 1193 0 0"" "" AC
AC
48OB~

// Temple of Talos script can loop interminably if <CHARNAME> murders too wantonly (Nythrun and Wisp)
COPY_EXISTING ar0904.bcs override
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~^ *Dead("talmiss")~
                                          ~  Dead("talmiss")  Exists("talmiss2")  !Dead("talmiss2")~
    REPLACE_TEXTUALLY ~^ *Dead("talmiss2")~
                                          ~  Dead("talmiss2")  Exists("talmiss")  !Dead("talmiss")~
  COMPILE_BAF_TO_BCS
BUT_ONLY
UNLESS ~16465 0 1 0 0 "talmiss[2]?" "" OB~

// Drow etc. guarding the way out of the Underdark start to stutter if they are charmed after you have made an enemy of the Ust Natha (Wisp)
COPY_EXISTING dwgates1.bcs override
  DECOMPILE_AND_PATCH BEGIN
    REPLACE_TEXTUALLY ~!Allegiance(Myself,ENEMY)~ ~!Allegiance(Myself,ENEMY) !StateCheck(Myself,STATE_CHARMED)~
  END
BUT_ONLY
UNLESS ~16439 8192 1 0 0 "" "" OB~ //UNLESS !StateCheck(Myself,STATE_CHARMED)

//Surface elves by the Underdark exit can bail out prematurely (Wisp)
COPY_EXISTING udelf1.bcs override
              udelf2.bcs override
              udelf3.bcs override
  DECOMPILE_AND_PATCH BEGIN
    REPLACE_TEXTUALLY "\(See(\[PC\])[%LNL%%TAB% ]*CombatCounter(0)\)" "\1 !Detect([ENEMY])"
  END
BUT_ONLY
UNLESS ~16500 0 1 0 0 "" "" OB%LNL%255 0 0 0 0 0 0 0 0 0 0 0 ""OB~ //UNLESS !Detect([ENEMY])

// valygar drops his body if imprisoned
COPY_EXISTING valygar.bcs override
  DECOMPILE_AND_PATCH BEGIN
    REPLACE_TEXTUALLY ~\(Global("DropValygar","GLOBAL",0)\)~ ~Dead("Valygar") \1~
  END
BUT_ONLY

/////                                                  \\\\\
///// area fixes                                       \\\\\
/////                                                  \\\\\

//Unreferenced night tilesets (Nythrun)
//see also ar1900n.wed
COPY_EXISTING ar1900.are override
              ar2807.are override
  READ_SHORT   0x48 location_flags
  WRITE_SHORT  0x48 location_flags | 0x40
BUT_ONLY

/////                                                  \\\\\
///// creature file fixes                              \\\\\
/////                                                  \\\\\
  
// planar-prison guard can not make the actors hostile by shouting (Wisp)
COPY_EXISTING pcapt03.cre override
  FOR (i = 0x248; i < 0x270; i += 8) BEGIN
    READ_ASCII i script
    PATCH_IF "%script%" STRING_EQUAL_CASE shout BEGIN
      WRITE_ASCII i gensht01 (8)
    END
  END
BUT_ONLY

// A fair bunch of people are male with female sounds or vice versa (Wisp)
// Males with female sounds
COPY_EXISTING c6nerit.cre override
  WRITE_LONG 0xa4 61724 //I welcome you with outstretched hand.
  WRITE_LONG 0xb8 61732 //May the Gods protect me!
  WRITE_LONG 0xc8 61729 //Justice shall be swift and final!
  WRITE_LONG 0xec 61730
  WRITE_LONG 0xf0 61731
  WRITE_LONG 0x10c 61725 //I trust you are here in good faith.
  WRITE_LONG 0x110 61726 //May the Gods look upon you kindly.
  WRITE_LONG 0x114 61724 //I welcome you with outstretched hand.
  WRITE_LONG 0x118 61727 //All of the faithful are welcome, here.
BUT_ONLY

COPY_EXISTING vvshad2.cre override
  WRITE_LONG 0xa4 61885 //Explain your intent, and make it good!
  WRITE_LONG 0xb8 61890 //Must... return to the shadows!
  WRITE_LONG 0xc8 61886 //Beg for death and I'll make it quick!
  WRITE_LONG 0xcc 61887 //No one crosses the Shadow Thieves... and lives!
  WRITE_LONG 0xec 61888
  WRITE_LONG 0xf0 61889
  WRITE_LONG 0x10c 61882 //Good to see a like-minded friend-to-be.
  WRITE_LONG 0x110 61883 //Speak if ye will.
  WRITE_LONG 0x114 61884 //Is there something you seek?
  WRITE_LONG 0x118 61885 //Explain your intent, and make it good!
BUT_ONLY

COPY_EXISTING suelfw6.cre override
  WRITE_LONG 0xa4 61850 //Monsters!  There are monsters everywhere in Suldanessellar!
  WRITE_LONG 0xec 61853
  WRITE_LONG 0xf0 61852
  WRITE_LONG 0x10c 61847 //Wh-what has happened to the queen?  She has been taken, hasn't she!
  WRITE_LONG 0x110 61848 //It is... it is the Exile!  The Exile has returned!
  WRITE_LONG 0x114 61851 //This cannot be happening!  It cannot!
  WRITE_LONG 0x118 61850 //Monsters!  There are monsters everywhere in Suldanessellar!
BUT_ONLY

COPY_EXISTING cowenf1.cre override
  WRITE_LONG 0xa4 61862 //Declare yourself!
  WRITE_LONG 0xb8 61869 //Retreat!
  WRITE_LONG 0xc8 61866 //I'll test your mettle with cold steel!
  WRITE_LONG 0xec 61867
  WRITE_LONG 0xf0 61868
  WRITE_LONG 0x10c 61863 //Do not disturb my duties.
  WRITE_LONG 0x110 61864 //At ease, citizen.
  WRITE_LONG 0x114 61865 //I trust you have no hostile intentions.
  WRITE_LONG 0x118 61862 //Declare yourself!
BUT_ONLY

COPY_EXISTING ttser2.cre override
  WRITE_LONG 0xa4 61690 //Care to dance?
  WRITE_LONG 0xb8 61687 //Another time, another place!
  WRITE_LONG 0xc8 61779 //Plant a blade in your innards, I will!
  WRITE_LONG 0xec 61780
  WRITE_LONG 0xf0 61781
  WRITE_LONG 0x10c 61774 //Prepare to be eviscerated, fool.
  WRITE_LONG 0x110 61690 //Care to dance?
  WRITE_LONG 0x114 61777 //This will be a slow and painful process.
  WRITE_LONG 0x118 61778 //You will suffer... oh, yes.
BUT_ONLY

//Females with male sounds
COPY_EXISTING daelf.cre override
  WRITE_LONG 0xa4 11107 //Yeah?
  WRITE_LONG 0xec 11167
  WRITE_LONG 0xf0 11168
  WRITE_LONG 0x10c 11119 //Hello there.
  WRITE_LONG 0x110 11070 //Few of the fair folk concern themselves with the affairs of the state.
  WRITE_LONG 0x114 "-1"
BUT_ONLY

COPY_EXISTING kproen05.cre override
  WRITE_LONG 0xa4 61872 //I serve with my blade.
  WRITE_LONG 0xb8 61877 //Back... I must fall back!
  WRITE_LONG 0xc8 61874 //Cross blades with me and die!
  WRITE_LONG 0xec 61875
  WRITE_LONG 0xf0 61876
  WRITE_LONG 0x10c 61870 //Speak quickly, citizen, I have little time for this.
  WRITE_LONG 0x110 61871 //Good day to you.
  WRITE_LONG 0x114 61872 //I serve with my blade.
  WRITE_LONG 0x118 61873 //Do nothing stupid and there'll be no problems.
BUT_ONLY

COPY_EXISTING suelf8.cre override
  WRITE_LONG 0xa4 61856 //The Tree of Life!  'Tis the Tree that must be saved, before any of us!
  WRITE_LONG 0xec 61861
  WRITE_LONG 0xf0 61860
  WRITE_LONG 0x10c 61854 //This is the Exile's doing!
  WRITE_LONG 0x110 61855 //So... so many have died!  So many!
  WRITE_LONG 0x114 61856 //The Tree of Life!  'Tis the Tree that must be saved, before any of us!
  WRITE_LONG 0x118 61857 //Rillifane!  Rillifane save us, I beg you!
BUT_ONLY

COPY_EXISTING udelf05.cre override
  WRITE_LONG 0xa4 11063 //Greetings, adventurers.
  WRITE_LONG 0xec 11075
  WRITE_LONG 0xf0 11076
  WRITE_LONG 0x10c 11070 //Few of the fair folk concern themselves with the affairs of the state.
  WRITE_LONG 0x110 11065 //The Fair Folk will inherit the Earth.
  WRITE_LONG 0x114 11063 //Greetings, adventurers.
  WRITE_LONG 0x118 11070 //Few of the fair folk concern themselves with the affairs of the state.
BUT_ONLY

COPY_EXISTING ppmag01.cre override
  WRITE_LONG 0xa4 47345 //A woman on the high seas has t' be tougher than any mate.
  WRITE_LONG 0xec 51867
  WRITE_LONG 0xf0 51868
  WRITE_LONG 0x10c 47345 //A woman on the high seas has t' be tougher than any mate.
  WRITE_LONG 0x110 47347 //Ahhhh, don't look at me like that, or I'll gut ye where ye stand.
  WRITE_LONG 0x114 48338 //Grog.  Grog an' a bath.  Aye...
  WRITE_LONG 0x118 51494 //So I smells like fish.  Begone with ye.
  WRITE_LONG 0x1b8 47347 //Ahhhh, don't look at me like that, or I'll gut ye where ye stand.
BUT_ONLY

ACTION_IF GAME_IS tob BEGIN
  COPY_EXISTING ammonk05.cre override
        PATCH_IF SOURCE_SIZE > 0x2d3 BEGIN
          WRITE_LONG 0xa4 61994 //Do not anger me.
          WRITE_LONG 0xb8 "-1"
          WRITE_LONG 0xc8 61995 //You shall pay for this, and pay dearly.
          WRITE_LONG 0xcc 61996 //Suffer!
          WRITE_LONG 0xec 61997
          WRITE_LONG 0xf0 61998
          WRITE_LONG 0x10c 61993 //As always, the pleasure is mine.
        END
  BUT_ONLY
  
  COPY_EXISTING yssold16.cre override
        PATCH_IF SOURCE_SIZE > 0x2d3 BEGIN
          WRITE_LONG 0xa4 61980 //You are welcome in my sight.
          WRITE_LONG 0xc8 61981 //This is your end!
          WRITE_LONG 0xcc 61982 //You've made a fatal error in judgement.
          WRITE_LONG 0xec 61985
          WRITE_LONG 0xf0 61986
          WRITE_LONG 0x10c 61981 //This is your end!
          WRITE_LONG 0x110 61982 //You've made a fatal error in judgement.
        END
  BUT_ONLY
  
  COPY_EXISTING sargrd06.cre override
        PATCH_IF SOURCE_SIZE > 0x2d3 BEGIN
          WRITE_LONG 0xa4 4901 //Yer a handsome bunch, ain't ya?
          WRITE_LONG 0xec 12568
          WRITE_LONG 0xf0 12569
          WRITE_LONG 0x10c 4901 //Yer a handsome bunch, ain't ya?
        END
  BUT_ONLY

  COPY_EXISTING yaga02.cre override
        PATCH_IF SOURCE_SIZE > 0x2d3 BEGIN
          WRITE_LONG 0xa4 61625 //We will be saved in the End.
          WRITE_LONG 0xb8 61630 //Aiiiieee!!  I have failed him!!
          WRITE_LONG 0xec 61628
          WRITE_LONG 0xf0 61629
          WRITE_LONG 0x10c 61625 //We will be saved in the End.
        END
  BUT_ONLY
END

//Dawnmaster Kreel's amazing wardrobe change (Wisp)
COPY_EXISTING dawnmas.cre override
  o = 0x2c
  PATCH_FOR_EACH colour IN 226 238 237 201 228 226 200 BEGIN //Values courtesy of cscleric.cre
    WRITE_BYTE o colour
    ++o
  END
  REMOVE_CRE_ITEMS
  ADD_CRE_ITEM staf01 #0 #0 #0 none weapon1 EQUIP TWOHANDED
  ADD_CRE_ITEM chan01 #0 #0 #0 none armor
  ADD_CRE_ITEM rndtre02 #0 #0 #0 none inv7

//Tabitha should be immune to charm (Wisp)
COPY_EXISTING coplion.cre override
  LPF ADD_CRE_EFFECT
    INT_VAR
      opcode = 101 //immunity to opcode
      parameter2 = 5
      timing = 9
  END
  LPF ADD_CRE_EFFECT
    INT_VAR
      opcode = 296 //immunity to animation
      timing = 9
    STR_VAR
      resource = spnwchrm
  END
  PATCH_FOR_EACH parameter1 IN 14672 14780 8364 BEGIN
    LPF ADD_CRE_EFFECT
      INT_VAR
        opcode = 267 //protection from display string
        parameter1
        timing = 9
    END
  END
BUT_ONLY

//Sahuagin with a gnoll soundset; strip him of all sounds, as that is how other Sahuagin roll (Wisp)
COPY_EXISTING chevil04.cre override
  PATCH_FOR_EACH offset IN 0xc8 0xcc 0xec 0xf0 0x10c 0x110 BEGIN
    WRITE_LONG offset "-1"
  END
BUT_ONLY

/////                                                  \\\\\
///// item file fixes                                  \\\\\
/////                                                  \\\\\

//items with dispellable on-equip effects (Wisp)
COPY_EXISTING AURSTAF.ITM  override //Dispellable protection from projectile: BULLET
              DRAGRING.ITM override //Dispellable protection from projectile: ARROWHVY, AXE, BOLT, BULLET, DAGGER, DART
              ELEMCHAN.ITM override //Dispellable opcode 232, renewing globe of blades ability
              ELEMYANC.ITM override //Ditto
              IMPINVIS.ITM override //Dispellable invisibility (creatures should not be visible, ever)
              //IPSION.ITM   override //Dispellable virtually-everything; fixed elsewhere
              JONHP1.ITM   override //Dispellable protection from fiends
              KUORING.ITM  override //Dispellable immunity to slow
              LICH.ITM     override //Dispellable protection from fiends
              //MAGE01.ITM   override //Invisibility. Should probably be dispellable
              MAGE05.ITM   override //Free Action. Dispellable everything
              MAGE06.ITM   override //Dispellable Haste
              //NPPLAT.ITM   override //Partly dispellable Free Action; fixed elsewhere
              NPSW03.ITM   override //Dispellable opcode 232, for the 'retribution' type effect on the sword
              SLAYERWP.ITM override //Dispellable protection from projectile: ARROWHVY, AXE, BOLT, BULLET, DAGGER, DART
              SW1HSEEK.ITM override //Dispellable APR bonus
  READ_LONG 0x6a eo
  FOR (i = 0; i < SHORT_AT 0x70; ++i) BEGIN
    READ_BYTE eo + 0x30 * i + 0xd rd
    PATCH_IF rd = 1 OR rd = 3 BEGIN
      WRITE_BYTE eo + 0x30 * i + 0xd 2
    END
  END
BUT_ONLY

// allow arbitrary return-to-human form from clock of the wuff
// see also clck04, shapeshifting spell batch
COPY_EXISTING ~wolfm.itm~ ~override/cdwolfm.itm~
  LPF ADD_ITEM_EQEFFECT INT_VAR opcode = 60 target = 1 timing = 2 parameter1 = 100 END
  LPF ADD_ITEM_EQEFFECT INT_VAR opcode = 60 target = 1 timing = 2 parameter1 = 100 parameter2 = 1 END
  LPF ADD_ITEM_EQEFFECT INT_VAR opcode = 53 target = 1 timing = 2 parameter1 = 31488 END
  LPF ADD_ITEM_EQEFFECT INT_VAR opcode = 44 target = 1 timing = 2 parameter1 = 18 parameter2 = 1 END
  LPF ADD_ITEM_EQEFFECT INT_VAR opcode = 15 target = 1 timing = 2 parameter1 = 17 parameter2 = 1 END
  LPF ADD_ITEM_EQEFFECT INT_VAR opcode = 215 target = 1 parameter2 = 1 duration = 117 timing = 3 STR_VAR resource = sppolymp END
  LPF ADD_ITEM_EQEFFECT INT_VAR opcode = 215 target = 1 parameter2 = 1 duration = 117 timing = 3 STR_VAR resource = polyback END

// allow arbitrary return-to-human form from clock of the wuff
// see also cdwolfm, shapeshifting spell batch
COPY_EXISTING ~clck04.itm~ ~override~
  LPF DELETE_ITEM_EFFECT INT_VAR opcode_to_delete = "-1" END // delete all effects
  LPF ADD_ITEM_EFFECT INT_VAR opcode = 215 target = 1 parameter2 = 1 duration = 3 STR_VAR resource = sppolymp END
  LPF ADD_ITEM_EFFECT INT_VAR opcode = 215 target = 1 parameter2 = 1 duration = 3 STR_VAR resource = polyback END
  LPF ADD_ITEM_EFFECT INT_VAR opcode = 171 target = 1 duration = 120 STR_VAR resource = spin122 END
  LPF ADD_ITEM_EFFECT INT_VAR opcode = 111 target = 1 duration = 120 STR_VAR resource = cdwolfm END
  PATCH_FOR_EACH spell IN spin124 spin123 spin122 spwi491 spinhum spin160 spin160 spin160 BEGIN
    LPF ADD_ITEM_EFFECT INT_VAR opcode = 172 target = 1 timing = 1 STR_VAR resource = EVAL "%spell%" END
  END

//Flasher Master Bruiser Mates lack their advertised +1 to hit and have an undocumented save penalty (Wisp)
COPY_EXISTING bolt07.itm override
  READ_LONG  0x64 ao
  READ_SHORT 0x68 na
  READ_LONG  0x6a eo
  FOR (i = 0; i < na; ++i) BEGIN
    WRITE_SHORT ao + 0x38*i + 0x14 1
    READ_SHORT  ao + 0x38*i + 0x1e en
    READ_SHORT  ao + 0x38*i + 0x20 ei
    FOR (j = 0; j < en; ++j) BEGIN
      WRITE_LONG eo + 0x30*(ei + j) + 0x28 0
    END
  END
BUT_ONLY

//Give Root of the Problem a price (Wisp)
COPY_EXISTING blun10.itm override
  WRITE_LONG 0x34 2750
BUT_ONLY

//Asp's Nest darts do 1 HP damage every second for 40 seconds but are stated to do 1 HP damage every 3 seconds for 120 seconds (Wisp)
COPY_EXISTING dart05.itm override
  PATCH_IF SOURCE_SIZE > 0x71 BEGIN
    READ_LONG  0x64 ao
    READ_SHORT 0x68 na
    READ_LONG  0x6a eo
    FOR (i=0;i<na;i+=1) BEGIN
      READ_SHORT ao + 0x38*i + 0x1e en ELSE 0
      READ_SHORT ao + 0x38*i + 0x20 ei ELSE 0
      FOR (j=0;j<en;j+=1) BEGIN
        READ_SHORT eo + 0x30*(ei + j) type ELSE 999
        PATCH_IF type = 25 BEGIN
          WRITE_LONG  eo + 0x30*(ei + j) + 0x4  3
          WRITE_LONG  eo + 0x30*(ei + j) + 0x8  3
          WRITE_LONG  eo + 0x30*(ei + j) + 0xe  120
        END ELSE BEGIN
          WRITE_LONG eo + 0x30*(ei + j) + 0xe 120
        END
      END
    END
  END
BUT_ONLY

//Belt of Inertial Barrier displays MR icon instead of Resistance to Magic Energy (Wisp)
COPY_EXISTING belt10.itm override
  READ_LONG  0x6a eo
  FOR (i = 0; i < SHORT_AT 0x70; ++i) BEGIN
    READ_SHORT eo + 0x30 * i type
    READ_LONG  eo + 0x30 * i + 0x8 p2
    PATCH_IF type = 142 AND p2 = 63 BEGIN //Display icon; magic resistance
      WRITE_LONG eo + 0x30 * i + 0x8 73 //Protection from Magical Energy
    END
  END
BUT_ONLY

// paralyze not universal
COPY_EXISTING ~demmau01.itm~ ~override~
  LPF DELETE_ITEM_EFFECT INT_VAR opcode_to_delete = 109 END
  LPF ADD_ITEM_EFFECT INT_VAR opcode = 109 target = 2 param2 = 2 resist_dispel = 1 duration = 30 probability1 = 15 savingthrow = BIT2 END
  LPF cd_item_alter_effect INT_VAR opcode = 174 duration_high = 30 END // unparalyze sound

// unparalyze sould plays too late
COPY_EXISTING ~ghoul1.itm~ ~override~
  LPF cd_item_alter_effect INT_VAR opcode = 174 duration_high = 30 END

// paralyze not universal
COPY_EXISTING ~ghoullor.itm~ ~override~
              ~lacedo.itm~   ~override~
              ~lacedo02.itm~ ~override~
              ~lich02.itm~   ~override~
  LPF DELETE_ITEM_EFFECT INT_VAR opcode_to_delete = 109 END
  LPF ADD_ITEM_EFFECT INT_VAR opcode = 109 target = 2 param2 = 2 resist_dispel = 1 duration = 30 savingthrow = BIT2 END
  LPF cd_item_alter_effect INT_VAR opcode = 174 duration_high = 30 END // unparalyze sound

// ghoul lors nauseated icon lasts too long
COPY_EXISTING ~ghoullor.itm~ ~override~
  READ_LONG  0x64 abil_off
  READ_SHORT 0x68 abil_num
  READ_LONG  0x6a fx_off
  FOR (index = 0 ; index < abil_num ; ++index) BEGIN
    READ_SHORT  (abil_off + 0x20 + (index * 0x38)) abil_fx_idx
    READ_SHORT  (abil_off + 0x1e + (index * 0x38)) abil_fx_num
    FOR (index2 = 0 ; index2 < abil_fx_num ; ++index2) BEGIN
      READ_SHORT (fx_off +        ((abil_fx_idx + index2) * 0x30)) opcode
      READ_LONG  (fx_off + 0x08 + ((abil_fx_idx + index2) * 0x30)) icon
      PATCH_IF ((opcode = 142) AND (icon = 7)) BEGIN // nauseated icon
        WRITE_LONG  (fx_off + 0x0e + ((abil_fx_idx + index2) * 0x30)) 100 // duration
      END
    END
  END
  BUT_ONLY

// add arcane spell failure (CamDawg)
COPY_EXISTING ~scrl12.itm~ ~override~ //cursed scroll of foolishness
  LAUNCH_PATCH_FUNCTION ~ADD_ITEM_EFFECT~ INT_VAR
    opcode        = 60  // spell failure
    target        = 1   // target self
    duration      = 600 // duration
    resist_dispel = 1   // dispel/bypass MR
    parameter1    = 50  // 50% spell failure
    power         = 4   // power
  END
  BUT_ONLY

// add feeblemind icon (CamDawg)
COPY_EXISTING ~scrl18.itm~ ~override~ // cursed scroll of stupidity
  LAUNCH_PATCH_FUNCTION ~ADD_ITEM_EFFECT~ INT_VAR
    opcode        = 142 // display portrait icon
    target        = 1   // target self
    resist_dispel = 1   // dispel/bypass MR
    duration      = 45  // duration
    parameter2    = 48  // feeblemind
    power         = 4   // power
  END
  BUT_ONLY

//Staff of Curing does not cure portrait icons (Wisp)
COPY_EXISTING staf10.itm override
  PATCH_FOR_EACH parameter2 IN 5 6 7 BEGIN //Intoxication, poison, disease
    LPF ADD_ITEM_EFFECT
      INT_VAR
        opcode = 240
        target = 2
        power = 2
        parameter2
        timing = 1
        resist_dispel = 3
    END
  END
BUT_ONLY

/////                                                  \\\\\
///// spell fixes                                      \\\\\
/////                                                  \\\\\

//Set power of summoning spells to 0, otherwise they can get blocked if the caster is under (M)GoI (code by Wisp; general idea by lotsa people)
COPY_EXISTING
  melis03.spl override //Taint of the Slayer
  senspisu.spl override //Summon Spider
  spcl621.spl override //Summon Spirit Animal
  spcl923.spl override //Summon Deva
  //spin534.spl override //Call Dark Horde, unused
  //spin548.spl override //Gate, power is 0, unused
  //spin549.spl override //Summon the Infernal Host, power is 0
  //spin569.spl override //Summon Ice Salamander, power is 0
  //spin570.spl override //Summon Fire Elemental, power is 0, unused
  spin615.spl override //Knight
  spin616.spl override //Flames
  spin622.spl override //Skull
  //spin631.spl override //Construct, unused
  //spin637.spl override //Guile, unused
  //spin638.spl override //Triumph, unused
  //spin677.spl override //<Invalid Strref -1>, power is 0, unused
  //spin730.spl override //Summon Fungus, power is 0
  //spin735.spl override //Wish, power is 0
  //spin841.spl override //<Invalid Strref -1>, power is 0, unused
  //spin842.spl override //<Invalid Strref -1>, power is 0, unused
  //spin843.spl override //<Invalid Strref -1>, power is 0, unused
  //spin844.spl override //<Invalid Strref -1>, power is 0, unused
  //spin845.spl override //<Invalid Strref -1>, power is 0, unused
  //spin855.spl override //<Invalid Strref -1>, power is 0
  //spin856.spl override //<Invalid Strref -1>, power is 0
  //spin857.spl override //<Invalid Strref -1>, power is 0
  //spin870.spl override //<Invalid Strref -1>, power is 0
  //spin880.spl override //<Invalid Strref -1>, power is 0
  sppr301.spl override //Animate Dead
  sppr402.spl override //Animal summoning I
  sppr410.spl override //Call Woodland Beings
  sppr501.spl override //Animal summoning II
  sppr601.spl override //Aerial Servant
  sppr602.spl override //Animal summoning III
  sppr604.spl override //Conjure Animals
  sppr605.spl override //Conjure Fire Elemental
  sppr702.spl override //Conjure Earth Elemental
  sppr703.spl override //Gate
  sppr723.spl override //Elemental Summoning
  sppr724.spl override //Greater Elemental Summoning
  sppr726.spl override //Summon Deva
  sppr727.spl override //Summon Fallen Deva
  //spra304.spl override //Animal summoning I, power is 0
  spra305.spl override //Animal summoning II
  spra306.spl override //Animal summoning III
  spwi309.spl override //Monster summoning I
  spwi407.spl override //Monster summoning II
  spwi423.spl override //Spider Spawn
  spwi501.spl override //Animate Dead
  spwi504.spl override //Monster summoning III
  spwi516.spl override //Conjure Lesser Fire Elemental
  spwi520.spl override //Conjure Lesser Air Elemental
  spwi521.spl override //Conjure Lesser Earth Elemental
  spwi601.spl override //Invisible Stalker
  spwi619.spl override //Wyvern Call
  spwi620.spl override //Conjure Fire Elemental
  spwi621.spl override //Conjure Air Elemental
  spwi622.spl override //Conjure Earth Elemental
  spwi623.spl override //Carrion Summons
  spwi624.spl override //Summon Nishruu
  spwi707.spl override //Cacofiend
  spwi716.spl override //Mordenkainen's Sword
  spwi717.spl override //Summon Efreeti
  spwi718.spl override //Summon Djinni
  spwi719.spl override //Summon Hakeashar
  //spwi722.spl override //Limited Wish, power is 0
  spwi807.spl override //Summon Fiend
  spwi905.spl override //Gate
  spwi923.spl override //Summon Planetar
  spwi924.spl override //Summon Dark Planetar
  spwish18.spl override //Summon Dark Planetar
  spwm154.spl override //Cacofiend
  sumslay.spl override //Summon Slayer Shadow
  FOR (READ_LONG 0x6a fx_off ELSE 0;fx_off<SOURCE_SIZE;fx_off+=0x30) BEGIN
    WRITE_BYTE fx_off + 3 0
  END
BUT_ONLY

// handle separately since it's on its own specific header (paralyze targeting)
COPY_EXISTING ~spcl415.spl~ ~override~ // target 2, power 3, 3/1, dur 30, spell -1 (min lev 11)
  LPF cd_spell_alter_effect INT_VAR header = 2 opcode = 142 opcode_new = 999 END
  LPF DELETE_SPELL_EFFECT INT_VAR opcode_to_delete = 215 END // delete existing visual
  LPF DELETE_SPELL_EFFECT INT_VAR opcode_to_delete = 999 END // delete existing portrait icon, spcl415
  LPF ADD_SPELL_EFFECT INT_VAR opcode = 177 target = 2 power = 3 parameter1 = 1 parameter2 = 3 resist_dispel = 1
    timing = 1 savingthrow = BIT0 savebonus = "-1" header = 2 STR_VAR resource = cdheld END
  LPF ADD_SPELL_EFFECT INT_VAR opcode = 177 target = 2 power = 3 parameter1 = 1 parameter2 = 3 resist_dispel = 1
    duration = 30 savingthrow = BIT0 savebonus = "-1" header = 2 STR_VAR resource = cdhda30 END
  LPF ADD_SPELL_EFFECT INT_VAR opcode = 177 target = 2 power = 3 parameter1 = 1 parameter2 = 3 resist_dispel = 1
    duration = 30 savingthrow = BIT0 savebonus = "-1" header = 2 STR_VAR resource = cdhdb30 END

// create unique spinny animation for horror (see cdhorror, fear immunity batches)
COPY_EXISTING ~spin105.spl~ ~override~ // horror, innate
              ~spwi205.spl~ ~override~ // horror, arcane
  READ_LONG  0x64 abil_off
  READ_SHORT 0x68 abil_num
  READ_LONG  0x6a fx_off
  FOR (index = 0 ; index < abil_num ; ++index) BEGIN
    READ_SHORT (abil_off + 0x1e + (0x28 * index)) abil_fx_num
    READ_SHORT (abil_off + 0x20 + (0x28 * index)) abil_fx_idx
    FOR (index2 = 0 ; index2 < abil_fx_num ; ++index2) BEGIN
      READ_SHORT (fx_off +        ((abil_fx_idx + index2) * 0x30)) opcode
      READ_ASCII (fx_off + 0x14 + ((abil_fx_idx + index2) * 0x30)) resref
      PATCH_IF ((opcode = 215) AND ("%resref%" STRING_COMPARE_CASE "spmindat" = 0)) BEGIN
        WRITE_ASCII (fx_off + 0x14 + ((abil_fx_idx + index2) * 0x30)) ~cdhorror~
      END
    END
  END
  BUT_ONLY

// allow arbitrary return-to-human form from clock of the wuff
// see also clck04, cdwolfm
COPY_EXISTING ~spin122.spl~ ~override~
              ~spin123.spl~ ~override~
              ~spin124.spl~ ~override~
              ~spin150.spl~ ~override~
              ~spin151.spl~ ~override~
              ~spin152.spl~ ~override~
              ~spin153.spl~ ~override~
              ~spin154.spl~ ~override~
              ~spin155.spl~ ~override~
              ~spin156.spl~ ~override~
              ~spin157.spl~ ~override~
              ~spinhum.spl~ ~override~
              ~spwi489.spl~ ~override~
              ~spwi490.spl~ ~override~
              ~spwi491.spl~ ~override~
              ~spwi493.spl~ ~override~
              ~spwi494.spl~ ~override~
              ~spwi495.spl~ ~override~
              ~spwi496.spl~ ~override~
              ~spwi497.spl~ ~override~
              ~spwi498.spl~ ~override~
  LPF ADD_SPELL_EFFECT INT_VAR opcode = 112 target = 1 timing = 1 STR_VAR resource = cdwolfm END

// associated hold effects playing on non-affected creatures
COPY_EXISTING ~spin648.spl~ ~override~ // target 2, power 1, 3/1, dur 60, no save
              ~spin988.spl~ ~override~ // target 2, power 3, 3/1, dur 60, spell -1
              ~sppr208.spl~ ~override~ // target 2, power 2, 3/1, dur 60, spell 0
              ~sppr989.spl~ ~override~ // target 2, power 3, 3/1, dur 60, spell -1
              ~spwi306.spl~ ~override~ // target 2, power 3, 3/1, dur 60, spell -1
              ~spwm122.spl~ ~override~ // target 2, power 2, 3/1, dur 60, spell 0
  LPF DELETE_SPELL_EFFECT INT_VAR opcode_to_delete = 142 END // delete existing portrait icon
  LPF DELETE_SPELL_EFFECT INT_VAR opcode_to_delete = 215 END // delete existing visual
  LPF DELETE_SPELL_EFFECT INT_VAR opcode_to_delete = 139 END // delete existing string
  // add new icon and animation via eff, adjust as needed below
  LPF ADD_SPELL_EFFECT INT_VAR opcode = 177 target = 2 power = 3 parameter1 = 1 parameter2 = 3 resist_dispel = 1
    timing = 1 savingthrow = BIT0 savebonus = "-1" STR_VAR resource = cdheld END
  LPF ADD_SPELL_EFFECT INT_VAR opcode = 177 target = 2 power = 3 parameter1 = 1 parameter2 = 3 resist_dispel = 1 
    duration = 60 savingthrow = BIT0 savebonus = "-1" STR_VAR resource = cdhda60 END
  LPF ADD_SPELL_EFFECT INT_VAR opcode = 177 target = 2 power = 3 parameter1 = 1 parameter2 = 3 resist_dispel = 1
    duration = 60 savingthrow = BIT0 savebonus = "-1" STR_VAR resource = cdhdb60 END

// fix power, saves
COPY_EXISTING ~spin648.spl~ ~override~
  LPF cd_spell_alter_effect INT_VAR opcode = 177 power = 1 savingthrow = 0 savebonus = 0 END

// fix power, saves
COPY_EXISTING ~sppr208.spl~ ~override~
              ~spwm122.spl~ ~override~
  LPF cd_spell_alter_effect INT_VAR opcode = 177 power = 2 savebonus = 0 END

// handle separately due to durations
COPY_EXISTING ~sppr305.spl~ ~override~
  // first, get abil 1 effects correct before extending headers
  LPF cd_spell_alter_effect INT_VAR opcode = 215 opcode_new = 177 parameter1 = 2 parameter2 = 3 timing = 1 duration = 0 STR_VAR resource = cdheld END
  LPF ADD_SPELL_EFFECT INT_VAR opcode = 177 target = 2 power = 3  parameter1 = 2 parameter2 = 3 resist_dispel = 1
    duration = 60 savingthrow = BIT0 STR_VAR resource = cdhda60 END
  LPF ADD_SPELL_EFFECT INT_VAR opcode = 177 target = 2 power = 3 parameter1 = 2 parameter2 = 3 resist_dispel = 1
    duration = 60 savingthrow = BIT0 STR_VAR resource = cdhdb60 END
  READ_LONG  0x64 abil_off
  READ_SHORT 0x68 abil_num
  READ_LONG  0x6a fx_off
  WHILE (abil_num < 16) BEGIN // build out ability headers
    READ_ASCII (abil_off +        ((abil_num - 1) * 0x28)) abil_last (0x28) // clone last ability
    READ_SHORT (abil_off + 0x1e + ((abil_num - 1) * 0x28)) abil_fx_num
    READ_SHORT (abil_off + 0x20 + ((abil_num - 1) * 0x28)) abil_fx_idx
    READ_ASCII (fx_off +        (abil_fx_idx * 0x30)) fx_last (abil_fx_num * 0x30) // clone fx block
    // now insert new effects for new ability
    INSERT_BYTES (fx_off + (0x30 * (abil_fx_idx + abil_fx_num))) (abil_fx_num * 0x30) // insert new block of effects
    WRITE_ASCIIE (fx_off + (0x30 * (abil_fx_idx + abil_fx_num))) "%fx_last%"          // write old block info
    FOR (index = 0 ; index < abil_fx_num ; ++index) BEGIN // adjust durations of new effects
      READ_SHORT (fx_off +        (0x30 * (abil_fx_idx + abil_fx_num + index))) opcode
      READ_LONG  (fx_off + 0x0e + (0x30 * (abil_fx_idx + abil_fx_num + index))) duration
      PATCH_IF (duration > 5) BEGIN
        SET duration += 12
        WRITE_LONG (fx_off + 0x0e + (0x30 * (abil_fx_idx + abil_fx_num + index))) duration // 2 rounds per level
        PATCH_IF (opcode = 177) BEGIN
          WRITE_ASCIIE (fx_off + 0x19 + (0x30 * (abil_fx_idx + abil_fx_num + index))) "%duration%"
        END
      END
    END
    // now insert new ability
    INSERT_BYTES (abil_off + (abil_num * 0x28)) 0x28
    WRITE_ASCIIE (abil_off + (abil_num * 0x28)) "%abil_last%"
    WRITE_SHORT (abil_off + 0x10 + (abil_num * 0x28)) (abil_num + 5) // min level
    WRITE_SHORT (abil_off + 0x20 + (abil_num * 0x28)) (abil_fx_idx + abil_fx_num) // index to new effect
    // update counters
    fx_off += 0x28
    abil_num += 1
  END
  WRITE_SHORT 0x68 abil_num
  WRITE_LONG  0x6a fx_off

//Creeping Doom's panic effect does not work; replace the repeating eff with delayed effects (Wisp)
//see also flpr717a.spl
COPY_EXISTING sppr717.spl override //Creeping Doom
  PATCH_IF SOURCE_SIZE > 0x71 BEGIN
    READ_LONG  0x64 ao
    READ_SHORT 0x68 na
    READ_LONG  0x6a eo
    en = 0
    ei = 0
    FOR (i=0;i<na;i+=1) BEGIN
      ei += en
      WRITE_SHORT ao + 0x28*i + 0x20 ei
      READ_SHORT  ao + 0x28*i + 0x1e en
      FOR (j=0;j<en;j+=1) BEGIN
        READ_SHORT eo + 0x30*(ei + j) type ELSE 999
        READ_ASCII eo + 0x30*(ei + j) + 0x14 rr ELSE blank
        PATCH_IF type = 272 AND "%rr%" STRING_EQUAL_CASE panic BEGIN
          DELETE_BYTES eo + 0x30*(ei + j) 0x30
          en -= 1
          j -= 1
          PATCH_FOR_EACH time IN 0 6 12 BEGIN
            INSERT_BYTES eo + 0x30*(ei + j)        0x30
            WRITE_SHORT  eo + 0x30*(ei + j)        146 //Cast spell (at creature)
            WRITE_BYTE   eo + 0x30*(ei + j) + 0x2  2
            WRITE_BYTE   eo + 0x30*(ei + j) + 0x3  7
            WRITE_LONG   eo + 0x30*(ei + j) + 0x8  1
            WRITE_BYTE   eo + 0x30*(ei + j) + 0xc  4
            WRITE_BYTE   eo + 0x30*(ei + j) + 0xd  1
            WRITE_LONG   eo + 0x30*(ei + j) + 0xe  time
            WRITE_BYTE   eo + 0x30*(ei + j) + 0x12 100
            WRITE_ASCII  eo + 0x30*(ei + j) + 0x14 flpr717a #8
            en += 1
            j += 1
          END
        END
      END
      WRITE_SHORT ao + 0x28*i + 0x1e en
    END
  END
BUT_ONLY

// Chromatic Orb is supposed to cause blindness at level one but instead causes -4 penalties to AC, THAC0, and saves. (CamDawg)
COPY_EXISTING ~spwi118.spl~ ~override~
              ~spdr101.spl~ ~override~
  PATCH_FOR_EACH "deleteme" IN 34 35 36 37 BEGIN
    LPF DELETE_SPELL_EFFECT INT_VAR opcode_to_delete = %deleteme% END
  END
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  READ_SHORT  ("%abil_off%" + 0x20) "abil_fx_idx" // lev 1
  READ_SHORT  ("%abil_off%" + 0x1e) "abil_fx_num" // lev 1
  FOR (index = 0 ; index < abil_fx_num ; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +                (0x30 * ("%abil_fx_idx%" + "%index%"))) "opcode"
    PATCH_IF ("%opcode%" = 0) BEGIN // change ac bonus to blindness
      WRITE_SHORT ("%fx_off%" +             (0x30 * ("%abil_fx_idx%" + "%index%"))) 74 // blindness
    END
    PATCH_IF ("%opcode%" = 54) BEGIN // change thac0 bonus to blind icon
      WRITE_SHORT ("%fx_off%" +             (0x30 * ("%abil_fx_idx%" + "%index%"))) 142 // display portrait icon
      WRITE_LONG  ("%fx_off%" + 0x08 + (0x30 * ("%abil_fx_idx%" + "%index%")))   8 // blindness
    END
    PATCH_IF ("%opcode%" = 33) BEGIN // change one of the saves to blinded string
      WRITE_SHORT ("%fx_off%" +             (0x30 * ("%abil_fx_idx%" + "%index%")))   139 // display string
      WRITE_LONG  ("%fx_off%" + 0x04 + (0x30 * ("%abil_fx_idx%" + "%index%"))) 14674 // 'blinded'
      WRITE_BYTE  ("%fx_off%" + 0x0c + (0x30 * ("%abil_fx_idx%" + "%index%")))       1 // instant/perm
      WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index%")))       0 // duration
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// holy smite/unholy blight damage fixes, part 3 (CamDawg)
// see also sp313l02.eff through sp313l10.eff
COPY_EXISTING ~sppr313.spl~ ~override~ // holy smite
              ~sppr314.spl~ ~override~ // unholy blight
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x10 + (0x28 * "%index%")) "level"
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    PATCH_IF ("%level%" = 1) BEGIN SET "level" = 5 END
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "eff_file"
      PATCH_IF ("%eff_file%" STRING_COMPARE_REGEXP "SP313L[012][0-9]" = 0) BEGIN // if damage eff
        READ_LONG ("%fx_off%" + 0x24 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "save"
        SET "efflev" = (("%level%" + "%save%") / 2)
        PATCH_IF ("%efflev%" = 10) BEGIN
          WRITE_ASCIIE ("%fx_off%" + 0x1a + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "%efflev%"
        END ELSE BEGIN
          WRITE_ASCIIE ("%fx_off%" + 0x1a + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "0%efflev%"
        END
      END
    END
  END
  BUT_ONLY

// armor glow missing at level one (CamDawg)
COPY_EXISTING ~spwi113.spl~ ~override~
  LPF ADD_SPELL_EFFECT INT_VAR    
    opcode        = 9          // color glow
    target        = 2          // preset target
    power         = 1          // power
    parameter1    = 0x5d6f0000 // pulse, RGB
    parameter2    = 0x00140005 // armor, cycle speed
    duration      = 12         // duration
    resist_dispel = 3          // dispel/bypass MR
    header        = 1          // add to first header
  END

/////                                                  \\\\\
///// store fixes                                      \\\\\
/////                                                  \\\\\

/////                                                  \\\\\
///// pro fixes                                        \\\\\
/////                                                  \\\\\

/////                                                  \\\\\
///// vvc fixes                                        \\\\\
/////                                                  \\\\\

// create unique spinny animation for horror (see spin105, spwi205, fear immunity batches)
COPY_EXISTING ~spmindat.vvc~ ~override/cdhorror.vvc~

/////                                                  \\\\\
///// eff fixes                                        \\\\\
/////                                                  \\\\\

// new eff for holy smite; needs to display blind icon for blinded creatures
COPY_EXISTING ~blind.eff~    ~override/cdblind.eff~
  WRITE_LONG 0x10 142 // display portrait icon
  WRITE_LONG 0x20 8   // icon: blinded

// new eff for holy smite; needs to display blinded string for blinded creatures
COPY_EXISTING ~blind.eff~    ~override/cdblind1.eff~
  WRITE_LONG 0x10 139   // display string
  WRITE_LONG 0x1c 14674 // string: blinded

COPY_EXISTING ~cdblind1.eff~ ~override/cdheld.eff~
  WRITE_LONG 0x1c 14102 // 'held'
  WRITE_LONG 0x24 1     // instant/perm
  WRITE_LONG 0x28 0     // duration

COPY_EXISTING ~cdblind.eff~ ~override/cdhda30.eff~
  WRITE_LONG 0x20 13 // held icon
  WRITE_LONG 0x28 30 // duration

COPY_EXISTING ~dawnvis.eff~ ~override/cdhdb30.eff~
  WRITE_LONG  0x18 0          // power
  WRITE_LONG  0x28 30         // duration
  WRITE_ASCII 0x30 ~spmindat~ // swirly anim

// create extended effs for hold animal; use abil_num from spell patch
OUTER_FOR (index = 60 ; index < 241 ; index += 12) BEGIN

  COPY_EXISTING ~cdhda30.eff~ ~override/cdhda%index%.eff~
                ~cdhdb30.eff~ ~override/cdhdb%index%.eff~
    WRITE_LONG 0x28 index // duration

END

// new eff for (un)holy word to display deaf icon; see sppr710.spl, sppr715.spl
COPY_EXISTING ~iconslow.eff~ ~override/icondeaf.eff~
  WRITE_LONG 0x20 112 // deafened
  
// holy smite/unholy blight damage fixes, part 1 (CamDawg)
// see also sppr313.spl, sppr314.spl
COPY_EXISTING ~sp313l05.eff~ ~override~
              ~sp313l06.eff~ ~override~
              ~sp313l07.eff~ ~override~
              ~sp313l08.eff~ ~override~
              ~sp313l09.eff~ ~override~
              ~sp313l10.eff~ ~override~
  WRITE_LONG 0x3c 4 // dice size 2 > 4
  BUT_ONLY

// holy smite/unholy blight damage fixes, part 2 (CamDawg)
// see also sppr313.spl, sppr314.spl
OUTER_SET "dicethrown" = 2
COPY_EXISTING ~sp313l05.eff~ ~override/sp313l02.eff~
              ~sp313l06.eff~ ~override/sp313l03.eff~
              ~sp313l07.eff~ ~override/sp313l04.eff~
  WRITE_LONG 0x38 "%dicethrown%" // # dice
  SET "dicethrown" = ("%dicethrown%" + 1)

/////                                                  \\\\\
///// bam fixes                                        \\\\\
/////                                                  \\\\\

//Correct invalid animation frames & offsets
COPY_EXISTING ~mtang21.bam~  ~override~ //Tanar'ri (Balor)
              ~mtang21e.bam~ ~override~
              ~mtang22.bam~  ~override~
              ~mtang22e.bam~ ~override~
              ~mtang23.bam~  ~override~
              ~mtang23e.bam~ ~override~
              ~mwyvg21.bam~  ~override~ //Wyvern
              ~mwyvg22.bam~  ~override~
              ~mwyvg23.bam~  ~override~
              ~mwyvg24.bam~  ~override~
  INNER_PATCH ~%SOURCE_RES%~ BEGIN
    READ_ASCII 6 bn (1) //Read BAM series (1-4)
  END
  READ_ASCII 0x0 sg (4) //Signature
  PATCH_IF (~%sg%~ STRING_EQUAL_CASE ~BAMC~ = 1) BEGIN //If compressed
    READ_LONG 0x8 dl //Uncompressed data length
    DECOMPRESS_REPLACE_FILE 0xc (SOURCE_SIZE - 0xc) dl
    sz = dl
  END ELSE BEGIN
    sz = SOURCE_SIZE
  END
  READ_SHORT 0x8 fm //Frame count
  READ_LONG 0xc ft //Frame entry offset
  FOR (f1 = 0; f1 < fm; f1 += 1) BEGIN //Frame loop
    READ_SHORT (ft + (f1 * 0xc)) fw //Frame width
    READ_SHORT (ft + (f1 * 0xc) + 2) fh //Frame height
    PATCH_IF ((fw < 1) AND (fh != 0)) OR ((fh < 1) AND (fw != 0)) BEGIN //If invalid dimensions
      WRITE_SHORT (ft + (f1 * 0xc)) 0 //Correct width
      WRITE_SHORT (ft + (f1 * 0xc) + 2) 0 //Correct height
      fw = 0
      fh = 0
    END
    PATCH_IF bn = 1 BEGIN //If upper left frame
      WRITE_SHORT (ft + (f1 * 0xc) + 4) fw //X coordinate
      WRITE_SHORT (ft + (f1 * 0xc) + 6) (fh + 40) //Y coordinate
    END ELSE BEGIN
      PATCH_IF bn = 2 BEGIN //If upper right frame
        WRITE_SHORT (ft + (f1 * 0xc) + 4) 0 //X coordinate
        WRITE_SHORT (ft + (f1 * 0xc) + 6) (fh + 40) //Y coordinate
      END ELSE BEGIN
        PATCH_IF bn = 3 BEGIN //If lower left frame
          WRITE_SHORT (ft + (f1 * 0xc) + 4) fw //X coordinate
          WRITE_SHORT (ft + (f1 * 0xc) + 6) 40 //Y coordinate
        END ELSE BEGIN
          PATCH_IF bn = 4 BEGIN //If lower right frame
            WRITE_SHORT (ft + (f1 * 0xc) + 4) 0 //X coordinate
            WRITE_SHORT (ft + (f1 * 0xc) + 6) 40 //Y coordinate
          END
        END
      END
    END
  END
  COMPRESS_REPLACE_FILE 0 sz 9
  INSERT_BYTES 0x0 0xc
  WRITE_ASCII 0x0 ~BAMCV1  ~
  WRITE_LONG 0x8 dl
BUT_ONLY

/////                                                  \\\\\
///// immunity effects batches                         \\\\\
/////                                                  \\\\\

// The Reflection shield should protect the wielder against Ice Arrows (Wisp)

COPY_EXISTING shld24.itm override
  PATCH_IF SOURCE_SIZE > 0x71 BEGIN
    READ_LONG  0x64 ab_off
    READ_SHORT 0x68 num_ab
    READ_LONG  0x6a fx_off
    READ_SHORT 0x70 num_fx
    FOR (i=0;i<num_fx;i+=1) BEGIN
      READ_SHORT fx_off + 0x30*i fx_type
      PATCH_IF fx_type = 197 BEGIN
        READ_LONG fx_off + 0x30*i + 0x8 pro
        SET $fl#pro_shld24("%pro%") = 1
      END
    END
    PATCH_FOR_EACH pro IN 1 3 4 6 9 11 13 14 15 16 19 26 29 31 34 102 BEGIN
      PATCH_IF !VARIABLE_IS_SET $fl#pro_shld24("%pro%") BEGIN
        INSERT_BYTES fx_off + 0x30*num_fx        0x30
        WRITE_SHORT  fx_off + 0x30*num_fx        197
        WRITE_BYTE   fx_off + 0x30*num_fx + 0x2  1
        WRITE_LONG   fx_off + 0x30*num_fx + 0x8  pro
        WRITE_BYTE   fx_off + 0x30*num_fx + 0xc  2
        WRITE_BYTE   fx_off + 0x30*num_fx + 0x12 100
        num_fx += 1
      END
    END
    WRITE_SHORT 0x70 num_fx
    FOR (i=0;i<num_ab;i+=1) BEGIN
      WRITE_SHORT ab_off + 0x38*i + 0x20 num_fx
      num_fx += SHORT_AT ab_off + 0x38*i + 0x1e
    END
  END
BUT_ONLY

// The Physical Mirror spell should protect the recipient against Bolts of Lightning (crossbow ammo type), Firetooth bolts (crossbow) and Arrows of Fire (bow ammo type). (Wisp)

COPY_EXISTING sppr613.spl override
  PATCH_IF SOURCE_SIZE > 0x71 BEGIN
    READ_LONG  0x64 ab_off
    READ_SHORT 0x68 num_ab
    READ_LONG  0x6a fx_off
    READ_SHORT 0x70 fx_idx
    num_fx = 0
    FOR (i=0;i<num_ab;i+=1) BEGIN
      fx_idx += num_fx
      READ_SHORT  ab_off + 0x28*i + 0x1e num_fx
      WRITE_SHORT ab_off + 0x28*i + 0x20 fx_idx
      FOR (j=0;j<num_fx;j+=1) BEGIN
        READ_SHORT fx_off + 0x30*(fx_idx + j) fx_type
        PATCH_IF fx_type = 197 BEGIN
          READ_LONG  fx_off + 0x30*(fx_idx + j) + 0x8 pro
          SET $fl#pro_sppr613("%i%" "%pro%") = 1
        END
      END
      PATCH_FOR_EACH pro IN 1 3 4 6 9 11 13 14 15 16 19 26 29 31 34 102 BEGIN
        PATCH_IF !VARIABLE_IS_SET $fl#pro_sppr613("%i%" "%pro%") BEGIN
          INSERT_BYTES fx_off + 0x30*num_fx        0x30
          WRITE_SHORT  fx_off + 0x30*num_fx        197
          WRITE_BYTE   fx_off + 0x30*num_fx + 0x2  1
          WRITE_LONG   fx_off + 0x30*num_fx + 0x8  pro
          WRITE_BYTE   fx_off + 0x30*num_fx + 0xc  2
          WRITE_BYTE   fx_off + 0x30*num_fx + 0x12 100
          num_fx += 1
        END
      END
      WRITE_SHORT ab_off + 0x28*i + 0x1e num_fx
    END
  END
BUT_ONLY

// Undead creatures are erroneously immune to Lightning Bolt instead of Hold Person (aVENGER)

COPY_EXISTING ~ring95.itm~ ~override~ // undead immunity ring
PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN // file size sanity check
READ_LONG   0x6a "fx_off"
READ_SHORT  0x70 "fx_num"
  FOR (index = 0; index < fx_num; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "opcode"
    READ_ASCII ("%fx_off%" + 0x14 + ("%index%" * 0x30)) "resref"
    PATCH_IF (("%opcode%" = 206) AND ("%resref%" STRING_EQUAL_CASE ~SPWI308~)) BEGIN // Lightning Bolt
      WRITE_ASCII ("%fx_off%" + 0x14 + ("%index%" * 0x30)) "SPWI306" #8 // Hold Person
    END
  END
END
BUT_ONLY_IF_IT_CHANGES


// Illusionary Werewolves should not damage characters who are unarmed or wielding ranged weapons (aVENGER)

COPY_EXISTING ~illusion.itm~ ~override~                                               // Illusionary Werewolf weapon
READ_LONG 0x64 abil_off
READ_SHORT 0x68 abil_num
READ_LONG 0x6a fx_off
  FOR (i = 0; i < "%abil_num%"; i += 1) BEGIN                                         // parse each ability
    READ_BYTE (%abil_off% + %i% * 0x38) abil_type                                     // read ability type
    PATCH_IF (%abil_type% = 1) BEGIN                                                  // only patch the melee ability header
      WRITE_SHORT ("%abil_off%" + 0x1c) 0                                             // damage type (None)
      WRITE_SHORT ("%abil_off%" + 0x16) 0                                             // damage dice
    END
  END
BUT_ONLY_IF_IT_CHANGES


// All trolls should have their hit points set to 1 after getting knocked down (aVENGER)

COPY_EXISTING ~dgtrol02.bcs~ ~override~ // Druid Grove trolls that are fighting some adventurers
               ~troll03.bcs~ ~override~ // small trolls which emerge out of a bigger one on the first floor of de'Arnise Keep
              ~firamb05.bcs~ ~override~ // the troll fighting the werewolf captain in Firkraag's lair
DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY EXACT_MATCH ~PlayDead(150)~ ~ApplySpell(Myself,TROLL_SETHP1) PlayDead(150)~
  REPLACE_TEXTUALLY EXACT_MATCH ~PlayDead(300)~ ~ApplySpell(Myself,TROLL_SETHP1) PlayDead(300)~
COMPILE_BAF_TO_BCS
BUT_ONLY_IF_IT_CHANGES


// The Spellhold Asylum door should be unlocked and opened once (aVENGER)

COPY_EXISTING ~ar1500.bcs~ ~override~
DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY EXACT_MATCH ~GlobalGT("AsylumPlot","GLOBAL",55)~ ~GlobalGT("AsylumPlot","GLOBAL",55) Global("RR#Door1501","AR1500",0)~
  REPLACE_TEXTUALLY EXACT_MATCH ~Unlock("Door1501")~ ~SetGlobal("RR#Door1501","AR1500",1) Unlock("Door1501")~
COMPILE_BAF_TO_BCS
BUT_ONLY_IF_IT_CHANGES


// The beneficial effects of the Deck of Many Things should bypass the user's Magic Resistance and/or Globe of Invulnerability (aVENGER)

ACTION_IF GAME_IS tob BEGIN
COPY_EXISTING ~spin606.spl~ ~override~     // DECK_SUN (Party gains 300,000 Experience Points)
              ~spin607.spl~ ~override~     // DECK_JESTER (The user gains 50,000 Experience Points)
              ~spin609.spl~ ~override~     // DECK_GEM (The user gains several gems)
              ~spin610.spl~ ~override~     // DECK_FATES (The user gains a +1 bonus to all stats for 1 day)
              ~spin611.spl~ ~override~     // DECK_COMET (The user gains a permanent 5% increase to Fire Resistance)
              ~spin618.spl~ ~override~     // DECK_MOON (The user gains a permanent increase of 10 Hit Points)
              ~spin619.spl~ ~override~     // DECK_THRONE (Party gains 1,000,000 Experience Points)
              ~spin621.spl~ ~override~     // DECK_KEY (The user gains a Ring of Protection +3)
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      WRITE_BYTE ("%fx_off%" + 0x03 + ("%index2%" * 0x30)) "0" // power: 0
      READ_BYTE  ("%fx_off%" + 0x0d + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "dispel"
      PATCH_IF ("%dispel%" != 0) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "2" // resist/dispel: 2
      END
    END
  END
BUT_ONLY_IF_IT_CHANGES
END


//reddeath doesn't work because it uses the wrong action (Wisp)
COPY_EXISTING reddeath.bcs override
  DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY CASE_INSENSITIVE EXACT_MATCH ReallyForceSpell ReallyForceSpellDead
  COMPILE_BAF_TO_BCS
UNLESS 240OB
BUT_ONLY


//Kruin can spawn again if you killed him before he could talk (Wisp)
COPY_EXISTING githspwn.bcs override
  DECOMPILE_BCS_TO_BAF
  REPLACE_TEXTUALLY CASE_INSENSITIVE EXACT_MATCH ~!Exists("Kruin")~ ~!Exists("Kruin") !Dead("Kruin")~
  COMPILE_BAF_TO_BCS
UNLESS ~16465 0 1 0 0 "Kruin" "" OB~
BUT_ONLY


// Keldorn re-joining variable typo fix (berelinde)

COPY_EXISTING ~keldorj.dlg~ ~override~
    DECOMPILE_DLG_TO_D
      REPLACE_TEXTUALLY ~SetGlobal("KeldornLeaves","GLOBAL",1)~  ~SetGlobal("KeldornLeave","GLOBAL",1)~
    COMPILE_D_TO_DLG
    BUT_ONLY_IF_IT_CHANGES


// A few trap spells ignore magic resistance, but they probably should not since all other trap spells don't (aVENGER)

COPY_EXISTING ~spwi001.spl~ ~override~ // Fireball (trap)
              ~spwi002.spl~ ~override~ // Lightning Bolt (trap)
              ~spwi003.spl~ ~override~ // Magic Missile (trap)
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +              (0x30 * ("%index2%" + "%abil_fx_idx%"))) "opcode"
      READ_BYTE  ("%fx_off%" + 0x0d + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "dispel"
      PATCH_IF ("%dispel%" != 1) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x0d + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "1" // resist/dispel: 1
      END
    END
  END
BUT_ONLY_IF_IT_CHANGES


// The innate immunity to psionics and mind-affecting spells of Mordenkainen Sword should not be dispellable (aVENGER)

COPY_EXISTING ~ipsion.itm~ ~override~  // Greenstone Amulet ("equipped" by Mordenkainen's Sword)
READ_LONG   0x64 "abil_off"
READ_SHORT  0x68 "abil_num"
READ_LONG   0x6a "fx_off"
READ_SHORT  0x70 "fx_num"
  FOR (index2 = 0 ; index2 < fx_num ; index2 = index2 + 1) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x03 + ("%index2%" * 0x30)) "0" // power: 0
        WRITE_BYTE ("%fx_off%" + 0x0d + ("%index2%" * 0x30)) "0" // dispel/resist: 0 (non-magical)
        WRITE_LONG ("%fx_off%" + 0x0e + ("%index2%" * 0x30)) "0" // duration: 0
  END
BUT_ONLY_IF_IT_CHANGES


// Fix Aerie's "Blanket Thieves" banter which could never occur due to a duplicated PartyRested() trigger (berelinde)

COPY_EXISTING ~baerie.dlg~ ~override~
  DECOMPILE_DLG_TO_D
    REPLACE_TEXTUALLY EXACT_MATCH ~PartyRested()
Gender(Player1,FEMALE)~ ~Gender(Player1,FEMALE)~
  COMPILE_D_TO_DLG
BUT_ONLY_IF_IT_CHANGES


// Fix Haer'Dalis' "Arcane muttering" banter with Edwin which could never occur due to a duplicated PartyRested() trigger (aVENGER)

COPY_EXISTING ~bhaerda.dlg~ ~override~
  DECOMPILE_DLG_TO_D
    REPLACE_TEXTUALLY EXACT_MATCH ~PartyRested()
InParty("Edwin")~ ~InParty("Edwin")~
  COMPILE_D_TO_DLG
BUT_ONLY_IF_IT_CHANGES


// Secret Word should be able to dispel a Globe of Invulnerability (aVENGER)

COPY_EXISTING ~spwi419.spl~ ~override~ // Secret Word
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1 ) BEGIN // cycle through abilities
        READ_SHORT  ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
        READ_SHORT  ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
        FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
          WRITE_BYTE ("%fx_off%" + 0x03 + (0x30 * ("%index2%" + "%abil_fx_idx%"))) "5" // power
        END
  END
BUT_ONLY_IF_IT_CHANGES


// Fix the incorrect orientation when entering Cayia's house in Brynnlaw (CamDawg)

COPY_EXISTING ~ar1606.are~ ~override~
  READ_LONG 0x68 "enter_off"
  READ_LONG 0x6c "enter_num"
  FOR (index = 0 ; index < enter_num ; index = index + 1) BEGIN
    READ_ASCII ("%enter_off%" +        ("%index%" * 0x68)) "name"
    PATCH_IF ("%name%" STRING_EQUAL_CASE "exit1600") BEGIN
      WRITE_SHORT ("%enter_off%" + 0x24 + ("%index%" * 0x68)) 6 // northwest
    END
  END
BUT_ONLY_IF_IT_CHANGES


// The Glabrezus in the Ranger stronghold quest and inside the Suldanessalar temple don't give any XP when killed (aVENGER)

COPY_EXISTING ~demgla01.cre~   ~override~ // Ranger stronghold Glabrezu
              ~demglab2.cre~   ~override~ // Suldanessalar temple Glabrezu
WRITE_LONG 0x14 12500 // XP value
BUT_ONLY_IF_IT_CHANGES


// Fix erroneously dispellable effects on Keldorn's armor (polytype)

COPY_EXISTING ~npplat.itm~ ~override~  // Firecam Full-Plate Armor
READ_LONG   0x64 "abil_off"
READ_SHORT  0x68 "abil_num"
READ_LONG   0x6a "fx_off"
READ_SHORT  0x70 "fx_num"
  FOR (index2 = 0 ; index2 < fx_num ; index2 = index2 + 1) BEGIN
    WRITE_BYTE ("%fx_off%" + 0x03 + ("%index2%" * 0x30)) "0" // power: 0
    WRITE_BYTE ("%fx_off%" + 0x0d + ("%index2%" * 0x30)) "0" // dispel/resist: 0 (non-magical)
    WRITE_LONG ("%fx_off%" + 0x0e + ("%index2%" * 0x30)) "0" // duration: 0
  END
BUT_ONLY_IF_IT_CHANGES


// Fix Storm of Vengeance not displaying the relevant icon on poisoned targets (polytype)

COPY_EXISTING ~sppr722.spl~ ~override~ // Storm of Vengeance
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
     READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 25) BEGIN // clone Poison opcode
        READ_ASCII ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "clone_fx" (0x30)
        SET "index2"= "%abil_fx_num%" // kills loop
        INSERT_BYTES            ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 0x30          // new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) "%clone_fx%"  // cloned effect
          WRITE_SHORT           ("%fx_off%" +        ("%abil_fx_idx%" * 0x30)) 142           // opcode: 142 (Display Special Effect Icon)
          WRITE_LONG            ("%fx_off%" + 0x04 + ("%abil_fx_idx%" * 0x30)) 0             // param1: 0
          WRITE_LONG            ("%fx_off%" + 0x08 + ("%abil_fx_idx%" * 0x30)) 6             // param2: 6 (Poisoned icon)
        SET "delta" = "%delta%" + 1
        WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) ("%abil_fx_num%" + 1)
      END
    END
  END
BUT_ONLY_IF_IT_CHANGES


// Fix the wrong enchantment level and missing poison icon on the Dagger of Venom (aVENGER)

COPY_EXISTING ~misc75.itm~ ~override~ // Dagger of Venom
WRITE_LONG 0x60 2   // set enchantment level to 2
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  SET "abil_length" = 0x38
  SET "fx_delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // start iterating through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%fx_delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 25) BEGIN // poison
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (48) // clone poison opcode
        INSERT_BYTES            ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 0x30      // insert new effect
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) "%clone%" // cloned opcode
          WRITE_SHORT           ("%fx_off%" +        (0x30 * "%abil_fx_idx%")) 142       // opcode: 142 (Display Special Effect Icon)
          WRITE_LONG            ("%fx_off%" + 0x04 + (0x30 * "%abil_fx_idx%")) 0         // param1: 0
          WRITE_LONG            ("%fx_off%" + 0x08 + (0x30 * "%abil_fx_idx%")) 6         // param2: 6 (Poisoned icon)
        SET "fx_delta" = "%fx_delta%" + 1
        SET "abil_fx_num" = "%abil_fx_num%" + 1
        WRITE_SHORT  ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%")) "%abil_fx_num%"
        SET "index2" = "%abil_fx_num%" // kills loop
      END
    END
  END
BUT_ONLY_IF_IT_CHANGES


// Fix Inquisitors not getting charm immunity at level 1 (Dakk)

COPY_EXISTING ~clabpa03.2da~ ~override~ // Inquisitor ability table
  SET_2DA_ENTRY  3 2 3 ~****~
  SET_2DA_ENTRY 10 1 3 ~AP_SPCL233b~
  PRETTY_PRINT_2DA
BUT_ONLY_IF_IT_CHANGES


// Fix the incorrect thieving skill racial bonus for elves, half-elves and halflings (Hurricane and aVENGER)

COPY_EXISTING ~SKILLRAC.2DA~ ~override~
  SET_2DA_ENTRY 2 4 8 ~15~ // Elf Move Silently correction (was 20)
  SET_2DA_ENTRY 4 4 8 ~10~ // Half-Elf Move Silently correction (was 15)
  SET_2DA_ENTRY 5 4 8 ~20~ // Halfling Move Silently correction (was 25)
BUT_ONLY_IF_IT_CHANGES


// Fix the incorrect lore bonus for 15 INT/WIS (Ascension 64 and Hurricane)

COPY_EXISTING ~LOREBON.2DA~ ~override~
  SET_2DA_ENTRY 15 1 2 ~3~
BUT_ONLY_IF_IT_CHANGES


// Fix the incorrect Move Silently entry for Ranger level 2 (Ascension 64 and Hurricane)

COPY_EXISTING ~SKILLRNG.2DA~ ~override~
  SET_2DA_ENTRY 2 1 2 ~21~
BUT_ONLY_IF_IT_CHANGES

// defensive spin uses 'unblockable' movement code to set movement to zero
COPY_EXISTING ~spcl522.spl~ ~override~
  LPF ADD_SPELL_EFFECT INT_VAR
    opcode = 176
    target = 1
    parameter2 = 1
    resist_dispel = 2
    duration = 24
    insert_point = 0
  END

// power/school/secondary for resist fear on magic flute
COPY_EXISTING ~brdflute.itm~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off" ELSE 0
  FOR (index = 0 ; index < abil_num ; ++index) BEGIN
    READ_ASCII  ("%abil_off%" + 0x04 + ("%index%" * 0x38)) "icon"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    PATCH_IF ("%icon%" STRING_COMPARE_CASE "spwi201b" = 0) BEGIN // resist fear
      WRITE_BYTE ("%abil_off%" + 0x17 + ("%index%" * 0x38)) 1 // school: abjuration
      WRITE_BYTE ("%abil_off%" + 0x19 + ("%index%" * 0x38)) 2 // secondary: specific protections
      FOR (index2 = 0 ; index2 < abil_fx_num ; ++index2) BEGIN
        WRITE_BYTE ("%fx_off%" + 0x03 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 2 // power level
      END
    END
  END
  BUT_ONLY

// match secondary to underlying spell
COPY_EXISTING ~misc7n.itm~ ~override~ // wand of lightning (unused?)
  READ_LONG  0x64 abil_off
  READ_SHORT 0x68 abil_num
  FOR (index = 0 ; index < abil_num ; ++index) BEGIN
    WRITE_BYTE (abil_off + 0x19 + (index * 0x38)) 10 // secondary: offensive damage
  END
  BUT_ONLY

// match secondary to underlying spell
COPY_EXISTING ~wand02.itm~ ~override~ // wand of fear
              ~wand04.itm~ ~override~ // wand of paralyzation
              ~wand08.itm~ ~override~ // wand of sleep
  READ_LONG  0x64 abil_off
  READ_SHORT 0x68 abil_num
  FOR (index = 0 ; index < abil_num ; ++index) BEGIN
    WRITE_BYTE (abil_off + 0x19 + (index * 0x38)) 11 // secondary: disabling
  END
  BUT_ONLY

// match secondary to underlying spell
COPY_EXISTING ~wand10.itm~ ~override~ // wand of monster summoning
  READ_LONG  0x64 abil_off
  READ_SHORT 0x68 abil_num
  FOR (index = 0 ; index < abil_num ; ++index) BEGIN
    WRITE_BYTE (abil_off + 0x19 + (index * 0x38)) 6 // secondary: conjuration
  END
  BUT_ONLY

// ground traps won't trigger due to container scripts
COPY_EXISTING ar1202.are override
              ar0502.are override
              ar5201.are override
  READ_SHORT 0x5a "info_num"
  READ_LONG  0x5c "info_off"
  FOR (index = 0; index < info_num ; index = index + 1) BEGIN
    READ_ASCII ("%info_off%" + 0x7c + (0xc4 * "%index%" )) "script" (2)
    PATCH_IF ("%script%" STRING_COMPARE_CASE "ct" = 0) BEGIN
      WRITE_ASCII ("%info_off%" + 0x7c + (0xc4 * "%index%" )) ~gt~ #2
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// container traps won't trigger due to ground scripts
COPY_EXISTING ar0503.are override
              ar5204.are override
  READ_LONG 0x70 co
  FOR (i = 0; i < SHORT_AT 0x5a; ++i) BEGIN
    READ_ASCII co + 0xc0 * i + 0x48 s (2)
    PATCH_IF "%s%" STRING_EQUAL_CASE gt BEGIN
      WRITE_ASCII co + 0xc0 * i + 0x48 CT #2
    END
  END
  BUT_ONLY

// script assigned to both container and area-trigger traps, but only working for area triggers
COPY_EXISTING gtspike.bcs override
  DECOMPILE_AND_PATCH BEGIN
    REPLACE_TEXTUALLY ~\(IsOverMe(\[GOODCUTOFF\])\)~ ~OR(2) \1 Opened([GOODCUTOFF])~
  END
  BUT_ONLY
  UNLESS ~16521 [0-9]+ 0 0 0 "" "" OB~


/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////                                                  \\\\\
///// Optional, but cool                               \\\\\
/////                                                  \\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\

/////                                                  \\\\\
///// keldorn xp                                       \\\\\
/////                                                  \\\\\

BEGIN @6 DESIGNATED 100
GROUP @2

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0100.g3~

// get xp for keldorn's reconciliation if keldorn is released from the party
COMPILE ~bg2fixpack/dlg/keldorn.d~

/////                                                  \\\\\
///// maze animations                                  \\\\\
/////                                                  \\\\\
                
BEGIN @7 DESIGNATED 101
GROUP @2

// maze animation, part 1
COPY_EXISTING ~SPWI813.SPL~ ~OVERRIDE~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off" ELSE 0
  FOR (index = 0; index < abil_num; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    FOR (index2 = 0; index2 < abil_fx_num; index2 = index2 + 1) BEGIN
      READ_SHORT   ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 215) BEGIN // if play 3d effect
        READ_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) "animation"
        PATCH_IF ("%animation%" STRING_COMPARE_CASE "spmaze2" = 0) BEGIN
          WRITE_BYTE ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // set prob to 0
        END ELSE BEGIN
          WRITE_LONG  ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 5 // duration
          WRITE_ASCII ("%fx_off%" + 0x14 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) ~SPSPMAZE~ #8
        END
      END ELSE
      PATCH_IF ("%opcode%" = 213) BEGIN // if maze
        WRITE_LONG ("%fx_off%" + 0x0e + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 4 // duration
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// maze animation, part 2
COPY_EXISTING ~SPMAZE2.VVC~ ~OVERRIDE/SPSPMAZE.VVC~
  WRITE_ASCII 0x78 ~EFF_M74~ #8
  WRITE_BYTE 0x4c 0x08
  WRITE_BYTE 0x68 0x00
  WRITE_EVALUATED_ASCII 0x08 ~%DEST_RES%~ #8
  
// animation fixes
COPY_EXISTING ~BHAAL4B.SPL~ ~OVERRIDE~
              ~SPCL213.SPL~ ~OVERRIDE~
              ~SPIN550.SPL~ ~OVERRIDE~
              ~SPIN553.SPL~ ~OVERRIDE~
              ~SPIN558.SPL~ ~OVERRIDE~
              ~SPIN674.SPL~ ~OVERRIDE~
              ~SPIN675.SPL~ ~OVERRIDE~
              ~SPIN696.SPL~ ~OVERRIDE~
              ~SPIN826.SPL~ ~OVERRIDE~
              ~SPIN891.SPL~ ~OVERRIDE~
              ~SPPR107.SPL~ ~OVERRIDE~
              ~SPPR408.SPL~ ~OVERRIDE~
              ~SPWI113.SPL~ ~OVERRIDE~
              ~SPWI214.SPL~ ~OVERRIDE~
              ~SPWI702.SPL~ ~OVERRIDE~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN // protects against invalid files
    FOR (READ_LONG 0x6a effectsOffset ELSE 0x72; effectsOffset < SOURCE_SIZE; effectsOffset = effectsOffset + 0x30) BEGIN
      READ_SHORT ~%effectsOffset%~ ~effectType~ ELSE 0x00
      PATCH_IF (~%effectType%~ = 0xd7) BEGIN // play 3d effect opcode
        READ_ASCII ~%effectsOffset%~ + 0x14 ~animation~ ELSE ~~
        PATCH_IF NOT (~%animation%~ STRING_COMPARE_CASE ~ICRMPARI~) OR NOT (~%animation%~ STRING_COMPARE_CASE ~ICSTRENI~) OR NOT
                     (~%animation%~ STRING_COMPARE_CASE ~SPPOWWRD~) OR NOT (~%animation%~ STRING_COMPARE_CASE ~SPROTECT~) BEGIN
          READ_BYTE  ~%effectsOffset%~ + 0x0c ~effectDuration~ ELSE 0x01
          READ_LONG  ~%effectsOffset%~ + 0x0e ~effectLength~ ELSE 0x02
          WRITE_LONG ~%effectsOffset%~ + 0x0e ((~%effectDuration%~ = 0x00) AND (~%effectLength%~ > 0x02)) ? 0x02 : ~%effectLength%~
        END ELSE
        PATCH_IF NOT (~%animation%~ STRING_COMPARE_CASE ~SPDISPMA~) OR NOT (~%animation%~ STRING_COMPARE_CASE ~SPTRUSEE~) BEGIN
          READ_BYTE  ~%effectsOffset%~ + 0x0c ~effectDuration~ ELSE 0x01
          READ_LONG  ~%effectsOffset%~ + 0x0e ~effectLength~ ELSE 0x03
          WRITE_LONG ~%effectsOffset%~ + 0x0e ((~%effectDuration%~ = 0x00) AND (~%effectLength%~ > 0x03)) ? 0x03 : ~%effectLength%~
        END ELSE
        PATCH_IF NOT (~%animation%~ STRING_COMPARE_CASE ~ICWRATI~) OR NOT (~%animation%~ STRING_COMPARE_CASE ~SPNWCHRM~) BEGIN
          READ_BYTE  ~%effectsOffset%~ + 0x0c ~effectDuration~ ELSE 0x01
          READ_LONG  ~%effectsOffset%~ + 0x0e ~effectLength~ ELSE 0x04
          WRITE_LONG ~%effectsOffset%~ + 0x0e ((~%effectDuration%~ = 0x00) AND (~%effectLength%~ > 0x04)) ? 0x04 : ~%effectLength%~
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~cspray.pro~   ~override/burnhand.pro~
  WRITE_SHORT 0x206 64 // range (5')
  WRITE_BYTE  0x217  0 // no explosion

ADD_PROJECTILE ~override/burnhand.pro~

COPY_EXISTING ~spwi103.spl~  ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN
    READ_LONG  0x64 "ho"
    FOR (READ_SHORT 0x68 "hc"; "hc" > 0x00; "hc" -= 0x01) BEGIN
      WRITE_SHORT ("ho" + ("hc" * 0x28) - 0x16) 1
      WRITE_BYTE  ("ho" + ("hc" * 0x28) - 0x1c) 4
      WRITE_SHORT ("ho" + ("hc" * 0x28) - 0x02) "burnhand"
    END
  END
  BUT_ONLY_IF_IT_CHANGES
  
// scroll fixes: effects target
COPY_EXISTING ~scrl68.itm~ ~override~ // burning hands
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_BYTE  ("%fx_off%" + 0x02 + (("%abil_fx_idx%" + "%index2%") * 0x30)) 1   // target: self
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: casting opcode
COPY_EXISTING ~scrl68.itm~ ~override~ // burning hands
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF ("%opcode%" = 146) BEGIN // cast spell
        WRITE_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) 148 // opcode: cast spell (scroll)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: ability targeting
COPY_EXISTING ~scrl68.itm~ ~override~ // burning hands
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_BYTE  ("%abil_off%" + 0x0c + ("%index%" * 0x38)) 4 // target: any point in range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// scroll fixes: range
COPY_EXISTING ~scrl68.itm~ ~override~ // burning hands
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // loops through abilities
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index%" * 0x38)) "abil_fx_num"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index%" * 0x38)) "abil_fx_idx"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN // searches through fx for cast spell
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index2%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 146) OR ("%opcode%" = 148)) BEGIN // cast spell
        WRITE_SHORT ("%abil_off%" + 0x0e + ("%index%" * 0x38)) 5 // range (ability header)
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// Make Errard's Divination spell actually use the Divination casting graphics (aVENGER)

COPY_EXISTING ~SPIN541.SPL~   ~override~ // Divination
 WRITE_SHORT   0x22  16 // Casting graphics: 16 (Divination)
BUT_ONLY_IF_IT_CHANGES


/////                                                  \\\\\
///// Cromwell's forging actually takes a day          \\\\\
/////                                                  \\\\\
                
BEGIN @8 DESIGNATED 102
GROUP @2

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0102.g3~

EXTEND_TOP ~ar0334.bcs~ ~bg2fixpack/baf/ar0334.baf~

/////                                                  \\\\\
///// Mixed-use dagger fixes                           \\\\\
/////                                                  \\\\\

BEGIN @9 DESIGNATED 103
GROUP @2

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0103.g3~

// removes melee abilities from Fire Tooth and Boomerang dagger; change APR to be consistent 
// with other throwing daggers; alters base Fire Tooth damage to 1d4 (again for consistency); damage change now rescinded (Wisp)
COPY_EXISTING ~dagg11.itm~ ~override~
              ~dagg12.itm~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET "fx_delta" = 0
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "opcode"
    PATCH_IF ("%opcode%" = 1) BEGIN  // attacks per round
      WRITE_LONG ("%fx_off%" + 0x04 + ("%index%" * 0x30)) 2 // number of attacks
      WRITE_LONG ("%fx_off%" + 0x08 + ("%index%" * 0x30)) 1 // set to value
    END
  END
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN // looks for melee ability header
    READ_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) "type"
    PATCH_IF ("%type%" = 1) BEGIN // melee ability check
     WRITE_BYTE   ("%abil_off%" +        ("%index%" * 0x38)) 0
      READ_SHORT  (0x1e + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_num"
      READ_SHORT  (0x20 + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_idx"
      DELETE_BYTES ("%fx_off%" + (0x30 * ("%abil_fx_idx%" - "%fx_delta%"))) (0x30 * "%abil_fx_num%") // deletes all associated effects
      DELETE_BYTES ("%abil_off%" + ("%index%" * 0x38)) 0x38                                          // deletes ability itself
      SET "fx_delta" = ("%fx_delta%" + "%abil_fx_num%")
      SET "abil_num" = ("%abil_num%" - 1)
      SET "index" = ("%index%" - 1)
      SET "fx_off" = ("%fx_off%" - 0x38)
    END ELSE BEGIN // if non-melee ability, need to adjust effect indices
      READ_SHORT  (0x20 + "%abil_off%" + ("%index%" * 0x38)) "abil_fx_idx"
      WRITE_SHORT (0x20 + "%abil_off%" + ("%index%" * 0x38)) ("%abil_fx_idx%" - "%fx_delta%")
      //The description says 2d4, it is conistent across both headers; changing the ranged damage to 1d4 is bunk, says I
      //PATCH_IF (("%type%" = 2) AND ("%SOURCE_RES%" STRING_COMPARE_CASE "dagg12" = 0)) BEGIN // ranged damage adjustment for Fire Tooth
      //  WRITE_SHORT (0x18 + "%abil_off%" + ("%index%" * 0x38)) 1 // only 1d4, not 2d4
      //  SAY 0x54 @135 // adjusts description
      //END
    END
  END
  WRITE_SHORT  0x68 "%abil_num%"
  WRITE_LONG   0x6a "%fx_off%"
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// Ghrey's Holy Symbol Fixes                        \\\\\
/////                                                  \\\\\

BEGIN @10 DESIGNATED 104
GROUP @2
REQUIRE_PREDICATE     FILE_EXISTS_IN_GAME ~mel01.cre~   @11 // ToB required

EXTEND_BOTTOM ~aerie.bcs~  ~bg2fixpack/baf/et_aerie.baf~
EXTEND_BOTTOM ~aeri25.bcs~ ~bg2fixpack/baf/et_aerie.baf~

EXTEND_BOTTOM ~anomen.bcs~ ~bg2fixpack/baf/et_anom.baf~
EXTEND_BOTTOM ~anom25.bcs~ ~bg2fixpack/baf/et_anom.baf~

EXTEND_BOTTOM ~viconia.bcs~ ~bg2fixpack/baf/et_vicon.baf~
EXTEND_BOTTOM ~vico25.bcs~  ~bg2fixpack/baf/et_vicon.baf~

COPY ~bg2fixpack/bam/d0baer.bam~ ~override~
     ~bg2fixpack/bam/d0shar.bam~ ~override~

// Holy Symbol of Helm Usable by Good Aligned. Poo, but necessary to let Anomen use it.
COPY_EXISTING ~belt13.itm~ ~override~
  READ_BYTE  0x1e "use"
  WRITE_BYTE 0x1e ("%use%" BAND 0b11111011) // removes good flag
  BUT_ONLY_IF_IT_CHANGES

COPY ~bg2fixpack/itm/j#belt12.itm~ ~override~
  SAY NAME2 @128
  SAY IDENTIFIED_DESC @129

COPY ~bg2fixpack/itm/j#belt14.itm~ ~override~
  SAY NAME2 @130
  SAY IDENTIFIED_DESC @131

/////                                                  \\\\\
///// Jenia will wait until PC hero of trademeet       \\\\\
/////                                                  \\\\\
                
BEGIN @12 DESIGNATED 105
DEPRECATED @22

// moved into core fixes per Gaider

/////                                                  \\\\\
///// giants have penalties v shorties                 \\\\\
/////                                                  \\\\\
                
BEGIN @13 DESIGNATED 106
GROUP @2

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0106.g3~

// giant weapons get THAC0 penalties vs. small people (revised by aVENGER)

ACTION_FOR_EACH ~file~ IN                                                          // for each of the following files
              ~giafir~                                                             // giant hammer 
             ~giafir2~                                                             // giant axe
             ~giafir3~                                                             // giant fist
            ~giants01~                                                             // giant sword
BEGIN                                                                              // execute the following
ACTION_IF FILE_EXISTS_IN_GAME ~%file%.itm~ BEGIN                                   // if the designated file with an ITM extension exists
COPY_EXISTING ~%file%.itm~ ~override~
PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN                                         // file size sanity check (filters out 0 byte files i.e. ALLOW_MISSING)
// =============================================================================== // the actual work starts from here
PATCH_FOR_EACH ~eff~ IN                                                            // for each of the following EFF files
            ~giant1~                                                               // THAC0 penalty vs. dwarves
            ~giant2~                                                               // THAC0 penalty vs. halflings
            ~giant3~                                                               // THAC0 penalty vs. gnomes
BEGIN                                                                              // execute the following
SET opcode = "177"                                                                 // effect: #177 (use EFF file)
SET target = "1"                                                                   // target: 1 (self)
SET timing = "2"                                                                   // timing mode: 2 (while equipped)
SET parameter1 = "142"                                                             // param1: 142 (IDS Entry - GIANT)
SET parameter2 = "4"                                                               // param2: 4 (IDS File - RACE.IDS)
SET power = "0"                                                                    // power: 0
SET resist_dispel = "0"                                                            // dispel/resistance: 0 (non-magical)
SET duration = "0"                                                                 // duration: 0
SET probability1 = "100"                                                           // probability1: 100%
SET probability2 = "0"                                                             // probability2: 0%
SET dicenumber = "0"                                                               // dicenumber: 0
SET dicesize = "0"                                                                 // dicesize: 0
SET savingthrow = "0"                                                              // saving throw type: 0 (none)
SET savebonus = "0"                                                                // save bonus: 0
SPRINT ~resource~ EVALUATE_BUFFER "%eff%"                                          // resref: the current EFF file
LAUNCH_PATCH_MACRO ~ADD_ITEM_EQEFFECT~                                             // add new equipping effect
END                                                                                // ends PATCH_FOR_EACH block
// =============================================================================== // the actual work ends here
END                                                                                // ends file size check
BUT_ONLY_IF_IT_CHANGES
END                                                                                // ends ACTION_IF FILE_EXISTS_IN_GAME block
END                                                                                // ends ACTION_FOR_EACH block

/////                                                  \\\\\
///// Remove Dual-class Restriction from ranger kits   \\\\\
/////                                                  \\\\\
                
BEGIN @14 DESIGNATED 107
GROUP @2

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0107.g3~

COPY_EXISTING ~dualclas.2da~ ~override~
  SET_2DA_ENTRY 32 2 7 ~1~ // archer (feralan)
  SET_2DA_ENTRY 33 2 7 ~1~ // stalker
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// Remove Wrath-Evil bonuses                        \\\\\
/////                                                  \\\\\

BEGIN @15 DESIGNATED 108
GROUP @2

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0108.g3~

// remove bonuses here as the player is already rewarded at the door
COPY_EXISTING ~ar2905.bcs~ ~override~
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~Global("Player1Wrath","GLOBAL",2)~ ~False()~
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// summoned demon behavior                          \\\\\
/////                                                  \\\\\

BEGIN @16 DESIGNATED 109
GROUP @2

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0109.g3~

COMPILE ~bg2fixpack/baf/demglasu.baf~
        ~bg2fixpack/baf/demnabsu.baf~
        ~bg2fixpack/baf/dempitsu.baf~

/////                                                  \\\\\
///// additional script fixes                          \\\\\
/////                                                  \\\\\
                
BEGIN @17 DESIGNATED 110
GROUP @2

// commoners missing scripts to turn hostile if attacked
COPY_EXISTING ~aewimer1.cre~ ~override~
              ~aewimer2.cre~ ~override~
              ~aewimer3.cre~ ~override~
              ~bdgoph01.cre~ ~override~
              ~bdgoph02.cre~ ~override~
              ~brat1.cre~    ~override~
              ~brat2.cre~    ~override~
              ~brat3.cre~    ~override~
              ~ftown1.cre~   ~override~
              ~ftown2.cre~   ~override~
              ~ftown3.cre~   ~override~
              ~ftown4.cre~   ~override~
              ~haquat.cre~   ~override~
              ~maria.cre~    ~override~
              ~mourner5.cre~ ~override~
              ~mourner6.cre~ ~override~
              ~mtown1.cre~   ~override~
              ~mtown2.cre~   ~override~
              ~mtown3.cre~   ~override~
              ~mtown4.cre~   ~override~
              ~murtlen.cre~  ~override~
              ~noblem1.cre~  ~override~
              ~noblem2.cre~  ~override~
              ~noblew1.cre~  ~override~
              ~noblew2.cre~  ~override~
              ~peony.cre~    ~override~
              ~postul1.cre~  ~override~
              ~postul3.cre~  ~override~
              ~postul5.cre~  ~override~
              ~postul6.cre~  ~override~
              ~pwauk2.cre~   ~override~
              ~radeel.cre~   ~override~
              ~scbutler.cre~ ~override~
              ~scqar.cre~    ~override~
              ~scsarles.cre~ ~override~
              ~sethle.cre~   ~override~
              ~trskin02.cre~ ~override~
              ~trtavp05.cre~ ~override~
              ~uhmer02.cre~  ~override~
              ~wellyn.cre~   ~override~
  SET "script_runenemy" = 0
  SET "script_wtrunsgt" = 0
  FOR (index = 0 ; index < 5 ; index = index + 1) BEGIN
    READ_ASCII (0x248 + ("%index%" * 0x08)) "script"
    PATCH_IF ("%script%" STRING_COMPARE_CASE "runenemy" = 0) BEGIN
      SET "script_runenemy" = 1
    END ELSE
    PATCH_IF (("%script%" STRING_COMPARE_CASE "wtrunsgt" = 0) OR
              ("%script%" STRING_COMPARE_CASE "wdrunsgt" = 0)) BEGIN
      SET "script_wtrunsgt" = 1
    END
  END
  PATCH_IF ("%script_runenemy%" + "%script_wtrunsgt%" = 1) BEGIN
    FOR (index = 0 ; index < 5 ; index = index + 1) BEGIN
      READ_ASCII (0x248 + ("%index%" * 0x08)) "script"
      PATCH_IF (("%script%" STRING_COMPARE_CASE "none" = 0) OR ("%script%" STRING_COMPARE_CASE "" = 0)) BEGIN
        PATCH_IF ("%script_runenemy%" = 0) BEGIN
          WRITE_ASCII (0x248 + ("%index%" * 0x08)) "runenemy"
          SET "script_runenemy" = 1
        END ELSE
        PATCH_IF ("%script_wtrunsgt%" = 0) BEGIN
          WRITE_ASCII (0x248 + ("%index%" * 0x08)) "wtrunsgt"
          SET "script_wtrunsgt" = 1
        END
      END
    END
  END
  BUT_ONLY_IF_IT_CHANGES

// create fatigue-free restoration spell for cut59a
COPY_EXISTING ~sppr417.spl~  ~override/cdpr417.spl~
  READ_LONG  0x64 "abil_off" ELSE 0
  READ_SHORT 0x68 "abil_num" ELSE 0
  READ_LONG  0x6a "fx_off"   ELSE 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + (0x28 * "%index%")) "type"
    PATCH_IF ("%type%" = 1) BEGIN // if melee
      READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
      READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
      FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
        PATCH_IF ("%opcode%" = 93) BEGIN // fatigue
          WRITE_BYTE ("%fx_off%" + 0x12 + (0x30 * ("%abil_fx_idx%" + "%index2%"))) 0 // probability 0
        END
      END
    END
  END

// dragons have responses to cloud-based attacks
// was presumed to be zone of sweet air, but already included in wing buffet spell, so ref removed
COPY_EXISTING ~abazdrag.bcs~ ~override~ // abazigal
              ~dragbrow.bcs~ ~override~ // draconis
              ~draggre2.bcs~ ~override~
              ~draggree.bcs~ ~override~
              ~gorsal.bcs~   ~override~ // saladrex
 DECOMPILE_BCS_TO_BAF
   REPLACE_TEXTUALLY ~ApplySpell(Myself,0)~ ~~ // in response to death fog/incend cloud, cloudkill
 COMPILE_BAF_TO_BCS
 BUT_ONLY_IF_IT_CHANGES

// direct target of breath attacks gets some extra damage; see drgrbrht or RED_DRAGON_HIT (spin693) in other dragon AI scripts
COPY_EXISTING ~abazdrag.bcs~ ~override~
              ~dragblue.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ReallyForceSpell(LastSeenBy(Myself),0)~ ~~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// unknown fourth possible option; efreet seems to be a common alternative to nishruu summoning (plus it's known to cre)
COPY_EXISTING ~amlich02.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~SpellNoDec(Myself,0)~ ~SpellNoDec(Myself,WIZARD_SUMMON_EFREET)~ // other three actions--two summoning spells and move to PC
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// blank block for HaveSpell, CastSpell--only one memorized but not scripted is ADHW
COPY_EXISTING ~bheye.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~HaveSpell(0)~ ~HaveSpell(WIZARD_ABI_DALZIMS_HORRID_WILTING)~
    REPLACE_TEXTUALLY ~Spell(NearestEnemyOf(Myself),0)~ ~Spell(NearestEnemyOf(Myself),WIZARD_ABI_DALZIMS_HORRID_WILTING)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// two presumably olive slimes were supposed to spawn--no such creatures
COPY_EXISTING ~ar2200.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~CreateCreature("jeloli01",\[4422\.3524\],6)~ ~CreateCreature("jelmus01",[4422.3524],6)~ // replace w/ mustard jelly
    REPLACE_TEXTUALLY ~CreateCreature("jeloli01",\[4052\.3574\],6)~ ~CreateCreature("jelgre01",[4052.3574],6)~ // replace w/ green slime
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// script designed to turn invisible repeatedly; given level and kit, assassination seems a good fit here
COPY_EXISTING ~chalcy02.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~SpellNoDec(Myself,0)~ ~SpellNoDec(Myself,ROGUE_ASSASINATION)~ // Some prep spell
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// blank block for HaveSpell, CastSpell in offensive situation--two spells memorized but not scripted: fireball and magic missile
// select MM as there's no range check for fireball safety
COPY_EXISTING ~clone1.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY
      ~HaveSpell(0)\([%TAB% %LNL%%MNL%%WNL%]+THEN[%TAB% %LNL%%MNL%%WNL%]+RESPONSE #100[%TAB% %LNL%%MNL%%WNL%]+\)Spell(NearestEnemyOf(Myself),0)~
      ~HaveSpell(WIZARD_MAGIC_MISSILE) \1 Spell(NearestEnemyOf(Myself),WIZARD_MAGIC_MISSILE)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// final game cutscene
COPY_EXISTING ~cut59a.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY
      ~ApplySpell(\([A-Za-z0-9]+\),0)~
      ~ApplySpellRES("cdpr417",\1)~   // some form of restoration--follows resurrections and full heal
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// cutscene
COPY_EXISTING ~cut67d.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ForceSpell("Dpimo01",0)~ ~ForceSpell("Dpimo01",CUTSCENE_DAMAGE_1)~   // irenicus doing something to Imoen
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// degardan has one messed up script
COPY_EXISTING ~degard2.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY // against non-humanoids; use HM even though not memorized since used in similar blocks in other AI scripts
      ~\(!General(LastSeenBy(Myself),HUMANOID)[%TAB% %LNL%%MNL%%WNL%]+\)HaveSpell(0)\([%TAB% %LNL%%MNL%%WNL%]+THEN[%TAB% %LNL%%MNL%%WNL%]+RESPONSE #100[%TAB% %LNL%%MNL%%WNL%]+\)Spell(LastSeenBy(Myself),0)~
      ~\1 HaveSpell(WIZARD_HOLD_MONSTER) \2 Spell(LastSeenBy(Myself),WIZARD_HOLD_MONSTER)~
    REPLACE_TEXTUALLY // death spell? something effective against multiple enemies-- cone of cold?
      ~\(NumCreatureGT(\[ALLY\],4)[%TAB% %LNL%%MNL%%WNL%]+Allegiance(Myself,ENEMY)[%TAB% %LNL%%MNL%%WNL%]+See(NearestEnemyOf(Myself))[%TAB% %LNL%%MNL%%WNL%]+\)HaveSpell(0)\([%TAB% %LNL%%MNL%%WNL%]+THEN[%TAB% %LNL%%MNL%%WNL%]+RESPONSE #100[%TAB% %LNL%%MNL%%WNL%]+\)Spell(LastSeenBy(Myself),0)~
      ~\1 HaveSpell(WIZARD_DEATH_SPELL) \2 Spell(LastSeenBy(Myself),WIZARD_DEATH_SPELL)~
    REPLACE_TEXTUALLY // one of several generic attack responses--melf's acid arrow?
      ~SpellNoDec(LastSeenBy(Myself),0)~
      ~SpellNoDec(LastSeenBy(Myself),WIZARD_MELF_ACID_ARROW)~
    REPLACE_TEXTUALLY // anti-mage spell--hold person? do this one last, had problems with matching
      ~HaveSpell(0)\([%TAB% %LNL%%MNL%%WNL%]+THEN[%TAB% %LNL%%MNL%%WNL%]+RESPONSE #100[%TAB% %LNL%%MNL%%WNL%]+\)Spell(LastSeenBy(Myself),0)~
      ~HaveSpell(WIZARD_HOLD_PERSON) \1 Spell(LastSeenBy(Myself),WIZARD_HOLD_PERSON)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// in between dragon fear and a wing buffet--per other dragon AI, should be lowering specific resistances to breath attack, but nothing to reduce poison resistance
COPY_EXISTING ~draggre2.bcs~ ~override~
              ~draggree.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ReallyForceSpell(NearestEnemyOf(Myself),0)~ ~~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

/*
// gauths should be firing off more spells
COPY_EXISTING ~gauth01.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY
      ~ReallyForceSpell(\[PC\],0)\([%TAB% %LNL%%MNL%%WNL%]+SetGlobal("GauthBehavior","LOCALS",1)\)~
      ~ReallyForceSpell([PC],0) \1~ // no idea
    REPLACE_TEXTUALLY
      ~\(!See(LeastDamagedOf(Myself))[%TAB% %LNL%%MNL%%WNL%]+HPGT(Myself,35)[%TAB% %LNL%%MNL%%WNL%]+THEN[%TAB% %LNL%%MNL%%WNL%]+RESPONSE #100[%TAB% %LNL%%MNL%%WNL%]+ReallyForceSpell(\[PC\],BEHOLDER_HOLD_PERSON)[%TAB% %LNL%%MNL%%WNL%]+\)ReallyForceSpell([PC],0)~
      ~\1 ReallyForceSpell([PC],0)~ // no idea
    REPLACE_TEXTUALLY
      ~\([^!]See(LeastDamagedOf(Myself))[%TAB% %LNL%%MNL%%WNL%]+HPGT(Myself,35)[%TAB% %LNL%%MNL%%WNL%]+THEN[%TAB% %LNL%%MNL%%WNL%]+RESPONSE #100[%TAB% %LNL%%MNL%%WNL%]+ReallyForceSpell(\[PC\],BEHOLDER_HOLD_PERSON)[%TAB% %LNL%%MNL%%WNL%]+\)ReallyForceSpell([PC],0)~
      ~\1 ReallyForceSpell([PC],0)~ // no idea
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
*/
/*
// missing spell in heal-?-restoration sequence
COPY_EXISTING ~gorgua01.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ApplySpell(Myself,0)~ ~ApplySpell(Myself,FORCE_DISPEL_MAGIC)~ // between full heal and restore--dispel effects?
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
*/

// gphealer has two HaveSpell, Spell blocks with unknown IDS entries--something offensive with a 5' radius
// found near-identical sequence for mage symbol spells in gpmage1
COPY_EXISTING ~gphealer.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY
      ~\(IF[%TAB% %LNL%%MNL%%WNL%]+\)HaveSpell(0)\([%TAB% %LNL%%MNL%%WNL%]+!HasBounceEffects(LastSeenBy(Myself))[%TAB% %LNL%%MNL%%WNL%]+!Range(LastSeenBy(Myself),5)[%TAB% %LNL%%MNL%%WNL%]+RandomNum(2,1)[%TAB% %LNL%%MNL%%WNL%]+THEN[%TAB% %LNL%%MNL%%WNL%]+RESPONSE #100[%TAB% %LNL%%MNL%%WNL%]+\)Spell(LastSeenBy(Myself),0)\([%TAB% %LNL%%MNL%%WNL%]+END[%TAB% %LNL%%MNL%%WNL%]+IF[%TAB% %LNL%%MNL%%WNL%]+\)HaveSpell(0)\([%TAB% %LNL%%MNL%%WNL%]+!HasBounceEffects(LastSeenBy(Myself))[%TAB% %LNL%%MNL%%WNL%]+!Range(LastSeenBy(Myself),5)[%TAB% %LNL%%MNL%%WNL%]+RandomNum(2,1)[%TAB% %LNL%%MNL%%WNL%]+THEN[%TAB% %LNL%%MNL%%WNL%]+RESPONSE #100[%TAB% %LNL%%MNL%%WNL%]+\)Spell(LastSeenBy(Myself),0)\([%TAB% %LNL%%MNL%%WNL%]+END\)~
      ~\1 HaveSpell(CLERIC_SYMBOL_DEATH) \2 Spell(LastSeenBy(Myself),CLERIC_SYMBOL_DEATH) \3 HaveSpell(CLERIC_SYMBOL_STUN) \4 Spell(LastSeenBy(Myself),CLERIC_SYMBOL_STUN) \5~ //
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// gpmage1 is missing IDS refs in a HaveSpell, Spell block
// gpmage2 has identical block
COPY_EXISTING ~gpmage1.bcs~  ~override~
              ~magehigh.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~HaveSpell(0)~ ~HaveSpell(WIZARD_DISPEL_MAGIC)~ // trigger...
    REPLACE_TEXTUALLY ~Spell(LastSeenBy(Myself),0)~ ~Spell(LastSeenBy(Myself),WIZARD_DISPEL_MAGIC)~ // ... and action
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// missing IDS refs in a HaveSpell, Spell block--offensive/disabling spell
// every mage12 ends with a magic missile block before melee
COPY_EXISTING ~lyros.bcs~   ~override~
              ~mage12b.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~HaveSpell(0)~ ~HaveSpell(WIZARD_MAGIC_MISSILE)~ // trigger...
    REPLACE_TEXTUALLY ~Spell(NearestEnemyOf(Myself),0)~ ~Spell(NearestEnemyOf(Myself),WIZARD_MAGIC_MISSILE)~ // ... and action
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// missing IDS refs in a HaveSpell, Spell block--offensive/disabling spell
// based on sequencing, chaos is a good guess here
COPY_EXISTING ~mage12e.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~HaveSpell(0)~ ~HaveSpell(WIZARD_CHAOS)~ // trigger...
    REPLACE_TEXTUALLY ~Spell(NearestEnemyOf(Myself),0)~ ~Spell(NearestEnemyOf(Myself),WIZARD_CHAOS)~ // ... and action
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// missing IDS refs in a HaveSpell, Spell block for > 6 opponents
// kproen02 has exact same sequencing
COPY_EXISTING ~mage14d.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~HaveSpell(0)~ ~HaveSpell(WIZARD_DEATH_SPELL)~ // trigger...
    REPLACE_TEXTUALLY ~Spell(LastSeenBy(Myself),0)~ ~Spell(LastSeenBy(Myself),WIZARD_DEATH_SPELL)~ // ... and action
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// one possible attack with mag missile and fireball--no bounce, indiv target, range > 5
// except for two extra response options, similar to many symbol sequences
COPY_EXISTING ~meliss01.bcs~ ~override~
              ~meliss02.bcs~ ~override~
              ~meliss03.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~SpellNoDec(LastSeenBy(Myself),0)~ ~SpellNoDec(LastSeenBy(Myself),WIZARD_SYMBOL_DEATH)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// big, high-level spell: only against 75% HP+. similar blocks are very high-level spells--comet, bigby, bone blades
COPY_EXISTING ~meliss03.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ForceSpell(LastSeenBy(Myself),0)~ ~ForceSpell(LastSeenBy(Myself),WIZARD_DRAGONS_BREATH)~ // dragon's breath?
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// lilarcor sound
COPY_EXISTING ~pipe04.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~PlaySound("MISC_02A")~ ~PlaySound("EFF_P54")~ // Cromwell's forging sound
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// some fire mephit attack
COPY_EXISTING ~mepfir.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ForceSpell(NearestEnemyOf(Myself),0)~ ~ForceSpell(NearestEnemyOf(Myself),MEPHIT_FLAME_FAN)~ // attack spell
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// two missing actions in four-action blocks; blocks seem identical
// for fire slamanders; should be offensive fire spell
COPY_EXISTING ~salgrfir.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~SpellNoDec(NearestEnemyOf(Myself),0)~ ~SpellNoDec(NearestEnemyOf(Myself),WIZARD_AGANNAZAR_SCORCHER)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

/*
// viekang's scripts; allegiance check to destroy minhp1
COPY_EXISTING ~sarvie01.bcs~  ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~Allegiance(Myself,0)~ ~Allegiance(Myself,EVILBUTBLUE)~ // third allegiance check?
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES
*/

// one of four attack options--others all cleric damage/disabling spells
COPY_EXISTING ~tahazz.bcs~ ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY ~ForceSpell(NearestEnemyOf(Myself),0)~ ~ForceSpell(NearestEnemyOf(Myself),CLERIC_FLAME_STRIKE)~
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

// demon knights
COPY_EXISTING ~uddeath.bcs~  ~override~
  DECOMPILE_BCS_TO_BAF
    REPLACE_TEXTUALLY
      ~ReallyForceSpell(LastSeenBy(Myself),0)~
      ~ReallyForceSpell(LastSeenBy(Myself),WIZARD_SYMBOL_STUN)~ // one of five attack options--symbol stun?
    REPLACE_TEXTUALLY
      ~ForceSpell(LastSeenBy(Myself),0)\([%TAB% %LNL%%MNL%%WNL%]+SetGlobal("DeathKnightFireball","LOCALS",1)\)~
      ~ForceSpell(LastSeenBy(Myself),WIZARD_FIREBALL) \1~ // one of two attack options--fireball?
    REPLACE_TEXTUALLY 
      ~ForceSpell(LastSeenBy(Myself),0)\([%TAB% %LNL%%MNL%%WNL%]+SetGlobal("DeathAttack","LOCALS",1)\)~
      ~ForceSpell(LastSeenBy(Myself),WIZARD_SYMBOL_DEATH) \1~ // one of three attack options--symbol death?
  COMPILE_BAF_TO_BCS
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// bard song fixes                                  \\\\\
/////                                                  \\\\\
                
BEGIN @18 DESIGNATED 111
GROUP @2

COPY ~bg2fixpack/spl/fjbard.spl~   ~override~
     ~bg2fixpack/spl/fjbarda.spl~  ~override~
     ~bg2fixpack/spl/fjbardb.spl~  ~override~
     ~bg2fixpack/spl/fjblade.spl~  ~override~
     ~bg2fixpack/spl/fjbladeb.spl~ ~override~

// apply song to trueclass bards and blades
COPY_EXISTING ~clabba01.2da~ ~override~
  PATCH_IF (SOURCE_SIZE > 0) BEGIN
    SET_2DA_ENTRY 3 1 3 ~AP_FJBARD  ~
  END
  BUT_ONLY_IF_IT_CHANGES

COPY_EXISTING ~clabba02.2da~ ~override~
  PATCH_IF (SOURCE_SIZE > 0) BEGIN
    SET_2DA_ENTRY 3 1 3 ~AP_FJBLADE ~
  END
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// wizard slayer ranged attacks                     \\\\\
/////                                                  \\\\\

BEGIN @19 DESIGNATED 112
GROUP @2

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0112.g3~

COPY_EXISTING ~spcl133.spl~ ~override~
  READ_LONG  0x64 "abil_off"
  READ_SHORT 0x68 "abil_num"
  READ_LONG  0x6a "fx_off"
  SET "delta" = 0
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    READ_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "abil_fx_num"
    READ_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "abil_fx_idx"
    SET "abil_fx_idx" = ("%abil_fx_idx%" + "%delta%")
    WRITE_SHORT ("%abil_off%" + 0x20 + (0x28 * "%index%")) "%abil_fx_idx%"
    FOR (index2 = 0 ; index2 < abil_fx_num ; index2 = index2 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "opcode"
      PATCH_IF ("%opcode%" = 248) BEGIN
        READ_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_idx%" + "%index2%"))) "clone" (0x30)
        INSERT_BYTES            ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 0x30
          WRITE_EVALUATED_ASCII ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) "%clone%"
          WRITE_SHORT           ("%fx_off%" +        (0x30 * ("%abil_fx_num%" + "%abil_fx_idx%"))) 249  // ranged hit effect
        SET "abil_fx_num" = ("%abil_fx_num%" + 1)
        SET "delta" = ("%delta%" + 1)
        SET "index2" = ("%index2%" + 1)
      END
    END
    WRITE_SHORT ("%abil_off%" + 0x1e + (0x28 * "%index%")) "%abil_fx_num%"
  END
  BUT_ONLY_IF_IT_CHANGES

// wiz slayer description update
ACTION_IF FILE_EXISTS_IN_GAME ~mel01.cre~ THEN BEGIN

  STRING_SET 25203 @145

END ELSE BEGIN

  STRING_SET 25203 @144

END

/////                                                  \\\\\
///// additional alignment fixes                       \\\\\
/////                                                  \\\\\

BEGIN @21 DESIGNATED 113
GROUP @2

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0113.g3~

// alignment corrections from Oversight
COPY_EXISTING ~garkid01.cre~ ~override~ // Iltha
              ~garkid02.cre~ ~override~ // Taar
                  ~alex.cre~ ~override~ // Sir Beverus
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 17 // alignment: lawful good
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~acolyte3.cre~ ~override~ // Watchknight Aabir
              ~bdact05.cre~  ~override~ // Zaren
              ~bdhigg01.cre~ ~override~ // Higgold
              ~gftown01.cre~ ~override~ // Commoner
              ~gmtown02.cre~ ~override~ // Commoner
              ~helmbyr.cre~  ~override~ // Acolyte Byron
              ~helmkni1.cre~ ~override~ // Shield Knight
              ~helmpr.cre~   ~override~ // Sir Lothtyran
              ~prophelm.cre~ ~override~ // Shield Knight
              ~sctelwyn.cre~ ~override~ // Guardian Telwyn
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 18 // alignment: lawful neutral
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~amtgen01.cre~ ~override~ // Jamis Tombelthen
              ~bounha.cre~   ~override~ // Bounty Hunter
              ~bounha04.cre~ ~override~ // Bounty Hunter
              ~jade2.cre~    ~override~ // Thenry
              ~jade3.cre~    ~override~ // Jeremon
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 19 // alignment: lawful evil
  END
  BUT_ONLY_IF_IT_CHANGES
  
// alignment corrections from Oversight
COPY_EXISTING ~jarev1.cre~   ~override~ // Harper
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 50 // alignment: chaotic neutral
  END
  BUT_ONLY_IF_IT_CHANGES

// alignment corrections from Oversight
COPY_EXISTING ~priss.cre~    ~override~ // Priss
              ~rumar.cre~    ~override~ // Rumar
              ~victown1.cre~ ~override~ // Commoner
              ~victown2.cre~ ~override~ // Commoner
              ~victown3.cre~ ~override~ // Nobleman
                ~drow07.cre~ ~override~ // Drow Priestess
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    WRITE_BYTE 0x27b 51 // alignment: chaotic evil
  END
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// free action prevents against stun                \\\\\
/////                                                  \\\\\

BEGIN @23 DESIGNATED 114
GROUP @2

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0114.g3~

// include macros for batch processing
INCLUDE ~bg2fixpack/lib/macro_fx_batch_prep.tph~

// add stun immunity to free action items
COPY_EXISTING ~blun30.itm~  ~override~ // foa +5
              ~potn45.itm~  ~override~ // potion of freedom
              ~ring09.itm~  ~override~ // ring of free action
              ~sper12.itm~  ~override~ // ixil's spike +6
              ~sppr403.spl~ ~override~ // spell of free action
  LAUNCH_PATCH_MACRO ~add_fx_batch_prep~ // defines vars for rest of patch
  PATCH_IF (SOURCE_SIZE >= min_size) BEGIN
    SET "new_fx" = 0
    FOR (index = (0 - global_loop) ; index < abil_num ; index = index + 1) BEGIN
      SET "new_fx_1" = 0
      PATCH_IF ("%index%" < 0) BEGIN // if loop through globals needed
        SET "abil_fx_idx" = 0
      END ELSE BEGIN // otherwise normal ability
        SET "counter_offset" = ("%abil_off%" + 0x1e + ("%abil_length%" * "%index%"))
        READ_SHORT  ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) "abil_fx_idx"
        SET "abil_fx_idx" = ("%abil_fx_idx%" + "%new_fx%")
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%abil_length%" * "%index%")) ("%abil_fx_idx%")
      END
      READ_SHORT "%counter_offset%" "counter" // fx_num on global loop, otherwise abil_fx_num
      FOR (index2 = 0 ; index2 < counter ; index2 = index2 + 1) BEGIN
        READ_SHORT ("%fx_off%"        + (0x08 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "opcode"
        READ_LONG  ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param1"
        READ_LONG  ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "param2"
        READ_ASCII ("%fx_off%" + 0x14 + (0x14 * "%fx_type%") + (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "resref"
        PATCH_IF (("%opcode%" = 101) AND ("%param2%" = 109)) BEGIN // hold immunity
          SET "new_fx_1" = 1
          READ_ASCII ("%fx_off%" +                             (("%abil_fx_idx%" + "%index2%") * (0x30 + (0xd8 * "%fx_type%")))) "template" ((0x30 + (0xd8 * "%fx_type%")))
        END
      END
      PATCH_IF ("%new_fx_1%" = 1) BEGIN
        INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
          WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
          WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 210          // pw stun immunity
        INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
          WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
          WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 45           // stun immunity
        INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
          WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
          WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 169          // prevent portrait icon
          WRITE_LONG   ("%fx_off%" + 0x08 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 55           // stun icon
        INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
          WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
          WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
          WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 1280         // strref
        INSERT_BYTES   ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) (0x30 + (0xd8 * "%fx_type%"))
          WRITE_ASCIIE ("%fx_off%"                               + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) "%template%" // clones immunity effect
          WRITE_SHORT  ("%fx_off%"        + (0x08 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 267          // disable string
          WRITE_LONG   ("%fx_off%" + 0x04 + (0x10 * "%fx_type%") + ("%abil_fx_idx%" * (0x30 + (0xd8 * "%fx_type%")))) 14043        // strref
        SET "new_fx" = ("%new_fx%" + 5)
        SET "counter" = ("%counter%" + 5)
      END
      WRITE_SHORT "%counter_offset%" "%counter%"
    END
    LAUNCH_PATCH_MACRO ~add_fx_batch_final~ // wrapup creature offset patching
  END
  BUT_ONLY_IF_IT_CHANGES

/////                                                  \\\\\
///// shapeshifter paw fixes                           \\\\\
/////                                                  \\\\\

BEGIN @24 DESIGNATED 115
GROUP @2
REQUIRE_PREDICATE FILE_EXISTS_IN_GAME ~tobex_ini/tobexcore.ini~ @29              // This component requires TobEx

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0115.g3~

// Add the non-dispellable flag to shapechange weapons if TobEx is detected
// This will prevent the natural weapons of the shapechange forms (i.e. claws and such) from being removed by Dispel Magic and Dead Magic Zones
ACTION_FOR_EACH ~file~ IN                                                          // for each of the following files
               ~brblp~                                                             // Shapeshifts Black Bear
               ~brbrp~                                                             // Shapeshifts Brown Bear, Shapeshifts Werewolf, Shapeshifts Greater Werewolf
              ~druear~                                                             // earth elemental transformation
              ~drufir~                                                             // fire elemental transformation
             ~earthrn~                                                             // Shapechange Earth Elemental
              ~firern~                                                             // Shapechange Fire Elemental
              ~goliro~                                                             // used by iron golems, Shapechange Iron Golem
            ~mindflay~                                                             // used by mind flayers, Shapechange Mind Flayer
            ~plyjelly~                                                             // jelly from cloak of sewers
             ~plysala~                                                             // Fire Salamander (Avenger kit form)
             ~plyspid~                                                             // Sword Spider (Avenger kit form)
            ~plytroll~                                                             // troll from cloak of sewers
            ~plywyvrn~                                                             // Baby Wyvern shape attack
             ~polyrat~                                                             // rat from cloak of sewers
             ~shakti1~                                                             // short sword +4
            ~slayerwp~                                                             // slayer, Slayer Change
              ~squirp~                                                             // Sphere of Chaos
            ~trollall~                                                             // Shapechange Giant Troll
              ~wolfgr~                                                             // Shapechange Greater Wolfwere
               ~wolfm~                                                             // Shapeshifts Wolf
BEGIN                                                                              // execute the following
ACTION_IF FILE_EXISTS_IN_GAME ~%file%.itm~ BEGIN                                   // if the designated file with an ITM extension exists
COPY_EXISTING ~%file%.itm~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x71) THEN BEGIN                                         // protects against invalid files
// =============================================================================== // the actual work starts from here
    READ_BYTE 0x1b "flags"
    PATCH_IF (("%flags%" BAND "0b00000001") = "0b00000000") BEGIN                  // if bit 24 isn't set
      WRITE_BYTE "0x1b" ("%flags%" BOR "0b00000001")                               // set bit 24
    END
// =============================================================================== // the actual work ends here
END                                                                                // ends file size check
BUT_ONLY_IF_IT_CHANGES
END                                                                                // ends ACTION_IF FILE_EXISTS_IN_GAME block
END

/////                                                  \\\\\
///// no thief bonuses for rangers & bards             \\\\\
/////                                                  \\\\\

BEGIN @28 DESIGNATED 116
GROUP @2

// dummy file allows detection of this component
COPY_EXISTING ~sw1h01.itm~ ~override/cdfp0116.g3~

// let ranger stealth go above 99
COPY_EXISTING ~skillrng.2da~ ~override~
  COUNT_2DA_ROWS 2 rows
  FOR (index = 0 ; index < rows ; ++index) BEGIN
    READ_2DA_ENTRY index 1 2 stealth
    SET_2DA_ENTRY  index 1 2 (stealth - 7)
  END
  BUT_ONLY

// let bard pp go above 99
COPY_EXISTING ~skillbrd.2da~ ~override~
  COUNT_2DA_ROWS ~2~ "rows"
  FOR (index = 0 ; index < rows ; ++index) BEGIN
    READ_2DA_ENTRY index 0 2 "level"
    READ_2DA_ENTRY index 1 2 "pp"
    PATCH_IF (IS_AN_INT level) BEGIN
      SET pp_adj = (20 + (5 * level))
      PATCH_IF (pp_adj > 200) BEGIN
        SET pp_adj = 200
      END
      PATCH_IF (pp < pp_adj) BEGIN
        SET_2DA_ENTRY index 1 2 "pp_adj"
      END
    END
  END
  BUT_ONLY

// need to adjust joinable ranger NPCs
ACTION_FOR_EACH file IN minsc7 minsc8 minsc9 minsc10 minsc12 minsc15 valyg8 valyg9 
  valyg11 valyg12 valyg14 _kivan _kivan4 _kivan6 _minsc _minsc2 _minsc4 _minsc4 BEGIN

  ACTION_IF FILE_EXISTS_IN_GAME ~%file%.cre~ THEN BEGIN
  
    COPY_EXISTING ~%file%.cre~ ~override~
      WRITE_BYTE 0x45 (THIS - 7)
      WRITE_BYTE 0x68 (THIS - 7)
      
  END

END

// need to adjust joinable bard NPCs
ACTION_FOR_EACH file IN haer10 haer11 haer13 haer15 haer19 _garric _garric2 _garric4 
  _garric6 _eldoth _eldoth5 eldoth eldoth5 garric garric2 garric4 garric6 BEGIN

  ACTION_IF FILE_EXISTS_IN_GAME ~%file%.cre~ THEN BEGIN
  
    COPY_EXISTING ~%file%.cre~ ~override~
      WRITE_BYTE 0x6a (THIS - 15)

  END

END

/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////                                                  \\\\\
///// Who loves ya baby? The Fixpack Team, that's who! \\\\\
/////                                                  \\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\
/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\/////\\\\\

// need to uncomment the following line to get this component at install time
//BEGIN ~SUPER SECRET COMPONENT~ DESIGNATED 10000

// For some of the common 'I don't like this' requests, I had some free time and decided to code
// this for players. See something you don't like? Should just be a few un-comments away.
// Want to change something not here? Ask in the 'I *hate* this fix' thread:
// http://forums.gibberlings3.net/index.php?showtopic=7890

// want Jaheira to know Zone of Sweet Air? Uncomment the block below
/*
COPY_EXISTING ~jaheir7.cre~  ~override~
              ~jaheir8.cre~  ~override~
              ~jaheir11.cre~ ~override~
              ~jaheir12.cre~ ~override~
              ~jahei12b.cre~ ~override~
              ~jahei14.cre~  ~override~
  PATCH_IF (SOURCE_SIZE >0x2d3) BEGIN
    ADD_KNOWN_SPELL ~sppr318~ #2 ~priest~
  END
  BUT_ONLY_IF_IT_CHANGES
*/

// Adds Holy Smite back to Viconia
/*
COPY_EXISTING ~viconi6.cre~  ~override~
              ~viconi8.cre~  ~override~
              ~viconi9.cre~  ~override~
              ~viconi11.cre~ ~override~
              ~viconi13.cre~ ~override~
              ~viconi16.cre~ ~override~
  PATCH_IF (SOURCE_SIZE > 0x2d3) THEN BEGIN // protects against invalid files
    ADD_KNOWN_SPELL ~sppr313~ #2 ~priest~
  END
  BUT_ONLY_IF_IT_CHANGES
*/

// removes elven/half-elven sleep/charm immunities
/*
COPY_EXISTING_REGEXP GLOB ~^cdelfcm[0-6]\.eff$~ ~override~
                          ~^cdelfsl[0-4]\.eff$~ ~override~
  WRITE_SHORT 0x2c 0
  BUT_ONLY_IF_IT_CHANGES
*/

// undo monk item usability fixes
/*
COPY_EXISTING ~amul21.itm~   ~override~ // Amulet of power
              ~brac21.itm~   ~override~ // gauntlets of ex specialization
              ~ring22.itm~   ~override~ // ring o' holiness
              ~ring35.itm~   ~override~ // ring of lock picking
              ~ring40.itm~   ~override~ // ring of acuity
              ~scrl8c.itm~   ~override~ // stone to flesh
              ~wa2ring.itm~  ~override~ // mercykiller ring
  PATCH_IF (%SOURCE_SIZE% > 0x71) THEN BEGIN
    READ_BYTE  0x21 "mu"
    WRITE_BYTE 0x21 ("mu" & (` 0xdf)) // removes monk unusability flag
  END
  BUT_ONLY_IF_IT_CHANGES
*/

// Innate Draw Upon Holy Might is fast casting
/*
COPY_EXISTING spin103.spl override // duhm innate
  READ_LONG  0x64 abil_off
  READ_SHORT 0x68 abil_num
  FOR (index = 0 ; index < abil_num ; index = index + 1) BEGIN
    WRITE_SHORT ("%abil_off%" + 0x12 + (0x28 * "%index%")) 2
  END
BUT_ONLY
*/

BEGIN ~cam testing~



/*
COPY_EXISTING_REGEXP GLOB ~^.+\.itm$~ ~override~
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  FOR (index = 0 ; index < fx_num ; index = index + 1) BEGIN
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "type"
    PATCH_IF ("%type%" = 177) BEGIN
      READ_ASCII ("%fx_off%" + 0x14 + ("%index%" * 0x30)) "eff_file"
      PATCH_PRINT "%SOURCE_FILE% is using %eff_file% as a global effect"
    END
  END
  FOR (index2 = 0 ; index2 < abil_num ; index2 = index2 + 1) BEGIN
    READ_BYTE   ("%abil_off%" +        ("%index2%" * 0x38)) "type"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index2%" * 0x38)) "abil_fx_idx"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index2%" * 0x38)) "abil_fx_num"
    PATCH_IF (("%type%" = 1) OR ("%type%" = 2)) BEGIN // melee ability check
      FOR (index3 = 0 ; index3 < abil_fx_num ; index3 = index3 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index3%") * 0x30)) "opcode"
        PATCH_IF ("%opcode%" = 177) BEGIN
          READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index3%") * 0x30)) "eff_file"
          PATCH_PRINT "%SOURCE_FILE% is using %eff_file% as an attack effect, type %type%"
        END
      END
    END
  END
  BUT_ONLY
*/

/*
// lycandam shared by wolfsbane amulet, kondar
COPY_EXISTING ~lycandam.eff~ ~override/cdsw1h03.eff~

// remove specific damage bonuses from one weapon bleeding to offhand/main weapon
// move global eff to melee/ranged headers
// no fix for thac0 bonus
// opcode 278 doesn't stack, so avoid conflicts with kit abilities, too
COPY_EXISTING ~blun18.itm~   ~override~ // skullcrusher
              ~blun23.itm~   ~override~ // bone club +2, +3 vs. undead
              ~carsomyr.itm~ ~override~ // Carsomyr +5, damage applied globally (2h, unused)
              ~chevil10.itm~ ~override~ // Flame Of The North, damage applied globally (undroppable sarevok weapon)
              ~dagg09.itm~   ~override~ // silver dagger
              ~halb04.itm~   ~override~ // Dragon's Bane +3, damage applied globally (2h)
              ~hamm04.itm~   ~override~ // hammer +1, +4 vs. giantkin
              ~hsword.itm~   ~override~ // Holy Sword, damage applied globally (unused)
              ~phanblad.itm~ ~override~ // phantom blade
              ~sw1h03.itm~   ~override~ // sword +1, +3 vs. shapeshifters
              ~sw1h18.itm~   ~override~ // sword o' balduran
              ~sw1h24.itm~   ~override~ // flame tongue
              ~sw1h31.itm~   ~override~ // daystar
              ~sw1h54.itm~   ~override~ // equalizer
              ~sw1h62.itm~   ~override~ // foebane +3
              ~sw1h63.itm~   ~override~ // foebane +5
              ~sw1h64.itm~   ~override~ // purifier +4
              ~sw1h65.itm~   ~override~ // purifier +5
              ~sw2h10.itm~   ~override~ // Carsomyr +5, damage applied globally (2h)
              ~sw2h12.itm~   ~override~ // Flame Of The North, damage applied globally (2h)
              ~sw2h19.itm~   ~override~ // Carsomyr +6, damage applied globally (2h)
              ~wamace.itm~   ~override~ // foebane +5
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  SET delta = 0
  FOR (index = 0 ; index < fx_num ; ++index) BEGIN
    READ_SHORT ("%fx_off%" +        ("%index%" * 0x30)) "type"
    READ_ASCII ("%fx_off%" + 0x14 + ("%index%" * 0x30)) "eff_file"
    PATCH_IF (("%type%" = 177) AND
              (("%eff_file%" STRING_COMPARE_CASE "DAMACEA" = 0) OR
               ("%eff_file%" STRING_COMPARE_CASE "DOPPDAM" = 0) OR
               ("%eff_file%" STRING_COMPARE_CASE "DRAGDAM3" = 0) OR
               ("%eff_file%" STRING_COMPARE_CASE "EVILDAM2" = 0) OR
               ("%eff_file%" STRING_COMPARE_CASE "FLAMENOR" = 0) OR
               ("%eff_file%" STRING_COMPARE_CASE "GIANTDAM" = 0) OR
               ("%eff_file%" STRING_COMPARE_CASE "HOLYAVEN" = 0) OR
               ("%eff_file%" STRING_COMPARE_CASE "LYCANDAM" = 0) OR
               ("%eff_file%" STRING_COMPARE_CASE "LYCNDAM3" = 0) OR
               ("%eff_file%" STRING_COMPARE_CASE "LYCNDAM4" = 0) OR
               ("%eff_file%" STRING_COMPARE_CASE "PHANBLAD" = 0) OR
               ("%eff_file%" STRING_COMPARE_CASE "SKULLCR" = 0) OR
               ("%eff_file%" STRING_COMPARE_CASE "SW2H19A" = 0) OR
               ("%eff_file%" STRING_COMPARE_CASE "UNDDAM1" = 0) OR
               ("%eff_file%" STRING_COMPARE_REGEXP "EQUAL0[1-8]" = 0) OR
               ("%eff_file%" STRING_COMPARE_REGEXP "FT[1-3]DAM" = 0) OR
               ("%eff_file%" STRING_COMPARE_REGEXP "SW1H6[45]A" = 0) OR
               ("%eff_file%" STRING_COMPARE_REGEXP "SW1H62[BCDEF]" = 0))) BEGIN
      PATCH_IF ("%eff_file%" STRING_COMPARE_CASE "lycandam" = 0) BEGIN SPRINT eff_file "cdsw1h03" END
      READ_ASCII   ("%fx_off%" +        ("%index%" * 0x30)) "clone" (48)
      DELETE_BYTES ("%fx_off%" +        ("%index%" * 0x30)) 0x30
      SET fx_num = (fx_num - 1)
      SET delta  = (delta - 1)
      SET index  = (index - 1)
      INNER_ACTION BEGIN // lazy, just grab ids targeting from eff

        COPY_EXISTING ~%eff_file%.eff~ ~override~
          READ_ASCII 0x1c "ids" (8)
          BUT_ONLY

      END
      FOR (index2 = 0 ; index2 < abil_num ; index2 = index2 + 1) BEGIN
        READ_BYTE   ("%abil_off%" +        ("%index2%" * 0x38)) "type"
        READ_SHORT  ("%abil_off%" + 0x20 + ("%index2%" * 0x38)) "abil_fx_idx"
        SET "abil_fx_idx" = "%abil_fx_idx%" + "%delta%"
        WRITE_SHORT ("%abil_off%" + 0x20 + ("%index2%" * 0x38)) "%abil_fx_idx%"
        PATCH_IF (("%type%" = 1) OR ("%type%" = 2)) BEGIN
          INSERT_BYTES (fx_off +        (0x30 * abil_fx_idx)) 0x30
          WRITE_ASCIIE (fx_off +        (0x30 * abil_fx_idx)) "%clone%"
          WRITE_SHORT  (fx_off +        (0x30 * abil_fx_idx)) 177     // use eff
          WRITE_BYTE   (fx_off + 0x02 + (0x30 * abil_fx_idx))   2     // preset target
          WRITE_ASCIIE (fx_off + 0x04 + (0x30 * abil_fx_idx)) "%ids%" // ids target from eff
          WRITE_BYTE   (fx_off + 0x0c + (0x30 * abil_fx_idx))   1     // instant/perm
          READ_SHORT  ("%abil_off%" + 0x1e + ("%index2%" * 0x38)) "abil_fx_num"
          WRITE_SHORT ("%abil_off%" + 0x1e + ("%index2%" * 0x38)) ("%abil_fx_num%" + 1)
          SET delta = (delta + 1)
        END
      END
    END
  END
  WRITE_SHORT  0x70 "%fx_num%"
  BUT_ONLY

// since targeting is changing, patch separately
COPY_EXISTING ~hamm06.itm~ ~override~ // dwarven thrower
  LPF DELETE_ITEM_EQEFFECT INT_VAR opcode_to_delete = 177 END
  PATCH_FOR_EACH race IN 142 113 BEGIN // giants and ogres
    LPF ADD_ITEM_EFFECT INT_VAR
      opcode        = 177        // use eff
      target        = 2          // preset target
      timing        = 1          // instant/perm
      parameter1    = "%race%"   // races from
      parameter2    = 4          // race.ids
      type          = 99         // gets melee and ranged
      STR_VAR resource = "hamm06"
    END
  END

// now patch effs from above to do damage directly instead of damage vs. type (damage matches weapon)
ACTION_DEFINE_ASSOCIATIVE_ARRAY cd_effing_effs BEGIN
  cdsw1h03 => 256 // new eff for bastard sword +1, +3 vs. shapeshifters
  damacea  =>   0 // jerrod's mace
  doppdam  => 256 // bastard sword +1, +3 vs. shapeshifters
  dragdam3 =>  16 // Dragon's Bane +3
  equal01  => 256 // equalizer
  equal02  => 256 // equalizer
  equal03  => 256 // equalizer
  equal04  => 256 // equalizer
  equal05  => 256 // equalizer
  equal06  => 256 // equalizer
  equal07  => 256 // equalizer
  equal08  => 256 // equalizer
  evildam2 => 256 // daystar
  flamenor => 256 // flame of the north
  ft1dam   => 256 // flame tongue
  ft2dam   => 256 // flame tongue
  ft3dam   => 256 // flame tongue
  giantdam =>   0 // hammer +1, +4 vs giantkin
  hamm06   =>   0 // dwarven thrower
  holyaven => 256 // carsomyr +5
  lycndam3 =>  16 // silver dagger
  phanblad => 256 // phantom blade
  skullcr  =>   0 // skullcrusher's eff
  sw1h62b  => 256 // foebane(s)
  sw1h62c  => 256 // foebane(s)
  sw1h62d  => 256 // foebane(s)
  sw1h62e  => 256 // foebane(s)
  sw1h62f  => 256 // foebane(s)
  sw1h64a  => 256 // purifier +4
  sw1h65a  => 256 // purifier +5
  sw2h19a  => 256 // carsomyr +6
  unddam1  =>   0 // bone club eff
END

ACTION_PHP_EACH cd_effing_effs AS eff => damtype BEGIN

  ACTION_IF FILE_EXISTS_IN_GAME "%eff%.eff" BEGIN

    COPY_EXISTING "%eff%.eff" override
      WRITE_LONG  0x10 12           // change to damage
      WRITE_SHORT 0x20  0           // normal
      WRITE_SHORT 0x22  "%damtype%" // damage type
      READ_LONG   0x60 "dam"        // read and move
      WRITE_LONG  0x60 0            // from here
      WRITE_LONG  0x1c "%dam%"      // to there

  END

END

// deva needs to have mesdie fire before die
COPY_EXISTING ~deva.itm~ ~override~
  LPF DELETE_ITEM_EFFECT   INT_VAR "opcode_to_delete" = 177 header = 1 END // delete existing 177
  PATCH_FOR_EACH resref IN cddisr die mesdie BEGIN // three for undead and
    LPF ADD_ITEM_EFFECT INT_VAR
      type         = 1   // melee
      opcode       = 177 // use eff
      target       = 2   // preset target
      parameter1   = 4   // undead
      parameter2   = 3   // general.ids
      timing       = 1   // instant perm
      insert_point = 0   // first effect
      STR_VAR resource = EVAL "%resref%" // eff from list
    END
  END
  LPF ADD_ITEM_EFFECT INT_VAR
    type         = 1   // melee
    opcode       = 177 // use eff
    target       = 2   // preset target
    parameter1   = 7   // illusion
    parameter2   = 7   // gender.ids
    timing       = 1   // instant perm
    insert_point = 0   // first effect
    STR_VAR resource = "die" // eff from list
  END
  BUT_ONLY

// runehammer undead damage incorrect
COPY_EXISTING ~hamm10.itm~ ~override~
              ~hamm11.itm~ ~override~
  READ_LONG   0x64 "abil_off" ELSE 0
  READ_SHORT  0x68 "abil_num" ELSE 0
  READ_LONG   0x6a "fx_off" ELSE 0
  FOR (index2 = 0 ; index2 < abil_num ; index2 = index2 + 1) BEGIN
    READ_BYTE   ("%abil_off%" +        ("%index2%" * 0x38)) "type"
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index2%" * 0x38)) "abil_fx_idx"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index2%" * 0x38)) "abil_fx_num"
    PATCH_IF (("%type%" = 1) OR ("%type%" = 2)) BEGIN // melee ability check
      FOR (index3 = 0 ; index3 < abil_fx_num ; index3 = index3 + 1) BEGIN
        READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index3%") * 0x30)) "opcode"
        READ_ASCII ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index3%") * 0x30)) "eff_file"
        PATCH_IF (("%opcode%" = 177) AND ("%eff_file%" STRING_COMPARE_CASE "cddisr" = 0)) BEGIN
          WRITE_ASCIIE ("%fx_off%" + 0x14 + (("%abil_fx_idx%" + "%index3%") * 0x30)) "%SOURCE_RES%" #8
        END
      END
    END
  END
  BUT_ONLY
  
COPY_EXISTING ~cddisr.eff~ ~override/hamm10.eff~
  WRITE_LONG 0x38 2 // 2d
  WRITE_LONG 0x3c 4 // 4
  WRITE_LONG 0x1c 4 // +4
  
COPY_EXISTING ~hamm10.eff~ ~override/hamm11.eff~
  WRITE_LONG 0x1c 5 // +5

// sol's searing orb - undead blindness should be 6 rounds, 12 on failed save
COPY_EXISTING ~sorb.itm~ ~override~
  LAUNCH_PATCH_FUNCTION ~DELETE_ITEM_EFFECT~ INT_VAR "opcode_to_delete" = 177 header = 1 END // delete existing 177s
  LPF ADD_ITEM_EFFECT INT_VAR
    opcode       = 177 // use eff
    target       = 2   // preset target
    power        = 6   // power
    parameter1   = 4   // undead
    parameter2   = 3   // general.ids
    timing       = 1   // instant perm
    type         = 2   // add to ranged
    STR_VAR resource = "udead66" // damage
  END
  FOR (index = 0 ; index < 2 ; ++index) BEGIN
    LPF ADD_ITEM_EFFECT INT_VAR
      opcode       = 177 // use eff
      target       = 2   // preset target
      power        = 6   // power
      parameter1   = 4   // undead
      parameter2   = 3   // general.ids
      timing       = (3 * index) // instant/lim or delay/lim
      savingthrow  = index // no save, save vs spells
      duration     = 36    // duration
      type         = 2     // add to ranged
      STR_VAR resource = "udeadbli" // blind
    END
  END

COPY_EXISTING ~udeadbli.eff~ ~override~
  WRITE_LONG 0x28 36 // duration
  BUT_ONLY
*/
  
  
/*


// looking for ids-targeted effects
COPY_EXISTING_REGEXP GLOB ~^.+\.itm$~ ~override~
                          ~^.+\.spl$~ ~override~
  PATCH_IF ("%SOURCE_FILE%" STRING_COMPARE_REGEXP "^.+\.spl" = 0) BEGIN
    SET "abil_length" = 0x28
    SET "name_off" = 0x08
  END ELSE BEGIN
    SET "abil_length" = 0x38
    SET "name_off" = 0x0c
  END
  READ_LONG   0x64 "abil_off"
  READ_SHORT  0x68 "abil_num"
  READ_LONG   0x6a "fx_off"
  READ_SHORT  0x70 "fx_num"
  FOR (index2 = 0 ; index2 < abil_num ; index2 = index2 + 1) BEGIN
    READ_SHORT  ("%abil_off%" + 0x20 + ("%index2%" * abil_length)) "abil_fx_idx"
    READ_SHORT  ("%abil_off%" + 0x1e + ("%index2%" * abil_length)) "abil_fx_num"
    FOR (index3 = 0 ; index3 < abil_fx_num ; index3 = index3 + 1) BEGIN
      READ_SHORT ("%fx_off%" +        (("%abil_fx_idx%" + "%index3%") * 0x30)) "opcode"
      PATCH_IF (("%opcode%" = 55) OR ("%opcode%" = 109) OR ("%opcode%" = 175) OR ("%opcode%" = 185) OR ("%opcode%" = 238)) BEGIN
        READ_LONG ("%fx_off%" + 0x04 + (("%abil_fx_idx%" + "%index3%") * 0x30)) "param1"
        READ_LONG ("%fx_off%" + 0x08 + (("%abil_fx_idx%" + "%index3%") * 0x30)) "param2"
        PATCH_IF NOT ((param2 = 2) AND (param1 = 0)) BEGIN // if not targeted at all
          READ_STRREF name_off name
          PATCH_PRINT "  ~%SOURCE_FILE%~ ~override~ // %name%: using opcode %opcode%, targetd at %param1% of %param2% on ability %index2%"
        END
      END
    END
  END
  BUT_ONLY
*/




















































































